<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1,shrink-to-fit=no" >
<TITLE>Compose -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/compose/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Compositing Images</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#compose"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Image Composition in IM</A>
    <UL>
    <LI><A HREF="#compose_terms"
        >Definition and Terms</A>
    <LI><A HREF="#compose_operators"
        >Image Composition Operators</A>
    </UL>
<DD><A HREF="#geometry"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Positioning The Overlay Image</A>
    <UL>
    <LI><A HREF="#geometry"
        >Composite Geometry/Gravity Settings</A>
    <LI><A HREF="#page"
        >Layer Canvas/Page Offsets</A>
    </UL>
<DD><A HREF="tables/"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Raw Tables of Compose Methods </A> (Separate Page)
<DD><A HREF="#duff-porter"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Duff-Porter Alpha Composition Methods</A>
    <UL><LI><DL><DT>
        <A HREF="#over"     ><CODE>Over</CODE></A>,&nbsp;
        <A HREF="#dstover"  ><CODE>Dst&nbsp;Over</CODE></A>,&nbsp;
        <A HREF="#src"      ><CODE>Src</CODE></A>,&nbsp;
        <A HREF="#copy"     ><CODE>Copy</CODE></A>,&nbsp;
        <A HREF="#replace"  ><CODE>Replace</CODE></A>,&nbsp;
    <BR><A HREF="#dst"      ><CODE>Dst</CODE></A>,&nbsp;
        <!A HREF="#in"      ><CODE>In</CODE></A>,&nbsp;
        <A HREF="#dstin"    ><CODE>Dst&nbsp;In</CODE></A>,&nbsp;
        <!A HREF="#out"     ><CODE>Out</CODE></A>,&nbsp;
        <A HREF="#dstout"   ><CODE>Dst&nbsp;Out</CODE></A>,&nbsp;
    <BR><A HREF="#atop"     ><CODE>ATop</CODE></A>,&nbsp;
        <!A HREF="#dstatop" ><CODE>Dst&nbsp;ATop</CODE></A>,&nbsp;
        <A HREF="#clear"    ><CODE>Clear</CODE></A>,&nbsp;
        <A HREF="#xor"      ><CODE>Xor</CODE></A>
    </DL></UL>
<DD><A HREF="#math"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Mathematical Compose Methods</A>
    <UL><LI><DL><DT>
            <A HREF="#multiply"         ><CODE>Multiply</CODE></A>,&nbsp;
            <A HREF="#screen"           ><CODE>Screen</CODE></A>,&nbsp;
            <A HREF="#bumpmap"          ><CODE>Bumpmap</CODE></A>,&nbsp;
            <A HREF="#divide"           ><CODE>Divide</CODE></A>,&nbsp;
        <BR><A HREF="#plus"             ><CODE>Plus</CODE></A>,&nbsp;
            <A HREF="#minus"            ><CODE>Minus</CODE></A>,&nbsp;
            <A HREF="#modulus_add"      ><CODE>ModulusAdd</CODE></A>,&nbsp;
            <A HREF="#modulus_subtract" ><CODE>ModulusSubtract</CODE></A>,&nbsp;
        <BR><A HREF="#difference"       ><CODE>Difference</CODE></A>,&nbsp;
            <A HREF="#exclusion"        ><CODE>Exclusion</CODE></A>,&nbsp;
            <A HREF="#lighten"          ><CODE>Lighten</CODE></A>,&nbsp;
            <A HREF="#darken"           ><CODE>Darken</CODE></A>,&nbsp;
        <BR><A HREF="#lighten_intensity"
                                     ><CODE>LightenIntensity</CODE></A>,&nbsp;
            <A HREF="#darken_intensity"
                                     ><CODE>DarkenIntensity</CODE></A>,&nbsp;
        </DL>
     <LI><A HREF="#set_theory"
         >Set Theory Equivelent Operations</A>
     <LI><A HREF="#math_blending"
         >Mathematical Composition and Alpha Blending</A>
     <LI><A HREF="#image_math"
         >Image Channel Mathematics using Image Composition</A>
     <LI><A HREF="#sync_flag"
         >Sync Channel Flag and Mathematical Composition</A>
     </UL>
<DD><A HREF="#light"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Lighting Composition Methods (Light, Dodge, Burn)</A>
    <UL><LI><DL><DT>
        <A HREF="#overlay"     ><CODE>Overlay</CODE></A>,&nbsp;
        <A HREF="#hardlight"   ><CODE>Hard&nbsp;Light</CODE></A>,&nbsp;
        <A HREF="#softlight"   ><CODE>Soft&nbsp;Light</CODE></A>, &nbsp;
        <A HREF="#pegtoplight" ><CODE>Pegtop&nbsp;Light</CODE></A>, &nbsp;
    <BR><A HREF="#linearlight" ><CODE>Linear&nbsp;Light</CODE></A>,
        <A HREF="#vividlight"  ><CODE>Vivid&nbsp;Light</CODE></A>,
        <A HREF="#pinlight"    ><CODE>Pin&nbsp;Light</CODE></A>,
    <!--<BR><A HREF="#shade_cmp"   >Comparision_of_Light Methods</A>,-->
    <BR><A HREF="#lineardodge" ><CODE>Linear&nbsp;Dodge</CODE></A>,&nbsp;
        <A HREF="#linearburn"  ><CODE>Linear&nbsp;Burn</CODE></A>,&nbsp;
        <A HREF="#colordodge"  ><CODE>Color&nbsp;Dodge</CODE></A>,&nbsp;
        <A HREF="#colorburn"   ><CODE>Color&nbsp;Burn</CODE></A>,&nbsp;
    </DL></UL>
<DD><A HREF="#channel"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Channel Copying Methods</A>
    <UL><LI><DL><DT>
        <A HREF="#copyopacity" ><CODE>Copy&nbsp;Opacity</CODE></A>,&nbsp;&nbsp;
        <A HREF="#copyred"     ><CODE>Copy&nbsp;Red</CODE></A>,&nbsp;
        <A HREF="#copygreen"   ><CODE>Copy&nbsp;Green</CODE></A>,&nbsp;
        <A HREF="#copyblue"    ><CODE>Copy&nbsp;Blue</CODE></A>,&nbsp;
    <BR><A HREF="#copycyan"    ><CODE>Copy&nbsp;Cyan</CODE></A>,&nbsp;
        <A HREF="#copymagenta" ><CODE>Copy&nbsp;Magenta</CODE></A>,&nbsp;
        <A HREF="#copyyellow"  ><CODE>Copy&nbsp;Yellow</CODE></A>,&nbsp;
        <A HREF="#copyblack"   ><CODE>Copy&nbsp;Black</CODE></A>,&nbsp;
    <BR><A HREF="#hue"         ><CODE>Hue</CODE></A>,&nbsp;
        <A HREF="#saturate"    ><CODE>Saturate</CODE></A>,&nbsp;
        <A HREF="#luminize"    ><CODE>Luminize</CODE></A>,&nbsp;
        <A HREF="#colorize"    ><CODE>Colorize</CODE></A>,&nbsp;
    </DL></UL>
<DD><A HREF="#dissolve"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Dissolve one Image Over Another</A>
<DD><A HREF="#blend"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Blend two images together</A>
    <UL>
    <LI><A HREF="#blend_dissolve"
        >Blend verse Dissolve</A>
    <LI><A HREF="#blend_use"
        >Using Blend to Modify a Single Image</A>
    </UL>
<DD><A HREF="#watermark"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Watermark or Modulate Image</A>
<DD><A HREF="#mask"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Using a Mask to Limit Composed Area</A>
    <UL>
    <LI><A HREF="#mask_trans"
        >Compose Mask and Transparency</A>
    </UL>
<DD><A HREF="#tile"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Composite using Image Tiles</A>
<DD><A HREF="#special"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Special Composition Methods</A>
    <DL><DD>
        <A HREF="#mathematics" ><CODE>Mathematics</CODE></A>,&nbsp;
        <A HREF="#changemask"  ><CODE>Change&nbsp;Mask</CODE></A>
    </DL>
<DD><A HREF="#mapping"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Image Mapping Composition Methods</A>
    <DL><DD>
        <A HREF="#blur"        >Variable <CODE>Blur</CODE></A>,&nbsp;&nbsp;
        <A HREF="#displace"    ><CODE>Displace</CODE> Mapping</A>
    </DL>
</DL></P>

Image Composition is the technique of combining images that have, or do not
have, transparency or an  alpha channel.  This is usually performed using the
IM "<CODE>composite</CODE>" command.  It may also be performed as either part
of a larger sequence of operations or internally by other image operators.
</P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="compose"></A>
<H2>Image Composition in IM</H2>

Image Composition is the process of merging two (and only two) images in
a variety of ways.  It is associated with <b>Alpha Composition</b> which
describes the result based on which part of the overlay is transparent.  Image
Composition is used for blending and averaging images, transfering image
channels, cutting, joining, or layering odd shaped segments of images.  Or, as
part of complex mathematical operations. </P>

A good alternate introduction on Image Composition is <A
HREF="http://www.svgopen.org/2005/papers/abstractsvgopen/" >SVG Compositing in
30 Minutes</A>. Or you can discover precise mathematical details by reading
the <A HREF="http://www.w3.org/TR/2009/WD-SVGCompositing-20090430/" >SVG
Alpha Compositing</A> page, which describes the more important image
composition methods. </P>

The following commands are the two direct image 'composite' methods available in
ImageMagick...

<CENTER>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  composite {<I>overlay</I>} {<I>background</I>} [{<I>mask</I>}] [-compose {<I>method</I>}]   {<I>result</I>}

  convert  {<I>background</I>} {<I>overlay</I>} [{<I>mask</I>}] [-compose {<I>method</I>}] -composite   {<I>result</I>}
</CODE></PRE></TD></TR></TABLE>
</CENTER></P>

The "<CODE>composite</CODE>" command is the conventional method of compositing
in IM.  Having a dedicated command demonstrates just how important Image
Composition is. </P>

The "<CODE>convert</CODE>" operator  "<CODE><A
HREF="../option_link.cgi?composite" >-composite</A></CODE>" can also do Image
Composition as part of a larger image processing task. </>

Note the reversed order of the images when using "<CODE>convert</CODE>".  The
order is practical as you are generally working with a primary canvas over
which you prepare and merge images forming a new image.  The order of the
images is important. </P>

Practical examples of both techniques (and more) can be reviewed in <A
HREF="../layers/#composite" >Layers of Multiple Images</A>, and is recomended
reading before continuing. </P>


<A NAME="compose_terms"></A>
<H3>Definition and Terms</H3>

The more important image is the <I>background</I> image, also often called the
<I>destination</I> image, is the image that is modified by Image Composition.
The <I>background</I> sets not only the final size of the Image Composition
but <I>meta-data</I>, such as 'comments', 'labels', 'density', 'profiles' and
so on, are also preserved.  It's position is fixed and usually forms the
canvas which you are building, thus the name <I>background</I>.  Remember
this! <P>

The <I>overlay</I> image, or <I>source</I> image, controls how the "<CODE><A
HREF="../option_link.cgi?compose" >-compose</A></CODE>" method should modify
the fixed <I>background</I> or <I>destination</I> image.  The image can be
re-positioned relative to the fixed <I>background</I> image (usually using
"<CODE><A HREF="../option_link.cgi?geometry" >-geometry</A></CODE>" and
"<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" settings).
However, both the <I>overlay</I> image and any meta-data it contains, is
deleted when the composite operation is finished. </P>

Sometimes a third <I>mask</I> image is added to the command.  This image is
used to define and control what parts of the <I>background</I> image will be
modified and to what degree by the resulting composition. For more details see
<A HREF="#mask" >Composite Masking</A> below.  </P>

As of IM v6.5.3-4, the special <A HREF="../basics/#define" >Define Setting</A>
"<CODE>compose:outside-overlay</CODE>" (see <A HREF="#outside-overlay"
>Outside-Overlay Setting</A>), can be set to a value of '<CODE>false</CODE>'
to disable any modification to the <I>background</I> image outside the
rectangular area that the <I>overlay</I> image covers.  Without this, some
composition <I>method</I>s will clear the areas not covered by the
<I>overlay</I>, as part of the <I>compose</I> definition. </P>

<BR>

The actual composition <I>method</I> is controlled by the "<CODE><A
HREF="../option_link.cgi?compose" >-compose</A></CODE>" setting, which
defaults to a value of '<A HREF="#over" ><CODE >Over</CODE></A>'.   That is,
the source image is drawn <B>Over</B> the <I>background</I> image, which is
what most people think of when they perform image composition. </P>

Most of this section of IM Examples is used to detail what the various
composition 'methods' do and how you can make use of them.  To view the
results of the compose methods see <A HREF="tables/" >Tables of Compose
Methods</A>. The tables do not illustrate the method's intended use, just the
raw output from various test images. </P>

The compose method is case-insensitive and the '<CODE>_</CODE>' or
'<CODE>-</CODE>' characters are optional.  As such the compose method
"<CODE>Dst_Over</CODE>" can also be specified as: "<CODE>dst_over</CODE>",
"<CODE>dst-over</CODE>", "<CODE>DstOver</CODE>", "<CODE>dstover</CODE>", or
even "<CODE>dstOVER</CODE>".  They all mean the same thing. </P>

Also, the compose methods: '<CODE>Over</CODE>', '<CODE>ATop</CODE>', '<CODE
>In</CODE>' and '<CODE >Out</CODE>' are short for the more verbose compose
method names: '<CODE>Src_Over</CODE>', '<CODE>Src_ATop</CODE>',
'<CODE>Src_In</CODE>' and '<CODE>Src_Out</CODE>'. </P>

On top of the long list of "<CODE><A HREF="../option_link.cgi?compose"
>-compose</A></CODE>" methods there are some that require extra numerical
arguments to work correctly. </P>

In the "<CODE>composite</CODE>" command these arguments are passed using the
special options: "<CODE><A HREF="../option_link.cgi?dissolve"
>-dissolve</A></CODE>", "<CODE><A HREF="../option_link.cgi?blend"
>-blend</A></CODE>", "<CODE><A HREF="../option_link.cgi?watermark"
>-watermark</A></CODE>" ('<CODE>modulate</CODE>'), "<CODE><A
HREF="../option_link.cgi?displace" >-displace</A></CODE>" and "<CODE><A
HREF="../option_link.cgi?distort" >-distort</A></CODE>". </P>

As of IM v6.5.3-4, the "<CODE>convert</CODE>" command can pass special
arguments to the "<CODE><A HREF="../option_link.cgi?composite"
>-composite</A></CODE>" operator by using the <A HREF="../basics/#define"
>Define Setting</A>, "<CODE>compose:args</CODE>".  For examples, see the
special <A HREF="#dissolve">Dissolve</A> and <A HREF="#blend" >Blend</A>
methods below.  </P>

<A NAME="compose_operators"></A>
<H3>Image Composition Operators</H3>

Apart from the direct two image compositing styles shown above, there are
a number of other image operations that also use alpha compositing as part of
their internal image processing. These operations are affected by the current
"<CODE><A HREF="../option_link.cgi?compose" >-compose</A></CODE>" setting,
though they will use either their own internal positioning, or a <A
HREF="../layers/#flatten" >Layered Image</A> virtual canvas offset positioning
technique. </P>

Here is a list of all operators that are known to be affected by the compose
setting... </P>

<BLOCKQUOTE><DL>
<DT><B><A HREF="../layers/#composition" >Composition of Pairs of Images</A></B>

<DD>Practical examples using the primary image composition operators, both
    the primative "<CODE>composite</CODE>" command, as well as the
    <A HREF="../option_link.cgi?composite" >-composite</A></CODE>"
    operator for "<CODE>convert</CODE>". </P>

    This low-level methods uses <A HREF="#geometry" >Geometry/Gravity
    Settings</A> to determine the position of the overlay image. </P>

<DT><B><A HREF="../layers/#flatten" >Layering Operators</A></B>

<DD>The image 'layerimage' operators "<CODE><A HREF="../layers/#flatten"
    >flatten</A></CODE>", "<CODE><A HREF="../layers/#mosaic"
    >mosaic</A></CODE>", and "<CODE><A HREF="../layers/#merge" >-layers
    merge</A></CODE>" overlay all multiple images in the current image
    sequence, onto a single new canvas, the size and position of which is
    determined by the layering operator chosen.  </P>

    This uses <A HREF="#page" >Virtual Canvas/Page Offset Settings</A> to
    determine the position of the overlay image. </P>

<DT><B><A HREF="../crop/#border" >Edge Expansion Operators</A></B>

<DD>Operators that overlay each individual image on internally prepared
    canvases.  This includes operators such as "<CODE><A
    HREF="../option_link.cgi?border" >-border</A></CODE>", "<CODE><A
    HREF="../option_link.cgi?frame" >-frame</A></CODE>", and "<CODE><A
    HREF="../option_link.cgi?extent" >-extent</A></CODE>".  (See <A
    HREF="../crop/#border" >Adding/Removing Image Edges</A>).</P>

    No positioning information is used, though "<CODE><A
    HREF="../option_link.cgi?extent" >-extent</A></CODE>" will make use of
    gravity and geometry offsets, to overlay on a solid color background
    image.  </P>

<DT><B><A HREF="../anim_mods/#compose_draw" >Draw Images</A></B>

<DD>The "<CODE><A HREF="../option_link.cgi?draw" >-draw 'image...'</A></CODE>"
    image overlay method will overlay a single external <I>source</I>
    image over a list of destination images. </P>

    It is the only image composition technique available to "<CODE><A
    HREF="../basics/#mogrify" >mogrify</A></CODE>".  It gets the 'overlay'
    image from an external source allowing it to overcome that command's
    no-list-operator limitation. </P>

    Resize and Position information is also given by the user, and these may
    be gravity effected. </P>

<DT><B><A HREF="../anim_mods/#composite">Multi-List Layers Composite</A></B>

<DD>The "<CODE><A HREF="../anim_mods/#composite" >-layers composite</A></CODE>"
    operator will let you compose two separate multiple image lists together,
    one pair of images at a time, to form a new merged multi-image sequence.
    It also composes a sequence of images with a single image (which can be
    either a static 'overlay' image, or a static 'destination' image).

    It is also the ONLY composition operator to allow you to use BOTH the
    universal "<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>"
    affected "<CODE><A HREF="../option_link.cgi?geometry"
    >-geometry</A></CODE>" offset (globally),  and the virtual canvas
    "<CODE><A HREF="../option_link.cgi?page" >-page</A></CODE>" offsets of
    individual images, from that global position.  </P>

    This composition operator is especially important for composing <A
    HREF="../anim_mods/#merge" >Image Animations</A>, or other image
    sequences, as a whole, rather than needing a script to process each pair
    of images at a time. </P>

</DL></BLOCKQUOTE></P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="geometry"></A>
<H2>Positioning The Overlay Image</H2>

<H3>Composite Geometry/Gravity Settings</H3>

In normal Alpha Composition the "<CODE><A HREF="../option_link.cgi?geometry"
>-geometry</A></CODE>" setting is used with "<CODE><A
HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" to position the source
image relative to the destination image.  Using these settings is covered in
great detail in <A HREF="../annotating/#image_gravity" >Image Positioning
using Gravity</A>.</P>

Note that the size component of "<CODE><A HREF="../option_link.cgi?geometry"
>-geometry</A></CODE>" is special in that it will <A
HREF="../resize/#geometry" >Resize an Image (geometry)</A>. In "<CODE><A
HREF="composite" >composite</A></CODE>" it resizes the source image but for
"<CODE><A HREF="convert" >convert</A></CODE>" the last image in the image
sequence is resized.  This is technically a separate aspect to <A
HREF="#compose" >Image Composition</A>. See <A HREF="../resize/#geometry"
>Geometry Resize</A> and <A HREF="../layers/#composite" >Layering images with
Composite</A>. </P>

In Alpha Composition only two images are involved, the 'source' and the
'destination' (or 'background'), though a third <A HREF="#mask" >Masking
Image</A> may also be provided limiting the affected area of the composition.
</P>

<A NAME="page"></A>
<H3>Layer Canvas/Page Offsets</H3>

The composition of Layered Images use a very different philosophy.  All the
images (as many as you like) are treated equally in the order given.  They all
have a "<CODE><A HREF="../option_link.cgi?page" >-page</A></CODE>" or <A
HREF="../basics/#page" >Page Offset</A> that position each image's top-left
corner relative to a virtual canvas 'origin' (the default offset) but without
gravity. </P>

To process multiple images a new background image is generated using the
current "<CODE><A HREF="../option_link.cgi?background"
>-background</A></CODE>" color with a size that is dependent on the operation
being performed.  This is assumed to be the 'destination' image (canvas).  ALL
the images are composited onto this new canvas one at a time in sequence. </P>

Even if only two images are given a new image is still created and two
separate compositions are applied. That is, it can be slow. All the images are
treated as 'source' images and the order they are listed determines the
result. </P>

The 'layer' offset however is NOT gravity affected. As each image can have
a separate 'canvas offset' multiple image composition is better applied using
<A HREF="../layers/#flatten" >Image Layering Operators</A> as well as <A
HREF="../anim_mods/#composite" >Multi-Image Sequence Composition</A> for
animations. </P>

The two styles are very different positioning techniques and it is important
you use the right style for the composition techniques you plan to use. </P>

<A NAME="both"></A>
<H3>Both positioning Techniques</H3>

Only one composition technique, the multi-image list <A
HREF="../anim_mods/#composite" >Layers Composition</A> operator, allows you to
use BOTH positioning methods simultaneously. </P>

First the two lists are globally positioned using"<CODE><A
HREF="../option_link.cgi?geometry" >-geometry</A></CODE>" and "<CODE><A
HREF="../option_link.cgi?gravity" >-gravity</A></CODE>", which is applied to
the virtual canvas size of the first image in each list.  Then each individual
image in the list is offset using "<CODE><A HREF="../option_link.cgi?page"
>-page</A></CODE>" from that global position to determine the final position.
</P>

Of course if an overlay image does not fit into a specific destination image in
the images provided, then it will be clipped by that image.  As such it is
generally a good idea to only use fully-coalesced images for the destination
image(s) to the appropriate size need.  The resulting images can of course be
trimmed in size again afterwards. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="duff-porter"></A>
<H2>Duff-Porter Alpha Composition Methods</H2>

The Duff-Porter image composition methods are a traditional set of 12 methods
which are very well defined.  They are known as Alpha Composition as the
images are merged according to some aspect of the image transparency or 'Alpha
Channel'.  You can find the mathematical definitions for these in the <A
HREF="http://www.w3.org/TR/2009/WD-SVGCompositing-20090430/" >SVG Alpha
Compositing</A> document.  </P>

Here is a classical table showing the results of these 12 methods with two
triangular images.

<CENTER>
  <A HREF="tables/montage_triangles.jpg"
     ><IMG SRC="tables/montage_triangles.jpg"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</CENTER></P>

Also see <A HREF="tables/" >Raw Tables of Compose Methods</A> with diagrams
showing more composition methods with different image shapes and gradients.
</P>

The default compose method (when completely undefined) is '<A HREF="#over"
><CODE >Over</CODE></A>', and is what most people normally want when composing
images.  </P>

To understand, and remember what each of the above compose methods do, the
resulting image would be the same as if you said...

<DIV ALIGN=center><B>
<PRE>{<I>Source</I>} --{<I>compose_method</I>}--&gt; {<I>background</I>}<PRE>
</B></DIV></P>

That is, the resulting image for method '<CODE>ATop</CODE>' is equivalent to "<B>the
overlay image '<CODE>ATop</CODE>' of the background image</B>".  Meaning, the
background image will keep its 'shape' but the colors of the source image will
sit 'on top' of the background. </P>

However remember the image order is reversed when using the "<CODE><A
HREF="../option_link.cgi?composite" >convert -composite</A></CODE>" operator.
</P>

These 12 methods define not only which of the two images are
'visible' in the result,  but also how it affects the part of the image which
is NOT overlaid by the <I>source</I> image.  That is, whether the original
'background' is left as is or completely cleared.  I purposefully made the
'destination' image in the above table larger so that you can see if the
rest of the image was cleared or not. </P>

These 'clearing' methods are: '<CODE><A HREF="#src" >Src</A></CODE>',
'<CODE>In</CODE>', '<CODE><A HREF="#dstin" >Dst_In</A></CODE>',
'<CODE>Out</CODE>', '<CODE>Dst_ATop</CODE>', and '<CODE><A HREF="#clear"
>Clear</A></CODE>'.  As of IM v6.5.3-4 you can use a <A
HREF="../basics/#define" >Define Setting</A>
"<CODE>compose:outside-overlay=false</CODE>" to prevent Duff-Porter
composition clearing the <I>destination</I> image outside the overlaid area.
See examples in '<CODE><A HREF="#copy" >Copy</A></CODE>' and '<CODE><A
HREF="#clear" >Clear</A></CODE>' composition methods, and the <A
HREF="#outside-overlay" >Outside-Overlay Setting</A>, for details.</P>

Note that '<CODE><A HREF="#copy" >Copy</A></CODE>' is a special '13th'
composition method provided by IM.  Basically is equivalent to an '<CODE><A
HREF="#over" >Over</A></CODE>' composition, but with background clearing in
the overlaid area.  However in implementation terms it is a '<CODE><A
HREF="#src" >Src</A></CODE>' composition with outside-overlay (or background
clearing) disabled. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify><FONT SIZE=-1><I>
  ImageMagick v5 and before did not clear any area not overlaid by the source
  image.  This was incorrect handling of the Duff-Porter Composition
  operators, and was corrected during IM v6 development.
</I></FONT></TD></TR></TABLE></P>

One of the most important aspects of Duff-Porter Alpha Composition methods is
that they will never make any 'fully transparent colored pixel' visible.  This
is important as a fully transparent part of the image has an undefined color.
It could actually contain ANY color value without effecting the visible result
of the image.  See <A HREF="../masking/#alpha" >Controlling Image
Transparency</A> for details about 'handling the transparency channel'.  </P>

This is why Duff-Porter composition is often the preferred masking method,
rather than the alternative '<CODE><A HREF="#copyopacity"
>CopyOpacity</A></CODE>' which completely replaces the Alpha Channel of an
image, and can make the undefined invisible colors, visible.  </P>


<A NAME="over"></A>
<H3>Over <FONT SIZE=3>(overlay image over background)</FONT></H3>

This is the default compose method, the one everyone thinks of when overlaying
an image on top of another image.  The overlay image is placed 'over' the
background image in the same way as an 'animation cell' or 'overhead
transparency' can be placed over a background scene or image.  </P>

It is so common that I doubt I really need to say much more. So lets present a
example of overlaying a single letter image over a background image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -background none  -fill white \
          -font Ravie  -pointsize 36   label:A   label_A_white.png
  composite -gravity center label_A_white.png   rose:   compose_over.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="label_A_white.png"
     ><IMG SRC="label_A_white.png"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="compose_over.gif"
     ><IMG SRC="compose_over.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The overlay can be centered with gravity as above, or positioned exactly using
a "<CODE><A HREF="../option_link.cgi?geometry" >-geometry</A></CODE>" setting.
If it is positioned outside the bounds of the background it will be clipped,
or ignored, as appropriate.  </P>

In this example, the image is overlaid using the "<CODE>convert
-composite</CODE>" operator, but positioned half way above the background.
Note the reversal of the image order.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose:   label_A_white.png \
          -geometry +5-15   -composite   convert_over.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="convert_over.gif"
     ><IMG SRC="convert_over.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="dstover"></A>
<H3>Dst_Over <FONT SIZE=3>(put image 'under' background)</FONT></H3>

Like other 'Dst_' methods, this works almost exactly like the 'Src_' version
of the method, but with the overlay and background images swapped.  As such
'<CODE><A HREF="#dstover" >Dst_Over</A></CODE>'   is  equivalent  to  placing
the source overlay image 'under'  the destination.  The result is that only
the parts of our source or overlay image not hidden by the destination or
background image will be visible as they peek out from underneath.  </P>

This is NOT exactly the same as '<CODE><A HREF="#over" >Over</A></CODE>' with
argument images swapped, as the size, positioning and other image meta-data,
still comes from the background or destination image. Remember the output
image size is the same as the 'background' image, and position of the source
image is relative to the background (using "<CODE><A
HREF="../option_link.cgi?geometry" >-geometry</A></CODE>" and "<CODE><A
HREF="../option_link.cgi?gravity" >-gravity</A></CODE>"). </P>

For example, here we overlay a black 'A; label 'under' our original white A.
We can reposition the black A, relative to the white A background.  As you can
see this is great for adding a hard shadow, without needing to worry about
expanding the image size.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -background none  -fill black \
          -font Ravie  -pointsize 36   label:A   label_A_black.png
  composite -compose Dst_Over  -geometry +5+5 \
          label_A_black.png  label_A_white.png   compose_under.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="label_A_black.png"
     ><IMG SRC="label_A_black.png"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="compose_under.png"
     ><IMG SRC="compose_under.png"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TD></TR></TABLE></P>

The important thing to note is that the size of the background is preserved
while the overlay's position, relative to the background, can be modified and is
clipped by the background.  This is what makes this operator such an important
and useful operator. </P>

The "<CODE><A HREF="../option_link.cgi?tile" >-tile</A></CODE>" setting of
"<CODE>composite</CODE>" also makes this form of 'over' very useful as a way
to tile underneath an image.  For example, tile the built in checkerboard
pattern underneath the shadowed letter we just created.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite  -compose Dst_Over -tile pattern:checkerboard \
             compose_under.png   compose_under_tiled.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="compose_under_tiled.jpg"
     ><IMG SRC="compose_under_tiled.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="src"></A>
<H3>Src <FONT SIZE=3>('crop' to background image dimensions)</FONT></H3>

This operator completely replaces the background image with the
overlay image.  The colors and transparency in the background are completely
junked leaving a blank image the same size as the original destination over
which is applied the source image. </P>

But what good is that? Well, two things.</P>

First, you are effectively replacing the background image
with the source image but preserving all the meta-data associated with the
original background image.  That is, the image changes but the meta-data does
not. </P>

Second, the size of the final image does not change
even though the image content does.  That is, the resulting image has
the same size as the original background.  As such you can effectively use
this operator to either crop or add a border to the source or overlay image so
that it becomes the same size as the given background image (along with the
background meta-data).  </P>

For example, suppose you want to make a plasma image and clip it so it is the
same size at the built-in rose image.  This will let you do it without
needing to know just how big the rose image is.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  composite -compose Src  -size 100x100  plasma:tomato-dodgerblue \
            rose:   compose_crop.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="compose_crop.gif"
     ><IMG SRC="compose_crop.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course the above is equivalent to a "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>" of the plasma image, not a
'resize'.  The original image's meta-data is also preserved. That is even
though this is now a plasma image, the image meta-data says it is still
a 'rose' image and came from the "rose:" image source. </P>

<BR>

If the overlay is smaller then the rest of the background image is replaced
with transparency to fill it out.  Please note however that the background
must have an alpha channel, or it will fill the extra space with black (the
color that '<CODE>none</CODE>' or '<CODE>transparent</CODE>' has without any
alpha channel).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose Src -gravity South \
            hand_point.gif   rose:   -alpha set   compose_expand.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="../images/hand_point.gif"
     ><IMG SRC="../images/hand_point.gif"     WIDTH=32 HEIGHT=32
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="compose_expand.gif"
     ><IMG SRC="compose_expand.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<A NAME="copy"></A>
<H3>Copy <FONT SIZE=3>(copy or replace image)</FONT></H3>

This operator is not one of the 12 'Duff-Porter' compose methods
which is why it was not on the chart above. It is very important
nevertheless.  It works exactly like the "<CODE>Src</CODE>" compose method,
but it does not touch the background image outside the overlaid area. That is,
it limits its copying abilities to just the area overlaid and nothing else.
</P>

This allows you to crop a small section of a larger image, work on the
smaller image for speed, then 'copy' the results back onto the larger image
without touching the other areas of that image.  This in turn allows you to
optimize image processing of very large images. </P>

Here is the same example I used above, but using '<CODE><A HREF="#copy"
>Copy</A></CODE>' instead of '<CODE><A HREF="#src" >Src</A></CODE>', showing
how IM will not waste time clearing out the rest of the background as demanded
by the 'Duff-Porter' algorithm.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose Copy -gravity South \
            hand_point.gif   rose:   -alpha set   compose_copy.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_copy.gif"
     ><IMG SRC="compose_copy.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This operator is also very similar to '<CODE><A HREF="#over"
>Over</A></CODE>', except that the transparency of the source image is also
copied, replacing the background image completely. If there is no
transparency it would perform exactly like '<CODE><A HREF="#over"
>Over</A></CODE>'. </P>

Internally, it modifies the special composition control setting
"<CODE>outside-overlay</CODE> (See Next). </P>


<A NAME="outside-overlay"></A>
<H4>Outside-Overlay Setting</H4>

As of IM v6.5.3-4 the ability to control if a composition method will effect
also areas outside the area overlaid was made user controllable by <A
HREF="../basics/#define" >Defining</A> "<CODE>compose:outside-overlay</CODE>".
It is 'on' by default but you can turn it off by setting it's value to
"<CODE>false</CODE>".   For example, here is an equivalent to the
<A HREF="#copy" >Copy Composition Method</A> but using the more traditional
<A HREF="#src" >Src Composition Method</A>..

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  hand_point.gif -alpha set -gravity South \
          -define compose:outside-overlay=false \
          -compose Src -composite    compose_copy_src.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_copy_src.gif"
     ><IMG SRC="compose_copy_src.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For an example of using this flag see <A HREF="../thumbnails/#pagecurl"
>PageCurl Corner Overlays</A>. </P>


<H4>Outside-Overlay vs SVG 'clip-to-self'</H4>

The "<CODE>compose:outside-overlay</CODE>" define is in many ways similar to
using the SVG 'clip-to-self' attribute.  Both restricts teh composition to
just the region overlaid, without effecting the rest of the destination image.
</P>

However SVG 'clip-to-self' applies only to the painted area (like a mask),
where IM's 'outside-overlay' setting applies to full rectangular area of the
source image where it overlay's the background image.  </P>

This is not very clear in the SVG Composition manual, as the examples given
are not explained very well, making them very confusing. But if you want to
try to understand them, see <A
HREF="http://www.w3.org/TR/SVGCompositing/#clip-to-self-property" >SVG
Composition 'clip-to-self' property</A> or <A
HREF="http://www.svgopen.org/2005/papers/abstractsvgopen/index.html#S10."
>Understanding SVG 1.2 composition, clip-to-self</A>. </P>

Note that a <A HREF="../masking/#write_mask" >Write Mask</A> can also be used
to achieve this type of control, but using shaped areas according to the mask
that is given. In this respect it is much more like the SVG 'clip-to-self'
attribute, where the source image is also used as the write mask. </P>


<A NAME="dst"></A>
<H3>Dst <FONT SIZE=3>(a 'no-op' compose)</FONT></H3>

This operator does nothing. The source, or overlay image,
is completely ignored and the destination, or background image, is left unchanged. </P>

The method's real use is as a means of 'turning off' an alpha composition
operation in other image operators. </P>

For example, we use the <A HREF="../crop/#frame" >Frame Operator</A> to
frame our rose image (with a transparent background) but then use
"<CODE>-compose Dst</CODE>" to prevent the image from being added to the
frame.  In other words, we only use the rose to set the size of the internal
frame of the result.  The frame, and only the frame, is the result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:   -alpha set  -mattecolor Gold  -bordercolor none \
          -compose Dst   -frame 7x7+3+2   compose_frame_dst.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_frame_dst.gif"
     ><IMG SRC="compose_frame_dst.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The special <A HREF="../basics/#alpha_set" >Alpha Set</A> operation assures an
<A HREF="../basics/#alpha" >Alpha Channel</A> is available in the image or you
will end up with a black middle rather than a transparent one. The "<CODE><A
HREF="../option_link.cgi?bordercolor" >-bordercolor</A></CODE>" defines the
color inside the frame which is usually placed underneath the source image.
</P>

The '<CODE><A HREF="#dst" >Dst</A></CODE>' method can also be useful in a
script to disable an alpha composition in a large an complex command without
needing to create two different IM commands. </P>


<A NAME="dstin"></A>
<H3>Dst_In <FONT SIZE=3>(or 'mask' the background with source)</FONT></H3>

The '<CODE><B>Dst_In</B></CODE>' method is like using the source image as a '<A
HREF="#copyopacity" ><CODE >Copy_Opacity</CODE></A>' mask for the background
image.  It will remove the overlay image's shape from the background image
like a cookie cutter which cuts out a cookie's shape from cookie dough.  </P>

For example, let's use the fancy 'A' from above as a mask to cut out its shape
from the rose image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose Dst_In  -gravity center \
            label_A_white.png  rose: -alpha Set  compose_mask.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_mask.png"
     ><IMG SRC="compose_mask.png"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Unlike the '<CODE><A HREF="#copyopacity" >Copy_Opacity</A></CODE>' method you
can NOT use a greyscale image as the mask as only the overlay image's alpha
channel is used in this operation.  Any color in the overlay is completely
ignored. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  All '<CODE>Dst_In</CODE> and '<CODE>Src_In</CODE>' methods actually does
  is multipy the alpha channels of the two images. The color of the
  appropriate image (according to the method) is preserved.
</I></FONT></TD></TR></TABLE></P>


<A NAME="dstout"></A>
<H3>Dst_Out <FONT SIZE=3>(or a 'erase' operation)</FONT></H3>

Using the 'cookie dough' metaphor of '<CODE><A HREF="#dstin"
>Dst_In</A></CODE>' the result of the '<CODE><B>Dst_Out</B></CODE>' method is
the dough that was left behind once a cookie has been cut out.  </P>

It can be used to cut holes, or take bites out of the background image, using
the shape of the overlay.  Any color in the overlay is again completely
ignored. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose Dst_Out  -gravity center \
            label_A_white.png  rose: -alpha Set  compose_erase.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_erase.png"
     ><IMG SRC="compose_erase.png"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The mathematical formulae of these two compose methods are designed explicitly
so that if you use '<CODE><A HREF="#dstin" >Dst_In</A></CODE>' and '<CODE><A
HREF="#dstout" >Dst_Out</A></CODE>' on the same set of images, you can fit
them back together (using '<CODE><A HREF="#plus" >Plus</A></CODE>' method)
just like a jigsaw puzzle. </P>

For example here we 'add' (using '<CODE><A HREF="#plus" >Plus</A></CODE>'
composition) the last two images we generated above.  This image is exactly
the same (to the pixel) as the original '<CODE>rose:</CODE>' image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose Plus  compose_mask.png  compose_erase.png \
            compose_rejoin.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_rejoin.png"
     ><IMG SRC="compose_rejoin.png"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE ASSERT>
  # check the colors come put correctly
  [ `compare -metric PAE rose: -alpha Set compose_rejoin.png null: 2>&1 |\
        sed 's/ .*//'` != '0' ] &&  echo >&2 \
    "ASSERTION FAILURE: Compose IN & OUT do not reform original image\!"
  # Test the alpha channel comes out as a single value
  [ `convert compose_mask.png  compose_erase.png \
          -channel A,Sync -evaluate multiply .5 \
          -compose Plus -composite  -alpha extract -unique-colors \
          -format %k info:` != '1' ] &&  echo >&2 \
    "ASSERTION FAILURE: Compose IN & OUT does not generate a single color\!"
  # And that it is an addition!  (single point test only)
  [ `convert compose_mask.png  compose_erase.png -crop 1x1+50+29 \
          -channel A,Sync -evaluate add -1 \
          -compose Plus -composite -alpha extract \
          -depth 16 txt:- | grep FFFDFFFDFFFD | wc -l` != '1' ] &&  echo >&2 \
    "ASSERTION FAILURE: Compose IN & OUT alpha did not 'plus' perfectly\!"

</CODE>

# Note   -separate         extracts the opacity channel,
# But    -alpha Extract    extracts the alpha channel

# Single point test (verbose)
  convert compose_mask.png  compose_erase.png -depth 16 -crop 1x1+50+29 \
      -print "---Original Colors---\n"  -write txt:- \
      -channel A,Sync -evaluate add -1 \
      -print "---Alpha Decremented---\n"  -write txt:- \
      -compose Plus -composite \
      -print "--Plus Composition...\n"  -write txt:- \
      -print "--Result should be:  unchanged color,  and alpha-2\n" \
      -print "That is alpha value of 65533 and a hex color of  #...FFFD\n" \
      null:

-->


Erasing part of an image is not an easy task in any graphics program. For
example a "<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>"
operation can only add color to an image. It will not remove color once it has
been applied to your canvas.  Think of a painter who is painting some
advertising on a glass door or window. He, or she, can add paint, but can't
remove paint, by painting over it. </P>

By drawing the shape you want to erase onto a transparent canvas, you can then
use '<CODE><A HREF="#dstout" >Dst_Out</A></CODE>' to remove it from your
working image. It's a bit like our painter carefully wiping off wet paint with
a specially shaped rag.  The shape can be used to remove all or some of the
color making it either fully or semi-transparent. </P>

For example, suppose you want to draw a crescent moon symbol on a transparent
canvas. This alpha composition method makes this difficult shape easy to
draw by overlaying two circles.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 70x70 xc:none -fill white -draw 'circle 35,35 35,5' \
          \( -size 70x70 xc:none -fill black -draw 'circle 28,30 35,5' \) \
          -alpha Set -compose Dst_Out  -composite   moon_crescent.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="moon_crescent.png"
     ><IMG SRC="moon_crescent.png"     WIDTH=70  HEIGHT=70
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The second image must be created and drawn in parenthesis.  If you don't
  you will find that "<CODE><A HREF="../option_link.cgi?draw"
  >-draw</A></CODE>" will draw onto BOTH the overlay image AND your original
  background which is obviously wrong. <P>

  If you did not use parentheses you will find a circle of semi-transparent
  black pixels around the erased part of the image. I know, it happened to me
  while creating this example much to my own annoyance.


</I></FONT></TD></TR></TABLE></P>


<A NAME="atop"></A>
<H3>ATop <FONT SIZE=3>('Over', but clip to background image)</FONT></H3>

Like '<CODE><A HREF="#over" >Over</A></CODE>' but limit the result to the
original shape of the background image.  In other words, the alpha channel on
the destination is unchanged but the image colors are overlaid by any
non-transparent parts of the source image. </P>

If the background image is fully opaque (no transparency), this operation will
act exactly like the normal '<CODE><A HREF="#over" >Over</A></CODE>'
composition.  It only differs when the background contains transparency which
also clips the overlay. </P>

What makes this useful is for overlaying lighting and shading effects that are
limited to the object (shape) of the destination. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
For example, say we have a red circle and want to add a highlight as if
it is a 3 dimensional ball.  We can create the circle, and the highlight,
then overlay the highlight using '<CODE><A HREF="#atop" >ATop</A></CODE>' to
limit it to the circle.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 70x70 xc:none \
            -fill red -draw 'circle 35,35 10,30'  red_circle.png

  convert -size 70x70 xc:none -draw 'circle 35,35 35,20' \
          -negate  -channel A -blur 0x8    red_highlight.png

  composite -compose ATop -geometry -13-17 red_highlight.png \
            red_circle.png red_ball.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="red_circle.png"
     ><IMG SRC="red_circle.png"     WIDTH=70  HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="red_highlight.png"
     ><IMG SRC="red_highlight.png"     WIDTH=70  HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="red_ball.png"
     ><IMG SRC="red_ball.png"     WIDTH=70  HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The creation of the white highlight was done using "<A
  HREF="../option_link.cgi?negate" ><CODE>-negate</CODE></A>" to ensure the
  whole image is actually white.  This was used to avoid a bug in the "<A
  HREF="../option_link.cgi?blur" ><CODE>-blur</CODE></A>" operator, which has
  now been fixed in IM version 6.2.4.  See <A HREF="../bugs/blur_trans/" >Blur
  with Transparency Bug</A> for more details of this old bug.
</I></FONT></TD></TR></TABLE></P>

In a similar way we can add a fuzzy shadow to our ball clipped to the
boundaries of the ball itself so that it looks even more 3-D like.  I'll leave
it as an exercise to the reader to figure out how the following command
achieves this result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  moon_crescent.png -fx 0 -channel A -blur 0x7 \
           red_ball.png  +swap -compose ATop -composite  red_ball2.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="red_ball2.png"
     ><IMG SRC="red_ball2.png"     WIDTH=70  HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

With a little more care with preparatory images the above image can be made
even more realistic. For showing the usage of this compose method, it
isn't bad. </P>

Further examples of using '<CODE><A HREF="#atop" >ATop</A></CODE>' compose
method, can be seen in <A HREF="../advanced/#3d-logos" >Generating 3-D
Logos</A>. </P>


<A NAME="clear"></A>
<H3>Clear <FONT SIZE=3>(Clear the Background. Ignore overlay image)</FONT></H3>

This is an unusual compose method that essentially ignores the overlay image
completely, and just clears the background image. </P>

This makes it an ideal method of creating a transparent or black canvas, the
same size as the background image, for complex projects.  As the overlay image
is not used, a single pixel "<CODE>null:</CODE>" image is a good overlay to
use.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose Clear null:  rose: -alpha Set compose_clear.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_clear.png"
     ><IMG SRC="compose_clear.png"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

Of course the <A HREF="../basics/#alpha_set" >Alpha Set</A> operation (while
not needed in this case) assures the destination has an alpha channel that can
be used when clearing the image to transparency. </P>

If you specifically <A HREF="#alpha_off" >turn off the alpha channel</A>, then
the operator will clear the image to black, due to the mathematics involved.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose Clear null:  rose: -alpha Off compose_black.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_black.png"
     ><IMG SRC="compose_black.png"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The special <A HREF="../basics/#define" >Define Setting</A>
"<CODE>compose:outside-overlay</CODE>" allows you limit this clearing to just
the area overlaid regardless if the overlay image contains transparency or
not.  For example:

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  hand_point.gif -alpha Set -gravity South \
          -define compose:outside-overlay=false \
          -compose Clear -composite   compose_clear_limited.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_clear_limited.gif"
     ><IMG SRC="compose_clear_limited.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="xor"></A>
<H3>Xor <FONT SIZE=3>(Clear the area shared)</FONT></H3>

This is a very strange and little used composition method.
It overlays two images then clears the overlapped area to transparency.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 \
          \( xc:none -fill blue   -draw 'circle 21,39 24,57' \) \
          \( xc:none -fill red    -draw 'circle 39,39 36,57' \) \
          -compose Xor   -composite   compose_xor_2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_xor_2.png"
     ><IMG SRC="compose_xor_2.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Things get even more interesting when a third image is xor'ed on the above
result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60  compose_xor_2.png  \
          \( xc:none -fill green  -draw 'circle 30,21 30,3'  \) \
          -compose Xor   -composite   compose_xor_3.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_xor_3.png"
     ><IMG SRC="compose_xor_3.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see overlapping multiple images can produce some wonderful
effects where any even number of images overlapping will be clear, while any
odd number of overlapping images will result in the last image overlaid showing through.
</P>

<PRE>FUTURE:  Xor effects on semi-transparent images get extremely weird.
Explore this and create an example demonstrating this weirdness.
</PRE></P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="math"></A>
<H2>Mathematical Compose Methods</H2>

This group of compose methods lets you perform mathematics with the images.
This may not seem very useful but for low level manipulation of images the
methods allow you to do things which you may not normally think of. </P>

Unlike the previous <A HREF="#duff" >Duff-Porter</A> image composition methods
they are generally greyscale methods.  That is they are usually applied to
images were either one or both images are greyscale, and usually do not
contain transparency.  That is not to say transparency can not be used (see <A
HREF="#math_blending" >Mathematical Composition and Alpha</A> below), but it
is not a very common practice. </P>

The default usage of Math Compositions is defined by the SVG image file format
specification.  You can read more about them in <A
HREF="http://www.w3.org/TR/2009/WD-SVGCompositing-20090430/" >SVG Composition
Guide (2009)</A>, also in <A
HREF="http://www.pegtop.net/delphi/articles/blendmodes/" >Pegtop Blend
Modes</A> and <A HREF="http://www.simplefilter.de/en/basics/mixmods.html"
>SimpelFilter: Photoshop Blend Modes</A>. </P>

The special gradient image you see adjacent to each of the following operators
visualizes the operator in terms of how it affects color values.  The result
is produced by composing two gradient images as in the following...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 64x64 gradient:             gradient_src.png
  convert -size 64x64 gradient: -rotate 90  gradient_dst.png
  composite gradient_src.png -compose Multiply gradient_dst.png \
            gradient_result.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="gradient_src.png"
     ><IMG SRC="gradient_src.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Source
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT=" + ">
</TD><TD ALIGN=center>
  <A HREF="gradient_dst.png"
     ><IMG SRC="gradient_dst.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dest
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT="=>">
</TD><TD ALIGN=center>
  <A HREF="gradient_result.png"
     ><IMG SRC="gradient_result.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Result
</TD></TR></TABLE>
</DIV></P>

Basically, if you use the color value of the overlay (source) pixel
vertically, and the background (destination) pixel horizontally, you can look
up the value that will result from applying that operator with those values.
</P>

In the above example, you will see that '<CODE><A HREF="#multiply"
>Multiply</A></CODE>' will generally make images darker, and that any black
value (0) in either input image will produce a black result.  Something that
can be very useful. </P>

<!--  Generate all the Gradient Tables for each image
<CODE EXECUTE SCRIPT>
  methods='
          Plus         ModulusAdd   Minus         ModulusSubtract
          Screen       Multiply     Difference    Exclusion
          Lighten      Darken       -none-        Divide
          LinearDodge  LinearBurn   ColorBurn     ColorDodge
          Overlay      SoftLight    PegtopLight   -none-
          HardLight    Pinlight     LinearLight   VividLight
          Bumpmap
          '

  utf_arrow=`env LC_CTYPE=en_AU.utf8 printf '\u2500\u2192'`

  for method in $methods; do
    [ "X$method" = 'X-none-' ] && continue
    convert gradient_dst.png gradient_src.png \
            -compose $method  -composite -compose Over \
            -bordercolor blue -border 1 \
            -background LightSteelBlue -pointsize 12 -font Arial \
            -size 66x \( label:"Dest $utf_arrow" \) -append \
            \( label:"Src $utf_arrow" -rotate -90 \) +swap +append \
            gradient_op_`echo $method | tr 'A-Z' 'a-z'`.png
  done
</CODE>-->

<A NAME="multiply"></A>
<A HREF="gradient_op_multiply.png"
   ><IMG SRC="gradient_op_multiply.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Multiply
&nbsp <FONT SIZE=5>(
<IMG SRC="../img_www/multiply.gif" ALIGN=absmiddle>
)</FONT> &nbsp;
<FONT SIZE=3>(make white transparent for diagrams/text)</FONT></H3>


Is one of the more useful, but under-rated, compose methods and is a simple
multiply of the two images. </P>

Its formula is of course: &nbsp; <CODE> <I>Src</I>*<I>Dest</I> </CODE> </P>

This means that if one of the images is pure white, the result will be the
other image. On the other hand if one image is black the result will be black.
Between these extremes one image will darken the destination image by the
amount given. </P>

Note that '<CODE>Multiply</CODE>' will only darken an image, it will never
brighten it.  That is, it 'attenuates' an image toward black, which makes this
compose method a '<I>Burn</I>' style of composition. (See <A HREF="#light"
>Lighting Composition Methods</A> below) </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert label:Rose label_white.gif
  composite -compose Multiply -gravity center \
            label_white.gif  rose:  compose_multiply.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="label_white.gif"
     ><IMG SRC="label_white.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="compose_multiply.gif"
     ><IMG SRC="compose_multiply.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TD></TR></TABLE></P>

This method works very well in a lot of situations, but is especially good
when one of the images images has black (or greyscale)
lines on a mostly white background, such as text images.  If both images
contain regions of color, then you may get unusual results.  </P>

In other words. this technique is perfect for overlaying images and other
diagrams directly onto line drawings with a white or very light colored
background.  </P>

For example, I want to add some diagrams to a page of text which will be
included in a ray-traced image.  You can see this 'page of text' in the image
resulting images of my <A
HREF="http://www.ict.griffith.edu.au/anthony/graphics/polyhedra/" >Studies in
Polyhedra</A>. </P>

Given two grey scale image masks, multiply is also a good way to erase parts
of an image to black based on some mask. It does this linearly, so the mask
can be a greyscale image rather than a purely Boolean on/off image. See <A
HREF="../masking/#compose" >Mathematical Composition</A>. </P>

Multiplying an image with itself is actually an useful technique to produce
a squared darkening of an image, so bright colors remain prominent, but other
colors become darker. Actually this is equivelent to a <A
HREF="../color_mods/#gamma" >Gamma</A> operator with a value of
"<CODE>0.5</CODE>", or an <A HREF="../transform/#evaluate_pow" >Evaluate
PowerOf</A> operation with a value of "<CODE>2.0</CODE>". </P>

For example see a <A HREF="../advanced/#stars" >Star
Generator</A>, to produce a more realistic distribution of star intensities.
Or it can be used on satellite cloud images before overlaying the result on a
geographical map. </P>

<A NAME="screen"></A>
<A HREF="gradient_op_screen.png"
   ><IMG SRC="gradient_op_screen.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Screen
<FONT SIZE=3>(make black transparent for diagrams/text)</FONT></H3>

This is almost exactly like '<CODE><A HREF="#multiply" >Multiply</A></CODE>'
except both input images are negated before the compose, and the final result
is also then negated again to return the image to normal.  In technical terms
the two methods are 'Duals' of each other. </P>

That makes its formula: &nbsp;
   <CODE> 1-(1-<I>Src</I>)*(1-<I>Dest</I>) </CODE> </P>

This means that if one of the images is pure black, the result will be the
other image. On the other hand if one image is white the result will be white.
Between these extremes one image will lighten the destination image by the
amount given. </P>

Note that a '<CODE>Screen</CODE>' composition will only make an image
brighter, never darker.  This is a style of composition known as
'<I>Dodge</I>' composition. (See <A HREF="#light" >Lighting Composition
Methods</A> below) </P>

This composition method is perfect for overlaying white text on a black
background, then onto other images...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -background black -fill white label:Rose label_black.gif
  composite -compose Screen -gravity center \
            label_black.gif  rose:  compose_screen.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="label_black.gif"
     ><IMG SRC="label_black.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="compose_screen.gif"
     ><IMG SRC="compose_screen.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

See <A HREF="../masking/#compose" >Mathematical Masking</A> for an example of
using this to overlay a white shape on an image. </P>



<A NAME="bumpmap"></A>
<A HREF="gradient_op_bumpmap.png"
   ><IMG SRC="gradient_op_bumpmap.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Bumpmap <FONT SIZE=3>(greyscale multiply)</FONT></H3>

The '<CODE><A HREF="#bumpmap" >Bumpmap</A></CODE>' method is essentially
the same as '<CODE><A HREF="#multiply" >Multiply</A></CODE>', except
that the source image is converted into grey-scale before being overlaid.  In
other words, it will darken the image anywhere the source image is dark. </P>

You could think of this as a 'multiply by intensity' type operator. </P>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose Bumpmap -gravity SouthEast -geometry +3+3 \
            hand_point.gif   cyclops.gif   -alpha Set   compose_bumpmap.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="compose_bumpmap.gif"
     ><IMG SRC="compose_bumpmap.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

Note how the "<CODE>hand_point.gif</CODE>" image is grayscaled before
applying. </P>

Its original purpose is to add texture (like a paper or fabric texture) to
images.  However as it can only darken images, it is not as useful as the
'<CODE><A HREF="#hardlight" >HardLight</A></CODE>' method which can both
lighten and darken images (see below). </P>


<A NAME="divide"></A>
<A NAME="dividesrc"></A>
<A NAME="dividedst"></A>
<A HREF="gradient_op_divide.png"
   ><IMG SRC="gradient_op_divide.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Divide, Divide_Dst, Divide_Src
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/divide.gif" ALIGN=absmiddle>
)</FONT> &nbsp;
<FONT SIZE=3>(removing shading effects)</FONT></H3>

The two images are divided from each other. Which image divides which depends
on if '<CODE>Divide_Src</CODE>' or '<CODE>Divide_Dst</CODE>' is applied. </P>

The formula for
'<CODE>Divide_Dst</CODE>' is &nbsp; <CODE><I>Src</I> / <I>Dest</I></CODE>
&nbsp; and for
'<CODE>Divide_Src</CODE>' is &nbsp; <CODE><I>Dest</I> / <I>Src</I></CODE> </P>

Due to the order of images normally defined in image composition, and the
"<CODE>composite</CODE> command, the original method '<CODE>Divide</CODE>
meant...

<DIV ALIGN=center><B>
<PRE>{<I>Source</I>} Divide {<I>background</I>}<PRE>
</B></DIV></P>

That is to say the original method name "<CODE>Divide</CODE>' is a synonym for
"<CODE>Divide_Dst</CODE>" meaning  "divide by destination". It is also the
operator used to define the displayed gradient chart. </P>

Note that the order of the images is very important as you get very different
results if the images, or the operator are swapped.  This is especially the
case with the "<CODE>convert</CODE>" command, which has the destination
image before the source image. </P>

Remember it is the destination image will define the actual final size, and
the meta-data in the resulting composition of the two images.  Also remember
it is the source image that is positioned relative to the destination image.
</P>

This composition method is of greatest practical use in the <A
HREF="../photos/#vignettation" >Removal of Vignette from Photographs</A>.  In
the next example I will use it as a means of background removal.</P>

<BR>

As normalized color values are used and these normally range from 0.0 (black)
to 1.0 (white), division will in fact brighten the numerator image, by the
amount of 'black' that appears within the image you are 'dividing by'. </P>

Now dividing to images, so the 'numerator' image (the one not specified by the
operator) is brightened, may sound weird.  It is however a very useful
operation.  It means you can effectively remove dark patches from an image
caused either by lens vignetting, bad scanning, or tinting caused by age. </P>

For example, I have an image of hand written text which was very roughly
scanned (using a digital camera without flash, then reduced in size to remove
digital noise).  The paper has faded edges, and as a flash was not used the
background is very dark, and has shading effects because the paper wasn't
completely flat. </P>

<DIV ALIGN=center>
  <A HREF="../images/text_scan.png"
    ><IMG SRC="../images/text_scan.png"
          ALIGN=middle VSPACE=4 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Just normalizing the image to enhance the contrast of the image doesn't help
to remove the edge coloring or other shading effects.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert text_scan.png -normalize text_scan_norm.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="text_scan_norm.png"
     ><IMG SRC="text_scan_norm.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

However by blurring the image to remove the lines, and then dividing that from
the original, we effectively remove all the gross shading effects from the
image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert text_scan.png \( +clone -blur 0x20 \) \
          -compose Divide_Src -composite  text_scan_divide.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="text_scan_divide.png"
     ><IMG SRC="text_scan_divide.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The result of the division is that the background color is turned white, while
the thin lines of the text remain clear, though slightly 'thinner'. </P>

As you can see it is a lot clearer than just normalizing it though some of
the anti-aliasing was also removed. Some extra adjustments could have been
made to the divisor image, but it is very close to what is expected. </P>

Using smaller blurs can produce an alternative means of generating artistic
outline images, such as shown in <A HREF="../photos/#color-in" >Coloring In
Outline Images</A>. </P>

This operator could be combined with a background gradient generator, such as
<A HREF="../canvas/#sparse-color" >Sparse Color Gradients</A> to generate
better background 'divisor' images, than just simply blurring the whole image.
</P>

<BR>

The divide operators are actually the similar to the '<CODE><A
HREF="#colordodge" >Color_Dodge</A></CODE>' composition method, but with the
divisor image negated, and used as the source image.  This is the composition
that it typically used in Photoshop, however it may require you to <A
HREF="../basics/#swap" >Swap</A> and <A HREF="../color_mods/#negate"
>Negate</A> images.  See '<CODE><A HREF="#colordodge" >Color_Dodge</A></CODE>'
for equivalences.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.6.8-5 only the original '<CODE><A HREF="#divide"
  >Divide</A></CODE>' method was provided (equivalent to the newer
  '<CODE><A HREF="#dividedst" >Divide_Dst</A></CODE>').
</I></FONT></TD></TR></TABLE></P>


<A NAME="plus"></A>
<A HREF="gradient_op_plus.png"
   ><IMG SRC="gradient_op_plus.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Plus
&nbsp <FONT SIZE=5>(
<IMG SRC="../img_www/plus.gif" ALIGN=absmiddle>
)</FONT> &nbsp;
<FONT SIZE=3>(Add colors together to form a blend)</FONT></H3>

Add the colors of the overlay to the background.  In essence causing the two
images to blend together equally. </P>

Its formula is naturally: &nbsp; <CODE> <I>Src</I> + <I>Dest</I> </CODE> </P>

Note however that if the added colors overflow the color limits, the color
will be clipped by the normal color range limits. This is why half the image
in the resulting gradient image is pure white, as these values were clipped at
their maximum value.  Caution is recommended to ensure that the resulting
image is not clipped if that is not wanted. </P>

The operator has a number of major uses. </P>

Merging together images which contain separate channel colors, but where only
the individual channel has color.  For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 xc:none -fill red \
          -draw 'circle 30,21 30,3'   compose_R.png
  convert -size 60x60 xc:none -fill lime \
          -draw 'circle 39,39 36,57'  compose_G.png
  convert -size 60x60 xc:none -fill blue \
          -draw 'circle 21,39 24,57'  compose_B.png
  composite -compose plus  compose_R.png compose_G.png  compose_plus_RG.png
  composite -compose plus  compose_R.png compose_B.png  compose_plus_RB.png
  composite -compose plus  compose_G.png compose_B.png  compose_plus_GB.png
  composite -compose plus  compose_R.png compose_plus_GB.png \
            compose_plus_RGB.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="compose_R.png"
     ><IMG SRC="compose_R.png"     WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="compose_G.png"
     ><IMG SRC="compose_G.png"     WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="compose_B.png"
     ><IMG SRC="compose_B.png"     WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="compose_plus_RG.png"
     ><IMG SRC="compose_plus_RG.png"     WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="compose_plus_RB.png"
     ><IMG SRC="compose_plus_RB.png"     WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="compose_plus_GB.png"
     ><IMG SRC="compose_plus_GB.png"     WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="compose_plus_RGB.png"
     ><IMG SRC="compose_plus_RGB.png"     WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Due to IM's compliance to the SVG standard, 'green' is not a true green
  color (like it is in X11 color names) but a dark or half bright green.
  A true RGB green can be specified with the color '<CODE>lime</CODE>' as we
  have done in the above example.
</I></FONT></TD></TR></TABLE></P>

It is also used as a mathematical operator to add together separate gradient
images.  For example in calculating a 'manhatten' <A
HREF="../compare/#difference" >Difference Images</A>, or in <A
HREF="../transform/#gradient_math" >Gradient Mathematics</A>. </P>


'<CODE><A HREF="#plus" >Plus</A></CODE>' is sometimes used to add white text to
an image.  This is NOT correct usage, and may result in some anti-aliasing
inconsistencies.  The better way is to use the '<CODE><A HREF="#screen"
>Screen</A></CODE>' compose method.  This uses a multiplication rather than an
additive method of increasing brightness. </P>

The <A HREF="#lineardodge" >Linear Dodge Compose Method</A> is is equivalent
to '<CODE><A HREF="#plus" >Plus</A></CODE>', but using the more normal
'<CODE><A HREF="#over" >Over</A></CODE>' alpha blending. </P>



<A NAME="plus_blend"</A>
<H4>Plus and Plus Blending</H4>

What makes the '<CODE><A HREF="#plus" >Plus</A></CODE>' more important is that
it is about the only mathematical operator that implements a different
blending function than '<CODE><A HREF="#over" >Over</A></CODE>' blending.  It
not only 'adds' the colors but it also 'adds' the alpha channel values, and is
about the only operator that does this, by default.  </P>

This is important as it allows for the correct joining of complementary masked
images. For example, see the merging of <A HREF="#dstout" >Dst In and Out</A>
images.  It also allows you to use transparency to generate a weighted average
or <A HREF="#blend" >Blend</A> of two images. </P>

If it wasn't for this special blending method of '<CODE><A HREF="#plus"
>Plus</A></CODE>', these special transparency handling techniques would not be
normally possible. </P>

<BR>

As of IM v6.6.1-6 the ability to use the mathematical operator on alpha
channels was added to all the <A HREF="#math" >Mathematical Compose
Methods</A> simply by removing the default '<CODE>Sync</CODE>' flag from
"<CODE><A HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting,
(simply specify the specific channels you want to apply it to). See <A
HREF="#image_math" >Image Channel Mathematics using Image Composition</A>
below. </P>

This means the '<CODE><A HREF="#plus" >Plus</A></CODE>' operator is the only <A
HREF="#math" >Mathematical Compose Methods</A> operator not effected by this
feature, as it is already applied by default. </P>

<BR>

<A NAME="minus"></A>
<A NAME="minusdst"></A>
<A NAME="minussrc"></A>
<A HREF="gradient_op_minus.png"
   ><IMG SRC="gradient_op_minus.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Minus, Minus_Dst, Minus_Src
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/minus.gif" ALIGN=absmiddle>
)</FONT></H3>

The result is one image subtracted from the other. </P>

Which image is the subtracted from the other depend on if
'<CODE>Minus_Src</CODE>' or '<CODE>Minus_Dst</CODE>' is applied.  Specifically
'<CODE>Minus_Dst</CODE>', means 'subtract the destination' or if applied in
a "<CODE>composite</CODE>" command....

The formula for..
'<CODE>Minus_Dst</CODE>' is &nbsp; <CODE><I>Src</I> - <I>Dest</I></CODE>
&nbsp; and for
'<CODE>Minus_Src</CODE>' is &nbsp; <CODE><I>Dest</I> - <I>Src</I></CODE> </P>

Due to the order of images normally defined in image composition, and the
"<CODE>composite</CODE> command, the original method '<CODE>Minus</CODE>
meant...

<DIV ALIGN=center><B>
<PRE>{<I>Source</I>} Minus {<I>background</I>}<PRE>
</B></DIV></P>

That is to say the original method name "<CODE>Minus</CODE>' is a synonym for
"<CODE>Minus_Dst</CODE>" meaning  "minus the destination". It is also the
operator used to define the displayed gradient chart. </P>

For example, subtract a circle from the final result of the previous '<CODE><A
HREF="#plus" >Plus</A></CODE>' operation above.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite compose_plus_RGB.png  -compose minus_dst  compose_R.png \
            compose_minus.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="compose_minus.png"
     ><IMG SRC="compose_minus.png"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note the way the alpha channel is handled, which is that same as all the other
mathematical operators except '<CODE><A HREF="#plus" >Plus</A></CODE>'. See <A
HREF="#math_blend" >Mathematical Composition and Alpha Blending</A>. This
handling can be modified by the use of a special '<CODE>Sync</CODE>' channel
flag. See <A HREF="#image_math" >Image Channel Mathematics</A> below for
details. </P>

The '<CODE><A HREF="#linearburn" >Linear Burn</A></CODE>' compose method can
also be used for color subtraction, but works by the user negating the image
to be subtracted.  See the <A HREF="#linearburn" >Linear Burn Compose Method</A>
for more details. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.6.8-5 only the original '<CODE><A HREF="#minus"
  >Minus</A></CODE>' method was provided (equivalent to the newer
  '<CODE><A HREF="#minusdst" >Minus_Dst</A></CODE>').
</I></FONT></TD></TR></TABLE></P>


<A NAME="add"></A>
<A NAME="modulus_add"></A>
<A HREF="gradient_op_modulusadd.png"
   ><IMG SRC="gradient_op_modulusadd.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>ModulusAdd</H3>

The '<CODE><A HREF="#modulus_add" >ModulusAdd</A></CODE>' is much like
the '<CODE><A HREF="#plus" >Plus</A></CODE>' except when the result exceeds
white, it is wrapped (modulus) back to black. </P>

For example, if we add two grayscale gradients the brightest colors will
wrap to form a second gradient.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 gradient:    gradient.png
  composite  gradient.png gradient.png -compose ModulusAdd  compose_add.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center><NOBR>
  <A HREF="compose_add.png"
     ><IMG SRC="compose_add.png"     WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

This modulus type of composition can be used to produce some very interesting
gradients such as.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite gradient.png \( gradient.png -rotate -90 \) \
            -compose ModulusAdd   gradient_diagonal.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="gradient_diagonal.png"
     ><IMG SRC="gradient_diagonal.png"  WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And multiple modulus additions can make venetian blind type repeated
gradients.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient.png \( +clone +clone +clone +clone \) \
          -background gray50 -compose ModulusAdd -flatten  gradient_venetian.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="gradient_venetian.png"
     ><IMG SRC="gradient_venetian.png"  WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Which produces a gradient repeated 5 times.  Note how I use a
background of '<CODE>gray50</CODE>' to effectively 'roll' the gradient half a
modulus cycle forward. </P>


<A NAME="subtract"></A>
<A NAME="modulus_subtract"></A>
<A HREF="gradient_op_modulussubtract.png"
   ><IMG SRC="gradient_op_modulussubtract.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>ModulusSubtract</H3>

The '<CODE><A HREF="#modulus_subtract" >ModulusSubtract</A></CODE>' operator
is the same as '<CODE><A HREF="#minus" >Minus</A></CODE>' except that it is
a modulus subtraction. Subtracting 'white' from 'gray' will result in the
original 'gray', and not black, as the values wrap back around. </P>

A side effect of modulus subtraction is that some parts may become white
instead of black, in seemingly uncontrolled ways.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose subtract  compose_plus_RGB.png  compose_R.png \
            compose_subtract.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
    <A HREF="compose_subtract.png"
       ><IMG SRC="compose_subtract.png"
             ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Doing a '<CODE><A HREF="#modulus_add" >ModulusAdd</A></CODE>' with a <A
HREF="../#color_mods/#negate" >Negated Image</A> will produce the same result.
</P>


<A NAME="difference"></A>
<A HREF="gradient_op_difference.png"
   ><IMG SRC="gradient_op_difference.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Difference
<FONT SIZE=3>(image compare, and selective negate)</FONT></H3>

The resulting image is the absolute difference in the color values. </p>

Its formula is: &nbsp; <CODE> abs(<I>Src</I> - <I>Dest</I>) </CODE> </P>

The '<CODE>black</CODE>' and
'<CODE>white</CODE>' difference will produce a maximum result of white while
any colors which are the same will produce black. Basically a simple form of
image comparison.  </P>

The more common use of this composite method is for comparing two images of
the same size to see how they differ, and even produce a percentage of that
difference. </P>

This operator is typically used to generate <A HREf="../compare/#difference"
>Comparison Difference Images</A>. </P>


The operator also can be used to selectively negate an image.  Overlaying
black has no effect on the background, while overlaying white negates the
colors in the image at that location.  </P>

In otherwords this operator (as well as the next) provides an image mapped  <A
HREF="../#color_mods/#negate" >Negatation</A> operator. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
For example lets negate half the rose image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 2x1 pattern:gray50  -scale 70x50\! black_n_white.gif
  composite black_n_white.gif   rose: \
            -gravity center -compose difference   compose_negate.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
    <A HREF="black_n_white.gif"
       ><IMG SRC="black_n_white.gif"
             ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
    <A HREF="compose_negate.gif"
       ><IMG SRC="compose_negate.gif"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<BR>

<A NAME="exclusion"></A>
<A HREF="gradient_op_exclusion.png"
   ><IMG SRC="gradient_op_exclusion.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Exclusion
<FONT SIZE=3>(image difference excluding greys)</FONT></H3>

Its formula is: &nbsp;
      <CODE> <I>Src</I> + <I>Dest</I> - 2*<I>Src</I>*<I>Dest</I> </CODE> </P>

This is sort of an averaged difference.  White on white will produce black (no
difference), the same with black on black.  However grey on grey will produce
a grey result.  White and black naturally still produce white (maximum
difference). </P>

Another way of looking at this is that bright image regions cause inversion to
the respective other layer.  Very dark regions change nothing at all. In this
manner the <b>Exclusion</b> method is the same as '<CODE><A HREF="#difference"
>Difference</A></CODE>' (see previous). </P>

One use for this operator is to multiply 'biased gradients' such as used for <A
HREF='../displace/#displacement_maps' >Displacement Maps</A>.  These are
gradients where a 50% gray value is thought of as being 'zero' with darker
colors representing a 'negative' value, and lighter colors representing a
'positive' value, with the values ranging from -1 to +1. See <A
HREF="../transform/#math_multiply" >Multiply Biased Gradients</A>, for
details. </P>


Another use of this compose method, submitted by Joe Fry, is a way to merge
multiple difference images together. The final image shows the
changes of all the images, not just between two images.  That is, given images
A, B and C, first generate the difference images for A, B  and  B, C  then use
exclusion on those results so that you get one image showing how all three
images changed.  </P>

This method is also closely related to how the <A HREF="#xor" >Xor</A>
composition blending operator handles the alpha transparency values. </P>


<A NAME="lighten"></A>
<A NAME="darken"></A>
<A HREF="gradient_op_darken.png"
   ><IMG SRC="gradient_op_darken.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<A HREF="gradient_op_lighten.png"
   ><IMG SRC="gradient_op_lighten.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Lighten and Darken
<FONT SIZE=3>(select maximum/minimum value)</FONT></H3>

Compare the source and destination image color values and take the respective
lighter or darker value. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=top><TD>The formula for Lighten is: &nbsp; &nbsp;
</TD><TD> If <CODE> <I>Src</I> &gt; <I>Dest</I> </CODE>
</TD><TD>  &nbsp; then &nbsp; <CODE> <I>Src</I> </CODE>
</TD></TR><TR><TD></TD><TD>
</TD><TD>  &nbsp; else &nbsp; <CODE> <I>Dest</I> </CODE>
</TD></TR></TABLE>
For darker, just invert the comparison. <P>

One use of '<CODE><A HREF="#lighten" >Lighten</A></CODE>' is to compose
a blurred version of the original image so that the 'highlights' in the
original image get a soft glow about them.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert flower_sm.jpg \( +clone -blur 0x3 \) \
          -compose Lighten -composite  flower_softglow.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/flower_sm.jpg"
     ><IMG SRC="../img_photos/flower_sm.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="flower_softglow.jpg"
     ><IMG SRC="flower_softglow.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

See <A HREF="../convolve/#soft_blur" >Soft Blur</A> for a better way (using
a 'blended blurring technique'), for a better way of achieving a similar
result. </P>

<BR>

These operators work by comparing and selecting the individual RGB channel
values, and as such this could result in some color distortion, especially
when dealing with primary colors of the image. </P>

For example here I have create a red and blue gradient image, then
use lighten to compose thme together.
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient:red-black -rotate 90  red_gradient.png
  convert -size 100x100 gradient:blue-black            blue_gradient.png

  convert red_gradient.png blue_gradient.png \
          -compose Lighten -composite   lighten_by_value.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="red_gradient.png"
     ><IMG SRC="red_gradient.png"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="blue_gradient.png"
     ><IMG SRC="blue_gradient.png"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="lighten_by_value.png"
     ><IMG SRC="lighten_by_value.png"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Because the blue channel is zero in the red gradient image, and visa-versa,
and '<CODE><A HREF="#lighten" >Lighten</A></CODE>' composition works by color
values, the result is just a simple merge of the red and blue images, to
produce a red-blue gradient image.  That is the above was equivelent to
a simple <A HREF="#channel" >Channel Copy Composition</A>.  </P>


One method to prevent color distortions, is to restrict the operator to only
adjusting the 'Lightness' channel of the image using HSL <A
HREF="../color_basics/#colorspace" >Colorspace</A>. Though that does not
always produce good results. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that "<CODE>Gimp</CODE>", "<CODE>Photoshop</CODE>",
  "<CODE>PhotoLine</CODE>", "<CODE>Paint Shop Pro</CODE>", all compare
  channels directly just like IM. </P>

  "<CODE>Photo-Paint</CODE>" compares the images by color intensity and uses
  that to decide which image to select colors from, thus preserving color
  integrity.  See <A HREF="#LightenIntensity" >Lighten-Intensity Method</A>
  below. </P>

  On the other hand "<CODE>Picture Publisher</CODE>", and
  "<CODE>PhotoImpact</CODE>" use the color lightness (as defined by the HSL
  colorspace) for the comparison. </P>

  For comparisions of the difference in gray-scale from various colorspaces
  see the example <A HREF="../color_mods/#grayscale" >Gray-Scaling
  using Colorspace</A>. </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="lighten_intensity"></A>
<A NAME="darken_intensity"></A>
<A HREF="gradient_op_darken.png"
   ><IMG SRC="gradient_op_darken.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<A HREF="gradient_op_lighten.png"
   ><IMG SRC="gradient_op_lighten.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Lighten-Intensity and Darken-Intensity
<FONT SIZE=3>(select color by intensity)</FONT></H3>

As on IM v6.6.9-5, a '<CODE>Lighten_Intensity</CODE>' and
'<CODE>Darken_Intensity</CODE>' variant was added.  This will compare the
intensity of the pixels in the two images, than select the pixel values based
on that result. </P>

That means no new colors will be added to the images, though new image will be
a mix of the colors from both images.  Also image order does not matter,
except that the size and meta-data comes from the destination image. </P>

For example here take the lighter of images containing a Red and Blue
gradient.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert red_gradient.png blue_gradient.png \
          -compose Lighten_Intensity -composite   lighten_intensity.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="red_gradient.png"
     ><IMG SRC="red_gradient.png"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="blue_gradient.png"
     ><IMG SRC="blue_gradient.png"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="lighten_intensity.png"
     ><IMG SRC="lighten_intensity.png"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see, the whole pixel was selected from the selected image. You will
get no mixing of the color channels. However as the intensity of blue is
regarded as darker than red, only the darkest of reds are replaced from the
darker blue gradient image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  This composition method is not defined by the  <A
  HREF="http://www.w3.org/TR/2009/WD-SVGCompositing-20090430/" >SVG
  composition guide (2009)</A> used by all the previous composition methods
  we have looked at so far.  As such their is no real definition as to how
  the alpha channel should effect the pixel comparision.
</I></FONT></TD></TR></TABLE></P>

<BR>

<B>With regards to alpha</B>, the method has two modes of operation. </P>

With the special '<CODE>Sync</CODE>' flag of the "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting enabled (the
default), the comparison will be based on the intensity of the colors,
weighted by the alpha (transparency) channel. That means a 'Half-Transparent
White' will have a weighted-intensity that is about the same as a 'Opaque
Mid-Gray' color.  <P>

This means that all other things being equal, a '<CODE><A
HREF="#lighten_intensity" >Lighten_Intensity</A></CODE>' will create a 'union'
of shaped images, while '<CODE><A HREF="#darken_intensity"
>Darken_Intensity</A></CODE>' will create a 'intersection' of (at least
non-black) shaped images.  This is NOT ideal, and may change, but its better
than no alpha input. </P>

The second mode of operation will be used if you turn off the
'<CODE>Sync</CODE>' channel flag (see <A HREF="#sync_flag" >Using the 'Sync'
Flag</A> below). For example by using "<CODE>-channel All</CODE>".  The pixel
selection will then be based purely on the color intensity, without any effect
of alpha weighting. However alpha channel value will be copied with the pixel
data that was actually selected. </P>

For images without transparency the result will be the same regardless of the
mode. </P>

This second mode also allows you to use a more restricted "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" defining which
channels may be copied from the source into the destination image, if
selected.  The selection however will still be purely based on just the
un-weighted color intensity. </P>

This means that you can more easilly create a 'shape mask' of the selection,
based on the intensity of colors in the two images.  You compare the images
based on color intensity, but only care about the alpha channel value in the
result. </P>

To make a 'mask' you would make one image fully-transparent (but still having
color), using <A HREF="../masking/#alpha_transparent" >Alpha Transparent</A>,
and the other image full-opaque (the default).  At the end you can use <A
HREF="../masking/#alpha_extract" >Alpha Extract</A> to get the mask of which
image had the lighter color for that pixel position.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert red_gradient.png -alpha transparent    blue_gradient.png \
          -compose Lighten_Intensity -composite \
          -alpha extract    lighten_intensity_mask.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="lighten_intensity_mask.png"
       ><IMG SRC="lighten_intensity_mask.png"   WIDTH=100 HEIGHT=100
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note the alpha values in the two images do not have to be just 'on' and 'off',
but could be set to some 'referance' value.  That means you could have a whole
sequence of images, each with a different alpha channel value. You can then
use this compose method to compare all the images together, and get a map
which image contained the lightest (or darkest) pixel at each location within
the image.  </P>

In other words the intensity composition methods can be used as a sort of
'selection', or 'comparision' operator, for a long list of images. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify><FONT SIZE=-1><I>
  Added as of IM v6.6.9-5.  But no formal defintion for the method has
  been found.  As such the current implementation is classed as <B>highly
  experimental</B>, and may change based on user suggestions. However the
  essentual idea is sound.
</I></FONT></TD></TR></TABLE></P>

<H4>Intensity Alternative for older versions of IM</H4>

If the '<CODE><A HREF="#lighten_intensity" >Lighten_Intensity</A></CODE>'
method is not available to your version of ImageMagick, you can recreate
a pure, color-only version, by using '<CODE><A HREF="#lighten"
>Lighten</A></CODE>' on a gray-scale copies of the two images, and by
comparing the result against the gray-scale copy, create a
selection mask to apply against the original. </P>

This is not easy, and the following is is one such solution...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert red_gradient.png blue_gradient.png \
          \( -clone 0--1 -colorspace Gray \
             \( -clone 0--1 -compose Lighten -composite \) \
             -delete 1 -compose Difference -composite -threshold 0 \
          \) -compose Src -composite     intensity_lightened.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="intensity_lightened.png"
       ><IMG SRC="intensity_lightened.png"   WIDTH=100 HEIGHT=100
             ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

It is a pretty horrible bit of processing, but as you can see, it works. </P>

To get a '<CODE><A HREF="#darken_intensity" >Darken_Intensity</A></CODE>'
version, replace the "<CODE>-delete 1</CODE>" with "<CODE>-delete 0</CODE>",
OR, replace "<CODE>-compose Lighten</CODE>" with "<CODE>-compose
Darken</CODE>".  Either will work.  </P>


<A NAME="set_theory"></A>
<H3>Set Theory Equivalent Operations</H3>

A number of the mathematical methods above are also used to perform set theory
or boolean operations with shapes.  </P>

The '<CODE><A HREF="#lighten" >Lighten</A></CODE>'compose method can be used to
find the '<I>Union</I>' (Boolean '<I>Or</I>') of two (or more) groups
(sets) or pixels.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 64x64 xc: -draw 'circle 22,32 5,32'  -negate circle_left.gif
  convert -size 64x64 xc: -draw 'circle 41,32 58,32' -negate circle_right.gif
  convert circle_left.gif circle_right.gif \
          -compose Lighten -composite    circle_union.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="circle_left.gif"
     ><IMG SRC="circle_left.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/union.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="u">
  <A HREF="circle_right.gif"
     ><IMG SRC="circle_right.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="circle_union.gif"
     ><IMG SRC="circle_union.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The '<CODE><A HREF="#darken" >Darken</A></CODE>' compose method produces an
'<I>Intersection</I>' (Boolean '<I>And</I>') of the pixels.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert circle_left.gif circle_right.gif \
          -compose Darken -composite    circle_intersection.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="circle_left.gif"
     ><IMG SRC="circle_left.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/intersection.gif" ALIGN=middle WIDTH=20 ALT="n">
  <A HREF="circle_right.gif"
     ><IMG SRC="circle_right.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="circle_intersection.gif"
     ><IMG SRC="circle_intersection.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The '<CODE><A HREF="#difference" >Difference</A></CODE>' compose method
produces an '<I>Exclusive OR</I>', (Boolean '<I>XOR</I>') of the two sets.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert circle_left.gif circle_right.gif \
          -compose Difference -composite    circle_disjunction.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="circle_left.gif"
     ><IMG SRC="circle_left.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/xor.gif" ALIGN=middle WIDTH=20 ALT="(+)">
  <A HREF="circle_right.gif"
     ><IMG SRC="circle_right.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="circle_disjunction.gif"
     ><IMG SRC="circle_disjunction.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

An '<CODE><A HREF="#exclusion" >Exclusion</A></CODE>' method could also have
been used for this purpose, though handles gray-scale (non-boolean) values
differently.  It is however the method used for '<CODE><A HREF="#xor"
>XOR</A></CODE>' Duff-Porter alpha blending. </P>

And lastly '<CODE><A HREF="#minus" >Minus</A></CODE>' can be used to generate
the '<I>Relative Complement</I>' of two sets of pixels.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert circle_left.gif circle_right.gif \
          -compose Minus_Src -composite    circle_complement.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="circle_left.gif"
     ><IMG SRC="circle_left.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/complement.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="-">
  <A HREF="circle_right.gif"
     ><IMG SRC="circle_right.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="circle_complement.gif"
     ><IMG SRC="circle_complement.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that a "<CODE><A HREF="../option_link.cgi?clamp" >-clamp</A></CODE>" may
be needed for <A HREF="../basics/#hdri" >HDRI</A> versions of ImageMagick when
applying any of the above 'set' or 'boolean' composition methods, to prevent
the generation of out of range values. </P>


<A NAME="math_blending"></A>
<H3>Mathematical Composition and Alpha Blending</H3>

You can use the above mathematical composition methods for performing
mathematical operations on image. However there is on major cave-at with this.
It will probbaly not work as you might want with images containing
transparency. </P>

By default almost all the above mathematical compositions follow a convention
defined by the SVG specification.  <A
HREF="http://www.w3.org/TR/2009/WD-SVGCompositing-20090430/" >SVG composition
guide (2009)</A>. </P>

What this means is that if you try to use mathematical compositions on images
with an alpha channel (that is some form of transparency), you will may not
get a true mathematical composition, but a 'blended' form of composition.

For example, here I create gradient images with some transparency
around them.  I then '<CODE><A HREF="#" >Multiply</A></CODE>' them
together.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 64x64 xc:none -draw 'rectangle 20,0 43,63' \
          gradient: -compose In -composite    alpha_src.png
  convert alpha_src.png -transverse     alpha_dst.png
  convert alpha_dst.png  alpha_src.png \
          -compose Multiply -composite  alpha_result.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="alpha_src.png"
     ><IMG SRC="alpha_src.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Source
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT=" + ">
</TD><TD ALIGN=center>
  <A HREF="alpha_dst.png"
     ><IMG SRC="alpha_dst.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dest
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT="=>">
</TD><TD ALIGN=center>
  <A HREF="alpha_result.png"
     ><IMG SRC="alpha_result.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Result
</TD></TR></TABLE>
</DIV></P>

Note that the parts of the images that did not overlap was just simply
included into the resulting image, as is, without modification.  That is the
images were 'blended together'. </P>

Worse still if the image contains partial transparencies, the color values
will be 'weighted' by the alpha channel. This is useful for a <A HREF="#plus"
>Plus Composition</A>, providing a 'weighted color addition' or <A
HREF="#blend" >Blending Operation</A>, but I have as yet not figured out any
use for a 'weighted multiply of colors' in images. <I>Anyone?</I>  </P>

If you are doing image mathematics, this behaviour is generally not desirable.
Though when doing such maths, you also generally do not have any alpha channel
so the 'alpha blending' and 'weighted color' problems rarely arises. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The <A HREF="#plus" >Plus Composition</A> is the only <A
  HREF="../compose/#math" >Mathematical Compose Method</A> that does not do
  'over alpha blending'.  Instead as per the <A
  HREF="http://www.w3.org/TR/2009/WD-SVGCompositing-20090430/" >SVG
  Specification</A> it separately adds each channel.  However the color
  channels are still weighted by the alpha value before being added, only the
  handling of the alpha values (the blending) differs. </P>

  This is important to provide correct 'addition' of masked shapes, such as
  demonstrated in <A HREF="#dstout" >DstOut Composition</A>.

</I></FONT></TD></TR></TABLE></P>


<A NAME="image_math"></A>
<H3>Image Channel Mathematics using Image Composition</H3>

If the image you are using a <A HREF="../compose/#math" >Mathematical Compose
Methods</A> on are simply fully-opaque gray-scale images, then you can use the
above methods on them directly, without any problems. </P>

However by default the compose methods will be applied to all the color
channels, with alpha blending, just as you saw above.  This makes applying
them to just a specific channel such as the alpha channel difficult. </P>

For example here I '<CODE><A HREF="#multiply" >Multiply</A></CODE>' two images
black images containing a transparent gradient. Using the default "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 64x64 gradient:black-none   alpha_grad_src.png
  convert alpha_grad_src.png -transverse   alpha_grad_dst.png
  convert alpha_grad_dst.png  alpha_grad_src.png \
          -compose Multiply -composite  alpha_grad_result.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="alpha_grad_src.png"
     ><IMG SRC="alpha_grad_src.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Source
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT=" + ">
</TD><TD ALIGN=center>
  <A HREF="alpha_grad_dst.png"
     ><IMG SRC="alpha_grad_dst.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dest
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT="=>">
</TD><TD ALIGN=center>
  <A HREF="alpha_grad_result.png"
     ><IMG SRC="alpha_grad_result.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Result
</TD></TR></TABLE>
</DIV></P>

Note that multiplying '<CODE>Black</CODE>' with '<CODE>Black</CODE>' is
'<CODE>Black</CODE>', so the color does not change in this example. Only the
resulting transparency is modified. </P>

However the result is defiantly not a multiplication of the images alpha
channel values, as by the <A
HREF="http://www.w3.org/TR/2009/WD-SVGCompositing-20090430/" >SVG
Definition</A> the semi-transparencies are blended using the 'over' method.
</P>

This is mathematically equivalent to a '<CODE><A HREF="#screen"
>Screen</A></CODE>' composition of the alpha channel, and not a multiply.
</P>

<A NAME="sync_flag"></A>
<H3>Sync Channel Flag and Mathematical Composition</H3>

As of IM v6.6.1-6 the <A HREF="#math" >Mathematical Compose Methods</A> were
modified to obey the '<CODE>Sync</CODE>' flag of the "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting. This flag
effectually means, "synchronise the color and alpha channel operations".  The
default "<CODE><A HREF="../option_link.cgi?channel" >-channel</A></CODE>"
setting is '<CODE>RGBK,Sync</CODE>'. So by default Color and Alpha channels
are handled appropriately, 'in sync', as per the SVN specification.  </P>

However by removing the '<CODE>Sync</CODE>' flag, the <A HREF="#math"
>Mathematical Compose Methods</A> will become 'channel operators' applying the
mathematical function to each channel, separately. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=middle><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert alpha_grad_dst.png  alpha_grad_src.png \
          -channel RGBA  -compose Multiply -composite  alpha_grad_nosync.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
    <A HREF="alpha_grad_nosync.png"
       ><IMG SRC="alpha_grad_nosync.png"
             ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And this a correct multiply of the alpha channel. </P>

<BR>

All this only applies to <A HREF="#math" >Mathematical Compose Methods</A> (as
detailed above) as well as the special '<CODE><A HREF="#mathematics"
>Mathematics</A></CODE>' compose method (see below). It does not apply to
other composition methods, such as <A HREF="light" >Lighting Composition
Methods</A> (see next). At least not yet. </P>

The '<CODE>Sync</CODE>' flag also effects how the <A HREF="#lighten_intensity"
>Lighten/Darken by Intensity Composition Method</A> (not a SVG defined
composition method) deals with alpha channel (above). </P>

For more information on using image mathematics, see <A
HREF="../transform/#gradient_math" >Mathematics on Gradients</A>.  More
specifically those examples look at using mathematical compositions for
generating <I>Biased Gradient Images</I>, which is bit more involved.  </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="color"></A>
<A NAME="light"></A>
<A NAME="shade"></A>
<H2>Lighting Composition Methods
<FONT SIZE=-1>  -- Light, Dodge, Burn</FONT></H2>

These methods modify the colors of an image in highly complex ways and are
typically used to adjust the shade or intensity of the image making some areas
brighter and others darker. </P>

<DL>
<DT>Lighting Composition methods fall into three sub-categories of related
    operators.
<DD>'<I>Burn</I>', which generally darkens images.
<DD>'<I>Dodge</I>', which generally brightens images.
<DD>'<I>Light</I>', which both darkens and lightens images based on the the
    darkness and brightness of one of the images.
</DL></P>

'<CODE><A HREF="#multiply" >Multiply</A></CODE>' (darkens colors) is generally
regarded as a pure '<I>Burn</I>' composition operation, while '<CODE><A
HREF="#screen" >Screen</A></CODE>' (lightens) is a '<I>Dodge</I>' composition
operator. </P>

Generally one of the images will consist of either a color pattern or photo,
while the other is a grey-scale image that is being used to brighten or darken
the image appropriately.  Which image should be the color, and which
gray-scale, is debatable and depends on how the method was implemented.  There
is no standard in this regard, so caution and experimentation is recommended.
</P>

As a consequence of the lack of standards for these operators, many users
do not understand or miss-use these operators.  I have also yet to find
any guide on correctly using these compose methods is practically
non-existent, so I had to do my best with the examples below.  </P>

<A NAME="overlay"></A>
<A HREF="gradient_op_overlay.png"
   ><IMG SRC="gradient_op_overlay.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Overlay <FONT SIZE=3>(add color to a gray-scale object)</FONT></H3>

This compose method is very unusual in that it has been designed to both
'<CODE><A HREF="#multiply" >Multiply</A></CODE>' (darken) and '<CODE><A
HREF="#screen" >Screen</A></CODE>' (lighten) an image at the same time.  Which
method is applied to a specific pixel is selected by the value of the
destination image, which can be regarded as being the 'lighting mask'. Because
of this the destination is generally a greyscale image, to which color is
being added.</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=top><TD>Its formula is: &nbsp; &nbsp;
</TD><TD> If <CODE> <I>Dest</I> &lt;= 0.5 </CODE>
</TD><TD>  &nbsp; then &nbsp;
</TD><TD ALIGN=center>    <CODE> 2*<I>Src</I>*<I>Dest</I> </CODE>
</TD></TR><TR><TD></TD><TD>
</TD><TD>  &nbsp; else &nbsp;
</TD><TD ALIGN=center>    <CODE> 1-2*(1-<I>Src</I>)*(1-<I>Dest</I>) </CODE>
</TD></TR></TABLE></P>

The result is a special compose method which preserves any pure white and
black (highlights) that is present in the destination image while tinting the
mid-tone greys of that image by the colors found in the overlay image. </P>

That is, given a grey-scale image as the destination, this operator will color
that background using the source image preserving any shadow and highlighting
effects that are present in the destination. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 64x64 gradient:yellow-blue gradient_yell-blue.jpg
  convert -size 64x64 gradient: -rotate 90 gradient_grey.jpg

  convert gradient_grey.jpg   gradient_yell-blue.jpg \
          -compose Overlay  -composite   compose_overlay_gradients.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="gradient_grey.jpg"
     ><IMG SRC="gradient_grey.jpg"     WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dest
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT=" + ">
</TD><TD ALIGN=center>
  <A HREF="gradient_yell-blue.jpg"
     ><IMG SRC="gradient_yell-blue.jpg"  WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Overlay
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT="=>">
</TD><TD ALIGN=center>
  <A HREF="compose_overlay_gradients.jpg"
     ><IMG SRC="compose_overlay_gradients.jpg"  WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Result
</TD></TR></TABLE>
</DIV></P>

As you can see the mid-tone grays of the gradient image was colored
with the colors of the image provided. And this is the normal use of the
compostion method, adding color to a greyscale lighting mask.  </P>

This method, unlike '<CODE><A HREF="#multiply" >Multiply</A></CODE>' or
'<CODE><A HREF="#screen" >Screen</A></CODE>', is not associative.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient_yell-blue.jpg  gradient_grey.jpg \
          -compose Overlay   -composite   compose_overlay_gradients2.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="gradient_yell-blue.jpg"
     ><IMG SRC="gradient_yell-blue.jpg"  WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dest
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT=" + ">
</TD><TD ALIGN=center>
  <A HREF="gradient_grey.jpg"
     ><IMG SRC="gradient_grey.jpg"     WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Overlay
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT="=>">
</TD><TD ALIGN=center>
  <A HREF="compose_overlay_gradients2.jpg"
     ><IMG SRC="compose_overlay_gradients2.jpg"  WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Result
</TD></TR></TABLE>
</DIV></P>

This 'overlaying color' into an image of grey highlights is makes this method
perfect for adding color to the output of the "<CODE><A
HREF="../option_link.cgi?shade" >-shade</A></CODE>" operator.  However you
need to be very careful to generate a perfect mid-tone grey from that
operator, to get correct coloring on areas without any highlights. See <A
HREF="../transform/#shade_overlay" >Shade Overlay Highlights</A> for details.
</P>

For example, given a circle we can shade it to produce 3 dimensional effects
then tint the result with the original image to restore the original colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 64x64  xc:dodgerblue \
          -draw 'fill skyblue   circle 32,32 7,27'  circle_blue.jpg
  convert circle_blue.jpg -shade 120x30 -auto-level circle_shaded.jpg
  convert circle_shaded.jpg  circle_blue.jpg \
            -compose Overlay -composite   circle_shaded_tinted.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="circle_shaded.jpg"
     ><IMG SRC="circle_shaded.jpg"  WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dest
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT=" + ">
</TD><TD ALIGN=center>
  <A HREF="circle_blue.jpg"
     ><IMG SRC="circle_blue.jpg"     WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Overlay
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT="=>">
</TD><TD ALIGN=center>
  <A HREF="circle_shaded_tinted.jpg"
     ><IMG SRC="circle_shaded_tinted.jpg"  WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Result
</TD></TR></TABLE>
</DIV></P>

For a more practical example of using the '<CODE><A HREF="#overlay"
>Overlay</A></CODE>' method see the "levels_3d" image on the <A
HREF="../backgrounds/#levels_3d" >Background Generator Examples</A> page. </P>

The biggest problem with this compose method is that any transparency in
either image will not be preserved.  That is, what is visible in either image
will be visible in the result. </P>

Typically this operator is used on image that contain no transparency, it
usually means you may need to do some extra steps to restore the transparency
of the destination or background image. </P>

One simple way of preverving the transparency is to simply <A
HREF="../masking/#alpha_off" >Turn off the Alpha Channel</A> of the
destination image, and thus make it inaccessable.  When the composition is
complete, you can just <A HREf="../masking/#alpha_on" >Turn It On Again</A>.
An example of this is given in <A HREF="../transform/#shade_shape" >Shaded
Shape Images</A>. </P>

Another method is to save a 'mask', or a copy of the original image, and then
use that mask or image to restore the transparency.  Examples of doing this is
provided in <A HREF="../color_mods/#tint_overlay" >Overlay Color Tinting</A>.
Or in the more complex example <A HREF="../advanced/#3d-logos-2" >Better 3-D
Logo Generation</A>. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify><FONT SIZE=-1><I>
  Up until IM version 6.1.6 the 'Overlay' compose method was broken in that
  it would only produce pure black or white results (most likely you would
  only get a pure black result).  Consequently most IM users had little
  chance of understanding this operator.  now that this have been fixed
  users will now be able to make good use of this method.
</I></FONT></TD></TR></TABLE></P>


<A NAME="hardlight"></A>
<A HREF="gradient_op_hardlight.png"
   ><IMG SRC="gradient_op_hardlight.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Hard_Light
<FONT SIZE=3>(add texture or highlight/shadow to an image)</FONT></H3>

This is the same as '<CODE><A HREF="#overlay" >Overlay</A></CODE>' except the
source and destination images are swapped.  If you compare the gradient images
of these two operators you can see that the gradient is diagonally transposed,
showing the swap of the source and destination inputs.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=top><TD>Its formula is: &nbsp; &nbsp;
</TD><TD> If <CODE> <I>Src</I> &lt;= 0.5 </CODE>
</TD><TD>  &nbsp; then &nbsp;
</TD><TD ALIGN=center>    <CODE> 2*<I>Src</I>*<I>Dest</I> </CODE>
</TD></TR><TR><TD></TD><TD>
</TD><TD>  &nbsp; else &nbsp;
</TD><TD ALIGN=center>    <CODE> 1-2*(1-<I>Src</I>)*(1-<I>Dest</I>) </CODE>
</TD></TR></TABLE></P>

So while '<CODE><A HREF="#overlay" >Overlay</A></CODE>' can add color to
a gray-scale shaded object, '<CODE><A HREF="#hardlight"
>Hard_Light</A></CODE>' adds gray-scale lighting effects to an image. Which
method you use depends on how you are thinking in terms of adding image
lighting effects. </P>

The important difference is which image is the 'destination' image so as to
preseve image meta-data, or even temporarilly <A HREF="../masking/#alpha_off"
>Disable the Alpha Channel</A> to preseve it during the operation.  </P>

For example here I generate a 'lighting effect' using a blurred "<CODE><A
HREF="../option_link.cgi?raise" >-raise</A></CODE>" operation of a pure gray
image the same size as the original.  This is then composed using '<CODE><A
HREF="#hardlight" >Hard_Light</A></CODE>' to add those lighting effects to the
image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -fill gray50 -colorize 100% \
          -raise 4 -normalize -blur 0x4  lighting_effect.png
  convert rose: lighting_effect.png \
          -compose hardlight -composite  compose_hardlight.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dest
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 VSPACE=20 ALT=" + ">
</TD><TD ALIGN=center>
  <A HREF="lighting_effect.png"
     ><IMG SRC="lighting_effect.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Overlay
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=20 ALT="=>">
</TD><TD ALIGN=center>
  <A HREF="compose_hardlight.png"
     ><IMG SRC="compose_hardlight.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Result
</TD></TR></TABLE>
</DIV></P>

This method makes adding both highlights (like a reflected light) or dark
shadow effects to an existing image, using the one operation easy.  </P>

Here is an example of direct adding lighting 'texture' to an image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: \( granite: -blur 0x.5 -normalize \) \
          -compose hardlight -composite compose_texture.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="compose_texture.png"
       ><IMG SRC="compose_texture.png"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note how strong the resulting text is, almost swamping the original image with
light and dark areas.  this is the disadvantage of using '<CODE><A
HREF="#hardlight" >Hard_Light</A></CODE>'. </P>

To combat this you may like to mute the contrast of an overlaid texture.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: \
          \( granite: -blur 0x.5 -normalize  +level 30,70%  \) \
          -compose hardlight -composite compose_texture_muted.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="compose_texture_muted.png"
       ><IMG SRC="compose_texture_muted.png"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Other lighting compose methods, such as '<CODE><A HREF="#softlight"
>Soft_Light</A></CODE>' may also produce better results more directly. </P>

For a better example see <A HREF="../photos/#texture" >Overlying a Texture</A>
in the <A HREF="../photos/#cookbook" >Photo Cookbook</A>.  A real life example
in using '<CODE><A HREF="#hardlight" >Hard_Light</A></CODE>' shading is
provided an <A HREF="../forum_link.cgi?t=11726" >IM Discussion Forums</A> on
the generation of 3D DVD covers from flat source images. </P>

Remember that both '<CODE><A HREF="#overlay" >Overlay</A></CODE>' and
'<CODE><A HREF="#hardlight" >Hard_Light</A></CODE>' shading are essentially
the same composition method.  The only difference is the images order. </P>


<A NAME="softlight"></A>
<A HREF="gradient_op_softlight.png"
   ><IMG SRC="gradient_op_softlight.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Soft_Light
<FONT SIZE=3>(softer highlighting of an image)</FONT></H3>

The '<B><CODE>Soft_Light</CODE></B>' compose method will also add highlights
and shadows to an existing color image.  However, the colors of the
destination image are modified to produce a softer contrast, and smoother
gradient in lighting effects. If you look carefully at the 'greyscale map
image' (see right) you will see no sharp discontinuity, though there actually
is two of them. (See also '<CODE><A HREF="#pegtoplight"
>Pegtop_Light</A></CODE>' next). </P>

It is more closely related to the '<CODE><A HREF="#overlay"
>Overlay</A></CODE>' composition than to '<CODE><A HREF="#hardlight"
>Hard_Light</A></CODE>', so the destination is typically the greyscale
lighting mask.  Whether this is intentional or not is unknown but it does make
it different to '<CODE><A HREF="#hardlight" >Hard_Light</A></CODE>' but it
means you are better off composing the main image onto the shading image
rather than vise-versa. :-( </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  <B>WARNING:</B> This lighting effect defined more like '<CODE><A
  HREF="#overlay" >Overlay</A></CODE>' rather than '<CODE><A HREF="#hardlight"
  >Hardlight</A></CODE>'.  However which should contain the gray-scale
  lighting image is unclear.  Using source can produce full black and white
  results, using destination however can not produce these extremes. </P>

  If anyone has some definitive reference, please let me know.

</I></FONT></TD></TR></TABLE></P>

For example here is the '<CODE>Soft_Light</CODE>' texture mapping.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:   \( granite: -blur 0x.5 -normalize \) \
          -compose softlight -composite compose_softlight.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="compose_softlight.jpg"
       ><IMG SRC="compose_softlight.jpg"
             ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see, even with a normalized "<CODE>granite:</CODE>" image, the
color changes are softer and less intensive than that of '<CODE><A
HREF="#hardlight" >Hard_Light</A></CODE>', or even '<CODE><A
HREF="#overlay" >Overlay</A></CODE>'.  However you also will never get any
pure black shadow or pure white highlights, added to the resulting image. </P>

Basically '<CODE><A HREF="#softlight" >Soft_Light</A></CODE>' has a softer
texture effect, which preserves the original coloring of the <I>source</I>
image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>

Here I show the color changes achieved as a result of using pure black, white
and a perfect-gray color overlays.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x3 gradient: -sample 70x46\! grayscale_3.gif
  composite grayscale_3.gif  rose: -compose softlight  compose_softlight_2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
    <A HREF="grayscale_3.gif"
       ><IMG SRC="grayscale_3.gif"
             ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
    <A HREF="compose_softlight_2.gif"
       ><IMG SRC="compose_softlight_2.gif"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you had done this with '<CODE><A HREF="#hardlight" >Hard_Light</A></CODE>'
the sides of the image would be pure black and white, rather than just a 50%
darkening or brightening. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.5.4-3 '<CODE><A HREF="#softlight" >Soft_Light</A></CODE>' did
  not work as expected, producing a brightening for any non-gray shade image
  overlay.  In actual fact I confirmed that it was implemented correctly
  according to the official <A
  HREF="http://www.w3.org/TR/2004/WD-SVG12-20041027/rendering.html#comp-op-soft-light"
  >2004 SVG specification</A>. </P>

  Unfortunately, it was the specification, not the implementation, that was
  incorrect. It was fixed in the <A
  HREF="http://www.w3.org/TR/2009/WD-SVGCompositing-20090430/#comp-op-soft-light"
  >March 2009 SVG specification</A>.  As such for IM v6.5.4-3 and later this
  operator now works as you would expect a light shading operator to work.

</I></FONT></TD></TR></TABLE></P>

<A NAME="pegtoplight"></A>
<A HREF="gradient_op_pegtoplight.png"
   ><IMG SRC="gradient_op_pegtoplight.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Pegtop_Light
<FONT SIZE=3>(a smoother variation to soft light)</FONT></H3>

While '<CODE><A HREF="#softlight" >Soft_Light</A></CODE>' is much smoother
than either '<CODE><A HREF="#softlight" >Hard_Light</A></CODE>' or '<CODE><A
HREF="#overlay" >Overlay</A></CODE>', it is still actually based on two
separate functions joined together.  The '<B><CODE>Pegtop_Light</CODE></B>'
method produces a near identical result as '<CODE><A HREF="#softlight"
>Soft_Light</A></CODE>' but uses a single smooth function without any
discontinuity, not even the two minor ones used by '<CODE><A HREF="#softlight"
>Soft_Light</A></CODE>'.  Because of this it is actually much simpler and
faster. </P>

Its formula is: &nbsp; <CODE> 2*<I>Src</I>*<I>Dest</I>
           + <I>Src</I><SUP>2</SUP>*(1 - 2*<I>Dest</I>) </CODE> </P>

For details see the <A
HREF="http://www.pegtop.net/delphi/articles/blendmodes/softlight.htm" >Pegtop
SoftLight Alternative</A> page. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  <B>WARNING:</B> This lighting effect defined more like '<CODE><A
  HREF="#overlay" >Overlay</A></CODE>' rather than '<CODE><A HREF="#hardlight"
  >Hard Light</A></CODE>'.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE><A HREF="#pegtoplight" >Pegtop_Light</A></CODE>' compose method
  was added to IM version 6.5.4-3.
</I></FONT></TD></TR></TABLE></P>


<A NAME="linearlight"></A>
<A HREF="gradient_op_linearlight.png"
   ><IMG SRC="gradient_op_linearlight.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Linear_Light
<FONT SIZE=3>(A very simple but strong shading scheme)</FONT></H3>

Another image shading method that is very sensitive to the overlaid shading
image.  It has much larger zones of pure black and white limits. </P>

Its formula is: &nbsp; <CODE> 2*<I>Src</I> + <I>Dest</I> - 1 </CODE> </P>

While it is a continuous function, it could really be considered
a combination of '<CODE><A HREF="#lineardodge" >LinearDodge</A></CODE>'
(equivalent to a '<CODE><A HREF="#plus" >Plus</A></CODE>' composition) and
'<CODE><A HREF="#linearburn" >LinearBurn</A></CODE>' (which is an offset
'plus' sometimes used to subtract images). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.5.4-3  '<CODE><A HREF="#linearlight" >Linear_Light</A></CODE>'
  was proved to be incorrectly implemented.
</I></FONT></TD></TR></TABLE></P>


<A NAME="vividlight"></A>
<A HREF="gradient_op_vividlight.png"
   ><IMG SRC="gradient_op_vividlight.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Vivid_Light
<FONT SIZE=3>(a variant of Linear Light)</FONT></H3>

The '<B><CODE>Vivid_Light</CODE></B>' method is the same as that implemented
in Photoshop 7, and is basically a minor refinement on the '<CODE><A
HREF="#linearlight" >Linear_Light</A></CODE>' method.  What it does is avoid
shading the extremes, so as to make strong primary colors in the images more
'vivid'.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=top><TD>Its formula is: &nbsp; &nbsp;
</TD><TD> If <CODE> <I>Src</I> &lt;= 0.5 </CODE>
</TD><TD>  &nbsp; then &nbsp;
</TD><TD ALIGN=center>    <CODE> 1-(1-<I>Dest</I>)/(2*<I>Src</I>) </CODE>
</TD></TR><TR><TD></TD><TD>
</TD><TD>  &nbsp; else &nbsp;
</TD><TD ALIGN=center>    <CODE> <I>Dest</I>/(2*(1-<I>Src</I>)) </CODE>
</TD></TR></TABLE></P>

Another way of looking at this is a mix of  '<CODE><A HREF="#colorburn"
>Color_Dodge</A></CODE>' and  '<CODE><A HREF="#colordodge"
>Color_Burn</A></CODE>', for extremes, but '<CODE><A HREF="#linearlight"
>Linear_Light</A></CODE>' for the mid-tones. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE><A HREF="#vividlight" >Vivid_Light</A></CODE>' compose method was
  added to IM version 6.5.4-3.
</I></FONT></TD></TR></TABLE></P>


<A NAME="pinlight"></A>
<A HREF="gradient_op_pinlight.png"
   ><IMG SRC="gradient_op_pinlight.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Pin_Light</H3>

The '<B><CODE>Pin_Light</CODE></B>' function is designed to better preserve
the mid-tones of the destination image, restricting its shading to the lighter
and darker overlay shading.  Supposedly this simulates the harsh and sharp
lighting changes that result from a tiny pinhole light source, rather than
a more diffuse 'softer' light source. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=top><TD>Its formula is: &nbsp; &nbsp;
</TD><TD> If </TD><TD> <CODE> <I>Dest</I> &lt; 2*<I>Src</I>-1 </CODE>
</TD><TD>  &nbsp; then &nbsp;
</TD><TD ALIGN=center>        <CODE> 2*<I>Src</I> - 1 </CODE>
</TD></TR><TR><TD>
</TD><TD> elif &nbsp;
</TD><TD> <CODE> <I>Dest</I> &gt; 2*<I>Src</I>
</TD><TD>  &nbsp; then &nbsp;
</TD><TD ALIGN=center>        <CODE> <I>Dest</I> </CODE>
</TD></TR><TR><TD></TD><TD></TD><TD>
</TD><TD>  &nbsp; else &nbsp;
</TD><TD ALIGN=center>        <CODE> 2*<I>Src</I> </CODE>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE><A HREF="#pinlight" >Pin_Light</A></CODE>' compose method
  was added to IM version 6.5.4-3.
</I></FONT></TD></TR></TABLE></P>



<A NAME="lineardodge"></A>
<A HREF="gradient_op_lineardodge.png"
   ><IMG SRC="gradient_op_lineardodge.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Linear_Dodge
<FONT SIZE=3>(Photoshop 'Add' Compose)</FONT></H3>

If you compare the gradient image (right) for '<B><Code>Linear
Dodge</CODE></B>' with that of '<CODE><A HREF="#plus" >Plus</A></CODE>' you
will find that for two opaque images they have the exact same effect.

Its formula is of course: &nbsp; <CODE> Src + Dest </CODE> </P>

That is, for images with no transparency, these two commands with images
'<CODE>A</CODE>' and '<CODE>B</CODE> produce the same resulting image
'<CODE>R</CODE>'...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert  A  B   -compose    Plus     -composite   R
  convert  A  B   -compose LinearDodge -composite   R
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The method is equivalent to the Photoshop composition mode of the same name.
</P>

The only real difference bwteen the two methods is in how they handle images
containing semi-transparent colors.  Essentually <A HREF="#lineardodge"
>Linear_Dodge Composition</A> composition uses 'Over' alpha-blending, where as
<A HREF="#plus" >Plus Composition</A> uses 'Plus" alpha-blending.  For details
see <A HREF="#plus_blend" >Plus Blending</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE><A HREF="#lineardodge" >Linear_Dodge</A></CODE>' compose method
  was added to IM version 6.5.4-3.
</I></FONT></TD></TR></TABLE></P>


<A NAME="linearburn"></A>
<A HREF="gradient_op_linearburn.png"
   ><IMG SRC="gradient_op_linearburn.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Linear_Burn
<FONT SIZE=3>(A Photoshop 'Subtract' method)</FONT></H3>

The '<B><Code>Linear Burn</CODE></B>' compose method is an 'Add Minus
One' composition, that produces the same result as if you negated all the input
and output images of a '<CODE><A HREF="#lineardodger" >Linear
Dodge</A></CODE>' or '<CODE><A HREF="#plus" >Plus</A></CODE>' compose method.
</P>

Its formula is: <CODE> <I>Src</I> + <I>Dest</I> - 1 </CODE> </P>

In Photoshop this is not only known as '<Code>Linear Burn</CODE>' but also as
'<CODE>Subtract</CODE>'.  That is because if you <A
HREF="../color_mods/#negate" >Negate</A> one of the input images (such as the
source image), that image is subtracted from the other image.  For example
here is the resulting maths when you negate the source image...

<DIV ALIGN=center><CODE>
          (1-<I>Src</I>) + <I>Dest</I> - 1  ==&gt;  <I>Dest</I> - <I>Src</I>
</CODE></DIV></P>

That is, with no transparency, you can take image '<CODE>A</CODE>' and
subtract image '<CODE>B</CODE> produce the same resulting image
'<CODE>R</CODE>'...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert  A  B               -compose  minus_src  -composite  R
  convert  B  A               -compose  minus_dst  -composite  R
  convert  A \( B -negate \)  -compose linear_burn -composite  R
  convert  B -negate  A       -compose linear_burn -composite  R
</CODE></PRE></TD></TR></TABLE>
</DIV>

Basically whichever image is negated, is the image that '<CODE><A
HREF="#linearburn" >Linear Burn</A></CODE>' will subtract from the other.  It
does not matter if the image is the source or the destination image. In some
ways it make this compose method more versatile. </P>

For example here I subtract an image of a circle on the right (which I negate),
from the one on the left.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert circle_left.gif \( circle_right.gif -negate \) \
         -compose LinearBurn -composite   circle_subtract.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="circle_left.gif"
     ><IMG SRC="circle_left.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/bar.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="-">
  <A HREF="circle_right.gif"
     ><IMG SRC="circle_right.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="circle_subtract.gif"
     ><IMG SRC="circle_subtract.gif"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This composition method also makes it useful as an alternative to the <A
HREF="../layers/#eval-seq_subtract" >Subtract Evaluate Sequence Method</A> to
subtract multiple images from a single starting image. </P>

Note however '<CODE><A HREF="#linearburn" >Linear Burn</A></CODE>' can not be
applied directly to the alpha channel of images, where as the more <A
HREF="#image_maths" >Mathematical Compose Method</A> <A HREF="#minus"
>Minus</A> can. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE><A HREF="#lineardodge" >Linear_Burn</A></CODE>' compose method
  was added to IM version 6.5.4-3.
</I></FONT></TD></TR></TABLE></P>


<A NAME="colordodge"></A>
<A HREF="gradient_op_colordodge.png"
   ><IMG SRC="gradient_op_colordodge.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Color_Dodge
<FONT SIZE=3>(photoshop division)</FONT></H3>

This composition method uses the source overlay image as a mask that sort of
protects the background image from "light exposure" over long periods of time.
The parts exposed to a lighter mask is made lighter, (or dodged), while black
areas produce no change. </P>

You could think of it as placing an object on top of an photo for a very long
time, causing the parts exposed to light to slowly whiten with age, while the
parts that were covered remain as they were. </P>

A pure black overlay does not change the image while a pure white overlay will
make all the background colors white, except for those that were pure black.
</P>

However unlike either '<CODE><A HREF="#screen" >Screen</A></CODE>' (inverted
multiply) or '<CODE><A HREF="#lineardodge" >Linear_Dodge</A></CODE>' (add)
dodge compose methods, a pure black or all white destination image will remain
uneffected by the lighting mask. In other words only areas containing
grays and non-pure color is affected. </P>

Its formula is:  <CODE> <I>Dest</I> / (1-<I>Src</I>) </CODE></P>

<I>example and practical use needed here</I></P>

In actual fact '<CODE><A HREF="#colordodge" >ColorDodge</A></CODE>'
and the two '<CODE><A HREF="#divide" >Divide</A></CODE>' operators can
produce the same results. '<CODE><A HREF="#colordodge" >ColorDodge</A></CODE>'
however requires the image being used as a 'divisor' to be negated and used as
a 'source' image for the operator.  </P>

For example all these commands operating on images '<CODE>N</CODE>'
(numerator) divided by the '<CODE>D</CODE>' (denominator) produce the same
resulting image '<CODE>R</CODE>'... Assuming all the images are the same size.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=90% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert  N \( D -negate \)  -compose ColorDodge -composite  R
  convert  N    D             -compose DivideSrc  -composite  R
  convert  D    N             -compose DivideDst  -composite  R
</CODE></PRE></TD></TR></TABLE>
</DIV>

</I></FONT></TD></TR></TABLE></P>

See '<CODE><A HREF="#divide" >Divide</A></CODE>' for an example of how
dividing images can be used for the removal of a background gradient. </P>


<A NAME="colorburn"></A>
<A HREF="gradient_op_colorburn.png"
   ><IMG SRC="gradient_op_colorburn.png"
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
<H3>Color_Burn</H3>

This is the reverse of '<CODE><A HREF="#colordodge" >Color_Dodge</A></CODE>',
equivalent to inverting all the input and output images.  The result is that
the background image is darkened by a dark masking image, while white produces
no darkening. </P>

However unlike either '<CODE><A HREF="#multiply" >Multiply</A></CODE>' or
'<CODE><A HREF="#linearburn" >Linear_Burn</A></CODE>' burn compose methods,
a pure black or all white destination image will remain uneffected by the
lighting mask. In other words only areas containing grays and non-pure color
is affected. </P>

Its formula is:  <CODE> 1 - ( (1-<I>Dest</I>) / <I>Src</I>) </CODE></P>

<I>example and practical use needed here</I></P>

This command is equivelent to the previous set of formulas to implement
a division of images. Note the final negation in the command.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=90% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert  N -negate D   -compose ColorBurn -composite  -negate  R
</CODE></PRE></TD></TR></TABLE>
</DIV>

One use of '<CODE><A HREF="#colorburn" >Color_Burn</A></CODE>' is to clean
dark gradient backgrounds to pure black. Much like '<CODE><A HREF="#colorburn"
>Color_Dodge</A></CODE>' can divide backgrounds to white. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.5.4-3  '<CODE><A HREF="#colorburn" >Color_Burn</A></CODE>' was
  proved to be incorrectly implemented.
</I></FONT></TD></TR></TABLE></P>



<HR><!-- ---------------------------------------------------------------- -->

<A NAME="channel"></A>
<H2>Channel Copying Methods</H2>

These image composition methods are designed to transfer image channel
information from one image to another.  It however makes some assumptions
about the image from which the 'channel' is being copied.  I suggest you read
the sections <A HREF="../color_basics/#colorspace" >Image Color Space</A> and
<A HREF="../color_basics/#channels" >Color Channel Operators</A> to understand
how IM represents image color channels in memory before using them. </P>

The most useful channel copying composition methods is '<A HREF="#copyopacity"
><CODE >Copy_Opacity</CODE></A>' (see below).  It is simplist way to
completely replace (or add) just the alpha channel to an existing image using
a separate greyscale mask image. </P>


<A NAME="copyopacity"></A>
<H3>Copy_Opacity
<FONT SIZE=3>(Set transparency from gray-scale mask)</FONT></H3>

The original purpose of the '<CODE><A HREF="#copyopacity"
>Copy_Opacity</A></CODE>' operator was to copy the transparency channel of the
source image into the destination image, to set that image's transparent parts.
This is more commonly done using Duff-Porter operators, which are
specifically designed for compositing images with alpha transparencies. </P>

For example, if the destination is fully-opaque, which is typical of this
operator's use, then either '<CODE><A HREF="#dstin" >Dst_In</A></CODE>',
or even '<CODE>Dst_ATop</CODE>' operators will achieve the same result. </P>

So why is the '<CODE><A HREF="#copyopacity" >Copy_Opacity</A></CODE>'
operator so important, when their are alternatives? </P>

The answer is how this operator handles a special case.  When the overlay
(source) image has no alpha channel, then this operator will treat it as
a simple grey-scale image mask.  That is, it will replace any existing alpha
channel of the image with the greyscale image given. </P>

In summary anything that is black in the gray-scale image will be thought to
be fully transparent, and white fully-opaque. </P>

This is so important, and so commonly used, I will make it a rule of thumb...
<DIV ALIGN=center><B>
    Images using this operator should <I>NOT</I> contain any alpha channel.
</B></DIV></P>

You can ensure that the images do not have any alpha channel by <A
HREF="../basics/#alpha_off" >Turning Off the Alpha Channel</A>.  on both input
images before compositing using the '<CODE><A HREF="#copyopacity"
>Copy_Opacity</A></CODE>' compose setting. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example, make a grey scale moon image (which is easy to draw), then
use it as a mask for a blue <A HREF="../canvas/#plasma" >plasma gradient</A>,
to produce a nice mottled looking blue moon.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 70x70 xc:black -fill white -draw 'circle 35,35 35,5' \
                               -fill black -draw 'circle 28,30 35,5' \
          moon_mask.gif
<r>  convert -size 70x70 plasma:white-dodgerblue  moon_mask.gif \
          -alpha Off  -compose CopyOpacity   -composite  moon_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="moon_mask.gif"
     ><IMG SRC="moon_mask.gif"     WIDTH=70  HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="moon_gradient.png"
     ><IMG SRC="moon_gradient.png"     WIDTH=70  HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If your images have transparent components that you need to preserve, then
this is not the Alpha Composition operator you need.  More than likely you
want to use '<CODE><A HREF="#dstin" >Dst_In</A></CODE>' instead, to subtract
the transparent areas of the source overlay from your destination (in which
case both images need to have an alpha channel enabled and used. </P>

This operator is explained in even more detail in <A HREF="../fonts/#mask"
>Using a Mask Image with Fonts</A> and in <A HREF="../masking/#editing"
>Editing Image Masks</A>.  It is also used in many other examples throughout
these pages. </P>


<A NAME="copyred"></A>
<A NAME="copygreen"></A>
<A NAME="copyblue"></A>
<H3>Copy_Red,  Copy_Green,  Copy_Blue</H3>

Copy the given color channel of the source image into the destination image.
</P>

As a gray-scale RGB image has the same data in all three color channels, these
methods can be thought of as copying a greyscale channel image to replace the
specified channel in the destination image.  Much as the '<A
HREF="#copyopacity" ><CODE>Copy_Opacity</CODE></A>' (see above) can replace
the 'alpha channel' of an image with a greyscale image. </P>

These channel copying methods are rarely used today thanks to the use of
various <A HREF="../color_basics/#channels" >Color Channel Operators</A> to
separate out and re-combine color channels via grayscale channel images. </P>

Note that when merging various grayscale gradient patterns very interesting color
images can be generated using these operators.  For some examples look at the
color gradient combinations in <A HREF="tables/" >raw compose operator
tables</A>. </P>


<A NAME="copycyan"></A>
<A NAME="copymagenta"></A>
<A NAME="copyyellow"></A>
<H3>Copy_Cyan,  Copy_Magenta,  Copy_Yellow</H3>

These are synonyms for the same methods in the previous section. </P>

Basically as the '<CODE>Red</CODE>' channel in RGB images is also used as the
'<CODE>Cyan</CODE>' channel in the CYMK images.  The same for
'<CODE>Green</CODE>' and '<CODE>Magenta</CODE>' channels, and the
'<CODE>Blue</CODE>' and '<CODE>Yellow</CODE>' channels. </P>

Because of this copying the '<CODE>Cyan</CODE>' channel is the same as copying
a '<CODE>Red</CODE>' channel.  What type of channel the image data is
representing depends on the current <A HREF="../color_basics/#colorspace"
>Color Space</A> of the image in memory. </P>

<A NAME="copyblack"></A>
<H3>Copy_Black</H3>

This also just copies the '<CODE>Black</CODE>' channel from source to the
destination, if it exists.  However that channel only exists for CMYK images.
</P>

If the 'Black' channel does not exist this does nothing, which is probably a
bug.  What it probably should do is copy a grey-scale 'Black' channel image,
to the black channel of the destination image (assuming that it exists). </P>


<A NAME="hue"></A>
<H3>Hue
<FONT SIZE=3>(copy the hue of a RGB image to destination)</FONT></H3>

This operator copies the hue H of the source image to replace the hue of the
destination image, leaving the backgrounds saturation S and  luminance L
(<I>OR is it luminance Y?</I>) unchanged. </P>

This assumes both images are in RGB colorspace image. I have not tested this
with a non-RGB colorspace image. </P>


<A NAME="saturate"></A>
<H3>Saturate
<FONT SIZE=3>(copy the saturation of a RGB image to destination)</FONT></H3>

Copies the Saturation S from source to destination, (assuming the image is a
RGB colorspace image) leaving the color hue H and luminance L (<I>OR is it
luminance Y?</I>) unchanged. </P>

This assumes both images are in RGB colorspace image. I have not tested this
with a non-RGB colorspace image. </P>


<A NAME="luminize"></A>
<H3>Luminize
<FONT SIZE=3>(copy the luminance of a RGB image to destination)</FONT></H3>

Copies the  luminance L (<I>OR is it luminance Y?</I>) from source to
destination, leaving the color hue H and saturation S unchanged. </P>

This assumes both images are stored using RGB colorspace. I have not tested
this with a non-RGB colorspace image. </P>


<A NAME="colorize"></A>
<H3>Colorize
<FONT SIZE=3>(copy the color hue and saturation to destination)</FONT></H3>

Copies the  hue H and saturation S  from source to destination, leaving the
color luminance L (<I>OR is it luminance Y?</I>) unchanged. </P>

This assumes both images are stored using RGB colorspace.  I have not tested
this with a non-RGB colorspace image. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="dissolve"></A>
<H2>Dissolve One Image Over Another</H2>

What the "<CODE><A HREF="../option_link.cgi?dissolve" >-dissolve</A></CODE>"
operator does is provide a controlled '<CODE><A HREF="#over" >Over</A></CODE>'
compose method.  It adjusts the transparency of the overlay image, before it
is overlaid on top of the the background, according to the percentages given.
</P>

<DL><DD><PRE><NOBR>
<B>    composite -dissolve {<I>percent</I>} overlay  bgnd  result
<BR>
<BR>   composite -dissolve {<I>src_percent</I>}x{<I>dst_percent</I>} overlay  bgnd  result
<BR>
<BR>  convert bgnd  overlay   -compose dissolve \
<BR> &nbsp;
     &nbsp; -define compose:args={<I>src_percent</I>},{<I>dst_percent</I>} \
<BR> &nbsp; &nbsp; -composite   result
</B></NOBR></PRE></DL>

Providing two arguments (new to IM v6), allows you to exactly define how much
of both the overlay and the background image is dissolved before the images
are overlaid. </P>

If only a single percentage argument is given, only the overlay is dissolved
to leave that amount, (0 percent is completely transparent, 100 source is
unchanged) before being overlaid (using the '<CODE><A HREF="#over"
>Over</A></CODE>' compose method) onto the background.  Furthermore, if you
continue past a value of 100% (also new for IM v6), it will then start to
dissolve away the background image. </P>

In other words, in the 0 to 100 percent range, the background image is not
dissolved at all (with a <I>dst_percent</I> of <CODE>100%</CODE>), while in
the 100 to 200 range, the overlay is left as is, (<I>src_percent</I> set to
<CODE>100%</CODE>), and the background is dissolved, so it is completely gone
when the argument reaches a value of <CODE>200%</CODE>). </P>

Here is a table of results with various dissolve arguments...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  composite -dissolve {<I>argument</I>}  -gravity South \
            star.gif   dragon_sm.gif -alpha Set   {<I>result</I>}
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center><NOBR>
   <A HREF="../images/star.gif"
     ><IMG SRC="../images/star.gif"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="../images/dragon_sm.gif"
     ><IMG SRC="../images/dragon_sm.gif"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=0 ALIGN=center><TR><TD>
    <A HREF="dissolve_montage.jpg"
       ><IMG SRC="dissolve_montage.jpg"
             ALIGN=middle VSPACE=2 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see "<CODE><A HREF="../option_link.cgi?dissolve"
>-dissolve</A></CODE>" will first slow dissolve a new image over the
background, then slowly dissolve away the original background image. Which is
very suitable for images containing transparent areas.  You can also control
the dissolve of the background, so while one image dissolves on top, you
can arrange for the background to dissolve away underneath. </P>

This is very good, but is not really suitable for a proper slide show style of
dissolve between images. As one image is overlaid the images are not merged
together equally, and swapping the image arguments (and corresponding dissolve
arguments) will produce different results. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
    For the 100% to 200% range, or the second percentage argument to work, the
    background image must contain an alpha channel.  This is especially
    important for JPEG images which do not contain any transparencies by
    default. <P>

    As such it is probably a good idea to tell IM to give all images an alpha
    channel using the <NOBR>"<CODE><A HREF="../option_link.cgi?alpha"
    >-alpha</A> Set</CODE>"</NOBR> operator before applying the
    '<CODE>dissolve</CODE>' composite method.

</I></FONT></TD></TR></TABLE></P>

The biggest caveat with using dissolve on both images is that the transparency
effects the average.  That is, dissolving two images by 50% will always result
in the colors being semi-transparent, even when both input images are fully
opaque.  For example:

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert dragon_sm.gif star.gif -alpha on \
          -compose dissolve -define compose:args='50,50' \
          -gravity South  -composite     dissolve_50_50.png
  composite -compose Dst_Over -tile pattern:checkerboard \
            dissolve_50_50.png   dissolve_50_50_bg.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="dissolve_50_50_bg.png"
       ><IMG SRC="dissolve_50_50_bg.png"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can see that after overlaying the image over a checkerboard pattern, that
all parts of the image are at least semi-transparent.  Though the
actual parts overlaid is less transparent than any part where one of the
source images is transparent. </P>

The only time you will get a fully-opaque image from a '<CODE>Dissolve</CODE>'
composition is if one of the images (usually the 'background') is not dissolved (a
100 percent value), and remains opaque.  This is why the default is to
use a 100 value for the 'background' , at least at first. </P>

The following are special cases for specific "<CODE><A
HREF="../option_link.cgi?dissolve" >-dissolve</A></CODE>" arguments...

<TABLE ALIGN=center WIDTH=70%>
<TR VALIGN=top><TH><CODE>  0x0 </CODE><TD ROWSPAN=4 WIDTH=20><TD ALIGN=justify>
    Both images are dissolved to full transparency. <BR>
    Equivalent to a '<CODE><A HREF="#clear" >Clear</A></CODE>' compose method.
<TR VALIGN=top><TH><CODE>   0  </CODE><TD ALIGN=justify>
    Just the background image unchanged (source made transparent). <BR>
    Equivalent to a '<CODE><A HREF="#dst" >Dst</A></CODE>' compose method.
<TR VALIGN=top><TH><CODE>  100 </CODE><TD ALIGN=justify>
    A normal overlay of the overlay image onto the background. <BR>
    Equivalent to a '<CODE><A HREF="#clear" >Over</A></CODE>' compose method.
<TR VALIGN=top><TH><CODE>  200  </CODE><TD ALIGN=justify>
    The overlay image on a blank canvas (background made transparent). <BR>
    Equivalent to a '<CODE><A HREF="#src" >Src</A></CODE>' compose method.
</TABLE></P>

The "<CODE><A HREF="../option_link.cgi?dissolve" >-dissolve</A></CODE>"
compositing method is commonly used as an alternative way of <A
HREF="../annotating/#wmark_image" >Watermarking with Images</A>, particularly
with color watermarks. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="blend"></A>
<H2>Blend Two Images Together</H2>

The "<CODE><A HREF="../option_link.cgi?blend" >-blend</A></CODE>" compositing
method provides what the "<CODE><A HREF="../option_link.cgi?dissolve"
>-dissolve</A></CODE>" compositing method was originally intended to provide,
before it was hijacked for other more basic operations. </P>

Where as the "<CODE><A HREF="../option_link.cgi?dissolve" >-dissolve</A></CODE>"
method overlays images on top of each other, "<CODE><A
HREF="../option_link.cgi?blend" >-blend</A></CODE>" merges images
together such that both images are treated equally (being just added
together), according to the percentage arguments given.  As such you can
achieve the same result (except in final image size) by swapping the
percentages and the image arguments.  This is not the case with "<CODE><A
HREF="../option_link.cgi?dissolve" >-dissolve</A></CODE>" method. </P>

In otherwords, "<CODE><A HREF="../option_link.cgi?blend" >-blend</A></CODE>"
is associative (arguments are swappable), while "<CODE><A
HREF="../option_link.cgi?dissolve" >-dissolve</A></CODE>" is not.  </P>

<DL><DD><PRE><NOBR>
<B>    composite -blend {<I>percent</I>} overlay  bgnd  result
<BR>
<BR>   composite -blend {<I>src_percent</I>}x{<I>dst_percent</I>} overlay  bgnd  result
<BR>
<BR>   convert bgnd  overlay   -compose blend \
<BR> &nbsp;
     &nbsp; -define compose:args={<I>src_percent</I>},{<I>dst_percent</I>} \
<BR> &nbsp; &nbsp; -composite   result
</B></NOBR></PRE></DL>

If only a single percentage value is given, it is used as the dissolve
percentage for the overlay, while the background image is dissolved by the
exact opposite amount.  That is a "<CODE>-blend 30</CODE>" will dissolve the
overlay by 30%, and the background by 70% before the two images are added
together. thus it is equivalent to "<CODE>-blend 30x70</CODE>".  The result of
this is that the opacity of the two images (in the areas overlaid) will still
add up to 100%. </P>

By giving two percentages you can control exactly how much of the two images
are to be merged together. </P>

Here is a table of results with various dissolve arguments...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  composite -blend {<I>argument</I>}  -gravity South \
            compose_R.png compose_plus_GB.png  -alpha Set  {<I>result</I>}
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center><NOBR>
   <A HREF="compose_R.png"
     ><IMG SRC="compose_R.png"           WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="compose_plus_GB.png"
     ><IMG SRC="compose_plus_GB.png"             WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=0 ALIGN=center><TR><TD>
    <A HREF="blend_montage.jpg"
       ><IMG SRC="blend_montage.jpg"
             ALIGN=middle VSPACE=2 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

From the results you can see that "<CODE><A HREF="../option_link.cgi?blend"
>-blend</A></CODE>" will let you slowly replace one image with another equally
without overlay. </P>

If you overlay the result of a blend on a black canvas, say the size of your
display, you can easily make a respectable slide show program in
which one image slowly dissolves into another. </P>

You can also see that because the images are added together (internally it
uses the '<CODE><A HREF="#plus" >Plus</A></CODE>' compose operator), you can
easily overload the color channel maximums, producing some artifacts. A 100%
white color in particular will ensure nothing of the other image will be
visible as all colors channels are already at their maximum. </P>

It is recommended that in most situations you only need to use the
single argument version of blend. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
    As with  "<A HREF="../option_link.cgi?dissolve"
    ><CODE>-dissolve</CODE></A>", the background image must contain an alpha
    channel for "<A HREF="../option_link.cgi?blend" ><CODE>-blend</CODE></A>"
    to work correctly, to dissolve the background image. <P>

    As such it is probably a good idea to tell IM to <A
    HREF="../basics/#alpha_set" >Set an Alpha Channel</A> on all images before
    applying the '<CODE><A HREF="#blend" >Blend</A></CODE>' composition.

</I></FONT></TD></TR></TABLE></P>

The following are special cases for specific "<CODE><A
HREF="../option_link.cgi?blend" >-blend</A></CODE>" arguments...

<TABLE ALIGN=center WIDTH=70%>
<TR VALIGN=top><TH><CODE>  0x0 </CODE><TD ROWSPAN=5 WIDTH=20><TD ALIGN=justify>
    Both images are dissolved to full transparency. <BR>
    Equivalent to a '<CODE><A HREF="#clear" >Clear</A></CODE>' compose method.
<TR VALIGN=top><TH><CODE>   0  </CODE><TD ALIGN=justify>
    Just the background image unchanged. <BR>
    Equivalent to a '<CODE><A HREF="#dst" >Dst</A></CODE>' compose method.
<TR VALIGN=top><TH><CODE>  100  </CODE><TD ALIGN=justify>
    The overlay image on a blank canvas. <BR>
    Equivalent to a '<CODE><A HREF="#src" >Src</A></CODE>' compose method.
<TR VALIGN=top><TH><CODE> 100x100 </CODE><TD ALIGN=justify>
    Just the two images added together. <BR>
    Equivalent to a '<CODE><A HREF="#plus" >Plus</A></CODE>' compose method.
<TR VALIGN=top><TH><CODE> 50 </CODE><TD ALIGN=justify>
    Average of both images.  This is equivalent to the "<CODE><A
    HREF="../option_link.cgi?average" >-average</A></CODE>" image sequence
    operator, but with two images.  (See also <A
    HREF="../layers/#average" >Averaging Images</A>)
</TABLE></P>

<A NAME="blend_dissolve"></A>
<H3>Blend verse Dissolve</H3>

While both Dissolve and Blend will make images semi-transparent "<CODE><A
HREF="../option_link.cgi?dissolve" >-dissolve</A></CODE>" composes the image
using '<CODE><A HREF="#over" >Over</A></CODE>', while "<CODE><A
HREF="../option_link.cgi?blend" >-blend</A></CODE>" merges the images using
'<CODE><A HREF="#plus" >Plus</A></CODE>'. </P>

This may not seem like much, but it can be very important, as it definines how
the two composition methods handle parts of the image which are not overlaid,
or in areas where the overlay is transparent. </P>

For example.
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert dragon_sm.gif star.gif -alpha on \
          -compose dissolve  -define compose:args=50 \
          -gravity South  -composite     dissolve_50.png
  convert dragon_sm.gif star.gif -alpha on \
          -compose blend  -define compose:args=50 \
          -gravity South  -composite     blend_50.png
</CODE></PRE></TD></TR></TABLE>
<TABLE WIDTH=60%>
<TR><TD ALIGN=center>
  <A HREF="dissolve_50.png"
     ><IMG SRC="dissolve_50.png"   WIDTH=82 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dissolve
</TD><TD ALIGN=center>
  <A HREF="blend_50.png"
     ><IMG SRC="blend_50.png"   WIDTH=82 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Blend
</TD></TR></TABLE>
</DIV></P>

Note that even though the non-overlaping parts of the 'dragon' background
is semi-transparent in the <A HREF="#blend" >Blended</A> images, the area of
the star is fully opaque in both, and contain the same color result!
</P>

That is for areas where both images are fully-opaque, and you allow IM to
calculate the appropriate second '<CODE>{<I>dst_percent</I>}</CODE>' argument,
you will also be full-opaque and have the same result. </P>

For example, here I merge the 'dragon' image with the built in 'rose' image.  I
crop both images to the same size, so that both fully-opaque images can fully
cover each other.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert dragon_sm.gif rose: -crop 70x46+0+0 +repage -alpha on \
          -compose dissolve  -define compose:args=50 \
          -gravity South  -composite     dissolve_50_opaque.png
  convert dragon_sm.gif rose: -crop 70x46+0+0 +repage -alpha on \
          -compose blend  -define compose:args=50 \
          -gravity South  -composite     blend_50_opaque.png
</CODE></PRE></TD></TR></TABLE>
<TABLE WIDTH=60%>
<TR><TD ALIGN=center>
  <A HREF="dissolve_50_opaque.png"
     ><IMG SRC="dissolve_50_opaque.png"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dissolve
</TD><TD ALIGN=center>
  <A HREF="blend_50_opaque.png"
     ><IMG SRC="blend_50_opaque.png"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Blend
</TD></TR></TABLE>
</DIV></P>

If you were to compare these two images, you will find they are exactly the
same. </P>

In summery, a <A HREF="#dissolve" >Dissolve</A> (over with just overlay image
given a percentage of transparency) is the same as a <A HREF="#blend"
>Blend</A> (weighted addition of both images each with appropriate percentages)
produces the same result for any fully-opaque image.  It is only when one or
both images contain transparency that the two methods differ. </P>


<A NAME="blend_use"></A>
<H3>Using Blend to Modify a Single Image</H3>

Blend is basically an 'interpolation function', or 'weighted average' allowing
you to combine two fully-opaque images in a controlled linear way.  That is
30% of the source plus 70% of the background, to produce a new 100% opaque
image. </P>

It can however do more than just combine two images. It can also be used to
brighten, set contrast, saturation, colorize and even sharpen a specific image.
</P>

This use of blend is discussed further in a document found by <I>BugBear</I>
&lt;bugbear&#64;papermule.co.uk&gt; on the WWW, <A
HREF="http://netpbm.sourceforge.net/doc/extendedopacity.html" >Image
Processing by Interpolation and Extrapolation</A> a copy of the one on <A
HREF="http://www.graficaobscura.com/interp/index.html" >Grafica Obscura</A>
(which is not directly linkable from an external source). This document is
recommended for further reading on using this function. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify><FONT SIZE=-1><I>
    Extrapolation ability was added to the "<CODE><A
    HREF="../option_link.cgi?blend" >-blend</A></CODE>" operator in IM
    v6.3.5-10.
</I></FONT></TD></TR></TABLE></P>

For example, here we can make the rose image brighter or darker
by blending it with a pure black image of the same size.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -blend   0 rose: -size 70x46 xc:black -alpha Set blend_dark_0.jpg
  composite -blend  50 rose: -size 70x46 xc:black -alpha Set blend_dark_50.jpg
  composite -blend 100 rose: -size 70x46 xc:black -alpha Set blend_dark_100.jpg
  composite -blend 150 rose: -size 70x46 xc:black -alpha Set blend_dark_150.jpg
  composite -blend 200 rose: -size 70x46 xc:black -alpha Set blend_dark_200.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR>
<TH><A HREF="blend_dark_0.jpg"
      ><IMG SRC="blend_dark_0.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><U>0%</U>
<TH><A HREF="blend_dark_50.jpg"
      ><IMG SRC="blend_dark_50.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>50%
<TH><A HREF="blend_dark_100.jpg"
      ><IMG SRC="blend_dark_100.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><U>100%</U>
<TH><A HREF="blend_dark_150.jpg"
      ><IMG SRC="blend_dark_150.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>150%
<TH><A HREF="blend_dark_200.jpg"
      ><IMG SRC="blend_dark_200.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>200%
</TR></TABLE>
</DIV></P>

As in any use of the <A HREF="#blend" >Blend Composition Method</A>, 0% results
in 'destination' image, while at 100% the results is the original 'source'
image unchanged. It is the blended and extrapolation images that is of greater
interest here. </P>

Similarly blending with a pure gray image lets you adjust any images contrast.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -blend   0 rose: -size 70x46 xc:'#808080' -alpha Set blend_gray_0.jpg
  composite -blend  50 rose: -size 70x46 xc:'#808080' -alpha Set blend_gray_50.jpg
  composite -blend  80 rose: -size 70x46 xc:'#808080' -alpha Set blend_gray_80.jpg
  composite -blend 100 rose: -size 70x46 xc:'#808080' -alpha Set blend_gray_100.jpg
  composite -blend 120 rose: -size 70x46 xc:'#808080' -alpha Set blend_gray_120.jpg
  composite -blend 150 rose: -size 70x46 xc:'#808080' -alpha Set blend_gray_150.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR>
<TH><A HREF="blend_gray_0.jpg"
      ><IMG SRC="blend_gray_0.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><U>0%</U>
<TH><A HREF="blend_gray_50.jpg"
      ><IMG SRC="blend_gray_50.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>50%
<TH><A HREF="blend_gray_80.jpg"
      ><IMG SRC="blend_gray_80.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>80%
<TH><A HREF="blend_gray_100.jpg"
      ><IMG SRC="blend_gray_100.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><U>100%</U>
<TH><A HREF="blend_gray_120.jpg"
      ><IMG SRC="blend_gray_120.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>120%
<TH><A HREF="blend_gray_150.jpg"
      ><IMG SRC="blend_gray_150.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>150%
</TR></TABLE>
</DIV></P>

Here I blend the image with a greyscale version of the image, allowing you to
control the saturation of colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -type grayscale  rose_gray.png
  composite -blend   0 rose: rose_gray.png -alpha Set blend_color_0.jpg
  composite -blend  50 rose: rose_gray.png -alpha Set blend_color_50.jpg
  composite -blend 100 rose: rose_gray.png -alpha Set blend_color_100.jpg
  composite -blend 150 rose: rose_gray.png -alpha Set blend_color_150.jpg
  composite -blend 200 rose: rose_gray.png -alpha Set blend_color_200.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR>
<TH><A HREF="blend_color_0.jpg"
      ><IMG SRC="blend_color_0.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><U>0%</U>
<TH><A HREF="blend_color_50.jpg"
      ><IMG SRC="blend_color_50.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>50%
<TH><A HREF="blend_color_100.jpg"
      ><IMG SRC="blend_color_100.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><U>100%</U>
<TH><A HREF="blend_color_150.jpg"
      ><IMG SRC="blend_color_150.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>150%
<TH><A HREF="blend_color_200.jpg"
      ><IMG SRC="blend_color_200.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>200%
</TR></TABLE>
</DIV></P>

Here I blend the rose image against its blurred version producing <A
HREF="../convolve/#soft_blur" >Softened Blurs</A> when interpolating, and <A
HREF="../convolve/#unsharpen" >Unsharpening</A> when extrapolating, from its
blurred form.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -blur 0x5  rose_blurred.png
  composite  -blend   0  rose: rose_blurred.png -alpha Set blend_blur_0.jpg
  composite  -blend  50  rose: rose_blurred.png -alpha Set blend_blur_50.jpg
  composite  -blend 100  rose: rose_blurred.png -alpha Set blend_blur_100.jpg
  composite  -blend 150  rose: rose_blurred.png -alpha Set blend_blur_150.jpg
  composite  -blend 200  rose: rose_blurred.png -alpha Set blend_blur_200.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR>
<TH><A HREF="blend_blur_0.jpg"
      ><IMG SRC="blend_blur_0.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><U>0%</U>
<TH><A HREF="blend_blur_50.jpg"
      ><IMG SRC="blend_blur_50.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>50%
<TH><A HREF="blend_blur_100.jpg"
      ><IMG SRC="blend_blur_100.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><U>100%</U>
<TH><A HREF="blend_blur_150.jpg"
      ><IMG SRC="blend_blur_150.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>150%
<TH><A HREF="blend_blur_200.jpg"
      ><IMG SRC="blend_blur_200.jpg"   WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>200%
</TR></TABLE>
</DIV></P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="watermark"></A>
<H2>Watermark Option - Compose '<CODE>Modulate</CODE>'</H2>

The "<CODE><A HREF="../option_link.cgi?watermark" >-watermark</A></CODE>"
composite option or the "<CODE>modulate</CODE>" compose method, is meant to
<i>dis-color</i> images in HSB space for copyright purposes.
</P>

<DL><DD><PRE><NOBR>
<B>    composite -watermark {<I>brightness</I>}[x{<I>saturation</I>}] overlay  bgnd  result
<BR>
<BR>   convert bgnd  overlay   -compose modulate \
<BR> &nbsp;
     &nbsp; -define compose:args={<I>brigthness</I>}[,{<I>saturation</I>}] \
<BR> &nbsp; &nbsp; -composite   result
</B></NOBR></PRE></DL>

The 'overlay' image is an alpha masked black and white image, which is used to
brighten/darken the destination image by the '<I>brightness</I>' percentage
given.  A '<I>brightness</I>' of '<CODE>0</CODE>' makes no change in the image
brightness, though a value of '<CODE>100</CODE>' replaces the brightness with
the intensity of the overlay image.  That is, if the overlay is black the
destination is made black, if white the destination image's color will be
fully saturated. </P>

The '<I>saturation</I>' defaults to '<CODE>100</CODE>' producing maximum
color saturation. If set to '<CODE>0</CODE>' the masked area will be
de-saturated to black and white. </P>

Here is a table of results with various arguments...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  composite -watermark {<I>argument</I>}  -gravity South \
            sphinx.gif  cyclops.gif   {<I>result</I>}
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center><NOBR>
   <A HREF="../images/sphinx.gif"
     ><IMG SRC="../images/sphinx.gif"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
   <A HREF="../images/cyclops.gif"
     ><IMG SRC="../images/cyclops.gif"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=0 ALIGN=center><TR><TD>
    <A HREF="wmark_montage.jpg"
       ><IMG SRC="wmark_montage.jpg"
             ALIGN=middle VSPACE=2 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>

A good value for lightly watermarking images is a <I>brightness</I> of about
about 15 to 30 percent. </P>

The following are special cases for specific "<CODE><A
HREF="../option_link.cgi?watermark" >-watermark</A></CODE>" arguments...

<TABLE ALIGN=center WIDTH=70%>
<TR VALIGN=top><TH><CODE>  0 </CODE><TD ROWSPAN=5 WIDTH=20><TD ALIGN=justify>
    No change is made to the destination image at all.
<TR VALIGN=top><TH><CODE>  100  </CODE><TD ALIGN=justify>
    Destination made black where overlay is black,
    and fully-saturated color hue where overlay is white
<TR VALIGN=top><TH><CODE>  0x0  </CODE><TD ALIGN=justify>
    The masked overlay area is de-saturated to gray-scale
<TR VALIGN=top><TH><CODE> 100x0 </CODE><TD ALIGN=justify>
    The gray-scale overlay is simply overlaid
    '<CODE><A HREF="#atop" >ATop</A></CODE>' of the destination.
</TABLE></P>

For other watermarking techniques see, <A HREF="../annotating/#wmark_image"
>Watermarking with Images</A>.


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="mask"></A>
<H2>Using a Compose Mask to Limit the Composed Area</H2>

The "<CODE>composite</CODE>" command and  "<CODE><A
HREF="../option_link.cgi?composite" >-composite</A></CODE>" operator will also
take a third masking image which will limit the area effected by the
"<CODE><A HREF="../option_link.cgi?compose" >-compose</A></CODE>" method. </P>

For example given two images, and a <I>mask</I> image you can overlay part of
the <I>source</I> image onto the <I>background</I> image, as defined by that
mask.  Please note however that the <I>background</I> image still defines the
final size of the resulting image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite tile_water.jpg   tile_aqua.jpg  moon_mask.gif   mask_over.jpg
</CODE></PRE></TD></TR></TABLE>
    <A HREF="../images/tile_water.jpg"
       ><IMG SRC="../images/tile_water.jpg"
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="../images/tile_aqua.jpg"
       ><IMG SRC="../images/tile_aqua.jpg"
             ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="moon_mask.gif"
       ><IMG SRC="moon_mask.gif"
             ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="=>">
    <A HREF="mask_over.jpg"
       ><IMG SRC="mask_over.jpg"
             ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The <I>mask</I> image is considered to be part of the destination image,
defining what parts of the destination can be modified by the result of the
alpha composition. That is, the white parts can be modified, while black parts
(and parts outside the mask image) are left as is. </P>

Unfortunately while "<CODE><A HREF="../option_link.cgi?gravity"
>-gravity</A></CODE>" and "<CODE><A HREF="../option_link.cgi?geometry"
>-geometry</A></CODE>" settings will let you re-position the <I>source</I>
image, the <I>mask</I> image is NOT re-positioned, and remains aligned with
the <I>destination</I> image.  </P>

So lets just be clear about this...
<DIV ALIGN=center><B>
        The mask is aligned to the original background image.
<BR>    Any gravity/geometry setting is not applied to it.
</B></DIV></P>

That means that if I want to re-position the mask, I need to enlarge the mask
image with the appropriate amount of black rows and columns.  See <A
HREF="../crop/#splice" >Splice, adding rows and columns of pixels</A>.

For example here is a "<CODE>convert</CODE>" version (source and background
image arguments are swapped), with the mask image adjusted so as to move it
relative to the background image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tile_aqua.jpg   tile_water.jpg \
          \( -background black -splice 10x25+0+0 moon_mask.gif \) \
          -composite   mask_offset.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="mask_offset.jpg"
       ><IMG SRC="mask_offset.jpg"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Remember that the the "<CODE>convert</CODE>" commands "<CODE><A
HREF="../option_link.cgi?composite" >-composite</A></CODE>" operator specifies
the destination or background image first. </P>

The result is like giving the mask an offset of '<CODE>+10+25</CODE>' but with
neither the source or background images moving. </P>

If you want to align the mask with the source image you may be better off
masking the source image separately (using '<CODE><A HREF="#copyopacity"
>Copy_Opacity</A></CODE>' or some other technique).  Then you can position
that result onto the background without alignment problems. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here is a similar example, but this time I use a gradient mask the same size
as the background image so as to blend the two images together, producing a
'shallows' effect.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tile_aqua.jpg  tile_water.jpg  -size 94x94  gradient: \
          -composite   water_shallows.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="water_shallows.jpg"
       ><IMG SRC="water_shallows.jpg"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This provides a simple way of overlapping two images.
See <A HREF="../photos/#overlap" >Overlapping Photos</A>. </P>

<A NAME="mask_trans"></A>
<H3>Compose Mask and Transparency</H3>

You may think from the above that using a three image composite mask is very
much like using the '<CODE><A HREF="copyopacity" >Copy_Opacity</A></CODE>' to
set a transparency of the overlay image, then composite that over your
background.  And for images without any transparency (such as the above) you
would be right.  But that is not the whole story. </P>

First the mask is tied into the destination image, rather than the source
image, so it is not offset or gravity effected. </P>

Also unlike '<CODE><A HREF="copyopacity" >Copy_Opacity</A></CODE>' the mask
image is treated as purely a gray-scale image.  IM will ignore any and all
alpha transparency the mask may have.  As such you do <I>not</I> need to worry
about <A HREF="../basics/#alpha_off" >Turning Off Alpha Channel"</A> in the
mask image. </P>

And finally the mask works by limiting the area which was modified,
which is very different to just masking the source image. </P>

For a simple '<CODE><A HREF="over" >Over</A></CODE>' composition, this
is the same as if the mask is multiplied with any transparency in the
source image, to limit what is overlaid. As such for completely opaque source
images you can think of it as the transparency for the source image. </P>

For example, overlay two circles as normal then overlay them with
a mask limiting the area in which the destination image is changed.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 xc:none -fill red  -draw 'circle 35,21 35,3'  m_src.png
  convert -size 60x60 xc:none -fill blue -draw 'circle 21,39 24,57' m_bgnd.png
  convert -size 60x60 xc:   -draw 'polygon 0,59 59,0, 0,0'          m_mask.png

  composite m_src.png  m_bgnd.png                   m_over.png
  composite m_src.png  m_bgnd.png   m_mask.png      m_over_masked.png
</CODE></PRE></TD></TR></TABLE>
    <A HREF="m_src.png"
       ><IMG SRC="m_src.png"     WIDTH=60 HEIGHT=60
             ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="m_bgnd.png"
       ><IMG SRC="m_bgnd.png"     WIDTH=60 HEIGHT=60
             ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 HSPACE=10 ALT="=>">
    <A HREF="m_over.png"
       ><IMG SRC="m_over.png"           WIDTH=60  HEIGHT=60
             ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<BR>
    <A HREF="m_src.png"
       ><IMG SRC="m_src.png"     WIDTH=60 HEIGHT=60
             ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="m_bgnd.png"
       ><IMG SRC="m_bgnd.png"     WIDTH=60 HEIGHT=60
             ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="m_mask.png"
       ><IMG SRC="m_mask.png"     WIDTH=60 HEIGHT=60
             ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 HSPACE=10 ALT="=>">
    <A HREF="m_over_masked.png"
       ><IMG SRC="m_over_masked.png"           WIDTH=60  HEIGHT=60
             ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV>

The result is equivalent to the red circles image being 'masked' by the given
gray scale mask, which is then overlaid onto the destination image. </P>


However with any other type of alpha composition method, you are better of
just thinking of the mask as limiting the area of effect, rather than as a
transparency mask of the source image. </P>

Here I used a '<CODE><A HREF="src" >Src</A></CODE>' method to replace the
masked area in the destination with the contents of the source image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite  m_src.png  m_bgnd.png  m_mask.png  -compose Src  m_src_masked.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="m_src_masked.png"
       ><IMG SRC="m_src_masked.png"           WIDTH=60  HEIGHT=60
             ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see only the area with the defined mask is actually replaced by the
result of the alpha composition.  If the mask was only used to modify the
transparency of the source image the above would only show the source image
and nothing from the background image. </P>

<PRE>FUTURE:  Using masked composition to overlay an object in front of a
backdrop, but behind some foreground object.  Also develop an animated example,
of something being obscured by foreground objects in the destination. </PRE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify><FONT SIZE=-1><I>
    The above was a major long term bug involving composite masking when you
    involved source or overlay images with transparency, and or attempted to
    use other alpha compositions other than the  '<CODE><A HREF="#over"
    >Over</A></CODE>' compose method. See <A HREF="../bugs/composite_mask/"
    >Composite Mask Bug</A> for details. </P>
</I></FONT></TD></TR></TABLE></P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="tile"></A>
<H2>Compose using Image Tiles</H2>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The "<CODE><A HREF="../option_link.cgi?tile" >-tile</A></CODE>" setting in
"<CODE>composite</CODE>" is very different to that same setting in either
"<CODE>convert</CODE>" or "<CODE>montage</CODE>".  If given it means that the
<I>source</I> image is to be tiled over the <I>background</I> image. </P>

For example here we tile a 'color star' over a netscape color map image...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite  -tile star.gif   netscape:   tile.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="tile.gif"
       ><IMG SRC="tile.gif"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

One common use of composite tiling is to tile a semi-transparent copyright or
some other notice over images before publishing them on the net.  For examples
of this see the last examples of <A HREF="../annotating/#wmark_text"
>Watermarking with Text</A>. </P>

Note that the setting is essentially (at least at this time) argument-less.
It is only a Boolean on and off flag to the final "<CODE>composite</CODE>"
operation.  Consequently you can not use it to tile a <I>background</I> image
as that would mean IM can not use the background image to set the final size
of the result. </P>

However you can tile an image under another image using '<CODE><A
HREF="#dstover" >Dst_Over</A></CODE>' instead.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -background none -pointsize 36 label:'Tile Under'  png:- |\
  composite -tile bg.gif  -   -compose Dst_Over   tile_under.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="tile_under.gif"
       ><IMG SRC="tile_under.gif"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Also many of the mathematical operators are associative, meaning the source and
destination can be swapped without affecting the result (except the final image
size). </P>

Currently there is no simple method of doing a tiled alpha composition in the
"<CODE>convert</CODE>" command. This is a shame as it would make <A
HREF="../canvas/#tile_memory" >Tiling with an Image already In Memory</A> a
lot easier than it currently is. </P>

The basic technique for composition tiling using "convert" is to <A
HREF="../basics/#clone" >Clone</A> the original image, and tile it using one
of the methods given in <A HREF="../canvas/#tile" >Tiled Canvases</A>.  For
example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -gravity center -pointsize 32 -font Corsiva \
          label:'Tile White\nBackgrounds' -bordercolor white -border 5 \
          \( -clone 0 -tile tile_aqua.jpg -draw "color 0,0 reset" \) \
          -compose Multiply -composite  tile_convert.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="tile_convert.gif"
       ><IMG SRC="tile_convert.gif"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The above replaces a 'white background' of the label using the <A HREF="#math"
>Mathematical Compose</A> method "<CODE><A HREF="#multiply"
>Multiply</A></CODE>".  Also see <A HREF="../color_basics/#compose" >Using
Image Mask, Mathematical Composition</A>. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="special"></A>
<H2>Special Composition Methods</H2>

There are also a few special purpose composition methods that have been added
for one reason or another. </P>

<A NAME="mathematics"></A>
<H3>Mathematics
<FONT SIZE=3>(User Defined Mathematical Compose Method)</FONT></H3>

This composite method takes 4 numerical values to allow the user to define
many different <A HREF="#maths" >Mathematical Compose Methods</A>. </P>

The four arguments, "<CODE>A</CODE>", "<CODE>B</CODE>", "<CODE>C</CODE>", and
"<CODE>D</CODE>", define the formula...

<DIV ALIGN=center><PRE>A*Sc*Dc + B*Sc + C*Dc + D</PRE></DIV>

where "<CODE>Sc</CODE>" is the source or overlay image, and "<CODE>Dc</CODE>"
is the background or destination image. All four values must be provided. </P>

For example, we could generate the equivelent of a '<CODE><A HREF="#multiply"
>Multiply</A></CODE>' compose method using the values  "<CODE>1,0,0,0</CODE>".

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient_dst.png gradient_src.png \
          -compose Mathematics -define compose:args='1,0,0,0' -composite \
          mathematics_multiply.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="gradient_src.png"
     ><IMG SRC="gradient_src.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Source
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT=" + ">
</TD><TD ALIGN=center>
  <A HREF="gradient_dst.png"
     ><IMG SRC="gradient_dst.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Dest
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=29 ALT="=>">
</TD><TD ALIGN=center>
  <A HREF="mathematics_multiply.png"
     ><IMG SRC="mathematics_multiply.png"   WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Result
</TD></TR></TABLE>
</DIV></P>

Similarly by looking up or figuring out the formula needed you can generate
other composition methods, such as... </P>

<CODE><A HREF="#screen" >Screen</A></CODE>:
    <CODE>1-(1-Sc)*(1-Dc)  =&gt; -Sc*Dc + Sc + Dc  =&gt;  -1,1,1,0</CODE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient_dst.png gradient_src.png \
          -compose Mathematics -define compose:args='-1,1,1,0' -composite \
          mathematics_screen.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="mathematics_screen.png"
       ><IMG SRC="mathematics_screen.png"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Or '<CODE><A HREF="#linearlight" >LinearLight</A></CODE>' which is directly
defined using the arguments "<CODE>0,2,1,-1</CODE>"...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient_dst.png gradient_src.png \
          -compose Mathematics -define compose:args='0,2,1,-1' -composite \
          mathematics_linearlight.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="mathematics_linearlight.png"
       ><IMG SRC="mathematics_linearlight.png"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Similarly you can generate other compose methods such as...
<TABLE CELLSPACING=0 CELLPADDING=0 BORDER=1 ALIGN=center>
  <TR><TH>&nbsp;Compose Method&nbsp;
      <TH>&nbsp;Mathematics Args&nbsp;</TR>
  <TR><TD ALIGN=center><CODE><A HREF="#multiply"    >Multiply</A></CODE>
      <TD ALIGN=center><CODE>1,0,0,0</CODE></TR>
  <TR><TD ALIGN=center><CODE><A HREF="#screen"      >Screen</A></CODE>
      <TD ALIGN=center><CODE>-1,1,1,0</CODE></TR>
  <TR><TD ALIGN=center><CODE><A HREF="#exclusion"   >Exclusion</A></CODE>
      <TD ALIGN=center><CODE>0,1,1,-1</CODE></TR>
  <TR><TD ALIGN=center><CODE><A HREF="#lineardodge" >Linear_Dodge</A></CODE>
      <TD ALIGN=center><CODE>0,1,1,0</CODE></TR>
  <TR><TD ALIGN=center><CODE><A HREF="#linearburn"  >Linear_Burn</A></CODE>
      <TD ALIGN=center><CODE>0,1,1,-1</CODE></TR>
  <TR><TD ALIGN=center><CODE><A HREF="#linearlight" >Linear_Light</A></CODE>
      <TD ALIGN=center><CODE>0,2,1,-1</CODE></TR>
</TABLE></P>

Other compose methods require the use of either squares, square-roots,
division, or even multiple special piece-wise functions and conditionals,
which prevents them from being defined using a simple smooth polynomial
function that this method provides. </P>

You can also create new compose methods, for example an expanded
alternative to <A HREF="#linearlight" >LinearLight</A></CODE>...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient_dst.png gradient_src.png \
          -compose Mathematics -define compose:args='0,1,1,-0.5' \
          -composite  mathematics_linearlight_2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="mathematics_linearlight_2.png"
       ><IMG SRC="mathematics_linearlight_2.png"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This particular DIY composition is important as a means of <A
HREF="../transform/#math_addition" >Adding Biased Gradients</A> such as sine
waves. </P>

Or another variant that can be used for 'Lighting Effects'...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert gradient_dst.png gradient_src.png \
          -compose Mathematics -define compose:args='0,1,.5,-.25' \
          -composite mathematics_linearlight_3.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="mathematics_linearlight_3.png"
       ><IMG SRC="mathematics_linearlight_3.png"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The mathematical composition method is especially important to letting you do
special types of <A HREF="../transform/#gradient_math" >Mathematics on
Gradients</A> that would otherwise be very complex to achieve using multiple
individual steps.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE><A HREF="#mathematics" >Mathematics</A></CODE>' compose method
  was added to IM version 6.5.4-3.  And is currently only available using the
  "<CODE>-compose</CODE>" operator.  It is not available from the
  "<CODE>composite</CODE>" command due to its need for arguments.
</I></FONT></TD></TR></TABLE></P>


<A NAME="changemask"></A>
<H3>Change_Mask
<FONT SIZE=3>(Make similar pixels transparent)</FONT></H3>

This is an unusual method that will only make specific pixels in the
destination image full-transparent.  That is, the pixels in the destination
image that match the given source image, according to the current <A
HREF="../color_basics/#fuzz" >Fuzz Factor</A> setting. </P>

This can be used for example to re-add transparency to an image that was
overlaid onto a complex (but very different) background.  For example, this
was exactly the problem presented by <I>Jesper Eije</I>...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert overlay_figure.gif   overlay_bgnd.gif  \
          -compose ChangeMask  -composite  overlay_removed.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/overlay_figure.gif"
     ><IMG SRC="../images/overlay_figure.gif"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="../images/overlay_bgnd.gif"
     ><IMG SRC="../images/overlay_bgnd.gif"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="=>">
  <A HREF="overlay_removed.png"
     ><IMG SRC="overlay_removed.png"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Easy. </P>

Note that as JPEG image colors often have slight color changes due to the
lossy nature of the file format, a small <A HREF="../color_basics/#fuzz" >Fuzz
Factor</A> setting will be needed to match very similar colors </P>

Also if the changed part of the image happens to match the
background color or pattern, you will get 'holes' in the resulting image or
mask, as such caution is always advised when using this with images that are
very similar. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

By swapping the two images, so the background image is given as the
destination image, you can extract the parts of the background that was
replaced or modified by the overlaid image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert overlay_bgnd.gif  overlay_figure.gif \
          -compose ChangeMask  -composite  overlay_changed.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="overlay_changed.png"
       ><IMG SRC="overlay_changed.png"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the result is only a transparent shape mask of the original
background image where similar pixels are just cleared to transparency.  It
will make no attempt to generate partial transparencies, or change colors,
and as such could leave a 'halo' of slightly different background colors
around the image where the original overlay and the background color merged
together.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

As this composition method only 'clears' pixels to full-transparency, an alpha
channel will always added to the resulting image. The color of the destination
image is not however cleared as it is in most other Alpha Composition methods.
As such you can negate the alpha channel, to get the unchanged colors.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert overlay_figure.gif overlay_bgnd.gif -compose ChangeMask  -composite \
          -channel A -negate      overlay_unchanged.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="overlay_unchanged.png"
       ><IMG SRC="overlay_unchanged.png"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In this case the order of the input images does not matter, unless a large <A
HREF="../color_basics/#fuzz" >Fuzz Factor</A> was set.  Remember the colors
will come from the destination image, with the difference between the images
defining the resulting shape mask. </P>

For more information on these problems see <A HREF="../masking/#bg_remove"
>Background Removal</A>.  </P>

The result is often limited in its direct usefulness.  It can however be
used to generate bitmap masks of the changes between the images (hence its
name).  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE><A HREF="#changemask" >ChangeMask</A></CODE>' composition
  method was added to IM v6.3.4, to provide a method for <A
  HREF="../anim_opt/#opt_trans" >Optimizing Transparency</A> for GIF
  Animations.  No other existing composition method provided the needed
  requirements, without combining 3 or more composition methods.
  Specifically the Boolean (or fuzz factor thresholding) requirement needed
  for transparency optimization. </P>

  The result however is so useful in its own right that it was made
  available for direct use by users, and so defined the name of this
  rather complex composition method.
</I></FONT></TD></TR></TABLE></P>

<A NAME="mapping"></A>
<H3>Image Mapping Effect Methods</H3>

There are also a couple of special methods that are not strictly composition
methods. Rather than directly combining the two images on
a pixel by pixel bases, the source or overlap image is a special control map,
for some larger effect. </P>

While the methods they represent are relatively simple their use is so
complex they have their own example section. <A HREF="../mapping/" >Image
Mapping Effects</A>. </P>

These special methods include... </P>

<A NAME="blur"></A>

The '<B><CODE>Blur</CODE></B>' method provides a method of bluring images in
different ways on a pixel by pixel bases.  It can generate a wide range of DIY
image blurring effects. See <B><A HREF="../mapping#blur" >Variable Blur
Mapping</A></B> for details. </P>

<A NAME="displace"></A>

The '<B><CODE>Displace</CODE></B>' method on the other hand provides both an
absolute and relative pixel lookup displacement technique that
generates not only specific image distortion methods, but also glass,
lens, and ripple, effects. See <B><A HREF="../mapping#distort" >Distort
and Displacement Mapping</A></B> for details. </P>


</DIV></P>
<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 5 January 2004 <BR>
Updated: 1 December 2010 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/compose/</CODE>
</ADDRESS></BODY></HTML>

