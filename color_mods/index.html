<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Color Modifications -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://imagemagick.org/Usage/color_mods/">
</HEAD><body><main class="container"><div class="magick-template"><div class="magick-header">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Color Modifications</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#grayscale"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Converting Color to Gray-Scale</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
<DD><A HREF="#levels"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Image Level Adjustments</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <UL>
    <LI><A HREF="#negate"
        >Negating Images</A>
        <FONT SIZE=-1>(reversing black and white)</FONT>
    <LI><A HREF="#level"
        >Level Adjustment Operator</A>
        <FONT SIZE=-1>(contrast and black/white adjustment)</FONT>
    <LI><A HREF="#level_plus"
        >Reversed Level Adjustments</A>
        <FONT SIZE=-1>(de-contrasting)</FONT>
    <LI><A HREF="#level_gamma"
        >Gamma Level Adjustment</A>
        <FONT SIZE=-1>(mid-tone adjustments)</FONT>
    <LI><A HREF="#gamma"
        >Gamma Operator Adjustment</A>
        <FONT SIZE=-1>(gamma without level adjustments)</FONT>
    <LI><A HREF="#level-colors"
        >Level Adjustments by Color</A>
        <FONT SIZE=-1>(adjust image levels using colors)</FONT>
    <LI><A HREF="#sigmoidal"
        >Sigmoidal Non-linearity Contrast</A>
        <FONT SIZE=-1>(non-linear contrast adjustment)</FONT>
    <LI><A HREF="#contrast_misc"
        >Miscellaneous Contrast Adjustments</A>
    </UL>
<DD><A HREF="#histogram"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Adjustments Using Histogram Modification</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1>(changing the histogram an image)</FONT>
    <UL>
    <LI><A HREF="#stretching"
        >Linear Histogram Stretching</A>
    <LI><A HREF="#normalize"
        >Normalize</A>
        <FONT SIZE=-1>(auto-level stretching)</FONT>
    <LI><A HREF="#contrast-stretch"
        >Contrast Stretch</A>
        <FONT SIZE=-1>(controlled stretching)</FONT>
    <LI><A HREF="#linear-stretch"
        >Linear-Stretch</A>
        <FONT SIZE=-1>(alternative stretching)</FONT>
    <LI><A HREF="#hist_redist"
        >Histogram Redistribution</A>
    <LI><A HREF="#equalize"
        >Equalize</A>
        <FONT SIZE=-1>(uniform histogram redistribution)</FONT>
    <LI><A HREF="#gaussian_redist"
        >Gaussian Redistribution</A>
    <LI><A HREF="#redist_method"
        >Histogram Redistribution Methodology</A>
    </UL>
<DD><A HREF="#diy_levels"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > DIY Level Adjustments</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1>(general tinting operators)</FONT>
    <UL>
    <LI><A HREF="#linear"
        >DIY Mathematical Linear Adjustments</A>
    <LI><A HREF="#non-linear"
        >Mathematical Non-linear Adjustments</A>
    <LI><A HREF="#curves"
        >'Curves' Adjustments</A>
    </UL>
<DD><A HREF="#tinting"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Tinting Midtones of Images</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1>(general tinting operators)</FONT>
    <UL>
    <LI><A HREF="#colorize"
        >Uniform Color Tinting</A>
    <LI><A HREF="#tint"
        >Midtone Color Tinting</A>
    <LI><A HREF="#sepia-tone"
        >Sepia Tone Coloring</A>
    <LI><A HREF="#duotone"
        >Duotone Effect</A>
    <LI><A HREF="#tint_diy"
        >Color Tinting, DIY</A>
    <LI><A HREF="#tint_overlay"
        >Color Tinting Overlay</A>
    </UL>
<DD><A HREF="#color_mods"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Global Color Modifiers</A>
    <UL>
    <LI><A HREF="#modulate"
        >Modulate Brightness, Saturation, and Hue</A>
    <LI><A HREF="#modulate_hue"
        >Modulate the Hue Color Cycle</A>
    <LI><A HREF="#modulate_diy"
        >Modulate DIY</A>
    <LI><A HREF="#modulate_colorspace"
        >Modulate in Other Colorspaces</A>
    <LI><A HREF="#modulate_LCH"
        >Modulate in LCHuv and other Colorspaces</A>
    <LI><A HREF="#color-matrix"
        >Color Matrix Operator</A>
    <LI><A HREF="#solarize"
        >Solarize Coloring</A>
    </UL>
<DD><A HREF="#color_lut"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Recoloring Images with Lookup Tables</A>
    <IMG SRC="../img_www/space.gif" WIDTH=20 HEIGHT=1>
    <FONT SIZE=-1></FONT>
    <UL>
    <LI><A HREF="#clut"
        >Color Lookup Tables</A>
    <LI><A HREF="#fx_to_lut"
        >Function to Color LUT conversion</A>
    <LI><A HREF="#clut_alpha"
        >CLUT and Transparency Handling</A>
    <LI><A HREF="#hald-clut"
        >Hald 3D Color Lookup Tables</A>
    <LI><A HREF="#hald_limits"
        >Hald CLUT Limitations</A>
    <LI><A HREF="#hald_replacement"
        >Color Replacement using Hald CLUT</A>
    <LI><A HREF="#replace_colormap"
        >Full Color Map Replacement</A> (no solution, just ideas)
    </UL>
</DL>

Here we look at techniques for modifying all the colors in an image as
a whole.  Whether it is to lighten or darken the image, or more drastic color
modifications.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGN=center>
<TR valign="top"><TD width="100%" ALIGN=justify>

To explore these technqiues we will need a test image... <BR>

Don't worry above how I actually generated this image, it is not important for
the exercise.  I did design it to contain a range of colors, transparencies
and other features, specifically to give IM a good workout when used.

</TD><TD>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

<I>If you are really interested in the commands used to generate this image
you can look at the special script, "<CODE><A HREF="../scripts/generate_test"
><B>generate_test</B></A></CODE>", I use to create it.</I> </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  WARNING: The color processes below generally assumes the image is using
  a linear colorspace.  Most images are however saved using a sRGB or Gamma
  corrected colorspace, as such to get things right colorspace correction
  should also applied first.

</I></FONT></TD></TR></TABLE></P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="grayscale"></A>
<H2>Converting Color to Gray-Scale</H2>

Gray scale images can be very useful for many uses, such as, furthering the
processing of the original image or for use in background compositions.

The best method of converting an image to gray-scale is to just ask IM to
magick the image into a gray-scale <A HREF="../color_basics/#colorspace"
>Color Space</A> representation for the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -colorspace Gray   gray_colorspace.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="gray_colorspace.png"
     ><IMG SRC="gray_colorspace.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note how the blue is much darker than the red, due the weighting to match the
intensity as they seem to appear to the human eye.  That is, '<CODE>red</CODE>'
is quite a bright color compared to '<CODE>blue</CODE>' which looks darker.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>

This is equivelent to the use of the '<CODE>rec709luma</CODE>' conversion
formula with the dedicated "<CODE><A HREF="../option_link.cgi?grayscale"
>-grayscale</A></CODE>" operator (Added IM v6.8.3-10).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -grayscale rec709luma  gray_grayscale.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_grayscale.png"
     ><IMG SRC="gray_grayscale.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The '<CODE>rec709luma</CODE>' value is just one of many greyscaling formula
that has been defined for use by the "<CODE><A
HREF="../option_link.cgi?intensity" >-intensity</A></CODE>" setting (see
below). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>

Here for example is the other common greyscaling formula
'<CODE>rec601luma</CODE>'

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -grayscale rec601luma  gray_grayscale_601.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_grayscale_601.png"
     ><IMG SRC="gray_grayscale_601.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see there is a slight different in intensity levels for the
different red, green and blue color channels. </P>

<BR>

However there a many other methods, and meanings of 'gray-scale'... </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example, you can drain all the color out of the image by using the
<A HREF="#modulate" >Modulate Operator</A>, to set all
color saturation levels to zero.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -modulate 100,0  gray_modulate.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_modulate.png"
     ><IMG SRC="gray_modulate.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This essentually converts the image to the HSL colorspace, and extracts the
grayscale '<CODE>Lightness</CODE>' value from that colorspace.  However using
a "<CODE>-define modulate:colorspace</CODE>" you can specify other colorspace
models to use.  See <A HREF="#modulate_colorspace" >Modulate in Other
Colorspaces</A> below. </P>

Note how the IM '<CODE>green</CODE>' color I used for the center colored disk
in my test image is not actually a pure green, such as used in the colored
rainbow, but the half-bright green defined by the new <A
HREF="http://www.w3.org/TR/SVG12/" >SVG -- Scalable Vector Graphics</A>
standard. If you need a pure RGB green you can use the color
'<CODE>lime</CODE>' instead. See <A HREF="../color_basics/#color_conflicts"
>Color Name Conflicts</A> for more detail. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Another way is to use the <A HREF="../transform/#fx" >FX DIY operator</A> to
average the three channels together to get a pure mathematical meaning of
gray-scale.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -fx '(r+g+b)/3' gray_fx_average.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_fx_average.png"
     ><IMG SRC="gray_fx_average.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
   The average of sRGB channel values also equivelent to the intensity channel
   of '<CODE>OHTA</CODE>' colorspace (red channel). Or the 'I' channel of HSI.
   colorspace.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Another technique is to simply add all three channels together (a color
measure known as manhatten distance) and while the resulting image will not
loose information due to 'quantum rounding' effects, you may loose information
about the brightest colors.  Unfortunately, you also loose the transparency
channel, too.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -separate \
          -background black -compose plus -flatten   gray_added.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_added.png"
     ><IMG SRC="gray_added.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

You can use the same adding channels technique to control the weighting of the
individual color channels.  For example this is one DIY formula that you can
use...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -fx '0.3*r+0.6*g+0.1*b' gray_diy.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_diy.png"
     ><IMG SRC="gray_diy.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

You can also use 'intensity' if you want the same meaning within the "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -fx intensity  gray_intensity.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_intensity.png"
     ><IMG SRC="gray_intensity.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<!--  not working yet
The 'intensity' function is itself controlled (as is a lot of other operators
needing a grayscale value) by a new setting call "<CODE><A
HREF="../option_link.cgi?intensity" >-intensity</A></CODE>". </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Here we use the '<CODE>brightness</CODE>' formula (maximum value of any of the
color channels) that is used by the HSB colorspace. </P>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -intensity brightness -fx intensity  gray_brightness.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_brightness.png"
     ><IMG SRC="gray_brightness.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
-->

<BR>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

However as the <A HREF="../transform/#fx" >FX DIY operator</A> is interpreted,
it can run very very slowly.  For more complex operations you can use the
simpler <A HREF="../transform/#evaluate" >Evaluate Operator</A>, "<CODE><A
HREF="../option_link.cgi?evaluate" >-evaluate</A></CODE>". </P>

For example here is a 2/5/3 ratio gray-scaled image, though again I make no
attempt to preserve the transparency channel of the original image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -channel R -evaluate multiply .2 \
                   -channel G -evaluate multiply .5 \
                   -channel B -evaluate multiply .3 \
                   +channel -separate -compose add -flatten gray_253.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_253.png"
     ><IMG SRC="gray_253.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The above would suffer from 'quantization' effects for an ImageMagick
  compiled at a 'Q8' <A HREF="../basics/#quality" >Quality Level</A>.  That
  is because the results of the "<CODE><A HREF="../option_link.cgi?evaluate"
  >-evaluate</A></CODE>" will be saved into a small 8 bit integer, used for
  image values. Only later are those values added together with the
  resulting loss of accuracy. </P>

  An ImageMagick compiled with 'Q16', or better still the <A
  HREF="../basics/#hdri" >HDRI</A>, quality compile options will produce
  a much more exact result.  Another new alternative is the <A
  HREF="../layers/#poly" >Poly - Weighted Image Merging Operator</A>, which
  will do the weighting and addition of the separated channel images in one
  operation, so avoiding 'quantum rounding' effects. </P>
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

A similar technique can be used to generate a pure mathematical gray-scale, by
directly averaging the three RGB channels equally.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -separate -average  gray_average.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_average.png"
     ><IMG SRC="gray_average.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However as you can see, I did not attempt to preserve the alpha channel of the
resulting image. </P>

Another fast alternative is to use the "<CODE><A
HREF="../option_link.cgi?recolor" >-recolor</A></CODE>" color matrix operator,
which will let you specify the weighting of the three color channels.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=gray_recolor.png>
  magick test.png -recolor '.2 .5 .3
                             .2 .5 .3
                             .2 .5 .3'   gray_recolor.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_recolor.png"
     ><IMG SRC="gray_recolor.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This doesn't affect transparency, but makes it a much better way of converting
colors using a specific weighting. </P>

Basically the first row of numbers is the channel weighting for the resulting
images red channel, next 3 for green, and the final three numbers for blue.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

You can also use "<CODE><A HREF="../option_link.cgi?type" >-type</A></CODE>"
to tell IM to treat the image as gray-scale, when either reading or writing
the image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -type GrayScaleMatte  gray_type.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_type.png"
     ><IMG SRC="gray_type.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The "<CODE><A HREF="../option_link.cgi?type" >-type</A></CODE>" setting is
  generally only used as a guide when an image is being read or written to
  a file. As such its action is delayed to the final write of the image.  Its
  effect is also highly dependant on the capabilities of the image file format
  involved and is used to override ImageMagick's normal determination during
  that process.  See the <A HREF="../basics/#type" >Type</A> examples for more
  information.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Before IM v6.3.5-9 the above will have removed any transparency in the
  written image (equivalent of a "<CODE><A HREF="../option_link.cgi?type"
  >-type</A> Grayscale</CODE>") due to a bug.  This was fixed as soon as I
  noted the problem and reported it.  (There is a lesson here :-)
</I></FONT></TD></TR></TABLE></P>

<BR>

A much more interesting technique is to extract a variety of different
meanings of brightness by extracting the appropriate <A
HREF="../color_basics/#channel" >Color Channel</A> from various <A
HREF="../color_basics/#colorspace" >Colorspace</A> representations of the
image.  Examples see <A HREF="../color_basics/" >Grayscale Channels from
Colorspace Representations</A>. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="levels"></A>
<H2>Image Level Adjustments</H2>

The most basic form of adjustment you can make to images are known as 'level'
adjustments.  This basically means taking the individual RGB color values (or
even the alpha channel values) and adjusting them so as to either stretch or
compress those values. </P>

As only channel values are being adjusted, they are best demonstrated on a
gray-scale image, rather than a color image.  However if you adjust all the
color channels of an image by the same amount you can use them with color
images, for the purposes of either enhancing, or adjusting the image.

Do not confuse this with the more automatic form of level adjustments, which
we will look at in the next major section of examples below, <A
HREF="#normalize" >Normalize Adjustments</A>.  This function will do exactly
the same operation regardless of the actual content of the image.  It does not
matter if the image is bright, or dark, or has a blue, or yellow  tint.  The
operations are blind to the actual image content. </P>

<!-- <CODE EXECUTE>
  im_graph '-noop' gp_noop.gif
</CODE> -->
<IMG SRC="gp_noop.gif" ALIGN=right HSPACE=5 BORDER=0 ALT="[IM Graph]">

In demonstrating these operations I will be using a modified "<CODE><A
HREF="http://www.gnuplot.info/" >gnuplot</A></CODE>" graph such as shown to
the right, which I generate using a special script "<CODE><A
HREF="../scripts/im_graph" >im_graph</A></CODE>".  The graph has
a red line which maps the given original 'x' value (representing the
gray-scale value of the top most gradient) to the 'y' value shown.  The
resulting color gradient is also shown underneath the input linear gradient.
</P>

The graph shown to right is of the IM "<CODE><A HREF="../option_link.cgi?noop"
>-noop</A></CODE>" operator which actually does nothing to an image.  As such
each of the image's color values are just mapped to exactly the same value
without change.  The lower gradient is thus the same as the upper gradient.
</P>


<A NAME="negate"></A>
<H3>Image Negation</H3>

The simplest and most basic global level adjustment you can make is to negate
the image, using the "<CODE><A HREF="../option_link.cgi?negate"
>-negate</A></CODE>" image operator. </P>

Essentially this makes &nbsp; white, black, &nbsp; and &nbsp; black, white,
&nbsp;, adjusting all the colors to match.  That is, it will make the color
red, its complementary color of cyan, &nbsp; and blue, yellow, etc. </P>

You can see this with the mapping graph shown below, as I use the "<CODE><A
HREF="../option_link.cgi?negate" >-negate</A></CODE>" operator on both the
'test' image and the standard IM 'rose' built-in image.  Note how the lower
gradient in the mapping graph image is now reversed, so that black and white
are swapped, and the same reversal appearing in the negated 'test' image.

<!-- <CODE EXECUTE>
  im_graph '-negate' gp_negate.gif
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -negate  test_negate.png
  magick rose:    -negate  rose_negate.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=middle>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <IMG SRC="gp_negate.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=middle>
  <A HREF="test_negate.png"
     ><IMG SRC="test_negate.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="rose_negate.gif"
     ><IMG SRC="rose_negate.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Internally negate is actually rather stupid. It handles the three color
channels independently, and by default ignores the alpha channel.  If this was
not the case, you would get a very silly result like this...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -channel RGBA  -negate  negate_rgba.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="negate_rgba.png"
     ><IMG SRC="negate_rgba.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The image is negated, as you can see by the semi-transparent color gradient.
But as the transparency channel has also been negated you loose all the opaque
colors in the image.  This is why the default setting for "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" is '<CODE>RGB</CODE>'.
See <A HREF="../color_basics/#channels" >Color Channels</A> for more
information.  </P>

You can limit the negation to just one channel, say the green color channel.
This may not seem very useful, but at times it is vitality important.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -channel green  -negate  negate_green.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="negate_green.png"
     ><IMG SRC="negate_green.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The "<CODE><A HREF="../option_link.cgi?negate" >-negate</A></CODE>" operator
is actually its own inverse.  Doing two negations with the same  "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting cancels each
other out.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick negate_green.png  -channel green  -negate  negate_restore.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="negate_green.png"
     ><IMG SRC="negate_green.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="negate_restore.png"
     ><IMG SRC="negate_restore.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Negation is extremely common in image processing, particularly when dealing
with gray-scale images as a step before or after other processing options.  As
such I recommend you play with it and keep it in mind whenever you are doing
anything, as working with negated images can solve some otherwise difficult
problems. </P>


<A NAME="level"></A>
<H3>Direct Level Adjustments</H3>

The "<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>" operator is
the more general level adjustment operator.  You basically give it two values
a 'black_point' and a 'white_point', as well as an optional third value (gamma
adjustment), which I will look at <A HREF="#level_gamma" >later</A>. </P>

What it does is map any color values in the image that is equal to or less
than the 'black_point', and make them black (or a 0 value).  Similarly, any
color values that are equal to or brighter that the 'white_point' will make
them white (or a Maximum value).  The colors in between these two points
are then 'stretched' linearly to fill the complete range of values. </P>

The effect of this is to improve the contrast, enhancing the colors within an
image.  For example here is a 25% contrast enhancement of our test image,
using the same values as shown by the graph. </P>

As you commonly adjust both the black and white points by the same amount from
the <CODE>0%</CODE> and <CODE>100%</CODE> amounts, you can just specify the
'black_point' only. The white point will be adjusted by the same amount
inward.

<!-- <CODE EXECUTE>
  im_graph '-level 25%' gp_level.gif
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -level 25%,75%  test_level.png
  magick rose:    -level 25%      rose_level.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=middle>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <IMG SRC="gp_level.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=middle>
  <A HREF="test_level.png"
     ><IMG SRC="test_level.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="rose_level.gif"
     ><IMG SRC="rose_level.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Note that <CODE>25%</CODE> is a huge contrast enhancement for any image, but
it clearly shows what it does. </P>

You don't have to change both the 'black' and 'white' points.  Instead it is
quite permissible to just adjust only one end of the color range. For example
we can make a very light, or a very dark rose image.

<!-- <CODE EXECUTE>
  im_graph '-level 0%,75%'   gp_level_lt.gif
  im_graph '-level 25%,100%' gp_level_dk.gif
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -level 0,75%     rose_level_light.gif
  magick rose: -level 25%,100%  rose_level_dark.gif
</CODE></PRE></TD></TR></TABLE>
  <IMG SRC="gp_level_lt.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rose_level_light.gif"
     ><IMG SRC="rose_level_light.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

<IMG SRC="../img_www/space.gif" WIDTH=60 HEIGHT=20 ALIGN=middle ALT="   ">

  <IMG SRC="gp_level_dk.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rose_level_dark.gif"
     ><IMG SRC="rose_level_dark.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

However I again warn you that the colors outside the given range are 'clipped'
or 'burned', and as such will no longer be available for later image
processing.  This is the biggest problem with using a "<CODE><A
HREF="../option_link.cgi?level" >-level</A></CODE>" operator. </P>

<!-- <CODE EXECUTE>
  im_graph '-level -25%' gp_level-.gif
</CODE> -->
<IMG SRC="gp_level-.gif" ALIGN=right HSPACE=5 BORDER=0 ALT="[IM Graph]">

By using a negative value you can do some rough de-contrasting of an image.
</P>

What this means is that rather than providing a color value for the values to
be mapped to 'black' and 'white' and thus stretching out the colors in
between, you instead compress the color values so as to map the imaginary
negative color to black or white.  The result is a general graying of the
image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=*>
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -level -25%  rose_decontrast.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_decontrast.gif"
     ><IMG SRC="rose_decontrast.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<BR CLEAR=all>

This method of de-contrasting an image however is very inaccurate and not
recommended, unless you have an IM older than version 6.4.2 where you don't
have access to the new <A HREF="#level_plus" >Reversed Level Operator</A>.

<!-- <CODE EXECUTE>
  im_graph '-level 100%,0' gp_level_neg.gif
</CODE> -->
<IMG SRC="gp_level_neg.gif" ALIGN=right HSPACE=5 BORDER=0 ALT="[IM Graph]">
</P>

You can use the "<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>"
operator to negate an image (as previously shown above, just by swapping the
'black' and 'white' point values given, using
"<CODE>-level&nbsp;100%,0</CODE>".

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=*>
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -level 100%,0  rose_level_neg.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_level_neg.gif"
     ><IMG SRC="rose_level_neg.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<BR CLEAR=all>

<!-- <CODE EXECUTE>
  im_graph '-level 50%,50%' gp_level_thres.gif
</CODE> -->
<IMG SRC="gp_level_thres.gif" ALIGN=right HSPACE=5 BORDER=0 ALT="[IM Graph]">

Or by setting them to the same value, you can effectively call all the color
values in the image to be thresholded.  Using "<CODE><A
HREF="../option_link.cgi?level" >-level</A></CODE>" to threshold an image is
exactly the same as if you used a <A HREF="../quantize/#threshold" >Threshold
Operator</A></CODE> with that value.  The mapping graph shown right, shows
the results of a "<CODE>-level&nbsp;50%,50%</CODE>" operation, and its effect
on a grayscale gradient. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=*>
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -level 50%,50%  rose_level_thres.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_level_thres.gif"
     ><IMG SRC="rose_level_thres.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<BR CLEAR=all>

Note that unlike "<CODE><A HREF="../option_link.cgi?threshold"
>-threshold</A></CODE>" the image is not automatically converted to
a grayscale image when used with the default "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting. </P>

The general nature of using level to linearly modify an image, makes the
"<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>" operator good
for general gray-scale image modifications, and mask adjustments.  Add the
fact that you can modify individual channels (using the "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting) as opposed to
the whole image, makes it one of the best color modification operators
available to IM users. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Note you can also use the <A HREF="../transform/#evaluate" >Evaluate and
  Function Operators</A> for a more direct mathematical modification of the
  color values, to achieve the same results for -level both + and - forms).
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Be warned that the "<CODE><A HREF="../option_link.cgi?level"
  >-level</A></CODE>" operator treats the transparency channel as 'matte'
  values.  As such 100% is fully transparent and 0% is opaque.  Please take
  this into account when using "<CODE><A HREF="../option_link.cgi?level"
  >-level</A></CODE>" with a blurred shape image.  This is most typically done
  after blurring an 'shape' image, to expand and stretch the results.  For
  examples of this see <A HREF="../thumbnails/#soft_edges" >Soft Edges</A>,
  and <A HREF="../blur/#shadow_outline" >Shadow Outlines</A>.
</I></FONT></TD></TR></TABLE></P>


<A NAME="level_plus"></A>
<H3>Reversed Level Adjustments
<FONT SIZE=-1> -- Decontrasting Images</FONT></H3>

As of IM version 6.4.2 the <A HREF="#level" >Level Operator</A> was expanded
to provide a 'reversed' form "<CODE><A HREF="../option_link.cgi?level"
>+level</A></CODE>" (note the 'plus'). Alternatively you can use the original
"<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>" form of the
operator but add a '<CODE>!</CODE>' to the level argument given (for older API
interfaces). </P>

The arguments for this variant is exactly the same, but instead of stretching
the values so as to map the 'black_point' and 'white_point' to 'black' and
'white', it maps 'black' and 'white' to the given points. In other words
"<CODE><A HREF="../option_link.cgi?level" >+level</A></CODE>" is the exact
reverse of "<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>". </P>

For example here we map 'black' to a 25% gray, and white to 75% gray,
effectively de-contrasting the image in a very exact way, using the two
methods of specifying the 'reversed' form.

<!-- <CODE EXECUTE>
  im_graph '+level 25%' gp_level+.gif
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png   +level 25%    test_level_plus.png
  magick rose:     -level 25%\!  rose_level_plus.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=middle>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <IMG SRC="gp_level+.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=middle>
  <A HREF="test_level_plus.png"
     ><IMG SRC="test_level_plus.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="rose_level_plus.gif"
     ><IMG SRC="rose_level_plus.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

If you magick compare the above "<CODE>+level&nbsp;25%</CODE>" operation with the use
of an a negative de-contrasting, "<CODE>-level&nbsp;-25%</CODE>" operator we
showed previously, you will see that are not the same. The 'plus' version
produces a much stronger de-contrasted image (it is greyer), but does so by
mapping to the exact values you give the operator, and not the 'imaginary'
values the 'minus' form used. This exact value usage is important, and one of
the reasons why the 'plus' form of the operator was added. </P>

Of course a '<CODE>25%</CODE>' is again a very large value, and it is not
recommended for use with typical image work. </P>

Note that the "<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>"
and "<CODE><A HREF="../option_link.cgi?level" >+level</A></CODE>", are in
actual fact the exact reverse of each other when given the same argument.
That is, one maps values to the range extremes, while the other maps from the
range extremes. </P>

For example here we compress the colors of the test image using "<CODE><A
HREF="../option_link.cgi?level" >+level</A></CODE>", then decompress them
again using "<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>", so
as to restore the image close to its original appearance.

<!-- <CODE EXECUTE>
  im_graph '+level 20% -level 20%' gp_level_undo.gif
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  +level 20%  -level 20%  test_level_undo.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <IMG SRC="gp_level_undo.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="test_level_undo.png"
     ><IMG SRC="test_level_undo.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The two images appear to be very very similar, and as I am using a high <A
HREF="../basics/#quality" >quality</A> 'Q16' version of IM, you will be hard
pressed to notice any difference at all.  However the values may not be
exactly the same, as you have effectively compressed the color values of the
image to a smaller range of integers, and then restored them again. In extreme
cases this can result in <A HREF="../basics/#quantum_effects" >Quantum
Rounding Effects</A>.  </P>

Doing these two operations in the opposite order (stretch, then compress the
color values) will produce <A HREF="../basics/#quantum_effects" >Quantum
Clipping Effects</A>. </P>

One other useful aspect of the "<CODE><A HREF="../option_link.cgi?level"
>+level</A></CODE>" operator is that you can completely compress all the color
values in an image to the same gray-scale level.

<!-- <CODE EXECUTE>
  im_graph '+level 30%,30%' gp_level_const.gif
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  +level 30%,30%  test_level_const.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <IMG SRC="gp_level_const.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="test_level_const.png"
     ><IMG SRC="test_level_const.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

By specifying levels according to the values of specific colors for each
individual channel, you can effectively magick a greyscale gradient into
a specific color gradient.  However this is rather difficult to calculate and
do.  As such a "<CODE><A HREF="../option_link.cgi?level-colors"
>-level-colors</A></CODE>" operator has also been provided that will let you
specify the black and white points in terms of specific colors rather than
'level' values.  See <A HREF="#level-colors" >Level by Color</A> below. </P>


<A NAME="level_gamma"></A>
<H3>Level Gamma Adjustments</H3>

Both the above "<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>"
variants also allow you to use a third setting. The 'gamma' adjustment value.
By default this is set to a value of <CODE>1.0</CODE>', which does not do any
sort of mid-tone adjustment of the resulting image, producing a pure linear
mapping of the values from the old image to the new image. </P>

However by making this value larger, you will curve the resulting line so as
to brighten the image, while shrinking that value will darken the image.  </P>

For example here I use just the 'gamma' setting to brighten and darken just
the mid-tones of the image.

<!-- <CODE EXECUTE>
  im_graph '-level 0%,100%,2.0' gp_level_glt.gif
  im_graph '-level 0%,100%,0.5' gp_level_gdk.gif
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -level 0%,100%,2.0   rose_level_gamma_light.gif
  magick rose: -level 0%,100%,0.5   rose_level_gamma_dark.gif
</CODE></PRE></TD></TR></TABLE>
  <IMG SRC="gp_level_glt.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rose_level_gamma_light.gif"
     ><IMG SRC="rose_level_gamma_light.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

<IMG SRC="../img_www/space.gif" WIDTH=60 HEIGHT=20 ALIGN=middle ALT="   ">

  <IMG SRC="gp_level_gdk.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rose_level_gamma_dark.gif"
     ><IMG SRC="rose_level_gamma_dark.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Values generally range from 10 for a blinding bright image, to .2 for very
dark image.  As mentioned a value of <CODE>1.0</CODE> will make no 'gamma'
changes to the image. However the special value of '<CODE>2.0</CODE>' (see
above) can be used to get the square root of the images normalized color. </P>

Both versions of the "<CODE><A HREF="../option_link.cgi?level"
>-level</A></CODE>" operate handles 'gamma' in the same way.  This means you can
combine the level adjustment of the 'black' and 'white' ends with a
non-linear 'gamma' adjustment.  You can also only adjust a single channel of
an image.  For example, here we give an image a subtle tint at the black end
of just the blue channel, while using gamma to preserve the mid-tone color
levels of the image.

<!-- <CODE EXECUTE>
  im_graph '+level 25%,100%,.6'  gp_level_blue.gif
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -channel B +level 25%,100%,.6 test_blue_tint.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <IMG SRC="gp_level_blue.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="test_blue_tint.png"
     ><IMG SRC="test_blue_tint.png"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This specific example could be used to tint a weather satellite photo, where
only the sea is pure black, while land is more grey. Other alternatives to
this blue channel adjustment are given below in <A HREF="#non-linear" >DIY
Mathematical Non-linear Adjustments</A>. </P>


<A NAME="gamma"></A>
<H3>Gamma Operation Adjustments</H3>

The "<CODE><A HREF="../option_link.cgi?gamma" >-gamma</A></CODE>" operator is
also provided, and has exactly the same effect as the 'gamma' setting in the
"<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>" operator.
However it will let you adjust the 'gamma' adjustment level for each
individual channel as well. </P>

Its real use is in adjusting the 'gamma' function of an image before
performing linear operations on them.  For more details see <A
HREF="../color_basics/#perception" >Human Color Perception and Gamma
Correction</A>. </P>

We can also use this function to brighten the image differently for each
individual RGB channel.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -gamma 0.8,1.3,1.0  gamma_channel.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gamma_channel.gif"
     ><IMG SRC="gamma_channel.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see this can be used to do some subtle tinting and color
adjustments to an image, or correct images with contain too much of a specific
color. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  For reasons about why you should used this function see <A
  HREF="../color_basics/#gamma" >Gamma Correction</A>. </P>
</I></FONT></TD></TR></TABLE></P>

This function actually equivelent to the <A HREF="../transform/#evaluate_pow"
>Evaluate POW function</A> but with the argument inverted. As such
a "<CODE>-evaluate POW 2.2</CODE>" will actually do a "<CODE>-gamma
0.45455</CODE>" (0.45455 is equal it 1/2.2) operation, which is the reverse of
a "<CODE>-gamma 2.2</CODE>". </P>

<BR>

One of the less obvious uses of "<CODE><A HREF="../option_link.cgi?gamma"
>-gamma</A></CODE>" is to zero out specific image channels (see <A
HREF="../color_basics/#zeroing" >Zeroing Color Channels</A>).  Or color an
image completely 'black', 'white' or some other primary color (see <A
HREF="../canvas/#color_misc" >Primary Colored Canvases</A>).  </P>


<A NAME="level-colors"></A>
<H3>Level Adjustment by Color</H3>

The "<CODE><A HREF="../option_link.cgi?level-colors"
>-level-colors</A></CODE>" operator was added to IM v6.2.4-1.  Essentially, it
is exactly the same as the <A HREF="#level" >Level Operator</A> we discussed
above, but with the value for each channel specified as a color value. </P>

That is, the "<CODE><A HREF="../option_link.cgi?level-colors"
>-level-colors</A></CODE>" option will map the given colors to 'black' and
'white' and stretching all the other colors between them linearly.  This
effectively removes the range of colors given from the image. </P>

And while this works, it is not particularly useful, as it is prone to fail
for colors that have common values in some channel.  For example, the colors
'<CODE>DodgerBlue</CODE>' and '<CODE>White</CODE>' have the same color values
in the blue channel. As such, "<CODE>-level-colors DodgerBlue,White</CODE>"
may not always magick those colors to black and white. </P>

The better technique in that case is to extract a greyscale image of the
channel with the highest differences (such as red) and level or normalize that
channel. </P>

WARNING: watch out for 'transparent' colors. </P>

<BR>

The plus form of the operator "<CODE><A HREF="../option_link.cgi?level-colors"
>+level-colors</A></CODE>" on the other hand is extremely useful as it will
map the 'black' and 'white' color to the given values compressing all the
other colors linearly to fit the two colors you give.  </P>

For example lets map '<CODE>black</CODE>' and '<CODE>white</CODE>' to
'<CODE>green</CODE>', and '<CODE>gold</CODE>'...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  +level-colors green,gold   levelc_grn-gold.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="levelc_grn-gold.png"
     ><IMG SRC="levelc_grn-gold.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see the grayscale gradient is remapped into a gradient bound by
the colors given, and although colors outside a gray-scale range are also
modified, they will also follow the basic style of the color range
specified.  This makes the  "<CODE><A HREF="../option_link.cgi?level-colors"
>+level-colors</A></CODE>" operator an extremely useful one, especially when
mapping grayscale images. </P>

If you only supply one colorname but include a comma, the missing color will
default either to '<CODE>black</CODE>' or '<CODE>white</CODE>' as appropriate.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  +level-colors ,DodgerBlue   levelc_dodger.png
  magick test.png  +level-colors ,Gold         levelc_gold.png
  magick test.png  +level-colors ,Lime         levelc_lime.png
  magick test.png  +level-colors ,Red          levelc_red.png

  magick test.png  +level-colors Navy,         levelc_navy.png
  magick test.png  +level-colors DarkGreen,    levelc_darkgreen.png
  magick test.png  +level-colors Firebrick,    levelc_firebrick.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="levelc_dodger.png"
     ><IMG SRC="levelc_dodger.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="levelc_gold.png"
     ><IMG SRC="levelc_gold.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="levelc_lime.png"
     ><IMG SRC="levelc_lime.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="levelc_red.png"
     ><IMG SRC="levelc_red.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="levelc_navy.png"
     ><IMG SRC="levelc_navy.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="levelc_darkgreen.png"
     ><IMG SRC="levelc_darkgreen.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="levelc_firebrick.png"
     ><IMG SRC="levelc_firebrick.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This makes it easy to magick grayscale images into a gradient for any color
you like.  For example here I remap a black and white gradient to a red and
white gradient, (note the ',' in the argument)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick cow.gif   +level-colors red,   cow_red.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/cow.gif"
     ><IMG SRC="../images/cow.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="cow_red.gif"
     ><IMG SRC="cow_red.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This didn't just replace 'black' with 'red' but also re-mapped all the
anti-aliased gray colors to an appropriate mix of 'red' and 'white', producing
a very smooth result.

  <A HREF="../color_basics/cow_replace_red.gif"
     ><IMG SRC="../color_basics/cow_replace_red.gif"   WIDTH=100 HEIGHT=100
           ALIGN=right VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</P>

If I had just performed a simple <A HREF="../color_basics/#replace" >Direct
Color Replacement</A> converting pure black colors to red, I would end up with
the horrible image (showen right). See <A HREF="../color_basics/#fuzz" >Fuzz
Factor</A> for the example used to generate that image. </P>

Of course if you want one of the colors to be made transparent instead you are
better off using the <A HREF="../masking/#alpha_shape" >-alpha Shape</A>
operator instead, as this requires you to transfer the gradient into the alpha
channel. </P>

<BR>

If you only specify a single color, without any 'comma' separator, that color
will be used for both black and white points. That means all the colors in the
image will be reset to that one color.  (according to the current "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting limitations).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  +level-colors dodgerblue  levelc_blue.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="levelc_blue.png"
     ><IMG SRC="levelc_blue.png"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is an identical result to using "<CODE>-fill DodgerBlue -colorize
100%</CODE>" to <A HREF="../colorize" >Colorize Images</A> (see below). </P>

If you want to set the images transparency setting as well you will need to
set "<CODE><A HREF="../option_link.cgi?channel" >-channel</A></CODE>" to
include the transparency channel, OR set the <A HREF="../basics/#alpha" >Alpha
Channel</A> to fully-opaque, using either "<CODE>-alpha opaque</CODE>" or
"<CODE>-alpha off</CODE>".

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -channel ALL +level-colors dodgerblue levelc_blue2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="levelc_blue2.png"
     ><IMG SRC="levelc_blue2.png"     WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Also see <A HREF="../canvas/#blank" >Blanking Existing Images</A>. </P>

Here are a few more examples of using this to adjust or 'tint' a colorful
image, rather than a gray-scale image.


<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: +level-colors             navy,lemonchiffon  levelc_faded.gif
  magick rose: +level-colors        firebrick,yellow        levelc_fire.gif
  magick rose: +level-colors 'rgb(102,75,25)',lemonchiffon  levelc_tan.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="levelc_faded.gif"
     ><IMG SRC="levelc_faded.gif"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="levelc_fire.gif"
     ><IMG SRC="levelc_fire.gif"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="levelc_tan.gif"
     ><IMG SRC="levelc_tan.gif"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In summary the "<CODE><A HREF="../option_link.cgi?level-colors"
>+level-colors</A></CODE>" is a gradient color replacement, a linear tinting
operator, and can also completely reset colors.  </P>


<A NAME="sigmoidal"></A>
<A NAME="sigmoidal-contrast"></A>
<H3>Sigmoidal Non-linearity Contrast</H3>

From a PDF paper on '<I><A
HREF="http://www.cs.dartmouth.edu/farid/downloads/tutorials/fip.pdf"
>Fundamentals of Image Processing</A></I>' (page 44) they present an
alternative to using a linear contrast control (level), with one using gamma
correction known as '<I>sigmoidal non-linearity contrast control</I>'. </P>

The result is a non-linear, smooth contrast change (a 'Sigmoidal Function' in
mathematical terms) over the whole color range, preserving the white and black
colors, much better for photo color adjustments.  </P>

The exact formula from the paper is very complex, and even has a mistake, but
essentially requires with two adjustment values.  A threshold level for the
contrast function to center on (typically centered at '<CODE>50%</CODE>'), and
a contrast factor ('<CODE>10</CODE>' being very high, and '<CODE>0.5</CODE>'
very low).  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
    For those interested, the corrected formula for the 'sigmoidal
    non-linearity contrast control' is...

    <DIV ALIGN=center><CODE>
        ( 1/(1+exp(<B>&beta;</B>*(<B>&alpha;</B>-u)))
             - 1/(1+exp(<B>&beta;</B>*(<B>&alpha;</B>))
        ) / ( 1/(1+exp(<B>&beta;</B>*(<B>&alpha;</B>-1)))
               - 1/(1+exp(<B>&beta;</B>*<B>&alpha;</B>)) )
    </CODE></DIV>

    Where <B>&alpha;</B> is the threshold level, and <B>&beta;</B> the contrast
    factor to be applied. </P>

    Here is an alternate version of the formula using intermedite variables.

    <DIV ALIGN=center><CODE>
       x = exp(<B>&beta;</B> * (<B>&alpha;</B> - u))
       y = exp(<B>&beta;</B> + 1
       result (x / y + 1) * (1 / (x + 1) - 1 / y)
    </CODE></DIV>

    The formula is actually very simple exponential curve, with the bulk of
    the above formula is designed to ensure that 0 remains zero and 1 remains
    one. That is, the graph always goes though the points 0,0 and 1,1.  And the
    highest gradient of change is at the given threshold.
</I></FONT></TD></TR></TABLE></P>

Here for example is a "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>"
implementation of the above formula, resulting from a very high contrast value
of '<CODE>10</CODE>' and a '<CODE>50%</CODE>' threshold value.  These values
have been rolled into the floating point constants, to speed up the function.

<!--
  gnuplot
    sig(x,a,b) = (1/(1+exp(b*(a-x))) - 1/(1+exp(b*a))) /\
                       (1/(1+exp(b*(a-1))) - 1/(1+exp(b*a)))
    plot [0:1] sig(x,0.5,10)

  NOTE:  exp(a+b) <=> exp(a)*exp(b)

  Example
       a=0.5;  b=10;
  offset:
       print  1/(1+exp(b*a))
       0.00669285092428486
  Multiplier:
       print  1/( 1/(1+exp(b*(a-1))) - 1/(1+exp(b*a)) )
       1.01356730981261

<CODE EXECUTE>
  im_graph "-fx (1/(1+exp(10*(.5-u)))-0.0067)*1.0136" gp_sigmoidal.gif
</CODE> -->

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -fx '(1/(1+exp(10*(.5-u)))-0.006693)*1.013567' \
              sigmoidal.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <IMG SRC="gp_sigmoidal.gif" ALIGN=middle HSPACE=5 BORDER=0 ALT="[IM Graph]">
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="sigmoidal.png"
     ><IMG SRC="sigmoidal.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Lucky for us IM v6.2.1 had this complex function built in as a new operator
"<CODE><A HREF="../option_link.cgi?sigmoidal-contrast"
>-sigmoidal-contrast</A></CODE>", allowing a much simpler application.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    magick test.png  -sigmoidal-contrast 10,50% test_sigmoidal.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="test_sigmoidal.png"
      ><IMG SRC="test_sigmoidal.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

As a bonus IM also provides the inverse, a 'sigmoidal contrast reduction'
function (as plus '<CODE>+</CODE>' form of the operator), which if applied
with the same arguments restores our original image (almost exactly).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    magick test_sigmoidal.png +sigmoidal-contrast 10,50% \
                                             test_sigmoidal_inv.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="test_sigmoidal_inv.png"
      ><IMG SRC="test_sigmoidal_inv.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And here we apply it to the rose image...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    magick rose: -sigmoidal-contrast 10,50%  rose_sigmoidal.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="rose_sigmoidal.gif"
      ><IMG SRC="rose_sigmoidal.gif"     WIDTH=70 HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

I did say '<CODE>10</CODE>' was a very heavy contrast factor. In fact anything
higher than this value can be considered to be more like a fuzzy threshold
operation, rather than a contrast enhancement. </P>

For a practical example of using this operator see the advanced <A
HREF="../advanced/#gel_effects" >"Gel" Effects Example</A>, where it is used
to sharpen the bright area being added to a shaped area color. </P>

<A NAME="contrast_misc"></A>
<H3>Miscellaneous Contrast Operators</H3>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>
<PRE>
   -contrast  and   +contrast
         Rather useless minor contrast adjustment operator

<A NAME="threshold"></A>-threshold
   Threshold the image, any value less than or equal to the given value is
   set to 0 and anything greater is set to the maximum value.

   Note that like level, this is a channel operator, but if the default
   'channel setting' is used only the gray-scale intensity of the image is
   thresholded producing a black and white image.

   magick rose: -threshold 45%  x:

   You can force normal channel behaviour, where each channel is thresholded
   individually buy using "-channel All"

   magick rose: -channel All -threshold 45%  x:

<A NAME="black-threshold"></A>-black-threshold
<A NAME="white-threshold"></A>-white-threshold
   This is like -threshold except that only one side of the threshold value is
   actually modified.

   For example, here anything that is darker than 30% is set to black.

   magick rose: -black-threshold 30%  x:
   magick rose: -white-threshold 50%  x:

   These operators however do not seem to be channel effected, so may only be
   suitable for gray-scale images!

</PRE>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="histogram"></A>
<H2>Adjustments Using Histogram Modification</h2>

<I>This section was a joint effort by <A
HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred Weinhaus</A> and Anthony
Thyssen. </I></P>

What is a histogram? </P>

A histogram is a special type of graph.  It simply sorts the color levels of
the pixels in an image into a fixed number of 'bins' each of which span some
small range of values.  As such each bin contains a count of the number of
color levels (pixel values) in the image that fall into that range. </P>

The result is a representation of how the color values that make up an image
are distributed, from black at the left, to white at at the right. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%" ALIGn=center>
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

The histogram can be generated for each channel separately or as a global
histogram which looks at values from all the channels combined.  The result is
often displayed as an image of a bar chart. In IM, this is done using the
special <A HREF="../files/#histogram">Histogram:</A> output format.  For
example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: histogram:histogram.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="histogram.gif"
     ><IMG SRC="histogram.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

But it can also be displayed as a line graph where the line connects the
tops of the bars. This will be demonstrated later in the discussion below. </P>

See <A HREF="../files/#histogram">Histogram:</A> for more details of this
special output format.  This is recommended reading at this point as it is the
best way to extract histogram information about images using IM. </P>

A histogram chart's actual height has little actual meaning, since it is
usually scaled so that the highest peak touches the top of the image.  As such
the height of each individual 'bar' is not relevant.  What is much more
important is the distribution of the histogram over the whole range, and how
the relative heights relate to each other over the whole of the chart. </P>

When looking at a histogram you would consider the following factors.
<UL>
<LI>Does the histogram form one wide band of values?  This means that the
    image makes wide use of the colorspace and thus has good contrast. </LI>
<LI>Or is it all in a tight group in the middle or at one end of the range?
    This means the image has a low contrast, making it look 'fogged' or
    'grayed', or perhaps overly light or dark.  </LI>
<LI>Does it form two or more peaks? As a result of highly different areas or
    regions in the image. </LI>
<LI>Where are most of the pixels?  At the left, meaning the image is very
    dark.  Or at the right, meaning it is very bright. Or spread out around
    the middle? </LI>
<LI>Are there regular gaps or empty spaces between individual bars? This
    usually means either the image has very few pixels, so it could not
    completely fill out the whole histogram, or the image was color reduced,
    or modified in some way, so as to produce those gaps. </LI>
</UL></P>

Essentially a histogram is a simpler representation of an image, and as such it
is much easier to change or adjust an image in terms of its histogram. </P>

Almost any mathematical color transformation that one applies to an image will
normally cause not only the image to be modified, but its histogram as well.
These include linear operations such as the <A HREF="#level" >Level
Operator</A> or non-linear operations such as the <A HREF="#gamma" >Gamma
Operator</A>, (see above).  The mapping graphs we saw above represent how the
graylevels in an image and thus how the image's histogram is to be
transformed.  </P>

For example, lets make a low contrast image to demonstrate.  However, the
final result is that it not only modifies the image, but does so by modifying
the image's histogram (by compressing it).

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick chinese_chess.jpg -contrast -contrast -contrast -contrast \
          chinese_contrast.png

  magick chinese_chess.jpg     histogram:chinese_chess_hist.gif
  magick chinese_contrast.png  histogram:chinese_contrast_hist.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/chinese_chess.jpg"
     ><IMG SRC="../img_photos/chinese_chess.jpg"   WIDTH=256 HEIGHT=196
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="chinese_contrast.png"
     ><IMG SRC="chinese_contrast.png"   WIDTH=256 HEIGHT=196
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="chinese_chess_hist.gif"
     ><IMG SRC="chinese_chess_hist.gif"   WIDTH=256 HEIGHT=200
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="chinese_contrast_hist.gif"
     ><IMG SRC="chinese_contrast_hist.gif"   WIDTH=256 HEIGHT=200
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In the above case, "<CODE>-contrast</CODE>, is a simple <A HREF="#level"
>Level</A> type operator that adds just a little more contrast to the image.
the result of this is that the histogram itself is spread out more, causing it
to cover the whole of the possible color range better. </P>

You can also see from the histograms, before and after, that the colors will
also end up with gaps and holes between the 'bins', due to the way in which
the stretching was performed.  Specifically it creates a 'histogram' with all
the colors being places into 'bin'. These 'binned' colors are then modified as
a whole, causing the image colors to be grouped together.  It is not
a particularly good way of handling image colors. </P>

This operator however works blindly, without any knowledge of the image
content or color distribution. It thus cannot be done without some user
control, as the operator could very easily make any image it is applied to,
worse, rather than better. </P>

In this section we will look at image processing operators that examine the
image's histogram as part of its decision making process.  It then modifies
images using the result this study, so as to enhance some quality of the image
color distribution.  As these operators make use of actual information coming
from the image being processed, they can often be used more globally over many
images with much checking by the user. </P>

Operators of this type include automatic linear 'level' type operators such as
"<CODE><A HREF="../option_link.cgi?normalize" >-normalize</A></CODE>",
"<CODE><A HREF="../option_link.cgi?contrast-stretch"
>-contrast-stretch</A></CODE>", and "<CODE><A
HREF="../option_link.cgi?linear-stretch" >-linear-stretch</A></CODE>", but
also non-linear ones such as "<CODE><A HREF="../option_link.cgi?equalize"
>-equalize</A></CODE>", and others that may eventually be included into
ImageMagick such as <A HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred
Weinhaus's</A> script, "<A
HREF="http://www.fmwconcepts.com/imagemagick/redist/" >redist</A></CODE>".
</P>


<A NAME="stretching"></A>
<H3>Histogram Stretching</H3>

The simplest techniques, like the previous example simply stretch the
histogram of the image outward to improve the color range.  However instead of
just blindly picking the <I>black-point</I> and <I>white-point</I> for <A
HREF="#level" >Level</A> operation, they select points based on the images
histogram. </P>

Basically they count up the number of color values in each histogram bin, from
each of the two ends, inward until they reach some threshold.  These points
will then be used as the <I>black-point</I> and <I>white-point</I> for the
histogram (level) stretching.  </P>

<I>Diagram needed</I></P>

Basically the histogram counts provide the graylevel values that the stretch
will force to black and white. This means that all pixels in the image that
fall within the range of bins from pure black to the selected
<I>black-point</I> bin's corresponding graylevel will end up pure black.  </P>

Likewise those pixels in the image that fall within the range of bins from
from pure white to the <I>white-point</I> bin's corresponding graylevel will
end up pure white. </P>

The pixels that are outside these points however will have been stretched
outside the possible color range of values, and as a result they will be simply
be set to the range limits.  That is these pixels are 'clipped' 'burned-in' as
they are converted to the extreme of pure black or pure white color values.
</P>

As a result if the 'threshold' limits for selecting the <I>black-point</I> and
<I>white-point</I> is set too high, you will get lots of black and white areas
in the image, with the resulting histogram having large counts (tall bars) at
the extreme end bins.  </P>

<I>Example of severe burn-in  --  Chinese Chess Image? </I>

<B>Summary of 'stretch' operators</B>... </P>

-contrast-stretch, and -linear-stretch all generate a histogram (using 1024
bins) to determine the color position to stretch. as such it is not 'exact'.
The other difference is how 'zero' is handled, and that -linear-stretch
actually does a -level operation to do the stretch, while -contrast-stretch
uses histogram bin values for color replacement stretching (which introduces a
1024 quantum rounding effect. -normalize uses -contrast-stretch internally.
</P>

A mathematically perfect normalization stretching operator is -auto-level.
While a perfect 'white-point only' or 'black-point only' version is posible
it has not been implemented at this time. </P>

<A NAME="auto-level"></A>
<H3>Auto-Level - perfect mathematical normalization</H3>

The "<CODE><A HREF="../option_link.cgi?auto-level" >-auto-level</A></CODE>"
finds the largest and smalled values in the image to use to stretch the image
to the full Quantum Range. At no time will values become 'clipped' or 'burned'
as a result of the histogram being stretch beyond the value range. </P>

The "<CODE><A HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting
will determine if all channels are stretch equally 'in sync' (using the
maximum and minimum over all channels) or separatally (each individual channel
as a separate entity). </P>

At this time the hidden color of fully-transparent pixels, are also used in
determining the levels, which can cause some problems when transparency is
involved. This is regarded as a bug. </P>

<PRE>FUTURE: We actually need three modes of operation...
  synced color channels with 'alpha' (and 'read') masking.
  synced channels (as defined by channel)       (current default)
  individual separate channels   (currently if -channel is set by user)
</PRE>

It is a pure-mathematical histogram stretch just as the manual <A
HREF="#level" >Level Operator</A> is.  That is the minimum will be adjusted to
zero and maximum to Quantum range, and a linear equation is used to adjust all
other values in the image. </P>

It does not use 'histogram bins' or any other 'grouping of values' that other
methods may use for either determining the levels to be used, or other
histogram adjustments.</P>


<A NAME="normalize"></A>
<H3>Normalize</H3>

The "<CODE><A HREF="../option_link.cgi?normalize" >-normalize</A></CODE>"
operator is the simplest of these three operators.  It simply expands the
grayscale histogram so that it occupies the full dynamic range of gray values,
while clipping or burning 2% on the low (black) end and 1% on the on the high
(white) end of the histogram. That is, 2% of the darkest grays in the image
will become black and 1% of the lightest grays will become white. </P>

This is not a large loss in most images, and the overall result is that the
contrast (intensity range) of the image will be automatically maximized. </P>

<I>An idealized diagram is needed here!</I></P>

<I>Example using chinese chess?</I></P>

Here we create a gray-scale gradient, and expand it to the full black and white
range.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 150x100 gradient:gray70-gray30 gray_range.jpg
  magick gray_range.jpg  -normalize  normalize_gray.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gray_range.jpg"
     ><IMG SRC="gray_range.jpg"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="normalize_gray.jpg"
     ><IMG SRC="normalize_gray.jpg"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  For practical reasons to do with JPEG color inaccuracies (see <A
  HREF="../formats/#jpg_color" >JPEG Color Distortion</A> for more details)
  and scanned image noise, "<CODE><A HREF="../option_link.cgi?normalize"
  >-normalize</A></CODE>" does not expand the very brightest and darkest
  colors, but a little beyond those values.  That is, it is equivalent to a
  "<CODE><A HREF="../option_link.cgi?contrast-stretch"
  >-contrast-stretch</A></CODE>" with a value of '<CODE>2%,99%</CODE>' (see
  below). </P>

  This means if highest and lowest color values are very close together,
  "<CODE><A HREF="../option_link.cgi?normalize" >-normalize</A></CODE>" will
  fail, an no action will be taken. </P>

  If you really want to expand the exact brightest and darkest color values to
  their extremes use "<CODE><A HREF="../option_link.cgi?auto-level"
  >-auto-level</A></CODE>" instead.

</I></FONT></TD></TR></TABLE></P>

Up until IM version 6.2.5-5,  "<CODE><A HREF="../option_link.cgi?normalize"
>-normalize</A></CODE>" worked purely as a grayscale operator. That is, each of
the red, green, blue, and alpha channels were expanded independently of each
other according to the "<CODE><A HREF="../option_link.cgi?channel"
>-channel</A></CODE>" setting.

As of IM version 6.2.5-5, if only the default "<CODE><A
HREF="../option_link.cgi?channel" >+channel</A></CODE>"  setting is given,
then "<CODE><A HREF="../option_link.cgi?normalize" >-normalize</A></CODE>"
will tie together all the color channels, and normalizes them all by the same
amount.  This ensures that pixel colors within the image are not shifted.
However, it also means that you may not get a pure white or black color pixel.
</P>

For example here we added some extra colors (a blue to navy gradient) to our
normalization test image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 100x100 gradient:gray70-gray30 \
          -size  50x100 gradient:blue-navy  +append  color_range.jpg
  magick color_range.jpg -normalize  normalize.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="color_range.jpg"
     ><IMG SRC="color_range.jpg"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="normalize.jpg"
     ><IMG SRC="normalize.jpg"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!-- <CODE EXECUTE ASSERT>
  [ "`magick identify -format '%[fx:saturation]' normalize.jpg`" != 0 ] && echo >&2 \
    "ASSERTION FAILURE: Normalize channels were not tied together."
</CODE> -->

As you can see from the last example, for color images "<CODE><A
HREF="../option_link.cgi?normalize" >-normalize</A></CODE>" maximized all the
channels together so one channel has a zero value, and another channel has a
maximum value.  That is, no black pixels were generated, as all the added blue
colors already contain 'zero' values in the 'red' and 'green' channels.  As
such the lower bounds of the image did not expand. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

If you want the old  "<CODE><A HREF="../option_link.cgi?normalize"
>-normalize</A></CODE>" behaviour (before IM v6.2.5-5), you will need to
specify any non-default "<CODE><A HREF="../option_link.cgi?channel"
>-channel</A></CODE>" setting.  For images that contain no alpha (or matte)
channel, you can just use the '<CODE>all</CODE>' channel setting.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick color_range.jpg -channel all  -normalize   normalize_all.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="normalize_all.jpg"
     ><IMG SRC="normalize_all.jpg"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Alternatively, you can normalize each channel as a separate image using the
"<CODE><A HREF="../option_link.cgi?separate" >-separate</A></CODE>" operator
(as of IM v6.2.9-2), then "<CODE><A HREF="../option_link.cgi?combine"
>-combine</A></CODE>" them back into a single image again.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick color_range.jpg -separate -normalize -combine normalize_sep.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="normalize_sep.jpg"
     ><IMG SRC="normalize_sep.jpg"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In these last two examples, we see that the grayscale areas of the image
turned yellow, since the '<CODE>red</CODE>' and '<CODE>green</CODE>' channels
were lightened, while the '<CODE>blue</CODE>' channel is only darkened
slightly. </P>

This brings use to an important point
<DIV ALIGN=center><B>
      Normalise and other Histogram operators are really grayscale operators,
<BR>       caution is needed when using it with color images.
</B></DIV></P>

In actual fact, "<CODE><A HREF="../option_link.cgi?normalize"
>-normalize</A></CODE>" is just a subset of the more general "<CODE><A
HREF="../option_link.cgi?contrast-stretch" >-contrast-stretch</A></CODE>" with
default values for black-point 2% and white-point=1%.  So what is "<CODE><A
HREF="../option_link.cgi?contrast-stretch" >-contrast-stretch</A></CODE>"?


<A NAME="contrast-stretch"></A>
<H3>contrast-stretch</H3>

The "<CODE><A HREF="../option_link.cgi?contrast-stretch"
>-contrast-stretch</A></CODE>" operator (added IM v6.2.6) is similar to
"<CODE><A HREF="../option_link.cgi?normalize" >-normalize</A></CODE>", except
it allows the user to specify the number of pixels that will be clipped or
burned-in. That is it provides you with some control over its selection of the
'<I>black-point</I>' and '<I>white-point</I>' it will use for the histogram
stretching. </I>

Thus the user specifies a count (or percent counts) of
the darkest grays in the image become black and the count of the lightest
greys to become white. </P>

For example, this will replace both the top and bottom 15% of colors with
their extremes (white and black), stretching the rest of the 70% of colors
appropriately.  The final result is to try to improve the overall contrast of
the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gray_range.jpg  -contrast-stretch 15%  stretch_gray.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gray_range.jpg"
     ><IMG SRC="gray_range.jpg"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="stretch_gray.jpg"
     ><IMG SRC="stretch_gray.jpg"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

You can also easily see the 'burn' and 'clip' effects at the top and bottom
of the above gradient, as those gray colors get stretched well beyond the
limits of the color range. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

And here I purposefully 'burn' 90% of the darker grays, leaving just 10% of
the brightest pixels to be stretched into a tight linear gradient at the top
of the image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gray_range.jpg  -contrast-stretch 90%x0%  stretch_black.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="stretch_black.jpg"
     ><IMG SRC="stretch_black.jpg"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This can be quite useful in order to find the brightest 'N' pixels in an
image, as they will be the only ones not 'burned' to a value of zero. (A
better way is to use "<CODE><A HREF="../option_link.cgi?threshold-black"
>-threshold-black</A></CODE>") </P>

One important aspect of "<CODE><A HREF="../option_link.cgi?contrast-stretch"
>-contrast-stretch</A></CODE>" is the use of zero for the <I>black-point</I>
and <I>white-point</I> threshold counts. In this case, "<CODE>-contast-stretch
0</CODE>", will locate the minimum and maximum bins in the image's histogram.
Since the counts actually begins at these bins, the result is simply to
stretch the min and max bins to full black and full white.  This will result
in a contrast stretch with a minimum or possibly zero amount of clipping, with
all the values in those 'bins' becoming 0 and maximum values. </P>

<TABLE CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD BGCOLOR="#800000" COLSPAN=5
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
</TR>
<TR><TD BGCOLOR="#800000" ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
    <TD ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1></TD>
    <TD>&nbsp;</TD>
    <TD ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1></TD>
    <TD BGCOLOR="#800000" ROWSPAN=2
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
</TR>
<TR><TD ALIGN=justify>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<A NAME="linear-stretch"></A>
<H3>Linear-Stretch</H3>

In many ways "<CODE><A HREF="../option_link.cgi?linear-stretch"
>-linear-stretch</A></CODE>" is very similar to the previous "<CODE><A
HREF="../option_link.cgi?contrast-stretch" >-contrast-stretch</A></CODE>"
operator.  Both functions can take black-point and white-point arguments as
either raw counts or as percentages of the total number of pixels involved.
However there are several important differences. </P>

One difference has to do with how the default black-point and white-point is
computed.  With "<CODE><A HREF="../option_link.cgi?contrast-stretch"
>-contrast-stretch</A></CODE>". If only one value, the black-point, is
provided, then the white point will be the same value.  Thus
"<CODE>-contrast-stretch 1</CODE>" is equivalent to "<CODE>-contrast-stretch
1x1</CODE>" and "<CODE>-contrast-stretch 1%</CODE>" is equivalent to
"<CODE>-contrast-stretch 1x1%"</CODE>".  However, with "<CODE><A
HREF="../option_link.cgi?linear-stretch" >-linear-stretch</A></CODE>", if only
one value, the black-point, is provided, then the white point will be the
complement value.  </P>

That is, if the black-point is specified as a raw count, then the white-point
will be the total pixels in the image minus the black-point count. Likewise,
if the black-point is specified as a percent count, then the white-point will
be, 100% minus the black-point percentage count. Thus
"<CODE>-linear-stretch 1%</CODE>" will be equivalent to "<CODE>-linear-stretch
1x99%</CODE>".  </P>

The second difference has to do with where counts begin. Consider a histogram
with 256 bins (some 'bins' which may have zero counts) going from graylevel 0
to graylevel 255.  In "<CODE><A HREF="../option_link.cgi?contrast-stretch"
>-contrast-stretch</A></CODE>", counts start at zero with the lowest (min) and
highest (max) populated bins in the image (which may or may not be at bin 0 or
bin 255 in the histogram). Thus a black-point of 10% will cumulate counts from
all bins after the min bin until it reaches 10% and stretch the black side
from that graylevel. Thus the amount burned-in at the black side of the
histogram will end up being 10% plus what was already found in the darker
'bins' before it.  Likewise with counting from the bright side of the
histogram. </P>

With "<CODE><A HREF="../option_link.cgi?linear-stretch"
>-linear-stretch</A></CODE>", the count starts at the ends of the histogram,
namely, at bin 0 and bin 255.  Thus the amount burned-in at the dark side will
always be the black-point value and the amount of burn-in at the bright side
will always be the white-point value.  </P>

As an example, lets take a gradient of 100 pixels and look at its histogram.
</P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE NO_TXT2GIF OUT=grad_hist.txt>
  magick -size 1x100 gradient: \
          -depth 8 -format "%c" histogram:info:
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE SCRIPT OUT=grad_hist_mod.txt>
  sed '/^$/d; s/      //' grad_hist.txt |
     sort -t, -k2n  -o grad_hist.txt
  head -n 3 grad_hist.txt; echo '   ...'; tail -n 3 grad_hist.txt
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="grad_hist.txt"
     ><IMG SRC="grad_hist_mod.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

As expected every bin is equally populated with a single pixel, producing a
count of 1. (To see the full listing click on the output text image above). </P>

Now lets do the same after using "<CODE>-contrast-stretch 10x10%</CODE>"

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE NO_TXT2GIF OUT=grad_cs_hist.txt>
  magick -size 1x100 gradient:   -contrast-stretch 10x10%  \
          -depth 8 -format "%c" histogram:info:
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE SCRIPT OUT=grad_cs_hist_mod.txt>
  sed '/^$/d; s/      //' grad_cs_hist.txt |
     sort -t, -k2n  -o grad_cs_hist.txt
  head -n 3 grad_cs_hist.txt; echo '   ...'; tail -n 3 grad_cs_hist.txt
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="grad_cs_hist.txt"
     ><IMG SRC="grad_cs_hist_mod.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

And now "<CODE>-linear-stretch 10x10%</CODE>".

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE NO_TXT2GIF OUT=grad_ls_hist.txt>
  magick -size 1x100 gradient:   -linear-stretch 10x10%  \
          -depth 8 -format "%c" histogram:info:
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE SCRIPT OUT=grad_ls_hist_mod.txt>
  sed '/^$/d; s/      //' grad_ls_hist.txt |
     sort -t, -k2n  -o grad_ls_hist.txt
  head -n 3 grad_ls_hist.txt; echo '   ...'; tail -n 3 grad_ls_hist.txt
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="grad_ls_hist.txt"
     ><IMG SRC="grad_ls_hist_mod.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

So we confirm that for "<CODE>-contrast-stretch 10x10%</CODE>" we get 11
pixels at each end.  That is equivalent to the count in the end bins plus 10%
of the image pixels, which is equal to 10 pixels. So 10+1=11 pixels burned-in.
On the other hand, in "<CODE>-linear-stretch</CODE>", the end bins end up
containing containing only 10 pixels or 10% of the image.  </P>

One consequence of the aforementioned difference is that
"<CODE>-contrast-stretch 0x0</CODE>" may change the image, if the lowest
and/or highest populated bins are not the end bins at 0 and 255.  In this
case, the image will be stretched between the graylevels corresponding to
those bins.  On the other hand, "<CODE>-linear-stretch 0x0</CODE>" will never
change the image.  </P>

For example, lets take the gradient and compress its graylevels by 10% on each
end.  That is, we will move black-point up 10% to graylevel 26 and white-point
down 10% to graylevel 230.  </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE NO_TXT2GIF OUT=grad_lv_hist.txt>
  magick -size 1x100 gradient:   +level 10x90%  \
          -depth 8 -format "%c" histogram:info:
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE SCRIPT OUT=grad_lv_hist_mod.txt>
  sed '/^$/d; s/      //' grad_lv_hist.txt |
     sort -t, -k2n  -o grad_lv_hist.txt
  head -n 3 grad_lv_hist.txt; echo '   ...'; tail -n 3 grad_lv_hist.txt
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="grad_lv_hist.txt"
     ><IMG SRC="grad_lv_hist_mod.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Now, lets apply "<CODE>-contrast-stretch 0x0</CODE>" to the above
de-contrasted gradient </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE NO_TXT2GIF OUT=grad_cs0_hist.txt>
  magick -size 1x100 gradient: -level 10x90%  -contrast-stretch 0x0  \
          -depth 8 -format "%c" histogram:info:
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE SCRIPT OUT=grad_cs0_hist_mod.txt>
  sed '/^$/d; s/      //' grad_cs0_hist.txt |
     sort -t, -k2n  -o grad_cs0_hist.txt
  head -n 3 grad_cs0_hist.txt; echo '   ...'; tail -n 3 grad_cs0_hist.txt
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="grad_cs0_hist.txt"
     ><IMG SRC="grad_cs0_hist_mod.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

And now "<CODE>-linear-stretch 0x0</CODE>"

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE NO_TXT2GIF OUT=grad_ls0_hist.txt>
  magick -size 1x100 gradient: -level 10x90%  -linear-stretch 10x10% \
          -depth 8 -format "%c" histogram:info:
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE SCRIPT OUT=grad_ls0_hist_mod.txt>
  sed '/^$/d; s/      //' grad_ls0_hist.txt |
     sort -t, -k2n  -o grad_ls0_hist.txt
  head -n 3 grad_ls0_hist.txt; echo '   ...'; tail -n 3 grad_ls0_hist.txt
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="grad_ls0_hist.txt"
     ><IMG SRC="grad_ls0_hist_mod.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>


So we see that the original image had a histogram that did not span the full
dynamic range of 0 to 255. It only went between graylevels 26 and 230. But
after applying "<CODE>-contrast-stretch 0x0</CODE>", it was stretched to full
dynamic range.  On the other hand, "<CODE>-linear-stretch 0x0</CODE>" made no
change in the resulting histogram.  </P>

The third difference is that "<CODE>-contrast-stretch</CODE>" is channel
sensitive, whereas "<CODE>-linear-stretch</CODE>" is not. </P>

That means that with "<CODE>-contrast-stretch</CODE>" any one or more channels
can be changed without affecting the others. Thus if no channel is specified,
the overall histogram from all the channels will be used to modify all the
channels in the same manner so that no color shifts are produced. </P>

However, if "<CODE>-channel RGB</CODE>" is specified, then each channel will
be stretched separately and the result will depend upon the end bins in each
channel. If they are different, then a color shift will be produced between
the individual channels in the resulting image. </P>

With "<CODE>-linear-stretch</CODE>", all the channels will be processed in a
common way, thus assuring that no color shifts of the channels relative to
each other will be produced.  </P>

So lets get a verbose magick identify and the histogram of a real image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE NO_TXT2GIF OUT=info_port.txt>
  magick port.png  -verbose -magick identify +verbose  histogram:port_hist.gif
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE SCRIPT OUT=info_port_mod.txt>
  sed '2,/blue: 8-bit/ d; /Image statistics:/,$ d;
       1s/.*/  .../;   s/.*standard.*/    .../;
       /kurtosis:/d; /skewness:/d;  ' info_port.txt
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80%>
<TR><TD BGCOLOR="#CCCCCC" width="100%">
  <A HREF="info_port.txt"
     ><IMG SRC="info_port_mod.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD><TD ALIGN=center>
  <A HREF="../img_photos/port.png"
     ><IMG SRC="../img_photos/port.png"   WIDTH=200 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="port_hist.gif"
     ><IMG SRC="port_hist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TR></TABLE>
</DIV></P>


We see that none of the channels of the above image span the full dynamic
range. Also note that each of the channels spans an uniquely different range
of values. </P>

Now lets apply "<CODE>-contrast-stretch 1x1%</CODE>" without a "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick port.png -contrast-stretch 1x1% \
          -write histogram:port_cs1_hist.gif   port_cs1.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="port_cs1.png"
     ><IMG SRC="port_cs1.png"   WIDTH=200 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="port_cs1_hist.gif"
     ><IMG SRC="port_cs1_hist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In the above result, the image is stretched consistently across all the
channels. Thus, there are no color shifts between channels. Now let's do the
same but with "<CODE>-channel RGB</CODE>".  </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick port.png  -channel RGB  -contrast-stretch 1x1% \
          -write histogram:port_cs1rgb_hist.gif    port_cs1rgb.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="port_cs1rgb.png"
     ><IMG SRC="port_cs1rgb.png"   WIDTH=200 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="port_cs1rgb_hist.gif"
     ><IMG SRC="port_cs1rgb_hist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In the above result, because we set "<CODE>-channel RGB</CODE>", rather than
use the default channel setting, the image is stretched differently for each
channel. This causes a color shift between channels. </P>

Now let's apply "<CODE>-linear-stretch</CODE>" without a
"<CODE>-channel</CODE>" setting.  </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick port.png   -linear-stretch 1x1% \
          -write histogram:port_ls1_hist.gif \
          port_ls1.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="port_ls1.png"
     ><IMG SRC="port_ls1.png"   WIDTH=200 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="port_ls1_hist.gif"
     ><IMG SRC="port_ls1_hist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In the above result, the image is stretched consistently across all
the channels. So there is no color shift between channels. Now let's do
the same, but with "<CODE>-channel RGB</CODE>".

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick port.png  -channel RGB  -linear-stretch 1x1% \
          -write histogram:port_ls1rgb_hist.gif    port_ls1rgb.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="port_ls1rgb.png"
     ><IMG SRC="port_ls1rgb.png"   WIDTH=200 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="port_ls1rgb_hist.gif"
     ><IMG SRC="port_ls1rgb_hist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In the above result with "<CODE>-linear-stretch</CODE>", the image is
stretched consistently across all the channels and "<CODE>-channel RGB</CODE>"
is ignored. Thus there is no color shift between channels and the result is
identical to that above without "<CODE>-channel RGB</CODE>".  </P>

&nbsp;</TD></TR>
<TR><TD width="100%" BGCOLOR="#800000" COLSPAN=5
        ><IMG SRC="../img_www/space.gif" WIDTH=3 HEIGHT=3></TD>
</TR></TABLE>


<A NAME="hist_redist"></A>
<H3>Histogram Redistribution</H3>

Histogram redistribution is a non-linear technique that redistributes the bins
in a histogram in order to achieve some particular shape. The two most common
shapes are uniform (flat) and Gaussian (bell-shaped), although Hyperbolic and
Rayleigh are other types of distributions have also been used.  </P>


<A NAME="equalize"></A>
<H3>Equalize - Uniform Histogram Redistribution</H3>

For the case of an uniform distribution, the histogram bins are shifted, spaced
and combined so that on average the histogram has a flat or constant height
across the whole range. This is called histogram equalization. The IM
function, "<CODE><A HREF="../option_link.cgi?equalize" >-equalize</A></CODE>",
does this. </P>

Unfortunately, it operates on each channel separately, rather than applying
the same operation to all channels.  As such, color shifts are possible, when
it is applied to RGB colorspace. </P>

Here is an example of histogram equalization using the IM function -equalize.
Notice the color balance shift from the equalization on each channel
independently.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick zelda.png  -write histogram:zelda_hist.gif \
          -equalize  -write histogram:zelda_equal_hist.gif \
          zelda_equal.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/zelda.png"
     ><IMG SRC="../img_photos/zelda.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_equal.png"
     ><IMG SRC="zelda_equal.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="zelda_hist.gif"
     ><IMG SRC="zelda_hist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_equal_hist.gif"
     ><IMG SRC="zelda_equal_hist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

You may note that the histogram does not look very uniform. But if we convert
the resulting image to grayscale and magick display its histogram, its histogram looks
a bit more uniform in comparison to the original image's grayscale histogram
</P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick zelda.png  -colorspace gray   histogram:zelda_ghist.gif

  magick zelda_equal.png  -colorspace gray \
          histogram:zelda_equal_ghist.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="zelda_ghist.gif"
     ><IMG SRC="zelda_ghist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_equal_ghist.gif"
     ><IMG SRC="zelda_equal_ghist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The other way to approach redistributing the bins is by using a transformation
look up table that is generated from the separate cumulative histograms of
each channel and the desired integrated distribution curve. If one does not
want any color shifts between channels, then one uses the combined histogram
from all the channels of the image. An approximation is simply to use the
histogram of the image after converting it to grayscale.  </P>

<A HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred Weinhaus</A> has
developed a script, called "<A
HREF="http://www.fmwconcepts.com/imagemagick/redist/" >redist</A></CODE>" that
does just that. It redistributes the histogram of an image into an uniform
distribution, while appling the same change to all color channels equally.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  redist -s uniform zelda.png  zelda_uniform.png

  magick zelda_uniform.png   histogram:zelda_uniform_hist.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/zelda.png"
     ><IMG SRC="../img_photos/zelda.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_uniform.png"
     ><IMG SRC="zelda_uniform.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="zelda_hist.gif"
     ><IMG SRC="zelda_hist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_uniform_hist.gif"
     ><IMG SRC="zelda_uniform_hist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note how the results different from the IM built-in "<CODE><A
HREF="../option_link.cgi?equalize" >-equalize</A></CODE>" operator.
Specifically, all the colors are preserved, without the color shift you saw
previously. </P>

What the script does is work on the grayscale histogram, which it then applies
to all the color channels, so that all the colors are kept together.  </P>

For comparison with the IM "<CODE><A HREF="../option_link.cgi?equalize"
>-equalize</A></CODE>" histograms, lets show the grayscale histogram results
here, too.  Note that the redistributed histogram appears to be a bit more
leveled out (flat, or uniform) than that of IM equalize. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick zelda.png  -colorspace gray   histogram:zelda_ghist.gif

  magick zelda_uniform.png  -colorspace gray \
          histogram:zelda_uniform_ghist.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="zelda_ghist.gif"
     ><IMG SRC="zelda_ghist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_uniform_ghist.gif"
     ><IMG SRC="zelda_uniform_ghist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<I>FUTURE: Add examples of equalizing in other colorspaces!  That is, the
grayscale channel in HSL, HSB and CMYK colorspaces.</I>


<A NAME="gaussian_redist"></A>
<H3>Gaussian Redistribution</H3>

Equalizing a histogram is not the only way of changing the histogram
distribution of an image. Actually it isn't normally very useful, except in
computer vision applications.  </P>

Here is the same image, but transformed so its histogram has a Gaussian
(bell-shaped) distribution.  The values used here are a 60% gray mean, with a
60 sigma roll-off to either side of that mean.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  redist -s gaussian 60,60,60  zelda.png \
         zelda_gaussian.png

  magick zelda_gaussian.png -colorspace gray \
          histogram:zelda_gaussian_ghist.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/zelda.png"
     ><IMG SRC="../img_photos/zelda.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_gaussian.png"
     ><IMG SRC="zelda_gaussian.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="zelda_ghist.gif"
     ><IMG SRC="zelda_ghist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_gaussian_ghist.gif"
     ><IMG SRC="zelda_gaussian_ghist.gif"   WIDTH=128 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

From the resulting grayscale histogram, you can see that the image is modified
so its colors follow a Gaussian bell curve type of distribution. </P>

For photos, this produces a more 'natural' looking result.  The image will not
only have been contrast optimized, but also adjusted in brightness so most of
the pixels in the image have about a 60% grayscale brightness. </P>



<A NAME="redist_method"></A>
<H3>Histogram Redistribution Methodology</H3>

So how does this type of direct histogram adjustment work? </P>

Basically it computes the histogram of the current image and that of the
desired distribution.  It then works out how the graylevel value of each 'bin'
needs to be changed so that the counts in the bins best follow the desired
distribution.   Some bins may be shifted darker, while others may be shifted
lighter. </P>

This is actually quite an involved process, so lets go though it step by step.
</P>

<BR>

First, we need to get the actual histogram data from ImageMagick, rather than
a graphic image of the histogram.  Note that the data is from all the color
values, combined into a grayscale. This was done so as to distribute all the
channels together, and adjust the image overall brightness to follow to the
desired curve.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=zelda_hist_graph.gif >
  magick zelda.png -colorspace gray \
         -depth 8 -format "%c" histogram:info:- |\
    tr -cs '0-9\012' ' ' |\
      awk '# collect the histogram data.
           { bin[$2] += $1; }
           END { for ( i=0; i&lt;256; i++ ) {
                   print bin[i]+0;
                 }
               } ' > zelda_hist_data.txt

  # get the maximum count for any one histogram 'bin'
  max_count=`sort -n zelda_hist_data.txt | tail -n 1`

  # magick histogram into a profile graph of the data
  echo "P2 256 1 $max_count" | cat - zelda_hist_data.txt |\
    im_profile -s - zelda_hist_graph.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/zelda.png"
     ><IMG SRC="../img_photos/zelda.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_hist_graph.gif"
     ><IMG SRC="zelda_hist_graph.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

To collect the data I take the 'comment' meta-data from the histogram image,
which IM includes just for this purpose. The data is then cleaned to leave
just the raw numbers (using a program called "<CODE>tr</CODE>", short for
'translate').  This raw data is then given to another utility program called
"<CODE>awk</CODE>", which is used to collect the actual histogram counts for
each bin. </P>

So that we can look at the results, I also process the histogram counts into a
gradient image (via the <A HREF="../formats/#netpbm" >NetPBM, PGM text
grayscale</A> image file format, and magick display it as a line graph using the
"<CODE><A HREF="../scripts/im_profile" >im_profile</A></CODE>" script.
Essentially this is just a different way of generating a histogram image,
though this time directly from a numerical data file. </P>

Now that we have the histogram data in a text file, we also need the histogram
of the function we want the redistributed data to match.  In this case, it is
a Gaussian distribution with a mean value of 153 (60% gray) and sigma width of
60.  Both values are in terms of the 256 range of the histogram 'bins'.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=gaussian_hist_graph.gif >
  awk '# AWK to generate gaussian distribution graph
        BEGIN { mean = 153;   sigma = 60;
                fact = 1/(2*(sigma/256)^2);
                expo = exp(1);
                for ( i=0; i&lt;256; i++ ) {
                  print int(65535*expo^(-(((i-mean)/256)^2)*fact));
                }
              }' /dev/null  > gaussian_hist_data.txt

   # magick gaussian data into a profile graph
   echo "P2 256 1 65535" | cat - gaussian_hist_data.txt |\
     im_profile -s -b - gaussian_hist_graph.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gaussian_hist_graph.gif"
     ><IMG SRC="gaussian_hist_graph.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The histograms above are interesting and reflect the image's original histogram
distribution and the histogram's desired state.  But for conversion purposes,
this form of histogram, while good for us to understand, is not very useful
for our purposes. </P>

Actually, what we really need are the cumulative histograms.  These histograms
are very similar to a normal histogram, except that each 'bin' in the
histogram is a count of its 'bin' plus all the 'bins' that came before it,
starting at 0.  That is, each 'bin' is an 'accumulation' or count of all the
darker 'bins'. </P>

These are actually easier to generate directly from the original image.
So lets repeat the process, but computing and saving the 'cumulative' counts.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=zelda_cumhist_graph.gif >
  magick zelda.png -colorspace gray \
         -depth 8 -format "%c" histogram:info:- |\
    tr -cs '0-9\012' ' ' |\
      awk '# Collect the cumulative histogram for an image
               { bin[$2] += $1; }
           END { for ( i=0; i&lt;256; i++ ) {
                   cum += bin[i];
                   print cum;
                 }
               } ' > zelda_cumhist_data.txt

  total_count=`tail -n 1 zelda_cumhist_data.txt`
  echo "P2 256 1 $total_count" | cat - zelda_cumhist_data.txt |\
    im_profile -s - zelda_cumhist_graph.gif

  awk '# AWK to generate gaussian distribution cumulative graph
        BEGIN { mean = 153;   sigma = 60;
                fact = 1/(2*(sigma/256)^2);
                expo = exp(1);
                for ( i=0; i&lt;256; i++ ) {
                  gas[i] = expo^(-(((i-mean)/256)^2)*fact);
                  total += gas[i]
                }
                for ( i=0; i&lt;256; i++ ) {
                  cum += gas[i];
                  print int(65535*cum/total);
                }
              }' /dev/null  > gaussian_cumhist_data.txt

  total_count=`tail -n 1 gaussian_cumhist_data.txt`
  echo "P2 256 1 $total_count" | cat - gaussian_cumhist_data.txt |\
    im_profile -s -b - gaussian_cumhist_graph.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE>
<TR><TD ALIGN=center>
  <A HREF="zelda_cumhist_graph.gif"
     ><IMG SRC="zelda_cumhist_graph.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <BR>Image Cumulative<BR>Histogram
</TD><TD ALIGN=center>
  <A HREF="gaussian_cumhist_graph.gif"
     ><IMG SRC="gaussian_cumhist_graph.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <BR>Gaussian Cumulative<BR>Histogram
</TD></TR></TABLE>
</DIV></P>

Now what we need to do is magick the image's cumulative histogram
into the gaussian cumulative histogram.  To do this, each gray value in the
input image is used to find its 'normalized' cumulative value.  This is then
mapped to the same cumulative value in the gaussian distribution and then
its corresponding gray value is found. </P>

This diagram should make the mapping process clearer...

<DIV ALIGN=center>
   <IMG SRC="../img_diagrams/redist_working.jpg"   WIDTH=407 HEIGHT=202
        ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[diagram]">
</DIV></P>

The following command does the lookup for every possible 8-bit color value, in
order to generate a Color Look Up Table, or CLUT.  This special image can then
be used to map the color values in the original image to the new values needed
to redistribute the image's histogram.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=zelda_redist.png >
  # Generate a CLUT to Redistribute the Histogram
  paste  zelda_cumhist_data.txt   gaussian_cumhist_data.txt |\
    awk '# AWK to generate gaussian distribution graph
              { bin[NR] = $1;   gas[NR] = $2;  }
          END { k=0;  # number of pixels less than this value
                print "P2 256 1 65535";
                for ( j=0; j&lt;256; j++ ) {
                  while ( k&lt;255 &amp;&amp;
                            gas[k]/gas[255] &lt;= bin[j]/bin[255] ) {
                    k++;
                  }
                  print 65535*k/255;
                }
              }' |\
      magick pgm:- gaussian_clut.png

  magick zelda.png   gaussian_clut.png -clut   zelda_redist.png
</CODE></PRE></TD></TR></TABLE>
<!--<CODE EXECUTE SCRIPT OUT=zelda_redist_graph.gif>
  magick zelda_redist.png  -colorspace gray \
         -depth 8 -format "%c" histogram:info:- |\
  tr -cs '0-9\012' ' ' |\
  awk '# collect the histogram data.
      { bin[$2] += $1;
        if ( max < bin[$2] ) max = bin[$2]
      }
      END { print "P2 256 1 65535";
            for ( i=0; i<256; i++ ) {
              print int(65535*bin[i]/max);
            }
          } ' |\
  im_profile -s  -  png:- |\
  magick gaussian_hist_graph.gif -crop 150x75+0+0 \
          png:- +swap -compose multiply -magick composite \
          zelda_redist_graph.gif
</CODE>-->
  <A HREF="../img_photos/zelda.png"
     ><IMG SRC="../img_photos/zelda.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_redist.png"
     ><IMG SRC="zelda_redist.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="zelda_hist_graph.gif"
     ><IMG SRC="zelda_hist_graph.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_redist_graph.gif"
     ><IMG SRC="zelda_redist_graph.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see, converting a histogram of an image to attempt to follow
a specific distribution function, such a gaussian bell curve, is quite
an involved and highly numerical process. </P>

Here it is all in one rather long and complex command...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=zelda_gaussian_redist.png >
  magick zelda.png -colorspace gray \
         -depth 8 -format "%c" histogram:info:- |\
    tr -cs '0-9\012' ' ' |\
      awk '# AWK to generate gaussian distribution graph
            { # just read in image histogram into a 'bin' table
                  bin[$2] += $1;
                }
            END { # Generate Gaussian Histogram
                  mean = 153;   sigma = 60;
                  fact = 1/(2*(sigma/256)^2);
                  expo = exp(1);
                  for ( i=0; i&lt;256; i++ ) {
                    gas[i] = expo^(-(((i-mean)/256)^2)*fact);
                  }
                  # Convert normal histograms to cumulative histograms
                  for ( i=0; i&lt;256; i++ ) {
                    gas[i] += gas[i-1];
                    bin[i] += bin[i-1];
                  }
                 # Generate Redistributed Histogram
                 k=0;  # number of pixels less than this value
                 print "P2 256 1 65535";
                 for ( j=0; j&lt;256; j++ ) {
                   while ( k&lt;255 &amp;&amp;
                            gas[k]/gas[255] &lt;= bin[j]/bin[255] ) {
                     k++;
                   }
                   print 65535*k/255;
                 }
                }' |\
        magick zelda.png   pgm:-  -clut   zelda_gaussian_redist.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/zelda.png"
     ><IMG SRC="../img_photos/zelda.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="zelda_gaussian_redist.png"
     ><IMG SRC="zelda_gaussian_redist.png"   WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Just some final words on the above technique. </P>

<UL>
<LI>Using "<CODE>awk</CODE>" to do the calculations to speed up Fred
    Weinhaus's "<CODE><A HREF="http://www.fmwconcepts.com/imagemagick/redist/"
    >redist</A></CODE>" script were suggested and contributed by Anthony
    Thyssen. </P>

<LI>To apply the above redistribution technique to generate a 'uniform', or
    'equalized' distribution, the function histogram is simply a constant.
    This in turn results in an an integrated distribution that is simply the
    formula <CODE>y = x</CODE>, or simply a diagonal straight line.  Applying
    the same conversion technique leads to a CLUT image that turns out to be
    identical to the input image's cumulative histogram.  </P>

    In other words, for an equalization of the histogram, you can simply
    magick the image's cumulative histogram into a CLUT and apply it to the
    image directly.  </P>

<LI>Most Image processing packages, including ImageMagick at this time, apply
    the transformation formulae directly to the values in the image itself,
    rather than generate an intermediate CLUT.   However as histograms and
    thus cumulative histograms have a limited size (256 'bins' typically),
    that can lead to serious errors, since the image color values may be
    rounded off, during the process.  </P>

    However with ImageMagick, we generate an intermediate CLUT (containing
    those same round off errors), and then magick the original un-rounded
    image values though the prepared CLUT using a linear interpolation of the
    values.  As a result of this interpolation, the color values of the new
    image is more accurate, as they have not been rounded off or 'bin'ed
    during processing.  </P>

</UL></P>

The above will hopefully eventually be built into ImageMagick.  In the mean
time Fred Weinhaus's "<A HREF="http://www.fmwconcepts.com/imagemagick/redist/"
>redist</A></CODE>" script is available to do the task. </P>

You may also be interested in Fred's "<A
HREF="http://www.fmwconcepts.com/imagemagick/retinex/" >retinex</A></CODE>"
script, which attempts to make similar automatic enhancements to images, in
localized regions of the image, rather than globally as this technique does.
</P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="diy_levels"></A>
<H2>DIY Level Adjustments</H2>


<A NAME="linear"></A>
<H3>Mathematical Linear Histogram Adjustments</H3>

The various basic forms of <A HREF="#level" >Level Adjustments</A> shown above
linearly adjust the colors of the image. </P>

These changes can be applied mathematically as well.  For example by
multiplying the image with a specific color, we set all pure white areas to
that color.  So lets just read in our image, create an image containing the
color we want, then multiply the original image with this color using the IM
free-form "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" or <A
HREF="../transform/#fx" >DIY Operator</A>. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -size 1x1 xc:Yellow \
          -fx 'u*v.p{0,0}'    fx_linear_white.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_linear_white.png"
     ><IMG SRC="fx_linear_white.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

By getting "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" to read the
color from a second '<CODE>v</CODE>' image makes it easy to change the color,
without needing to magick colors to RGB values for use in the mathematics.
</P>

If you were using a fancy graphical image processing package like "<CODE><A
HREF="http://www.gimp.org/" >Gimp</A></CODE>" and "<CODE><A
HREF="http://www.adobe.com/products/photoshopfamily.html"
>Photoshop</A></CODE>" the above operation would have been applied to an image
by adjusting the images color histogram graph 'curve'. </P>

<!-- <CODE EXECUTE>
  im_histogram -l -t 'Linear White Tint' 'x * .7' fx_linear_white_plot
</CODE> -->
  <A HREF="fx_linear_white_plot.jpg"
     ><IMG SRC="fx_linear_white_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

For example to the right is a "<CODE><A HREF="http://www.gnuplot.info/"
>gnuplot</A></CODE>" generated graph (See the script "<CODE><A
HREF="../scripts/im_histogram" ><B>im_histogram</B></A></CODE>") of the
mathematical formula showing what happens to just one of the three RGB
channels.  The original color (green line) is remapped to a darker color (red
line) linearly.  </P>

Linearly tinting the black colors is also quite simple.  For example
to linear map '<CODE>black</CODE>' to a gold like color
'<CODE>rgb(204,153,51)</CODE>', (while leaving '<CODE>white</CODE>' as
'<CODE>white</CODE>'), would require a mathematical formula such as...
<PRE>          result = 1-(1-color)*(1-intensity)</PRE>

This formula negates the colors, multiples the image with the negated color
wanted, and negates the image back again. The result is tinting of the black
side of the gray scale, leaving white unchanged. </P>

<!-- <CODE EXECUTE>
  im_histogram -l -t 'Linear Black Tint' \
               '1-(1-.3)*(1-x)'     fx_linear_black_plot
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -size 1x1 xc:'rgb(204,153,51)'  \
          -fx '1-(1-v.p{0,0})*(1-u)'   fx_linear_black.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_linear_black_plot.jpg"
     ><IMG SRC="fx_linear_black_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_linear_black.png"
     ><IMG SRC="fx_linear_black.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

A "<A HREF="http://www.gnuplot.info/" >gnuplot</A>" histogram graph of the
remapping formula is also displayed in the above for your reference. </P>

With a slightly more complicated formula you can linearly replace both the
'<CODE>black</CODE>' and '<CODE>white</CODE>' end of the grayscale with
specific colors.

<!-- <CODE EXECUTE>
  im_histogram -l -t 'Linear Color Tint' \
                '.7*x+.2*(1-x)'    fx_linear_color_plot
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -size 1x2  gradient:gold-firebrick \
          -fx 'v.p{0,0}*u+v.p{0,1}*(1-u)'   fx_linear_color.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_linear_color_plot.jpg"
     ><IMG SRC="fx_linear_color_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_linear_color.png"
     ><IMG SRC="fx_linear_color.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The "<CODE>-size 1x2 gradient:color1-color2</CODE>" in the above is only used
to generate a two color pixel image for the "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" formula to reference.  The first
color replaces white, while the second replaces black, while all others are
interpolated between white and black.  As is typical of a gray-scale operator,
each RGB channel is treated as a separate gray scale channel, though the
linear interpolation is different for each channel. </P>

This by the way is exactly equivalent to the <A HREF="#level-colors" >Level
Adjustments by Color</A> operator "<CODE><A
HREF="../option_link.cgi?level-colors" >+level-colors</A></CODE>" </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>

However unlike "<CODE><A HREF="../option_link.cgi?colors"
>+level-colors</A></CODE>", the colors to use can of course come from any
image source, and not just the color names provided as an argument. However
even direct use of color names is possible.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png   -fx "yellow*u+green*(1-u)"  fx_linear.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_linear.png"
     ><IMG SRC="fx_linear.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="non-linear"></A>
<H3>Mathematical Non-linear Histogram Adjustments</H3>

While linear color adjustments are important, and faster methods are available,
there are many situations where a linear 'level' adjustment, is not what is
wanted,  and this is where the "<CODE><A HREF="../option_link.cgi?fx"
>-fx</A></CODE>" <A HREF="../transform/#fx" >DIY Operator</A>, becomes more
useful. </P>

Well an alternative formula for linear adjustment is  "<CODE>-fx
'v.p{0,1}+(v.p{0,0}-v.p{0,1})*u'</CODE>", which  has the advantage that the
'<CODE>u</CODE>' can be replaced by a single random function
'<CODE>f(u)</CODE>' to produce non-linear color change. </P>

This lets you do more interesting things.  For example what if in the last
example you wanted to push all the colors toward the '<CODE>black</CODE>'
side, resulting in the image being a more '<CODE>firebrick</CODE>' color.

<!-- <CODE EXECUTE>
  im_histogram -l -t 'Non-Linear Color Tint' \
                '.2+(.8-.2)*x**4'     fx_non-linear_plot
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -size 1x2  gradient:gold-firebrick \
          -fx 'v.p{0,1}+(v.p{0,0}-v.p{0,1})*u^4'  fx_non-linear.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_non-linear_plot.jpg"
     ><IMG SRC="fx_non-linear_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_non-linear.png"
     ><IMG SRC="fx_non-linear.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

In a more practical example, Adelmo Gomes needed a color adjustment for a
automated <A HREF="http://members.aol.com/landsatcd/MOREHTML/colorize.html"
>Weather Map Recoloring</A> script he was developing. </P>

In this case he wanted to tint pure black parts of the image to a .25 blue,
but leave the rest of the gray-scale alone, especially the white and mid-tone
grays of the image. Only the blue color needed such adjustment, which he
currently was doing by hand in an image editor. </P>

For example you could use a quadratic formula like '<CODE>u^2</CODE>' to tint
the black end of the histogram to a '<CODE>.25</CODE>' blue color.  Only the
blue channel needs to be modified, so the value was inserted directly into
the formula.

<!-- <CODE EXECUTE>
  im_histogram -l -t 'Non-Linear Color Tint' \
                '.25+(1-.25)*x**2'     fx_quadratic_plot
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -channel B  -fx '.25+(1-.25)*u^2'  fx_quadratic.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_quadratic_plot.jpg"
     ><IMG SRC="fx_quadratic_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_quadratic.png"
     ><IMG SRC="fx_quadratic.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

However while this produced a reasonable result it does darken the mid-tone
grays slightly, producing a sickly off-yellow color. </P>

To avoid this a 'exponential' function can be used instead, to give better
control of the tinting process.

<!-- <CODE EXECUTE>
  im_histogram -l -t 'Non-Linear Tint for Blue Channel' \
                '.25*exp(-x*4.9)+x'     fx_expotential_plot
</CODE> -->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -channel B  -fx '.3*exp(-u*4.9)+u'  fx_expotential.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/multiply.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_expotential_plot.jpg"
     ><IMG SRC="fx_expotential_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fx_expotential.png"
     ><IMG SRC="fx_expotential.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Again the graph show how blue channel was modified to give black a distinctive
dark blue tint. </P>

The second value ('<CODE>4.9</CODE>') is the falloff back to a linear
'<CODE>+u</CODE>' graph.  The smaller this value is the slower the fall off,
and the more linear the adjustment becomes. The larger the value, the more
dramatic the 'fall-off'.  The value may need to be adjusted for different
color values, so this is not a good general formula for general black color
tinting, but perfect for tinting weather maps. </P>

Generally if you can express the color adjustment you want mathematically, you
can then use "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator
to achieve the results you want. </P>


<A NAME="curves"></A>
<H3>'Curves' Adjustments</H3>

<IMG SRC="../img_diagrams/curves_gui.gif"      WIDTH=197 HEIGHT=200
     ALIGN=right VSPACE=2 HSPACE=5 ALT="[diagram]">

Normally in a graphical photo editor you would be presented with a histogram
'curves' chart such as I have shown to the left.  The user can then edit the
'curve' by moving four (or more) control points, and the histogram adjustment
function will follow those points. </P>

The control points generally specify that the first grayscale level is after
adjustment to become the second grayscale level.  So a point like 0.0,0.2
basically means that a 0% gray (black) should after adjustment be a 20% gray
level. </P>

Now IM does not allow you to directly specify 'control points' to generate a
'curve' adjustment, what it wants is the mathematical formula of that 'curve'
generated. Lucky for us there are programs that can generate that curve
formula from the control points, including "<CODE><A
HREF="http://www.go.dlr.de/pdinfo_dv/gnuplot.html" >gnuplot</A></CODE>",
"<CODE><A HREF="http://www.go.dlr.de/pdinfo_dv/fudgit.html"
>fudgit</A></CODE>", "<CODE>mathematica</CODE>", and "<CODE><A HREF="http://www.mathworks.com/"
>matlab</A></CODE>", as well as many more mathematical software packages. </P>

The following is one method you can use to generate the formula from four
control points using "<CODE>gnuplot</CODE>" which is a standard extra package
you can install on most linux distributions, as well as windows.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  ( echo "0.0 0.2";  echo "1.0 0.9"; \
    echo "0.2 0.8";  echo "0.7 0.5"; )   > fx_control.txt

  ( echo 'f(x) = a*x**3 + b*x**2 + c*x + d'; \
    echo 'fit f(x) "fx_control.txt" via a, b, c, d'; \
    echo 'print a,"*u^3 + ",b,"*u^2 + ",c,"*u + ",d'; \
  ) | gnuplot 2>&1 | tail -1             > fx_funct.txt
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  im_histogram -d fx_control.txt  -t "Histogram Curve Fit" \
            -- "`sed 's/u/x/g; s/\^/**/g'  fx_funct.txt`"   fx_funct_plot
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5>
<TR VALIGN=middle><TD ALIGN=center>
  <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
  <TR><TD>
    <A HREF="fx_control.txt"
       ><IMG SRC="fx_control.txt.gif"
             ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[Data]"></A>
  </TD></TR></TABLE>
  Control Points
</TD><TD>
    <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="fx_funct_plot.jpg"
     ><IMG SRC="fx_funct_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=right VSPACE=0 HSPACE=0 BORDER=1 ALT="[Gnuplot]"></A>
</TD></TR><TR><TD></TD><TD></TD></TD>
  <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
  <TR><TD>
    <A HREF="fx_funct.txt"
       ><IMG SRC="fx_funct.txt.gif"
             ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[Gnuplot]"></A>
  </TD></TR></TABLE>
   Gnuplot Fitted FX Function
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Note that the number of parameters ('<CODE>a</CODE>' to '<CODE>d</CODE>'
  in above) needed for curve fitting, must equal the number of control
  points you provide.  As such if you want five control points you need to
  include another '<CODE>e</CODE>' term to the function. </P>

  If your histogram curve goes though the fixed control points
  <CODE>0,0</CODE> and <CODE>1,1</CODE>, you really only need two parameters
  as '<CODE>d</CODE>' will be equal to '<CODE>0</CODE>', and
  '<CODE>c</CODE>' will be equal to '<CODE>1-a-b</CODE>'. </P>

</I></FONT></TD></TR></TABLE></P>

A more detailed usage guide to the above specifically for Windows users, but
works for linux users too, has been posted on <A
HREF="http://stackoverflow.com/questions/27468172/" >StackOverflow: IM Curves
using Gnuplot on Windows</A>. </P>

As you can see from the extra "<CODE>gnuplot</CODE>" generated image above,
the function generated fits the control points perfectly. Also as it generated
a "<A HREF="../option_link.cgi?fx" >-fx</A></CODE>" style formula it can be used
as is as an IM argument. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>

For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png    -fx "`cat fx_funct.txt`"     fx_funct_curve.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fx_funct_curve.png"
     ><IMG SRC="fx_funct_curve.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

To make it easier for users to magick control points into a histogram
adjustment function, I have created a shell script called "<CODE><A
HREF="../scripts/im_fx_curves" ><B>im_fx_curves</B></A></CODE>" to call
"<CODE>gnuplot</CODE>", and output a nicer looking polynomial equation of the
given the control points.  Gabe Schaffer, also provided a perl version (using a
downloaded "<CODE>Math::Polynomial</CODE>" library module) called "<CODE><A
HREF="../scripts/im_fx_curves.pl" ><B>im_fx_curves.pl</B></A></CODE>" to do
the same thing.  Either script can be used. </P>

For example here is a different curve with 5 control points...
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    im_fx_curves  0,0.2  0.3,0.7  0.6,0.5  0.8,0.8  1,0.6  > fx_curve.txt
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE NO_TXT2GIF>
  echo 0,0.2  0.3,0.7  0.6,0.5  0.8,0.8  1,0.6   |\
         perl -pe 's/ +/\n/g; s/,/ /g;'       > fx_curve_pts.txt
  im_histogram -d fx_curve_pts.txt  -t "Histogram Curve Fit" \
         -- "`sed 's/u/x/g; s/\^/**/g'  fx_curve.txt`"   fx_curve_plot
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5>
<TR VALIGN=middle><TD>
  <A HREF="fx_curve_plot.jpg"
     ><IMG SRC="fx_curve_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=right VSPACE=0 HSPACE=0 BORDER=1 ALT="[Gnuplot]"></A>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
  <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
  <TR><TD>
    <A HREF="fx_curve.txt"
       ><IMG SRC="fx_curve.txt.gif"
             ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[Gnuplot]"></A>
  </TD></TR></TABLE>
</TD></TR></TABLE>
</DIV></P>

However the FX function is very slow.  But as of IM 6.4.8-9 you can now
directly pass the discovered coefficients of the fitted polynomial expression
directly into a <A HREF="../transform/#function_polynomial" >Polynomial
Function Method</A>. </P>

You can generate the comma separated list of coefficients using "<CODE><A
HREF="../scripts/im_fx_curves" ><B>im_fx_curves</B></A></CODE>" with a
special '<CODE>-c</CODE>' option...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    im_fx_curves -c  0,0.2  0.3,0.7  0.6,0.5  0.8,0.8  1,0.6  > coefficients.txt
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5>
<TR VALIGN=middle><TD>
  <A HREF="fx_curve_plot.jpg"
     ><IMG SRC="fx_curve_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=right VSPACE=0 HSPACE=0 BORDER=1 ALT="[Gnuplot]"></A>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
  <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
  <TR><TD>
    <A HREF="coefficients.txt"
       ><IMG SRC="coefficients.txt.gif"
             ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[Gnuplot]"></A>
  </TD></TR></TABLE>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example lets apply those curves to our test image...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -function Polynomial `cat coefficients.txt`  test_curves.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="test_curves.png"
     ><IMG SRC="test_curves.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


A more practical example of this method is detailed in the advanced <A
HREF="../advanced/#aqua_effects" >"Aqua" Effects</A> example. </P>

An alternative away generating 'curves' is looked at in the IM Forum Discussion
<A HREF="../forum_link.cgi?f=1&t=22224&p=92056" >Arbitrary tonal reproduction
curves</A>. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="tinting"></A>
<H2>Tinting Images</H2>

<A NAME="colorize"></A>
<H3>Uniformly Color Tinting Images</H3>

Typically tinting an image is achieved by blending the image with a color by a
certain amount.  This can be done using an <A HREF="../transform/#evaluate"
>Evaluate Operator</A> or <A HREF="../compose/#blend" >Blend Images</A>
techniques, but these are not simple to use.</P>

Lucky for us a simpler method of bleeding an uniform color into an image is
available by using the "<CODE><A HREF="../option_link.cgi?colorize"
>-colorize</A></CODE>" image operator. This operator blends the current
"<CODE><A HREF="../option_link.cgi?fill" >-fill</A></CODE>" color,
into all the images in the current image sequence.  The alpha channel
of the original image is preserved, with only the color channels being
modified. </P>

For example lighten an image (gray scale or otherwise) we use "<CODE><A
HREF="../option_link.cgi?colorize" >-colorize</A></CODE>" to blend some amount
of white into the image, making it brighter without saturating the image
completely.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -fill white -colorize 50%  colorize_lighten.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="colorize_lighten.png"
     ><IMG SRC="colorize_lighten.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Similarly we can use a '<CODE>black</CODE>' fill color to darken an image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -fill black -colorize 50%  colorize_darken.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="colorize_darken.png"
     ><IMG SRC="colorize_darken.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

To gray both ends of the image toward the mid-tones, you would use a specific
gray fill color.  The color '<CODE>gray50</CODE>' is the exact middle color of
the RGB color spectrum.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -fill gray50 -colorize 40%  colorize_grayer.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="colorize_grayer.png"
     ><IMG SRC="colorize_grayer.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This is also often used as an method of 'de-contrast' such as what the <A
HREF="#level_plus" >Reverse Level Adjustment Operator</A> provides, though
with less control. </P>

The "<CODE><A HREF="../option_link.cgi?colorize" >-colorize</A></CODE>"
operator also allows you to specify dissolve percentages for each of the three
color channels separately.  This is useful for linearly darkening (or
lightening) an image in a special way. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Before IM v6.7.9 the "<CODE><A HREF="../option_link.cgi?colorize"
  >-colorize</A></CODE>" operator did not modify the alpha channel at all.
  From that version onwards, as you can see above, it now uniformly tints
  all pixels including fully transparent pixels.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

One common use of the "<CODE><A HREF="../option_link.cgi?colorize"
>-colorize</A></CODE>" operator is to simply replace all the colors in an
existing image (tinting '<CODE>100%</CODE>'), but preserve the transparency
(alpha) shape of the image, so as to produce a colored mask. However from
IM v6.7.9 you will need to protect the alpha channel from this operator
by disabling it, then re-enabling the alpha channel. (See <A
HREF="../masking/#alpha_on" >Alpha On</A> for more details). </P>

For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -alpha off \
          -fill blue -colorize 100% \
          -alpha on  colorize_shape.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="colorize_shape.png"
     ><IMG SRC="colorize_shape.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Without this protection, colorize would have fully-blanked the canvas to
the given color...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png -fill blue -colorize 100% colorize_blank.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="colorize_blank.png"
     ><IMG SRC="colorize_blank.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However if there is a posibility of using a verion of IM older than IM v6.7.9
I recommend you include a "<CODE>-alpha opaque</CODE>" or "<CODE>-alpha
off</CODE>" operation in the above to ensure the resulting image is the
completely blank image you expect. </P>

Note that you can blank canvases faster using <A HREF="#level-colors" >Level
Adjustments by Color</A> operator with a single color, rather than a range of
colors.  See also <A HREF="../canvas/#blank" >Blank Canvases</A>. </P>

<A NAME="tint"></A>
<H3>Midtone Color Tinting</H3>

While the <A HREF="#colorize" >Colorize operator</A> applies the "<CODE><A
HREF="../option_link.cgi?fill" >-fill</A></CODE>" color to tint all the colors
in an image linearly, the "<CODE><A HREF="../option_link.cgi?tint"
>-tint</A></CODE>" operator applies the "<CODE><A
HREF="../option_link.cgi?fill" >-fill</A></CODE>" color in such a way as to
only tint the mid-tone colors of an image. </P>

The operator is a grayscale operator, and the color is moderated or enhanced
by the percentage given (0 to 200).  To limit its effects it is also adjusted
using a mathematical formula so that it will not effect black and white.
but have the greatest effect on mid-tone colors of each color channel.</P>

A "<CODE>-tint 100</CODE>" essentially will tint a perfect gray color so that
it becomes half the intensity of the fill color.  A lower value will tint it
to a darker color while a higher value will tint it so toward a perfect match
of that color. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -fill red  -tint 40 tint_red.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="tint_red.png"
     ><IMG SRC="tint_red.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The green color in the test image is not a true RGB green, but a Scaled Vector
Graphics '<CODE>green</CODE>', which is only half as bright as a true green
color. As such it is also a mid-tone color, and thus is affected by the
"<CODE><A HREF="../option_link.cgi?tint" >-tint</A></CODE>" operator, becoming
darker, unlike red and blue color spots of the test image. </P>

Also you can tint the individual color components, by using a comma separated
list of percentages.  For example "<CODE>-tint 30,40,20,10</CODE>".  This
however can be tricky to use and may need some experimentation to get right.
Better to specify the color you want for perfect 50% grays.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  <!-- <CODE EXECUTE>
     im_histogram -t "Tint Vector Function" \
            '1-(4.0*((x-0.5)*(x-0.5)))' tint_plot
  </CODE> -->
  <A HREF="tint_plot.jpg"
     ><IMG SRC="tint_plot.gif"   WIDTH=150 HEIGHT=100
           ALIGN=right VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  The "<CODE><A HREF="../option_link.cgi?tint" >-tint</A></CODE>" operator
  works by somehow taking the color and percentages given then then adjusting
  the individual colors in the image according to the "<CODE><A
  HREF="../option_link.cgi?fill" >-fill</A></CODE>" colors intensity, as per
  the following formula.  (see graph right) </P>

  <DIV ALIGN=center><CODE>f(x)=(1-(4.0*((x-0.5)*(x-0.5))))</CODE></DIV> </P>

  A quadratic function, the result of which is used as vector for the existing
  color in the image.  As you can see gives a complete replacement of the color
  for a pure mid-gray, with no adjustment for either white or black.
  </P>

  Or lower level operators that you can use to DIY this sort of thing, see <A
  HREF="../transform/#fx" >FX Operator</A>, as well as <A
  HREF="../transform/#evaluate" >Evaluate and Function Operators</A>.
  </P>

</I></FONT></TD></TR></TABLE></P>

The tinting operator is perfect to adjust the results of the output of
"<CODE><A HREF="../option_link.cgi?shade" >-shade</A></CODE>", (See <A
HREF="../transform/#shade_overlay" >Shade Overlay Highlight Images</A>), such
as the examples in <A HREF="../advanced/#3d-bullets" >3d Bullet Images</A>.
</P>

You can also use "<CODE><A HREF="../option_link.cgi?tint" >-tint</A></CODE>"
to brighten or darken the mid-tone colors of an image. This is sort of like a
'gamma adjustment' for images, though not exactly. </P>

For example using a tint value greater than 100 with a '<CODE>white</CODE>'
color will brighten the mid-tones.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -fill white  -tint 130 tint_lighter.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="tint_lighter.png"
     ><IMG SRC="tint_lighter.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

While a value less than 100 will darken colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  -fill white  -tint 70 tint_darker.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="tint_darker.png"
     ><IMG SRC="tint_darker.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  At this time, the a pure mid-tone gray color will not be mapped to the
  "<CODE><A HREF="../option_link.cgi?fill" >-fill</A></CODE>" color. </P>

  The percentage argument is not a 'blend percentage' but really more
  a 'brightness percentage'.  It will for example not work at all for
  a 'black' fill color. </P>

  I do not know why it was designed this way or the history behind it. It does
  however make exact control of the final colors when tinting grayscale
  images, very awkward. </P>

  Using <A HREF="#tint_overlay" >Overlay Compostion Tinting</A> below will
  provide a more exact (though very linear, rather than parabolic) color
  tinting of mid-tone grays. </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="sepia_tone"></A>
<A NAME="sepia-tone"></A>
<H3>Sepia Tone Coloring</H3>

A special photographic recoloring technique, "<CODE><A
HREF="../option_link.cgi?sepia-tone" >-sepia-tone</A></CODE>" is basically
consists to converting the image into a gray-scale, and coloring all the
mid-tones to a special brown color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose:  -sepia-tone 65%     sepia-tone.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sepia-tone.jpg"
     ><IMG SRC="sepia-tone.jpg"          WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The argument given is the gray-scale 'mid-point' that is to become the closest
to the sepia-tone color, which is similar to the color
'<CODE>Goldenrod</CODE>'. </P>

The most common use of this is to generate a <A HREf="#duotone" >Duotone
Effect</A> so as to generate 'old looking' photos (See wikipedia on <A
HREF="http://en.wikipedia.org/wiki/Sepia_tone#Sepia_toning" >Sepia Tone</A>).
</P>

For example here I <A HREF="#tint" >Tint</A> a contrast enhanced gray-scale
rose image, using various colors, to achieve similar sepia-tone like effects.
Which color you should use on the exact effect you are looking for.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick rose: -colorspace gray -sigmoidal-contrast 10,40%  rose_grey.jpg
  for color in      goldenrod  gold  khaki  wheat
  do
    magick rose_grey.jpg  -fill $color   -tint 100    sepia_$color.jpg
  done
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rose_grey.jpg"
     ><IMG SRC="rose_grey.jpg"      WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="sepia_goldenrod.jpg"
     ><IMG SRC="sepia_goldenrod.jpg"      WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sepia_gold.jpg"
     ><IMG SRC="sepia_gold.jpg"           WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sepia_khaki.jpg"
     ><IMG SRC="sepia_khaki.jpg"          WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sepia_wheat.jpg"
     ><IMG SRC="sepia_wheat.jpg"          WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

I myself find that mixing or blending a sepia-tone image, with the original,
so as to reduce its effect can also produce a better 'faded' effect.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: \( +clone -sepia-tone 60% \) -average  sepia-tone_blended.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sepia-tone_blended.jpg"
     ><IMG SRC="sepia-tone_blended.jpg"          WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

See also <A HREF="#hald-clut" >Hald Color Lookup Tables</A> for a method by
which you can save much more complex color change variations, such as the last
example above. </P>


<A NAME="duotone"></A>
<H3>Duotone Effect</H3>

A 'duotone' is a printing method where you mix the grayscale of an image
(black ink) with some other color to produce a better result, with a limited
budget or printing equipment.  For example the reason all the old photos you
see today have a sepia-tone look about them, is because sepia-tone inks
survived and did not deteriorate, or fade with time.  Other 'black and white'
images formats faded into uselessness. See the <A HREF="#sepia-tone" >Sepia Tone
Operator</A> above.</P>

Another duotone technique known as 'Cyanotype' (more commonly known as
'blue-prints') became widely used as method of making large scale copies of
the original black and white architect drawings.  Remember this tenchique was
used long before the invention of lazers and from that photo-copying (and
Xerox). </P>

For more information see the Wikipedia entry for <A
HREF="http://en.wikipedia.org/wiki/Duotone" >Duotone</A>, also <A
HREF="http://thelawlers.com/Blognosticator/?p=592" >Fake duotones vs Real
duotones</A>. </P>

The above <A HREF="#tint" >Tint Operator</A> however produces a reasonable
facsimile of the duotone effect, just as it did for a sepia-tone like effect
above.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  magick rose: -colorspace gray -sigmoidal-contrast 10,40%  rose_grey.jpg
  for color in      blue  darkcyan  goldenrod  firebrick
  do
    magick rose_grey.jpg   -fill $color   -tint 100    duotone_$color.jpg
  done
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rose_grey.jpg"
     ><IMG SRC="rose_grey.jpg"            WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="duotone_blue.jpg"
     ><IMG SRC="duotone_blue.jpg"            WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="duotone_darkcyan.jpg"
     ><IMG SRC="duotone_darkcyan.jpg"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="duotone_goldenrod.jpg"
     ><IMG SRC="duotone_goldenrod.jpg"       WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="duotone_firebrick.jpg"
     ><IMG SRC="duotone_firebrick.jpg"       WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that I generally chose a darker version of the 'duotone' color, but you
can also adjust this using the argument of the <A HREF="#tint" >Tint
Operator</A>. The brightness and contrast can also be adjusted using the
arguments of the <A HREF="#sigmoidal-contrast" >Sigmoidal Contrast
Operator</A>. </P>

Another more exacting way of generating a duotone from three colors (the
black-point, mid-point and white-point colors) is to use a <A HREF="#clut"
>Color Lookup Table</A> (see below). </P>

Here is just a quick example where I create a very unusual duotone using the
colors  '<CODE>Black</CODE>', '<CODE>Chocolate</CODE>', and
'<CODE>LemonChiffon</CODE>' for the duotone. And yes the black-point color is
typically left black, which is why it is usally called <I>duo</I>-tone.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 1x1 xc:Black xc:Chocolate xc:LemonChiffon \
                                   +append     duotone_clut.gif
  magick -size 20x256 gradient: -rotate 90   duotone_clut.gif \
          -interpolate Bicubic -clut       duotone_gradient.gif
  magick rose_grey.jpg   duotone_clut.gif \
          -interpolate Bicubic -clut       rose_duotone.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="duotone_clut.gif"
     ><IMG SRC="duotone_clut.gif"         WIDTH=60 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="duotone_gradient.gif"
     ><IMG SRC="duotone_gradient.gif"         WIDTH=256 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="rose_grey.jpg"
     ><IMG SRC="rose_grey.jpg"            WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="duotone_clut.gif"
     ><IMG SRC="duotone_clut.gif"         WIDTH=60 HEIGHT=20
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rose_duotone.jpg"
     ><IMG SRC="rose_duotone.jpg"            WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The advantage of the above is an exact control of the mid-point color (unlike
<A HREF="#tint" >Tint</A> which isn't exact). You can also use any the three
colors you like directly, just as in the above example, or use an expanded
gradient of the colors for finer control of the colors between the three (or
more) control points. </P>

The technique also provides you with a very compact way of storing the
specific duotone effect, for repeated and future usage. </P>

Also see <A HREF="#hald-clut" >Hald Color Lookup Tables</A> for more complex
method of saving color changes, that go beyond coloring greyscale images. </P>


<A NAME="tint_diy"></A>
<H3>Color Tinting, DIY</H3>

One of the biggest problems with "<CODE><A HREF="../option_link.cgi?tint"
>-tint</A></CODE>" is that it is a grayscale (or vector) operator. That is, it
handles each of the red,green,blue channels completely separately to each
other.  That in turn means that a primary and secondary color like
'<CODE>blue</CODE>' or '<CODE>yellow</CODE>' are not affected by "<CODE><A
HREF="../option_link.cgi?tint" >-tint</A></CODE>", even though all the gray
levels are. </P>

However thanks to various channel mathematical transforms such as the
<A HREF="../transform/#fx" >FX Operator</A> and the faster <A
HREF="../transform/#evaluate"
>Evaluate and Function Operators</A>, you can generate your own color overlays
to modify the image.  That is, to <A HREF="#tint" >Tint</A> the image in a
similar what that the <A HREF="#colorize" >Colorize Operator</A> does. </P>

For example, here I magick an image's gray-scale brightness level into a
semi-transparent overlay of the specific color wanted.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png  \( +clone -colorspace gray \
               -function polynomial -4,4,0 -background Gold -alpha shape \) \
          -magick composite   tint_diy_compose.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tint_diy_compose.png"
     ><IMG SRC="tint_diy_compose.png"       WIDTH=150   HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Warning, this does not preserve image transparency correctly, but it will work
fine for fully-opaque images.</P>

Note that unlike tint, any color can be used, including '<CODE>black</CODE>'
as the color is not treated as a vector addition, but an alpha composition.
The result is not quite the same as what you would get for a normal tint.
</P>


<A NAME="tint_overlay"></A>
<H3>Color Tinting Overlay</H3>

The special <A HREF="../compose/#compose" >Alpha Composition</A> methods
'<CODE><A HREF="../compose/#overlay" >Overlay</A></CODE>' and '<CODE><A
HREF="../compose/#hardlight" >Hardlight</A></CODE>' were actually designed
with color (and pattern) tinting in mind.  These compose methods also will
replace mid-tone grays leaving black and white highlights in the image alone.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example here I quickly generate a colored overlay image, and compose it
to tint the original image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png \( +clone +matte -fill gold -colorize 100% \) \
          -compose overlay -magick composite  tint_overlay.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tint_overlay.png"
     ><IMG SRC="tint_overlay.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the alpha composition does not preserve any transparency of the
original image, requiring the use of a second alpha composition operation to
fix this problem.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png \
          \( +clone +matte -fill gold -colorize 100% \
             +clone +swap -compose overlay -magick composite \) \
          -compose SrcIn -magick composite  tint_overlay_fixed.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tint_overlay_fixed.png"
     ><IMG SRC="tint_overlay_fixed.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Using '<CODE><A HREF="../compose/#overlay" >Overlay</A></CODE>' is much more
linear form of tinting than the quadratic function used above, and like
"<CODE><A HREF="../option_link.cgi?tint" >-tint</A></CODE>" is applied to each
channel of the image separately such that primary and secondary colors are
also left unchanged. </P>

Also no adjustment control is provided by this alpha composition method, so if
you want to control the level of tinting, you will need to adjust the
overlay image transparency before applying the tint. </P>

Of course unlike the other tinting methods I have shown so far, you are not
limited to tinting a simple color, but can apply a tint using an image, or
tile pattern.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick test.png \
          \( -size 150x100 tile:tile_disks.jpg \
             +clone +swap -compose overlay -magick composite \) \
          -compose SrcIn -magick composite  tint_overlay_pattern.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tint_overlay_pattern.png"
     ><IMG SRC="tint_overlay_pattern.png"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This however is getting outside the scope of basic color handling so I'll
leave image tinting at that. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The alpha composition method '<CODE><A HREF="../compose/#hardlight"
  >HardLight</A></CODE>' will produce the same results as '<CODE><A
  HREF="../compose/#overlay" >Overlay</A></CODE>' but with the source and
  destination images swapped. </P>

  This could have been used instead of the "<CODE>+swap</CODE>" in the last
  few examples.
</I></FONT></TD></TR></TABLE></P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="color_mods"></A>
<H2>Global Color Modifiers</H2>

<A NAME="modulate"></A>
<H3>Modulate Brightness, Saturation, and Hue</H3>

The  "<CODE><A HREF="../option_link.cgi?modulate" >-modulate</A></CODE>"
operator is special in that it modifies an image in the special HSL
(hue-saturation-lightness) <A HREF="../color_basics/#colorspace"
>colorspace</A>.  It converts each color pixel in into this color space and
modifies it and converts it back to its original color space. </P>

It takes three values (though later values are optional) as a percentage such
that 100 will make no change to an image.  For example..

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -modulate 100,100,100  mod_noop.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="mod_noop.gif"
     ><IMG SRC="mod_noop.gif"     WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The first value, <I>brightness</I> is a multiplier of the images overall
brightness.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose:  -modulate 0     mod_bright_0.gif
  magick rose:  -modulate 50    mod_bright_50.gif
  magick rose:  -modulate 80    mod_bright_80.gif
  magick rose:  -modulate 100   mod_bright_100.gif
  magick rose:  -modulate 150   mod_bright_150.gif
  magick rose:  -modulate 200   mod_bright_200.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="mod_bright_0.gif"
     ><IMG SRC="mod_bright_0.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mod_bright_50.gif"
     ><IMG SRC="mod_bright_50.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mod_bright_80.gif"
     ><IMG SRC="mod_bright_80.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mod_bright_100.gif"
     ><IMG SRC="mod_bright_100.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=3 ALT="[IM Output]"></A>
  <A HREF="mod_bright_150.gif"
     ><IMG SRC="mod_bright_150.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mod_bright_200.gif"
     ><IMG SRC="mod_bright_200.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that while a brightness argument of '<CODE>0</CODE>' will produce a pure
black image, you cannot produce a pure white image using this operator on its
own. </P>

The second value <I>saturation</I> is also a multiplier adjusting the overall
amount of color that is present in the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose:  -modulate 100,0     mod_sat_0.gif
  magick rose:  -modulate 100,20    mod_sat_20.gif
  magick rose:  -modulate 100,70    mod_sat_70.gif
  magick rose:  -modulate 100,100   mod_sat_100.gif
  magick rose:  -modulate 100,150   mod_sat_150.gif
  magick rose:  -modulate 100,200   mod_sat_200.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="mod_sat_0.gif"
     ><IMG SRC="mod_sat_0.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mod_sat_20.gif"
     ><IMG SRC="mod_sat_20.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mod_sat_70.gif"
     ><IMG SRC="mod_sat_70.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mod_sat_100.gif"
     ><IMG SRC="mod_sat_100.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=3 ALT="[IM Output]"></A>
  <A HREF="mod_sat_150.gif"
     ><IMG SRC="mod_sat_150.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="mod_sat_200.gif"
     ><IMG SRC="mod_sat_200.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

A saturation of '<CODE>0</CODE>' will produce a grayscale image, as was also
shown in <A HREF="#grayscale" >Converting Color to Gray-Scale</A> above.  The
gray however mixes all three color channels equally, as defined by the HSL
colorspace, as such does not produce a true 'intensity' grayscale. </P>

Essentially small values produce more 'pastel' colors, while values larger
than '<CODE>100</CODE>' will produce more cartoon-like colorful images. </P>

Note that as the <I>brightness</I> and <I>saturation</I> are percentage
multipliers, you would need to multiply by a very large number to change
almost all the image color values to near maximum.  That is you would need to
use a <I>brightness</I> factor of close to one million, to make all colors
except pure black, white.</P>

<A NAME="modulate_hue"></A>
<H4>Hue Modulation</H4>

The final value, <I>Hue</I>, is actually much more useful. It rotates the
colors of the image, in a cyclic manner.  To achieve this the <I>Hue</I> value
given produces a 'modulus addition', rather than a multiplication. </P>

However be warned that the hue is rotated using a percentage, and not by an
angle.  This may seem weird but "<CODE><A HREF="../option_link.cgi?modulate"
>-modulate</A></CODE>" has always been that way. </P>

Conversion formulas between angle and the modulate argument is...
<DIV ALIGN=center>
<CODE><I>hue_angle</I> = ( <I>modulate_arg - 100</I> ) * 180/100</CODE> <BR>
<CODE><I>modulate_arg</I> = ( <I>hue_angle * 100/180</I> ) + 100</CODE>
</DIV></P>

That means '<CODE>100</CODE>' (for all three arguments) produces no change.
While a value of '<CODE>0</CODE>' or '<CODE>200</CODE>' will effectivally
negate the colors in the image (but not the intensity). </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose:  -modulate 100,100,0      mod_hue_0.gif
  magick rose:  -modulate 100,100,33.3   mod_hue_33.gif
  magick rose:  -modulate 100,100,66.6   mod_hue_66.gif
  magick rose:  -modulate 100,100,100    mod_hue_100.gif
  magick rose:  -modulate 100,100,133.3  mod_hue_133.gif
  magick rose:  -modulate 100,100,166.6  mod_hue_166.gif
  magick rose:  -modulate 100,100,200    mod_hue_200.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR valign="top"><TD ALIGN=center>
  <A HREF="mod_hue_0.gif"
     ><IMG SRC="mod_hue_0.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 0 <BR>(red &lt;-&gt; cyan) </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_hue_33.gif"
     ><IMG SRC="mod_hue_33.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 33.3 <BR>(red -&gt; blue) </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_hue_66.gif"
     ><IMG SRC="mod_hue_66.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 66.6 </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_hue_100.gif"
     ><IMG SRC="mod_hue_100.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=3 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 100% <BR> no-op </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_hue_133.gif"
     ><IMG SRC="mod_hue_133.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 133.3 </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_hue_166.gif"
     ><IMG SRC="mod_hue_166.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 166.6 <BR>(red -&gt; green) </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_hue_200.gif"
     ><IMG SRC="mod_hue_200.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 200 <BR> (same as 0) </FONT>
</TD></TR></TABLE>
</DIV></P>

As you can see a value of '<CODE>33.3</CODE>' produces a negative, or
counter-clockwise rotation of all the colors by approximately 60 degrees,
effectively mapping the red to blue, blue to green, and green to red. </P>

Using values of '<CODE>0</CODE>' or '<CODE>200</CODE>' produces a complete 180
degree negation of the colors, without negating the brightness of the image.
</P>

Note that hues are cyclic, as such using a value of '<CODE>300</CODE>' will
produce a 360 degree color rotation, and result in no change to the image.
</P>

For examples of using 'Hue Modulation' to modify colors in images see, <A
HREF="../photos/#chroma_key" >Chroma Key Masking</A> and <A
HREF="../layers/#layer_pins" >Pins in a Map</A>. </P>

<br/>

These types of operations and more can also be applied using advanced <A
HREF="../color_basics/#colorspace" >Color Space</A> techniques, such as using
in <A HREF="#recolor" >Recolor Matrix Operator</A> (below), but for basic
'modulation' of an image, this operator greatly simplifies things. </P>

For primary color swapping, either <A HREF="#recolor" >Recolor Matrix
Operator</A>, or channel swapping (see <A HREF="../color_basics/#combine"
>Separate/Combine Operators</A>), is probably more accurate technique. Though
it is much less versatile. </P>

See also <A HREF="#hald-clut" >Hald Color Lookup Tables</A> for a method by
which you can save color change variations, especially changes in Hue, for
later reuse. </P>

<A NAME="modulate_diy"></A>
<H4>Modulate DIY</H4>

You can if really want to "Do It Yourself". You basically magick the image
into the appropriate color space, modify the values, and magick back.
Remember that in HSL <A HREF="../color_basics/#colorspace" >Color Space</A>,
the Green channel holds the Saturation value, and the Blue channel holds the
Luminance value. </P>

For example here is the equivalent to a "<CODE>-modulate 80,120</CODE>"
(darken slightly, increase color saturation), using the default HSL
colorspace...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -colorspace HSL \
          -channel B -evaluate multiply 0.80 \
          -channel G -evaluate multiply 1.20 \
          +channel -colorspace sRGB   modulate_channel.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"            WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="modulate_channel.png"
     ><IMG SRC="modulate_channel.png"      WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Of course if you modify the Hue (red channel) using this method you will need
to ensure the final value 'wraps' around (a modulus), rather than simply
clipping the value at the maximum or minimum value (both of which is the 'red'
hue). As such it is probably easier to just directly use the <A
HREF="#modulate" >Modulate Operator</A>, for Hue modifications.


<A NAME="modulate_colorspace"></A>
<H4>Modulate in Other Colorspaces</H4>

The biggest problem with "<CODE><A HREF="../option_link.cgi?modulate"
>-modulate</A></CODE>" is when handing images containing a lot of 'near white'
colors.  As it does its work in HSL colorspace, colors that are off-white
will become more 'saturated' as the brightness is reduced.  You can see this
in the white leaf of the rose image above, which shows lots of color artifacts
at a 50% darkening. </P>

This is especially a problem when dealing with JPEG image formats, as it tends
to generate off-white colors (actually all colors are generally slightly off
in JPEG) due to its lossy compression algorithm.  For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick wedding_party_sm.jpg  -modulate 85  modulate_off-white.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/wedding_party_sm.jpg"
     ><IMG SRC="../img_photos/wedding_party_sm.jpg"        WIDTH=121 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="modulate_off-white.png"
     ><IMG SRC="modulate_off-white.png"      WIDTH=121 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The problem here is that in HSL all the off white colors were packed into
a small 'white point' area of the color space used (a double cone).  When
brightness is then reduced the off-white colors get expanded as the cone of
color expands, causing the off white color to generate a more colorful
(saturated) set of off-white colors.  That is, small variations in color are
exaggerated.  </P>

The solution to this is to "<CODE><A HREF="../option_link.cgi?modulate"
>-modulate</A></CODE>" in the HSB colorspace,
instead of HSL colorspace.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The 'B' in HSB, means Brigthness, but is also commonally known as HSV, with
  using 'V' meaning Value. They are the same colorspace, but 'V' is a
  confusing term, as a value normally means 'a stored number'. </P>

  There is also a HSI colorspace, (using 'I' of Intensity) but it is uncommon,
  and not needed due to the addition of the HCL (where 'L' means Luminance)
  cyclic colorspace (see below). </P>

</I></FONT></TD></TR></TABLE></P>

In the HSB colorspace, 'white' is not a single point, but a large 'disk', and
as such off-whites, are not 'close' to each other.  As such when you reduce
the brightness, the off-whites contract equally, reducing any slight color
variations rather than expanding them. As such the whites just become gray,
and not more colorful. </P>

To modulate the image in HSB <A HREF="../color_basics/#colorspace" >Color
Space</A> you can either use the DIY technique (see above) in that colorspace.
Or with IM v6.5.3-7 and later, you can <A HREF="../basics/#define" >Define an
Operational Control</A> of '<CODE>modulate:colorspace</CODE>' with one of the
'Hue' color spaces.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick wedding_party_sm.jpg \
          -define modulate:colorspace=HSB -modulate 85 \
          modulate_HSB.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="modulate_HSB.png"
     ><IMG SRC="modulate_HSB.png"      WIDTH=121 HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Other 'Hue' colorspaces is HWB, and HCL (see next section). </P>

Of course if you resized the image to this small size, an even better solution
is NOT to save the image to JPEG, which was the cause of the off-white values.
Better still don't save the image at all, until after you are finished, so you
can keep all the color values at the best in-memory <A
HREF="../basics/#quality" >quality</A> setting. </P>

The reason HSB colorspace is not used by default for modulate, is because if
you brighten an image in this colorspace the colors become more saturated, and
bolder, rather than the image becoming more brilliant and whiter. </P>

Here for example is a 150% brighten of the 'rose' image in the default HSL,
and a specified HSB colorspace, for comparison.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose:         -modulate 150        mod_bright_HSL.gif
  magick rose: -define modulate:colorspace=HSB \
                         -modulate 150        mod_bright_HSB.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE WIDTH=50%>
<TR><TD ALIGN=center>
  <A HREF="mod_bright_HSL.gif"
     ><IMG SRC="mod_bright_HSL.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR>HSL
</TD><TD ALIGN=center>
  <A HREF="mod_bright_HSB.gif"
     ><IMG SRC="mod_bright_HSB.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR>HSB
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Before IM v6.4.0-10 the "<CODE><A HREF="../option_link.cgi?modulate"
  >-modulate</A></CODE>" operator actually did use HSB color space rather than
  HSL colorspace. This was changed because of a bug report by an user about the
  above situation. </P>

  The point is for some images you are damned if you use HSL, and for other
  images you are damned if you use HSB colorspace.  It just depends on what
  you are attempting to do! </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="modulate_LCH"></A>
<A NAME="modulate_HCL"></A>
<H4>Modulate in LCHab and other Colorspaces</H4>

Hue modulation (in HSL or HSB colorpsace) is actually regarded as rather
crude.  These colorspaces do not take into account a more realistic intensity
of the colors.  As such rotating between the hues 'blue' and 'yellow' will
also generate very large brightness shifts.  See <A
HREF="http://en.wikipedia.org/wiki/HSL_and_HSV#Disadvantages" >Wikipedia:
Disadvantages to HSL Colorspace</A>.</P>

One alternative is to do a Luminance preserving rotation as described on the
<A HREF="http://www.graficaobscura.com" >Grafica Obscura</A> in the "Matrix
Operations" Paper.  This is complex as the color modifications are being done
as part of the operation, as a single calculated matrix operation that is
different depending on how much of a rotation is required.</P>

As of IM v6.8.4-7 the <A HREF="#modulate" >Modulate Operator</A> can also
handle the special colorspaces '<B><CODE>LCHab</CODE></B>' and
'<B><CODE>LCHuv</CODE></B>' which are Cylindrical (Hue-Chroma) forms the the
respective '<B><CODE>Luv</CODE></B>' and '<B><CODE>Lab</CODE></B>'
colorspaces. see <A
HREF="http://en.wikipedia.org/wiki/CIELUV#Cylindrical_representation"
>Wikipedia, Cylindrical LUV, or LCHuv colorspace</A> and <A
HREF="http://hclcolor.com/" >The HCL Colorspace</A> for more information. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The equivelent channels of '<B><CODE>LCHab</CODE></B>' and
  '<B><CODE>LCHuv</CODE></B>' colorspaces are reverse to those of the
  '<B><CODE>HCL</CODE></B>' and '<B><CODE>HCB</CODE></B>' colorspaces.  That
  is the 'grayscale' intensity equivelent is in the first ('red') channel and
  Hue is in the third ('Blue') channel of the image.
</I></FONT></TD></TR></TABLE></P>

For example we do some hue rotations for the red rose using
'<B><CODE>LCHab</CODE></B>' colorspace.  Compare these with the previous set
for the '<B><CODE>HSL</CODE></B>' colorspace above.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=mod_lch_0.gif>
  for i in   0 25 50 75 100 125 150 175;  do
    magick rose: -define modulate:colorspace=LCHab \
                            -modulate 100,100,$i     mod_lch_$i.gif
  done
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR valign="top"><TD ALIGN=center>
  <A HREF="mod_lch_0.gif"
     ><IMG SRC="mod_lch_0.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=7 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 0% &amp; 200%</FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_lch_25.gif"
     ><IMG SRC="mod_lch_25.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=7 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 25% <BR>(red-&gt;blue) </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_lch_50.gif"
     ><IMG SRC="mod_lch_50.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=7 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 50% </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_lch_75.gif"
     ><IMG SRC="mod_lch_75.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=7 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 75% </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_lch_100.gif"
     ><IMG SRC="mod_lch_100.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=7 BORDER=3 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 100% <BR> no-op </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_lch_125.gif"
     ><IMG SRC="mod_lch_125.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=7 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 125%</FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_lch_150.gif"
     ><IMG SRC="mod_lch_150.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=7 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 150% </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_lch_175.gif"
     ><IMG SRC="mod_lch_175.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=7 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> 175% </FONT>
</TD></TR></TABLE>
</DIV></P>

Note that the hues are spread out differently to the more traditional Hue
colorspaces. But more importantly, the intensity of the original image is
preserved. </P>

Because of this you will never cycle from a pure primary/secondary color to
another pure primary/secondary color, as none of these have the same
intensity.  The progression of colors over the hues does however flow more
smoothly with less sharp 'peaks' at the primary and secondary colors. </P>

Here is comparison of a simple hue rotation of red to blue for
'<CODE>LCHab</CODE>' verses the normal '<CODE>HSL</CODE>' colorspace (using
appropriate rotation percentages).

<DIV ALIGN=center>
<TABLE><TR valign="top"><TD ALIGN=center>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> Original </FONT>
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=13>
</TD><TD ALIGN=center>
  <A HREF="mod_lch_25.gif"
     ><IMG SRC="mod_lch_25.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=4 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> LCHab <BR> 25% </FONT>
</TD><TD ALIGN=center>
  <A HREF="mod_hue_33.gif"
     ><IMG SRC="mod_hue_33.gif"        WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <FONT SIZE=-2><BR> HSL/HSB <BR> 33.3% </FONT>
</TD></TR></TABLE>
</DIV></P>

Note how the blue is nowhere near as dark, but is a shade that better matches
the shade of the original image. </P>

For more information on HCL colorspace hues, see the examples on <A
HREF="../color_basics/#colorwheel_LCH" >The LCH Color Wheel</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Before  IM v6.8.4-7 you would have used the colorspace
  '<B><CODE>HCL</CODE></B>' (introduced IM v6.7.9-1).  This colorspace is
  exacty the same as '<B><CODE>LCHuv</CODE></B>' but with the channel order
  reversed (Hue stored in Red channel of the image, it was just teh way that
  colorspace is defined).  This meant you had to also swap the various
  channels around to allow the  <A HREF="#modulate" >Modulate Operator</A> to
  work correctly.  </P>

  The '<B><CODE>LCHab</CODE></B>' and '<B><CODE>LCHuv</CODE></B>' colorspaces
  order the channels in the same way as '<B><CODE>HSL</CODE></B>', so as to
  allow modulate to work properly, and directly on the colorsapce without
  requiring channel re-ordering. </P>

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Note that for very dark colors the '<B><CODE>LCHuv</CODE></B>' can generate
  color values with discontinuities.  This however should not happen for real
  images, only images generated directly in the cylindrical space. </P>
</I></FONT></TD></TR></TABLE></P>


<A NAME="recolor"></A>
<A NAME="color-matrix"></A>
<H3>Color Matrix Operator</H3>

The "<CODE><A HREF="../option_link.cgi?color-matrix"
>-color-matrix</A></CODE>" operator will recolor images using a matrix
technique.  That is to say you give it a matrix of values which represents
how to linearly mix the various color channel values of an image to produce
new color values. </P>

Typical usage is to provide the operator with 9 values, which form three
functions (rows) or three multipliers (columns).  As such the first three
numbers is the color formula for the red' channel. The next for 'green' and so
on

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -color-matrix ' 1 0 0
                                0 1 0
                                0 0 1 '   matrix_noop.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="matrix_noop.png"
     ><IMG SRC="matrix_noop.png"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Is equivalent to applying the equations...

<DIV ALIGN=center><TABLE>
<TR><TD><CODE>red'  </CODE><TD><CODE>=  1 * red  +  0 * green + 0 * blue</CODE>
<TR><TD><CODE>green'</CODE><TD><CODE>=  0 * red  +  1 * green + 0 * blue</CODE>
<TR><TD><CODE>blue' </CODE><TD><CODE>=  0 * red  +  0 * green + 1 * blue</CODE>
</TABLE></DIV></P>

In this particular case no change is made to the image. The matrix forms a
special array, known as an 'identity matrix'. </P>

By mixing up the rows you can use to swap the various channels around.  For
example here I swap the red and blue channel values.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -color-matrix ' 0 0 1
                                0 1 0
                                1 0 0 '  matrix_red_blue_swap.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="matrix_red_blue_swap.png"
     ><IMG SRC="matrix_red_blue_swap.png"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Or simply copy the red channel to the other two channels, to extract
or separate out the 'red channel' (Also see <A HREF="../color_basics/#separate"
>Separating Channel Images</A>)...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -color-matrix ' 1 0 0
                                1 0 0
                                1 0 0 '  matrix_red_channel.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="matrix_red_channel.png"
     ><IMG SRC="matrix_red_channel.png"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

or magick the image to gray-scale image using a 2/5/3 greyscale ratio
(See <A HREF="#grayscale" >Converting Color to Gray-Scale</A>)...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -color-matrix ' .2 .5 .3
                                .2 .5 .3
                                .2 .5 .3 '  matrix_grayscale.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="matrix_grayscale.png"
     ><IMG SRC="matrix_grayscale.png"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<BR>

You can use a larger matrix of up to a set of 6 rows and columns.  These
correspond to the channels:  '<CODE>Red</CODE>', '<CODE>Green</CODE>',
'<CODE>Blue</CODE>', '<CODE>Black</CODE>' (if set), '<CODE>Alpha</CODE>' (if
set), and a constant. </P>

Note the channels: '<CODE>Black</CODE>' and '<CODE>Alpha</CODE>'; must
still be provided if the matrix is that large, even though the value itself
may not be present or used. </P>

The last constant column is just a simple addition (or subtraction if
negative) to the formula.  The 6th row (if given) is simply ignored, and not
used. </P>

By default the 'matrix' definition follows the same structure as a
<A HREF="../morphology/#user" >User Defined Morphology/Convolution Kernel</A>
and is treated as being a 'square' kernel if no size geometry is specified.
The offset of the kernel is currently not used. </P>

The given 'array of values' is then overlaid on a larger '6x6 identity matrix'
(a diagonal of 1's) before being applied to the image.  This internal handling
means that you can actually simply the matrixvalue by only a few row of
numbers, rather than all of them. </P>

This is especially useful when you need to include the 'constant' in the
color calculations, or only want to modify one channel. </P>

For example invert (negate) the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -color-matrix '6x3: -1  0  0 0 0 1
                                     0 -1  0 0 0 1
                                     0  0 -1 0 0 1'  matrix_negate.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="matrix_negate.png"
     ><IMG SRC="matrix_negate.png"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Set all red channel values to maximum (using the 'constant')...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -color-matrix '6x1: 0,0,0,0,0,1'  matrix_red_max.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="matrix_red_max.png"
     ><IMG SRC="matrix_red_max.png"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Because of the overlay on the identity matrix, none of the other channel
values are effected, though they are still re-calculated internally. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Before IM v6.6.1-0, "<CODE><A HREF="../option_link.cgi?color-matrix"
  >-color-matrix</A></CODE>" was named "<CODE>-recolor</CODE>.
</I></FONT></TD></TR></TABLE></P>


<A NAME="color-matrix_examples"></A>
<H4>Color Matrix Examples</H4>

<B>Sepia Color</B>, or at least a linear form of that operation

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=matrix_sepia.png>
  magick rose: -color-matrix ' 0.393 0.769 0.189
                                0.349 0.686 0.168
                                0.272 0.534 0.131  ' matrix_sepia.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="matrix_sepia.png"
     ><IMG SRC="matrix_sepia.png"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<B>Vivid colors</B>, in a technique called  <A
HREF="http://www.reflectiveimages.com/digitalvelvia.htm" >Digital
Velvia</A>...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -color-matrix '  1.2 -0.1 -0.1
                                -0.1  1.2 -0.1
                                -0.1 -0.1  1.2 ' matrix_vivid.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="matrix_vivid.png"
     ><IMG SRC="matrix_vivid.png"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This matrix brightens each color channel while subtracting the colors from the
other channels, making colors more vivid in the RGB image.  This is not quite
the same as using <A HREF="#modulate" >Modulate</A> to increase an images
color saturation by 20%, but it is similar to it. </P>

<B>Polaroid Color</B>...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose: -color-matrix \
            '6x3:  1.438 -0.122 -0.016  0 0 -0.03
                  -0.062  1.378 -0.016  0 0  0.05
                  -0.062 -0.122 1.483   0 0 -0.02 ' matrix_polaroid.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="matrix_polaroid.png"
     ><IMG SRC="matrix_polaroid.png"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<I>Future: Hue rotations using a color matrix</I>...<BR>
Such as described on the
<A HREF="http://www.graficaobscura.com/matrix/index.html" >Grafica Obscura</A>
web page.</P>

<BR>

For more information on using a color matrix see...<UL>
<LI><A HREF="http://www.webwasp.co.uk/tutorials/218/tutorial.php#luminaries"
    >Color Matrix Filter  Adobe Flash Tutorial</A>
<LI><A HREF="http://www.c-sharpcorner.com/UploadFile/mahesh/Transformations0512192005050129AM/Transformations05.aspx"
    >Color Transformations and the Color Matrix</A>
<LI><A HREF="http://rainmeter.net/cms/Tips-ColorMatrixUnleased"
    >ColorMatrix Unleased</A>
<LI><A HREF="http://www.graficaobscura.com/matrix/index.html"
    >Grafica Obscura - Matrix Operations for Image Processing</A>
<LI><A HREF="http://www.m2osw.com/swf_struct_any_filter#swf_filter_colormatrix"
    >SWF Color Matrix Filter</A> (for hue rotate with luminance preservation)
</UL></P>

However be warned that most of these implementations use a <A
HREF="http://en.wikipedia.org/wiki/Transposed" >Diagonally Transposed</A> form
of the matrix, in which columns form the equation, instead of the rows. Or
involve fewer channels (smaller number of rows/columns). </P>


<A NAME="solarize"></A>
<H3>Solarize Coloring</H3>

To "<CODE><A HREF="../option_link.cgi?solarize" >-solarize</A></CODE>" an
image is to basically 'burn' the brightest colors black.  The brighter the
color, the darker the solarized color is.  This happens in photography when
chemical film is over exposed.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose:  -solarize 90%     solarize.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="solarize.jpg"
     ><IMG SRC="solarize.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Basically anything above the grayscale level given is negated. So if you give
an argument of '<CODE>0%</CODE>' you basically have a poor man's <A
HREF="#negate" >Negate Operator</A>. </P>

For example here is a faked "<CODE><A HREF="../option_link.cgi?solarize"
>-solarize</A></CODE>" using a "<CODE><A HREF="../option_link.cgi?fx"
>-fx</A></CODE>" mathematical formula.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose:  -fx  '.9>u ? u : 1-u'     solarize_fx.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="solarize_fx.jpg"
     ><IMG SRC="solarize_fx.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This operator is particularly well suited to extracting the midtone gray
colors from images. </P>

For example here I use very strong <A HREF="#sigmoidal" >Sigmoidal
Contrast</A> operation to produce a sort of 'fuzzy' threshold at 70% gray.  I
then <A HREF="#solarize" >Solarize</A> the result to generate a fuzzy-spike
rather than a fuzzy-threshold.  A final level adjustment then brings the spike
to maximum brightness to generate a 'filament' effect.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 10x300 gradient: -rotate 90 \
                         -sigmoidal-contrast 50x70%   fuzzy_thres.png
  magick fuzzy_thres.png  -solarize 50%   fuzzy_spike.png
  magick fuzzy_spike.png  -level 0,50%    filament.png
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  im_profile -s fuzzy_thres.png fuzzy_thres_pf.gif
  im_profile -s fuzzy_spike.png fuzzy_spike_pf.gif
  im_profile -s filament.png filament_pf.gif
</CODE> -->
  <A HREF="fuzzy_thres_pf.gif"
     ><IMG SRC="fuzzy_thres_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="fuzzy_spike_pf.gif"
     ><IMG SRC="fuzzy_spike_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="filament_pf.gif"
     ><IMG SRC="filament_pf.gif"   WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<FONT SIZE=-1><I>ASIDE:</I> The above images showing 'profile' graphs of the
gradient, was generated using the "<CODE><A HREF="../scripts/im_profile"
>im_profile</A></CODE>" in the IM Examples, <A HREF="../scripts/" >Scripts</A>
directory. </FONT></P>

Note how anything that is white becomes black, while the mid-tone grays around
the central spike are preserved.  The fuzziness and placement of the spike is
determined by the "<CODE><A HREF="../option_link.cgi?sigmoidal-contrast"
>-sigmoidal-contrast</A></CODE>" operator. </P>

I call it a 'filament' as typically the result looks remarkably like glowing
electrical filaments, or lightning discharges.  See <A
HREF="../canvas/#random_flux" >Random Flux</A> for another example of this
effect.  </P>

This extraction of mid-tone grays is also put to good use in techniques for
generating <A HREF="../transform/#edge_bitmap" >Edge Outlines from Bitmap
Shapes</A>, and for the <A HREF="../transform/#math_multiply" >multiplication
of two biased gradients</A>. </P>

Another novel use of this operation is in determining if an image is basically
a pure black and white sketch or drawing (such as from a book), rather than a
shaded gray-scale or color images, See <A HREF="../compare/#type_bw"
>Determining if an image is: Pure Black and White, or Gray-scale</A> </P>



<HR><!-- ---------------------------------------------------------------- -->

<A NAME="color_lut"></A>
<H2>Recoloring Images with Lookup Tables</H2>

While you can recolor images using the various histogram color adjustments as
shown above, there is another technique for recoloring images, simply by
'looking up' the modified values from a pre-prepared color gradient, or
"Color Look Up Tables" (Color LUT, or CLUT). </P>

There are two types of Color LUT's: simple one dimensional or 'per-channel'
LUT's and 3d color LUT's. </P>

A channel LUT has three independent look-up tables: one each for the R G and
B channels. Each entry in the channel LUT maps an input channel value to an
output channel value. The red channel of the output image is only effected by
the original red value of the input image. </P>

A 3D color LUT however allow the whole color to be replaces as a function of
the whole input color.  That is the output value of the red channel can be
dependent on any or all of the input red, green, and blue values. This is
sometimes called channel cross-talk. </P>

<A NAME="clut"></A>
<H3>Color (Channel) Lookup Tables</H3>

A common requirement of an image processing tool is the ability to replace the
whole range of colors, from a pre-prepared table of colors.  This allows you
to magick images of one set of colors (generally gray-scale) into completely
different set of colors, just by looking up its replacement color from a
special image. </P>

Of course you do need a 'Look Up Table' image from which to read the
replacement colors.  For these first few examples, I choose to use a vertical
gradient of colors for the LUT so that the IM "<CODE><A
HREF="../canvas/#gradient" >gradient:</A></CODE>" generator can be used to
simplify the generation of the 'color lookup table'.  </P>

Well so much for the theory. Let try it out by recoloring a simple <A
HREF="../canvas/#plasma_grayscale" >gray-Scale Plasma</A> image, replacing the
grayscale with a dark-blue to off-white gradient of colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<r>  magick -size 100x100 plasma:fractal -virtual-pixel edge -blur 0x5 \
          -shade 140x45  -normalize \
          -size 1x100 xc:black -size 9x100 gradient: \
          +append  gray_image.jpg
  magick -size 10x100  gradient:navy-snow       gradient_ice-sea.png
  magick gray_image.jpg  gradient_ice-sea.png -clut  gray_recolored.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gray_image.jpg"
     ><IMG SRC="gray_image.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="gradient_ice-sea.png"
     ><IMG SRC="gradient_ice-sea.png"   WIDTH=10 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="gray_recolored.jpg"
     ><IMG SRC="gray_recolored.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The "<CODE><A HREF="../option_link.cgi?clut" >-clut</A></CODE>" operator
takes two images. The first is the image to replace color values in, the
second is a gradient image that is either a single row, or a single column.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The "<CODE><A HREF="../option_link.cgi?clut" >-clut</A></CODE>" operator was
  added to IM v6.3.5-8.
</I></FONT></TD></TR></TABLE></P>

If your IM is too old to understand the "<CODE><A
HREF="../option_link.cgi?clut" >-clut</A></CODE>" operator or you want to do
something out of the ordinary, such as a 2 dimensional color lookup table,
then you can roll your own using the <A HREF="../transform/#fx" >General DIY
Operator, FX</A>. For example here is a slow, but equivalent command to the
above.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD width="100%" ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 width="100%" BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gray_image.jpg  gradient_ice-sea.png \
          -fx 'v.p{0,u*v.h}'  gray_recolored_fx.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gray_recolored_fx.jpg"
     ><IMG SRC="gray_recolored_fx.jpg"    WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The problem is that even for a simple process such as the above the "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" operator is very slow, and has
to be designed specifically for either a row or column LUT.  But it does work.
</P>

The LUT does not have to be very large. For example here we use a very small
LUT, with a very limited number of colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 1x6 gradient:navy-snow  gradient_levels.png
  magick gray_image.jpg  gradient_levels.png  -clut  gray_levels.jpg
</CODE></PRE></TD></TR></TABLE>
<!-- <CODE EXECUTE>
  magick gradient_levels.png -scale 16x100\! gradient_levels_mag.png
-->
  <A HREF="gray_image.jpg"
     ><IMG SRC="gray_image.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="gradient_levels.png"
     ><IMG SRC="gradient_levels_mag.png"   WIDTH=16 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="gray_levels.jpg"
     ><IMG SRC="gray_levels.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

I enlarged the gradient image for the web page magick display above, otherwise it
would be too small to see properly. The LUT is in actual fact only 6 pixels in
size.  However if you look at the result you will see that the Color Lookup
Operator smooths out those 6 colors into a smooth gradient. </P>

What is happening is that IM is doing an <A HREF="../misc/#interpolate"
>Interpolated Lookup</A> of the LUT image.  That is, instead of just picking
the color found, it does a weighted average of all the nearby colors to better
represent the LUT.  In this particular case, it used the default '<CODE><A
HREF="../misc/#bilinear" >Bilinear</A></CODE>' setting that just links each
colored pixel together with linear line segments. </P>

Different "<CODE><A HREF="../option_link.cgi?interpolate"
>-interpolate</A></CODE>" settings generate different levels of smoothing of
the colors when using a very small color LUT.  Here for example I show a
various type of interpolated smoothing of the LUT colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick gray_image.jpg  gradient_levels.png \
          -interpolate Integer         -clut  gray_levels_integer.jpg
  magick gray_image.jpg  gradient_levels.png \
          -interpolate NearestNeighbor -clut  gray_levels_nearest.jpg
  magick gray_image.jpg  gradient_levels.png \
          -interpolate Average         -clut  gray_levels_average.jpg
  magick gray_image.jpg  gradient_levels.png \
          -interpolate Blend           -clut  gray_levels_blend.jpg
  magick gray_image.jpg  gradient_levels.png \
          -interpolate BiLinear        -clut  gray_levels_bilinear.jpg
  magick gray_image.jpg  gradient_levels.png \
          -interpolate Catrom          -clut  gray_levels_catrom.jpg
  magick gray_image.jpg  gradient_levels.png \
          -interpolate Spline          -clut  gray_levels_spline.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0><TR valign="top"><TD ALIGN=center>
  <A HREF="gray_levels_integer.jpg"
     ><IMG SRC="gray_levels_integer.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Integer
</TD><TD ALIGN=center>
  <A HREF="gray_levels_nearest.jpg"
     ><IMG SRC="gray_levels_nearest.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Nearest
</TD><TD ALIGN=center>
  <A HREF="gray_levels_average.jpg"
     ><IMG SRC="gray_levels_average.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Average
</TD><TD ALIGN=center>
  <A HREF="gray_levels_blend.jpg"
     ><IMG SRC="gray_levels_blend.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Blend
</TD><TD ALIGN=center>
  <A HREF="gray_levels_bilinear.jpg"
     ><IMG SRC="gray_levels_bilinear.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>BiLinear
</TD><TD ALIGN=center>
  <A HREF="gray_levels_catrom.jpg"
     ><IMG SRC="gray_levels_catrom.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Catrom
</TD><TD ALIGN=center>
  <A HREF="gray_levels_spline.jpg"
     ><IMG SRC="gray_levels_spline.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Spline
</TD></TR></TABLE>
</DIV></P>

The '<CODE><A HREF="../misc/#integer" >Integer</A></CODE>' and '<CODE><A
HREF="../misc/#nearest" >Nearest</A></CODE>' settings are
special in that they do no smoothing colors at all.  That is, no new 'mixed
colors' will be added, <I>only</I> the exact color values present will be used
used to color a grayscale image.  However note how the lookup of the colors
differ between the two.  It is a subtle difference but can be very important.
</P>

The '<CODE><A HREF="../misc/#average" >Average</A></CODE>' setting on the
other hand also generated bands of color but only using a mix of the colors,
resulting in one less color than the size of the color lookup table image.
'<CODE><A HREF="../misc/#blend" >Blend</A></CODE>' however mixes '<CODE><A
HREF="../misc/#average" >Average</A></CODE>' and '<CODE><A
HREF="../misc/#nearest" >Nearest</A></CODE>' together, to add more pixels.
</P>

This type of color 'banding' (or <A HREF="../filter/#blocking" >Blocking
Artefacts</A>) is actually rather common for geographic maps, and temperature
graphs, as it gives a better representation of the exact shape of the map.
The sharp boundary edges are known as iso-lines.  Adding a slight one pixel
<A HREF="../blur/#blur" >Blur</A> to the final image can improve the look
of those edges, making it look a little smoother, without destroying the color
banding. </P>

The '<CODE><A HREF="../misc/#bilinear" >BiLinear</A></CODE>' setting will also
generate banding but only in the form of sharp gradient changes, when the
colors change sharply (not in this example). While '<CODE><A
HREF="../misc/#catrom" >Catrom</A></CODE>' will smooth out the color changes.
Finally '<CODE><A HREF="../misc/#spline" >Spline</A></CODE>' will blur the
colors, and may not generate any of the colors in the given CLUT. </P>

To avoid interpolation problems, or better define the color gradients, the
best idea is to use much longer LUT.  Ideally this should cover the full range
of possible intensity values.  For ImageMagick Q16 (compiled with 16 bit
quality) that requires a LUT to have a height of 65536 pixels. But <A
HREF="../misc/#interpolate" >Pixel Interpolation</A> allows you to use a more
reasonable LUT gradient image of 500 pixels suitable for most image
re-coloring tasks.  </P>

Note that the vertical gradient LUT used in the above examples appears
upside-down to our eyes, as the black or '<CODE>0</CODE>' index is at the top
of the image.  Normally we humans prefer to see gradients with the black level
at the bottom (thanks to our evolutionary past). </P>

If you rather save the gradient image the 'right way up' you can "<CODE><A
HREF="../option_link.cgi?flip" >-flip</A></CODE>" the image as you reading it
in.  For example lets try a more complex LUT, flipping the vertical gradient
before using it on the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 1x33 gradient:wheat-brown gradient:Brown-LawnGreen \
          gradient:DodgerBlue-Navy   -append  gradient_planet.png
  magick gray_image.jpg \
          \( gradient_planet.png -flip \) -clut   gray_planet.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gray_image.jpg"
     ><IMG SRC="gray_image.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="gradient_planet.png"
     ><IMG SRC="gradient_planet.png"   WIDTH=10 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="gray_planet.jpg"
     ><IMG SRC="gray_planet.jpg"   WIDTH=110 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see for a vertical gradient, flipping it before using makes
a lot of sense. </P>

For more examples of generating gradients see  <A HREF="../canvas/#gradient"
>Gradients of Color</A>. </P>

You may also be interested in a way of tiling greyscale images using an image
for each grey level, which can produce even better 'map' like images.  See <A
HREF="../quantize/#diy_symbols" >Dithering with Patterns</A>. </P>


<A NAME="fx_to_lut"></A>
<H3>Function to Color LUT Conversion</H3>

These pre-prepared "Lookup Table Images" (or LUTs) can also be used to greatly
increase the speed of very complex and thus slow "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" operations, so instead of IM
interpreting the functional string 3 or 4 times per pixel, it can do a much
faster lookup of the replacement color. </P>

The procedure for doing this is quite straight forward, either apply the
function to an unmodified linear gradient, or replace the '<CODE>u</CODE>' in
the function with the value '<CODE>(i/w)</CODE>' or '<CODE>(j/h)</CODE>' to
calculate the replace value based on its position.  </P>

For example, in the advanced <A HREF="../advanced/#aqua_effects" >'Aqua'
Effects</A> example, I used a complex "<CODE><A HREF="../option_link.cgi?fx"
>-fx</A></CODE>" function to adjust the gray-scale output of the <A
HREF="../transform/#shade" >Shade operator</A>".  Also as this gray-scale
adjustment is also overlaid onto a 'DodgerBlue' shape, there is no reason why
the results of both of these operators could not be combined into a single
gradient lookup table.  </P>

That is, we generate a LUT from the  "<CODE><A HREF="../option_link.cgi?fx"
>-fx</A></CODE>" formula and the color overlay. Also for these examples
I decided to generate a single row of pixels rather than a column as I did
previously.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 1x512 gradient: -rotate 90 +matte \
          -fx '3.5u^3 - 5.05u^2 + 2.05u + 0.3' \
          -size 512x1 xc:DodgerBlue -compose Overlay -magick composite \
          aqua_gradient.png
</CODE></PRE></TD></TR></TABLE>
   <A HREF="aqua_gradient.png"
      ><IMG SRC="aqua_gradient.png"   WIDTH=512 HEIGHT=10
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The polynomial  "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>"
  in the above can now be generated more directly and faster using a <A
  HREF="../transform/#function_polynomial" >Polynomial Function</A>.

  For example
  <PRE>"<A HREF="../option_link.cgi?function"
  >-function</A> Polynomial 3.5,-5.05,2.05,0.3"</PRE>

</I></FONT></TD></TR></TABLE></P>

This pre-generated LUT can now be applied to the shaded shape much more
quickly at the minimal cost of storing a very small image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -font Candice -pointsize 72 -background None label:A \
          -trim +repage  aqua_mask.png
  magick aqua_mask.png -alpha Extract -blur 0x6 -shade 120x21 \
          -alpha On -normalize  aqua_shade.png
  magick aqua_shade.png  aqua_gradient.png -clut aqua_font.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="aqua_mask.png"
     ><IMG SRC="aqua_mask.png"
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="aqua_shade.png"
     ><IMG SRC="aqua_shade.png"
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="aqua_font.png"
     ><IMG SRC="aqua_font.png"
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
<BR><FONT SIZE=-2>
        WARNING: the above is incomplete (edges have not been darkened)
</FONT></DIV>

As you can see, the result is very effective, and once an appropriate LUT
gradient has been generated, you can re-use the same gradient over and over,
as many times as you want. </P>


<A NAME="clut_alpha"></A>
<H4>CLUT and Transparency Handling</H4>

The "<CODE><A HREF="../option_link.cgi?clut" >-clut</A></CODE>" operator is
controlled by the "<CODE><A HREF="../option_link.cgi?channel"
>-channel</A></CODE>" setting, but in reality, it only replaces the individual
channel values within the image. </P>

That means that normally each individual channel of the source image is used
to 'lookup' the replacement value for just that channel from the color lookup
table.  That includes the alpha channel which is usually very
inconvenient, and difficult to apply. </P>

Typically the "<CODE><A HREF="../option_link.cgi?clut" >-clut</A></CODE>"
operator is used to either colorize a gray-scale source image, (see previous
examples), OR it is used to do a histogram adjustment of a color image using a
gray-scale CLUT (Color Lookup Table).  In other words, usually one of the
images will typically be gray-scale. </P>

As of IM v6.4.9-8, if a "<CODE><A HREF="../option_link.cgi?channel"
>-channel</A></CODE>" setting specifies that if you are wanting to
replace/adjust the alpha channel of an image (an '<CODE>A</CODE>' is present),
and either the 'source' image or 'CLUT' image has no alpha channel
defined, then IM will assume that that image is gray-scale, and will act
accordingly.  </P>

For example, here I generate a simple blurred triangle, as a grey-scale image.
I can then color using a Color Lookup Table that includes transparency.  I did
not flip the CLUT image this time, so the black replacement will be at the top
and white replacement at the bottom.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 100x100 xc:  -draw 'polygon 50,10 10,80 90,80' \
          -blur 0x10  blurred_shape.jpg
  magick -size 1x5 xc:none \
          -draw 'fill red    point 0,2' \
          -draw 'fill yellow rectangle 0,0 0,1'   gradient_border.png
  magick blurred_shape.jpg -alpha off    gradient_border.png \
          -channel RGBA  -interpolate integer -clut  clut_shape.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="blurred_shape.jpg"
     ><IMG SRC="blurred_shape.jpg"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="gradient_border.png"
     ><IMG SRC="gradient_border.png"   WIDTH=10 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="clut_shape.png"
     ><IMG SRC="clut_shape.png"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Remember the above will only work as expected if the gray-scale image has no
alpha channel (turned off using either "<CODE><A
HREF="../option_link.cgi?alpha" >-alpha</A> off</CODE>" or "<CODE><A
HREF="../option_link.cgi?matte" >+matte</A></CODE>"), and you specify that you
also want to lookup alpha channel values (using "<CODE><A
HREF="../option_link.cgi?channel" >-channel</A> RGBA</CODE>"). </P>

And here is the other special case where were have an image with transparency
(and alpha channel) that needs to be adjusted using a gray-scale histogram
adjustment gradient (with no alpha channel enabled). </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick -size 100x100 xc:none -draw 'polygon 50,10 10,80 90,80' \
          tile_disks.jpg -compose In -magick composite shape_triangle.gif
  magick shape_triangle.gif -channel A -blur 0x10 +channel shape_blurred.png
  magick -size 1x50 gradient: xc:black -append -flip \
          -sigmoidal-contrast 6x0%  feather_histogram.jpg
  magick shape_blurred.png \( feather_histogram.jpg -alpha off \) \
          -channel A    -clut    shape_feathered.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="shape_triangle.gif"
     ><IMG SRC="shape_triangle.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=8 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="shape_blurred.png"
     ><IMG SRC="shape_blurred.png"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="feather_histogram.jpg"
     ><IMG SRC="feather_histogram.jpg"   WIDTH=10 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="shape_feathered.png"
     ><IMG SRC="shape_feathered.png"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The above is a typical <A HREF="../blur/#feathering" >Image Feathering</A>
problem.  The 'black' halo in the intermediate image is caused by the
"<CODE><A HREF="../option_link.cgi?blur" >-blur</A></CODE>" operation making
the fully-transparent areas surrounding the triangle visible. As
fully-transparent has an undefined color, IM defaults to black.  The CLUT
image itself was designed to ensure that any pixel that was less than 50%
transparent will be turned fully-transparent, effectively making the
previously fully transparent parts of the image, transparent again. </P>

For this example I over-do the initial 'blur', then over-correct the alpha
channel adjustment.  The result is a sever rounding of the points of the
triangle.  For normal image feathering would typically use much smaller values
for both the "<CODE><A HREF="../option_link.cgi?blur" >-blur</A></CODE>" and
the "<CODE><A HREF="../option_link.cgi?sigmoidal-contrast"
>-sigmoidal-contrast</A></CODE>" alpha adjustment. </P>

<A HREF="http://www.fmwconcepts.com/imagemagick/" >Fred Weinhaus</A>, has
implemented a blurred feathering technique in his "<A
HREF="http://www.fmwconcepts.com/imagemagick/feather/" >feather</A>" script,
to make it easier to use. </P>


<A NAME="hald-clut"></A>
<H3>Hald 3D Color Lookup Tables</H3>

As of IM v6.5.3-4 you can now also use a full 3D Color Lookup Table which can
be used to directly replace all the colors of multiple images.  That is,
instead of just looking up the value of each each color channel as a separate
entity (as in the <A HREF="#clut" >CLUT</A> above), the whole color is used to
lookup the new color. </P>

However a 3D color tables usually require special file formats to correct
store the 3D array of color values.  However by using a special arrangement of
color values the 3D table can be stored into a 2D image known as a <B>Hald
Color LUT</B>.  This is just a normal image and as such ANY good image file
format can be used to save a Hald 3D Color LUT.  </P>

For more details and examples of HALD Images, see the official website <A
HREF="http://www.quelsolaar.com/technology/clut.html" >Hald Images, Clut
Technology</A>. </P>

To generate a Hald 3D color table, use the '<CODE>HALD:{<I>level</I>}</CODE>'
image generator.  For example, here is a small one that I have enlarged so
you can see the individual pixels...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick  hald:3    hald_3.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="hald_3_lg.png"
     ><IMG SRC="hald_3_lg.png"   WIDTH=189 HEIGHT=189
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!--<CODE EXECUTE> enlarge_image -7 hald_3.png hald_3_lg.png </CODE>-->

The table holds a color cube with a side of
'<CODE>{<I>level</I>}<SUP>2</SUP></CODE>' colors or 9 colors.  The full color
cube contains '<CODE>9 &times; 9 &times; 9</CODE>' colors, giving a total of
729 colors, which is stored in an image of that numbers square root, or 27x27
pixels. </P>

The colors are stored so the first 9 colors (in the top-left corner) forms
a gradient going from 'pure-black' to 'pure-red'. Every 9<SUP>th</SUP> color
then forms a gradient in 'green', and every 81<SUP>st</SUP> color will form
a gradient of 'blue'.  The last color in the bottom-right corner is
'pure-white'.  You can think of the image as an even simpler 1D array of
pixels that are referenced as a 3D color cube, if it helps you to imagine it.
</P>

Now this is only a small HALD CLUT image.  More typically you would use at
least a level 8 Hald (<I>the default</I>), which will hold a color cube with
64 colors per side, or 64^3 = 262144 colors, and produce an image that is
512x512 pixels in size. and saves into into an approximate 10Kbyte PNG image.
This is not all 8 bit colors but is quite good. </P>

For a HALD image with every 8 bits color, you would need a level 16 version,
producing a 4096x4096 image. Whcih just does to prove that even normal digital
camera images generally can not hold every posible 8 bit color. </P>

However a smaller Hald image can be used, as IM will interpolate the
neighbouring 8 colors from the Hald to work out the final color for the lookup
replacement.  It will simply not be as good a representation as a larger
version. Hald images larger than 8 are not recommended, and would require very
large images, of at least 16 bits per value depth to hold it.</P>

Now these generated hald images are the 'identity' or 'no-op' CLUT images.
That is, they are the normal colors values forming the 3D color cube, and as
such will produce no change the image.  For example lets apply a 'no-op' Hald
image, using the  "<CODE><A HREF="../option_link.cgi?hald-clut"
>-hald-clut</A></CODE>" operator...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick rose:  hald_3.png -hald-clut   rose_hald_noop.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="hald_3.png"
     ><IMG SRC="hald_3.png"   WIDTH=27 HEIGHT=27
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rose_hald_noop.png"
     ><IMG SRC="rose_hald_noop.png"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!-- <CODE EXECUTE ASSERT>
  [ `magick compare -metric PAE rose: rose_hald_noop.png null: 2>&1 |
               sed 's/ .*//'` != '0' ] && echo >&2 \
    "ASSERTION FAILURE: Noop Hald CLUT made a chnage to the image\!"
</CODE> -->

This image is exactly the same as the original, and the Hald image contained
no changes. </P>

However by modifying the Hald image, either by hand, or using a color
modification, then you can substitute the original colors for the modified
colors.  For example here I create a blended-sepia-tone color scheme...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick hald_3.png \( +clone -sepia-tone 60% \) -average hald_sepia.png
  magick rose.png   hald_sepia.png -hald-clut   rose_hald_sepia.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="hald_sepia.png"
     ><IMG SRC="hald_sepia.png"   WIDTH=27 HEIGHT=27
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="rose_hald_sepia.png"
     ><IMG SRC="rose_hald_sepia.png"   WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Of course if you can apply a specific color modification to a Hald image, you
can also apply it to the actual image directly too.  But you can now save your
color modifications to reuse them, and can then be applied as many times as
like.  That means you can spend your effort on the halt, and save it for the
future. </P>

You can also send, or download Hald CLUT images for other people and even
other applications.  You could even directly edit the colors in a Hald, using
an image editor like "<CODE>Gimp</CODE>" or "<CODE>Photoshop</CODE>", or if
saved in a <A HREF="../files/#txt" >Enumerated Pixel Text Image</A> use a
plain text editor!  All this is especially the case for very complex color
modifications </P>


<I>Please mail me any Hald CLUT images you have found interesting or useful,
and I will example them here.  You will be credited, here as well!</I> </P>

<A NAME="hald_limits"></A>
<H4>Hald CLUT Limitations</H4>

Unlike the simpler 1 Dimensional gradient lookup using the <A HREF="#clut"
>CLUT Operator</A> you can use a Hald CLUT to rotate colors. For example swap
red and blue colors.  It is a much more versatile CLUT method.  However it is
not as good for doing simpler things like coloring a gray-scale image, or
doing a histogram adjustment of color values. </P>

It can also replace colors with transparent, or semi-transparent values, by
saving such replacement colors in the Hald CLUT image.  However this
replacement lookup is by color only.  You cannot use it to replace
transparent colors in specific ways. It isn't after all a 4D color lookup
hyper-cube! </P>


<A NAME="hald_replacement"></A>
<H4>Color Replacement using Hald CLUT</H4>

Now as the whole color value is used to lookup the color replacement, you
could also use this as a method of directly replacing all the colors in an
image with some other color. </P>

However as IM currently does a linear interpolated lookup of the Hald, you
will need to set the replacement color in all 8 neighbouring color cells of
the 3D color cube. </P>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<I>This needs more work, and may need a 'nearest-neighbour' Hald Lookup
setting (say using -interpolate), rather than a 3D linear interpolated lookup
to work better for specific color replacement.  Also some easy way of locating
specific colors in a Hald (nearest-neighbour, or the 8 neighbours) would make
this a lot easier.  </I></P>

<I>If you have ideas, suggestions, or better still small examples, then please
contribute by mailing them to me, or the IM Discussion Forums</I> </P>


Another idea is that if you have two images, the original and the converted,
then it should be possible to fill-in a Hald CLUT image from the comparison of
the two images.  When the immediate colors have been filled in the rest of the
color cube should be able to be at least roughly derived by curve fitting the
colors that are present. That is, create a 4-D color surface from the color
changes discovered. </P>

When complete than you can apply the Hald CLUT to any other image so as to
either make the same color transformation (in either direction) to any other
image. </P>

<A NAME="replace_colormap"></A>
<H3>Full Color Map Replacement</H3>

FUTURE: Replace all the colors in one color map with colors in another color
map.  Suggestions as to how to best do this is welcome, or programmers to
implement some image color map function.  One method may be to use ideas
presented in <A HREF="../quantize/#diy_symbols" >Dithering with Symbols</A>.
</P>

The best known solution (but hardly ideal) is currently provided by Fred
Weinhaus in is "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/mapcolors/index.php"
>mapcolors</A></CODE>" script. This script essentially maps each color one at
a time, masking the pixels involved from one image into a new initially blank
image. </P>

Another idea is to somehow map a 3 dimentional color replacement into a <A
HREF="#hald" >HALD Color Table</A>. This will not just map the specified
colors, but also re-map the colors between the specified colors in a logical
way. <I>HALD generator wanted.</I> </P>


<HR><!-- ---------------------------------------------------------------- -->

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<PRE>More color options yet to be looked at in detail...

  -contrast
  -brightness-contrast

Color Cycling?
    -cycle     shift colormap (for animations of fractals???)

Chromaticity Color Points???
   white-point x,y
   red-primary x,y
   green-primary x,y
   blue-primary x,y


Thresholds  (after negation)
  Specifically  -white-threshold and -black-threshold

</PRE>

</DIV></P>
<HR><!-- ---------------------------------------------------------------- -->
</div></main><footer class="magick-footer"><div class="container-fluid">
Created: 19 December 2003 <BR>
Updated: 6 October 2011 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://imagemagick.org/Usage/color_mods/</CODE>
</div></footer></body></HTML>

