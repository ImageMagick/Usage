<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" >
<TITLE>Distorting -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/distorts/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Distorting Images</H1>

<DIV ALIGN=justify>

<B>Index</B><BR>
<TABLE CELLSPACING=0>
<TR VALIGN=top><TD COLSPAN=2>
<A HREF="../"
   ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
   > ImageMagick Examples Preface and Index</A>
</TD></TR>
<TR VALIGN=top><TD><DL>

<DD><A HREF="#summary"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > General Distortion Techniques</A>
    <UL>
    <LI><A HREF="#forward_mapping"
        >Forward or Direct Pixel Mapping</A>
    <LI><A HREF="#mapping"
        >Reversed Pixel Mapping</A>
    <LI><A HREF="#lookup"
        >Interpolated Pixel Lookup</A>
    <LI><A HREF="#super_sample"
        >Super-Sampling, Improved Results</A>
    <LI><A HREF="#area_resample"
        >Area Resampling, the next step</A>
    <LI><A HREF="#area_vs_super"
        >Area Sampling vs Super Sampling</A>
    </UL>
<DD>&nbsp;
<DD><A HREF="affine/"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Affine Matrix Transforms</A> (separate sub-directory)
<DD>&nbsp;
<DD><A HREF="#distort"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Generalized Distortion Operator</A>
    <UL>
    <LI><A HREF="#distort_options" >Distort Options, Controls, and Settings</A>
    <LI><A HREF="#distort_bestfit" >Best Fit (+distort) Option</A>
    <LI><A HREF="#distort_filter"  >Image Filters and Color Determination</A>
        <DL><DD><FONT SIZE=-1>
            <A HREF="#distort_virtual"     >Virtual Pixels and Tiling</A>
        <BR><A HREF="#distort_invalid"     >Invalid Distortion Pixels</A>
        <BR><A HREF="#distort_ewa"         >EWA Resampling and Filters</A>
        <BR><A HREF="#distort_failure"     >Resampling Failure</A>
        <BR><A HREF="#distort_interpolate" >Interpolated Color Lookup</A>
        </FONT></DD></DL>
    <LI><A HREF="#distort_verbose" >Verbose Distortion Summary</A>
        <DL><DD><FONT SIZE=-1>
            <A HREF="#distort_noop"  >No-Op Distortions</A>
        </FONT></DD></DL>
    <LI><A HREF="#distort_viewport" >Viewport, Where Distort Looks</A>
        <DL><DD><FONT SIZE=-1>
            <A HREF="#centered_square"    >Centered Square Crop</A>
        <BR><A HREF="#aspect_ratio_crop"  >Aspect Ratio Crop</A>
        </FONT></DD></DL>
    <LI><A HREF="#distort_scale"    >Output Scaling, and Super-Sampling</A>
    </UL>
<DD>&nbsp;
<DD><A HREF="#methods"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Introduction to Distortion Methods</A>
    <BR>&nbsp;
    <UL>
    <LI><A HREF="#srt"
        ><B>SRT</B> Distortion</A>
        <NOBR><FONT SIZE=-1>(scale,rotate,translate)</FONT></NOBR>
        <BR>&nbsp;
    <LI><A HREF="#rotate_methods"
        >Methods of Rotating Images</A>
    <LI><A HREF="#control_points"
        >Distortions Using Control Points</A>
    <LI><A HREF="#control_coordinates"
        >Image Coordinates vs Pixel Coordinates</A>
    <LI><A HREF="#control_escapes"
        >Control Points using Percent Escapes</A>
    <LI><A HREF="#control_leastsq"
        >Control Point Least Squares Fit</A>
    <LI><A HREF="#control_files"
        >Control Point Files</A>
    <!--<LI><A HREF="#image_registration"
        >Image Registration</A> -->
    </UL>

</DL></TD>
<TD><DL>

<DD><A HREF="#affine"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Affine (Three Point) Distortion Methods</A>
    <UL>
    <LI><A HREF="#affine"
        ><B>Affine</B> Distortion</A>
    <LI><A HREF="#affine_projection"
        ><B>Affine Projection</B> Distortion</A>
    <LI><A HREF="#affine_examples"
        >Affine Distortion Examples</A>
        <DL><DD><FONT SIZE=-1>
            <A HREF="#affine_tile"  >Affine Tiling</A>
        <BR><A HREF="#cube3d"       >3D Cubes, using Affine Layering</A>
        <BR><A HREF="#shadow3d"     >3D Shadows, using Affine Shears</A>
        <BR><A HREF="#shadow3d_var" >3D Shadows, using Perspective</A>
        </FONT></DD></DL>
    <LI><A HREF="#resize"
        ><B>Resize</B> Distortion</A>
    </UL>
<DD><A HREF="#perspective"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Four Point Distortion Methods</A>
    <UL>
    <LI><A HREF="#perspective"
        ><B>Perspective</B> Distortion</A>
        <DL><DD><FONT SIZE=-1>
            <A HREF="#horizon" >Viewing Distant Horizons</A>
        <BR><A HREF="#box3d"   >3D Boxes, using Perspective Layering</A>
        </FONT></DD></DL>
    <LI><A HREF="#perspective_projection"
        ><B>Perspective Projection</B> Distortion</A>
    <LI><A HREF="#perspective_internals"
        >Perspective Internals</A>
    <LI><A HREF="#bilinear"
        >Bilinear Distortion Metjods</A>
        <DL><DD><FONT SIZE=-1>
            <A HREF="#bilinear_forward"   ><B>BilinearForward</B></A>
        <BR><A HREF="#bilinear_reverse"   ><B>BilinearReverse</B></A>
        <BR><A HREF="#bilinear_tiling"    >Bilinear Tiling</A>
        <BR><A HREF="#bilinear_internals" >Bilinear Internals</A>
        </FONT></DD></DL>
    </UL>
<DD><A HREF="#polynomial"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > <B>Polynomial</B> Distortion</A>
<DD><A HREF="#circular_distorts"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Circular and Radial Distortion Methods</A>
    <UL>
    <LI><A HREF="#arc"
        ><B>Arc</B> Distortion</A>
        <NOBR><FONT SIZE=-1>(images in circular arcs)</FONT></NOBR>
        <DL><DD><FONT SIZE=-1>
            <A HREF="#arc_rings"    >Arc into Full Circle Rings</A>
        <BR><A HREF="#arc_examples" >Arc Distortion Examples</A>
        <BR><A HREF="#arc_center"   >Arc, Center Point Placement</A>
        </FONT></DD></DL>
    <LI><A HREF="#polar"
        ><B>Polar</B> Distortion</A>
        <NOBR><FONT SIZE=-1>(full circle distort)</FONT></NOBR>
    <LI><A HREF="#depolar"
        ><B>DePolar</B> Distortion</A>
        <NOBR><FONT SIZE=-1>(polar to cartesian)</FONT></NOBR>
    <LI><A HREF="#polar_tricks"
        >Depolar-Polar&nbsp; Cycle Technique</A>
        <DL><DD><FONT SIZE=-1>
            <A HREF="#polar_problems" >Depolar-Polar&nbsp;Problem</A>
        <BR><A HREF="#polar_rotation" >Polar&nbsp;Rotation</A>
        <BR><A HREF="#rotation_blur"  >Rotational&nbsp;Blur</A>
        <BR><A HREF="#radial_streaks" >Radial&nbsp;Streaks</A>
        </FONT></DD></DL>
    <LI><A HREF="#barrel"
        ><B>Barrel</B> Distortion</A>
        <NOBR><FONT SIZE=-1>(lens correction)</FONT></NOBR>
    <LI><A HREF="#barrelinverse"
        ><B>BarrelInverse</B> Distortion</A>
        <NOBR><FONT SIZE=-1>(alternative barrel)</FONT></NOBR>
    </UL>
<DD><A HREF="#projective_distorts"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Projective Distortions</A>
    <UL>
    <LI><A HREF="#cylinder2plane"
        >Cylinder 2 Plane</A>
    <LI><A HREF="#plane2cylinder"
        >Plane 2 Cylinder</A>
    </UL>
<DD><A HREF="#freeform_distorts"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Multi-Point and Freeform Distorts</A>
    <UL>
    <LI><A HREF="#shepards"
        ><B>Shepards</B> Distortion</A>
        <NOBR><FONT SIZE=-1>(taffy pulling!)</FONT></NOBR>
        <DL><DD><FONT SIZE=-1>
            <A HREF="#shepards_rotation" >Shepards and Image Rotations</A>
        <BR><A HREF="#shepards_power"    >Shedard's Power Factor</A>
        <BR><A HREF="#shepards_summary"  >Shepards Summary</A>
        </FONT></DD></DL>
    </UL>
</DL>
</TD></TR></TABLE></P>

Having looked at the simple set of built-in image wrapping and distortion
operators IM has provided since its early days, here we go deeper and look at
the internal mechanics and more complex mathematical distortions of images.
</P>

From this deeper understanding, we then looks at a more generalize image
distortion operator. This includes distortions, from complex rotations,
scaling and shearing, to perspective or 3D distortions, to warping to and from
circular arcs, camera lens distortions, and finally to more general morph-like
distortions. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="summary"></A>
<H2>General Distortion Techniques</H2>

Now that we have been introduce to the simple distortion operators that IM
provides, lets take a step back and look at the nitty-gritty, and see how
image distortions actually work, and how you can improve the way you use them.
</P>

Later we'll go forward to much more complex ways of distortion images,
including methods that are not directly built into ImageMagick. </P>

There are only a few basic ways an image processor can distort images. </P>

The <A HREF="../warping/#simple" >Simple Distortion</A> operators for example
are achieved by <B>Pixel Swapping</B>.  That is, individual pixels or even
whole rows and columns of pixels are just swapped around to <A
HREF="../warping/#flip" >Flip</A>, <A HREF="../warping/#roll" >Roll</A>, <A
HREF="../warping/#transpose" >Transpose</A> and even <A
HREF="../warping/#rect_rotate" >Rectangular Rotates</A> of images. No color
changes are made, and the number of pixels remains the same. </P>

The next method of distorting images is by <B>Shifting or Shearing</B> the
columns and rows of pixels either horizontally or vertically, such as what IM
does with <A HREF="../warping/#shear" >Image Shearing</A> and the <A
HREF="../warping/#wave" >Wave Distortion</A> above.  The shears in turn
providing one method to <A HREF="../warping/#rotate" >Rotate Images</A> by any
given angle, in a manner that should be quite fast. </P>

However pixel shifting methods are limited to those basic distortions.  It can
not scale an image to a different size for example. You also have very little
control over the handling of areas in the resulting image that was not covered
by the original source image.  In the above mentioned functions IM just sets
the missing areas to the current background color. </P>

To be able to distort images in a much more general way you need to use a more
general distortion technique known as <B><A HREF="#mapping" >Reverse Pixel
Mapping</A></B>.  For example this method is used by the more complex <A
HREF="../warping/#circular" >Circular Distortions</A> such as <A
HREF="../warping/#implode" >Imploding</A> and <A HREF="../warping/#swirl"
>Swirling</A> images.  </P>


<A NAME="forward_mapping"></A>
<H3>Forward or Direct Pixel Mapping</H3>

The first thing people think of when attempting to distort an image is to just
take each pixel in the source image and move it directly to its new location
in the destination image. </P>

In fact this is sort of what actually happens for  <A
HREF="../warping/#simple" >Simple Distorts</A>, <A HREF="../crop/#crop" >Image
Cropping</A> and even for distorting Vector Images.  Each pixel (or
coordinate) is is just moved to its new position in the final image. </P>

Unfortunately this has problems when you try to do this for anything but
a simple distortion.  For example here I take an Enumerated Pixel list of
a small image, and just change the location of each pixel, so as to rotate it
to its new location.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=koala_rotated_direct.gif ERR=/dev/null>
  # Rotate by 17 degrees -- get the Sine and Cosine of this angle
  sin=`convert xc: -format "%[fx:sin( 17 *pi/180)]" info:`
  cos=`convert xc: -format "%[fx:cos( 17 *pi/180)]" info:`

  # For each Pixel, rotate that pixels coordinates
  convert koala.gif  txt:- |  sed '2,$ s/,/:/' |\
    gawk -F: 'NR == 1 { print }
              NR > 1 {  x = $1-32;    y = $2-32;
                        nx = int( c*x - s*y + 32 );
                        ny = int( s*x + c*y + 32 );
                        printf( "%d,%d: %s\n", nx, ny, $3 );
              }' s=$sin c=$cos - |\
      convert -background black  txt:-   koala_rotated_direct.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_rotated_direct.gif"
     ><IMG SRC="koala_rotated_direct.gif"   WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The distortion is a simple rotation of just 17 degrees, but the results are
not very nice at all. </P>

First of all each new pixel location is a floating point value, but pixels can
only exist in an integer grid, so the above simply junks the non-integer
fraction of the results. </P>

The second problem is that the result is full of holes where no pixel landed.
</P>

Which brings up the third problem. You many not see it but for every hole in
the resulting image, you would also find another location where two pixels
were placed. That is you have multiple pixels at the same location. What pixel
value should you use? In the above IM just used the last pixel defined for
a location. </P>

In other words the resulting image is incomplete, where each pixel in the
destination is not exactly where it should be, and could have multiple pixels,
or no pixel at all.  These are serious problems, and one that cannot be
easily solved when forward mapping pixels from the source image directly to
the destination image. </P>

That is not to say that it cannot work, and many research papers talk about
using a technique known as '<B>splatting</B>'. Basically they take each input
pixel, transform its location, and then draw it with appropriate spreading and
mixing of pixel colors in the new location. This technique is especially
useful when dealing with 3-D digitization of real world objects.  Here you
have a 'cloud' of known color surface points.  Any point visible to the user
is simple 'splatted' onto the screen so as to make a final image.  Have enough
points and the image will look complete.  With interactive 3D controls, it
works very well, and is very fast.  Splatting 3-dimensional points however is
beyond IM's scope of handling 2-D raster images. </P>


<A NAME="mapping"></A>
<H3>Reverse Pixel Mapping</H3>

Rather than trying to map pixels into the final image, you can map the
coordinate of each pixel in the destination image to the corresponding
location in the source image, and from the source image lookup the color that
pixel should contain.  This is known as a <I>Reverse Pixel Mapping</I> and is
what just about every image distortion program does. </P>

As each and every destination image pixel is processed, we can be sure that
every pixel in the destination gets one and only one color. So as long as we
can figure out the 'source' location for each destination pixel, we can
distort a source image to the destination image using any mathematical formula
you can imagine. </P>

<DIV ALIGN=center>
  <IMG SRC="../img_diagrams/mapping.gif"             WIDTH=335 HEIGHT=136
       ALIGN=middle VSPACE=2 HSPACE=5 ALT="[Diagram]"></A>
</DIV></P>

In Summary, a distortion mapping (reverse mapping) does the following.

<TABLE ALIGN=center><TR><TD><PRE>
For each pixel (I,J) in the destination or output image
   Map the I,J pixel position to a X,Y pixel position in the original image
   Look up the Color of the original image at position X,Y
       Using color interpolation, work out the appropriate color.
       Or the virtual-pixel setting, if it misses the actual source image.
   Set the destination images color for pixel I,J
</PRE></TD></TR></TABLE></P>

Note that I used the variable names '<CODE>I,J</CODE>' and '<CODE>X,Y</CODE>'
in the above as these variables map into the variables name that you would
typically use in the <A HREF="../transform/#fx" >FX DIY Operator</A>. </P>

For example here I simulate the same 17 degree rotation I attempted before,
but this time use the "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>"
operator to look up the nearest pixel to that location in the source image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=koala_rotated_fx.gif>
  # Rotate by 17 degrees -- get the Sine and Cosine of this angle
  sin=`convert xc: -format "%[fx:sin( 17 *pi/180)]" info:`
  cos=`convert xc: -format "%[fx:cos( 17 *pi/180)]" info:`
  cx=37; cy=37;   # center of rotation

  convert -size 75x75 xc:       koala.gif  \
          -virtual-pixel Black  -interpolate NearestNeighbor \
          -fx "ii = i - $cx;   jj = j - $cy;
               xx =  $cos*ii +$sin*jj + $cx;
               yy = -$sin*ii +$cos*jj + $cy;
               v.p{xx,yy}" \
          koala_rotated_fx.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_rotated_fx.gif"
     ><IMG SRC="koala_rotated_fx.gif"   WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can get more detail about the above DIY example in the sub-section on
<A HREF="affine/#affine_diy" >DIY Affine Distortion Mapping</A>.  </P>

As you can see we no longer have 'holes' in our image as a color is looked up
for each and every pixel in the destination.  It still does not look very
good, but that is a matter of adjusting exactly what color should be placed
into each pixel. </P>

That is Reverse Pixel Mapping does not generate either holes, or overlapping
pixels.  Each pixel has a properly defined color producing a complete
image. </P>

<BR>

The distinction between forward and reverse mapping is important as most
mathematical transformations are defined as forward mappings, mapping a single
source (X,Y) position to a destination (I,J) position.  And indeed a 'forward
mapping' works well for vector graphics, and drawing lines where you can just
map the ends of the line and draw it.  This is especially true for any linear
transformation, such as rotations, where lines remain straight.  It is in fact
what is done for all vector based languages such as such as postscript and
SVG.  </P>

But for a general raster image, you must use a 'reverse mapping' to distort
the image, so that you can be certain that you 'fill in' all the pixels of the
destination image. </P>

For example if you look the mathematics that was used to map the coordinates
in the above two cases, you will find they look almost exactly the same.  The
reverse mapping of a 'rotate' is another 'rotate', just in the opposite
direction.  If you look closely you will see that the 'sin' constant is
negated to the forward mapped version, and that is enough to reverse the
direction of rotation.  This detail is important and critical. </P>

The problem is not all forward mapping transforms, work well as a reversed
transform.  Some forward mappings in fact have no simple direct reverse
mappings.  This is not to say it can't be done, just not simply. </P>

On the other hand some image transformations work very well as a reverse
mapping, but do not have simple forward mappings. So using reverse mapping
method is both good and bad in mathematical terms.  </P>

<BR>

As an FYI here is the faster equivalent to the above using a <A HREF="#SRT"
>General Distortion, SRT</A> method that does the exact same rotation of the
image as was done above, and producing the exact same result, just faster.  </P>

Again the color lookup is restricted to just the color of the closest pixel to
the mapped position by using 'point' interpolation.  This means that no new
colors are added to the image (other than when we 'missed' the source image),
but you also get severe aliasing effects.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -virtual-pixel Black  -interpolate NearestNeighbor \
          -filter point    -distort SRT 17    koala_rotated_srt.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_rotated_srt.gif"
     ><IMG SRC="koala_rotated_srt.gif"   WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE ASSERT>
  [ "`compare -metric PAE koala_rotated_fx.gif \
                          koala_rotated_srt.gif null: 2>&1 |
        sed 's/ .*//'`" -gt '0' ] && echo >&2 \
    "ASSERTION FAILURE: FX and SRT equivalent methods, did not match"
</CODE> -->


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  For an alternative discussion of distortion transforms, see <A
  HREF="http://www.leptonica.com/affine.html#AFFINE-IMPLEMENTATION"
  >Leptonica, Affine Implementation</A> and specifically its discussion of
  'point-wise' method.  The other method, 'sequential', is essentially how IM
  used to implement its <A HREF="../warping/#rotate" >Rotate</A> and <A
  HREF="../warping/#shear" >Shear</A> distortion operators.

</I></FONT></TD></TR></TABLE></P>

<A HREF="names"></A>
<B>What's in a name?</B> </P>

During my study I found that there is no real clear naming of this image
processing method.  The actual algorithmic process is known a '<I>Reverse
Pixel Mapping</I>', while the use of mathematical equations is known as a
'<I>Geometric Transformation</I>'.  If the distortion is controlled by the
movement of various control points, it often known a '<I>Image Warping</I>' or
'<I>Rubber Sheeting</I>'. The process of defining specific points, usually to
find equivalent points between two or more images is known as '<I>Image
Registration</I>'.  </P>

Images can also be subdivided into smaller simpler units which are
individually distorted using a technique called '<I>Gridding</I>'
(quadrilaterals) and '<I>Triangular Meshing</I>' (triangles).  By using small
incremental distortions with blending of colors from two images you can
generate animated '<I>Image Morphs</I>' such as you see in movies and music
videos.  </P>

If a pre-prepared mapping image is used rather than a, on the fly,
mathematical lookup, you get '<I>Absolute Distortion Mapping</I>'  if the
lookup is a relative displacement (50% gray being no displacement or change of
the lookup coordinate) you get '<I>Displacement Mapping</I>'. If the mapping
just slightly modifies color (shading) rather than lookup distortions, you get
the related but different '<I>Bump Surface Mapping</I>'. </P>

In the 3d modeling, and in 3d computer games, the same techniques are also
used to give some type of colored pattern to flat and curved surfaces in
a method known as '<I>Texture Mapping</I>'. This can involve sub-dividing
images into grids and meshes that approach a single pixel. Then you have
viewing of an object that is defined in terms of millions of single points
using a technique called '<I>Point Splatting</I>', though that is typically
applied using a forward mapping distortion. </P>

All the above are very closely related, and most basically involve the look up
of a pixels color based on mapping a final destination coordinate, to the
source image (or object).  In other words mapping <I>Destination to
Source</I>.  What term should be used... Take your pick.  </P>


<A NAME="lookup"></A>
<H3>Pixel Color Lookup</H3>

There are still a few problems with the above <A HREF="#mapping" >Reverse
Pixel Mapping</A> technique.  First of all is that when mapping a pixel from a
fixed integer position in the destination, you can end up with a non-integer
position in the source image.  That is a location that falls somewhere between
the individual pixels on the source image.  To determine what color should be
returned a process called <A HREF="../misc/#interpolation" >Interpolation</A>
is used to determine the final color for that real position by mixing the
colors of the surrounding pixels. </P>

The <A HREF="../misc/#interpolation" >Interpolation</A> setting will also
handle the case when a part of a distorted image becomes 'stretched out' so
that a single source pixel becomes smeared over a large area of the
destination image.  However the opposite is not handled very well by a simple
interpolation method. And that requires other techniques which we will look at
below. </P>

For example here we again rotate our koala, but this time use a "<CODE><A
HREF="../option_link.cgi?interpolate" >-interpolate</A> <A
HREF="../misc/#mesh" >Mesh</A></CODE>" setting to mix the four nearby pixels
so as to produce a better, more correct, color from the lookup.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -virtual-pixel Black  -interpolate Mesh \
          -filter point    -distort SRT 17    koala_rotated_mesh.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_rotated_mesh.gif"
     ><IMG SRC="koala_rotated_mesh.gif"   WIDTH=75 HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see by using a simple merger of just the closest neighboring colors
surrounding the non-integer lookup point, you can greatly improve the look of
the distorted image. </P>

But there are other problems involved... </P>

For example what do you do when the mapped position 'misses' the source image
completely. In this case, what color should be returned is determined by the
<A HREF="../misc/#virtual-pixel" >Virtual Pixel</A> setting.  This setting
will pick a color, such as the nearest edge of the source image, pretend the
source image is infinitely tiled (or mirror tiled) across the plain, or use
some specific color such as 'white', 'black', or 'transparent' or the user
defined background color. </P>

There is also the possibility that there is no mathematically valid coordinate
for a specific destination position being mapped. For example the pixel looks
into the 'sky' of a perspective 'plane' (See <A HREF="#horizon" >Viewing
Distant Horizons</A>), and thus does not even see the 'plane' in which the
source image lies. </P>

In this case a <A HREF="../misc/#virtual-pixel" >Virtual Pixel</A> is useless
as it does 'hit' the source image plane in a N-dimensional space, and as such
the destination pixel is completely invalid!  In this case IM uses the current
"<CODE><A HREF="../option_link.cgi?matte" >-matte</A></CODE>" setting for the
pixel color. If it is a 'near-miss' IM will anti-alias this invalid color
with a neighbouring colors of the image plane, if it knows how. It does for
perspective distortions. </P>


<A NAME="super_sample"></A>
<H3>Super Sampling</H3>

Interpolation works well for simple image distortions. But if part of the
source image gets compressed into a much smaller area, each destination pixel
could actually require a merging of a much larger area of the source image.
Remember pixels are not really points, but represent a rectangular area of
a real image.  </P>

This means in some cases we really should be trying to compress a large area
of the source image into a single destination pixel.  When this happens
a simple <A HREF="#lookup" >Pixel Lookup</A>  will fail, as it only looks up
the color at a single 'point' in the source image (using the surrounding pixel
neighbourhood), and does not merge and combine all the colors of the input
image that may have to be compressed into that single pixel. </P>

The result of this is that a destination pixel could end up with an
essentially random color from the source image, rather than an average of all
the colors involved.  This is not in itself bad, but when all the pixels in
an area doe this you get images with seemingly random, isolated pixels, Moire
effects, and aliased 'stair-casing' effects.  Thin lines also start to look
more like dotted and dashed lines (see examples for the <A
HREF="../resize/#sample" >Sample Operator</A>), or could disappear entirely.
All these effects are known collectively as <A HREF="../filter/#aliasing"
>Aliasing Artefacts</A>.  </P>

One solution to this to more color lookups from the source image, for each and
every pixel in the destination, so as to try and determine a more correct
color for each pixel in the destination image. The simplest solution is
generally known as <B>super-sampling</B>, or <B>over-sampling</B>.  See the <A
HREF="http://en.wikipedia.org/wiki/Super-sampling" >Wikipedia Entry on
Super-Sampling</A>. </P>

By taking more samples from the source image, over the area that will map
onto each destination pixel, the final color of that pixel will become a more
accurate representation of distorted image at that point.  The more color
samples you make, the more accurate the final color will be, and a smoother
more realistic look will be generated, though the slower the distortion
becomes. </P>

Remember this technique only really improves the general look of the
destination in areas where the source image becomes compressed by more than
50%.  In areas where the distortion magnifies the source image, or keeps it
about the same scale, a single <A HREF="../misc/#interpolation" >Interpolated
Look Up</A> of the source image look up will generally produce a good result
with just one single lookup. </P>

In the <A HREF="../warping/#implode" >Imploding Images</A> warping examples
(and many other examples throughout IM Examples), I touched briefly on the
simplest method of 'super-sampling'. Basically enlarging the size of the
output image (or in this case simply by enlarging the input image), and then
performing the distortion.  After the distortion is complete we then resize
the image back to its normal size again, which merges all the extra 'samples'
that was generated. </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 94x94 xc:red -bordercolor white -border 3 \
          -virtual-pixel tile                -implode 4 \
          implode_tiled_box.gif
  convert -size 94x94 xc:red -bordercolor white -border 3 \
          -virtual-pixel tile  -resize 400%  -implode 4 -resize 25% \
          implode_tiled_ss.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=5 WIDTH=80%><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="implode_tiled_box.gif"
     ><IMG SRC="implode_tiled_box.gif"        WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR>Normal Implosion of a Box Image</TD>
<TD ALIGN=center>
  <A HREF="implode_tiled_ss.gif"
     ><IMG SRC="implode_tiled_ss.gif"        WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR>Super Sampled Implosion</TD>
</TR></TABLE></DIV></P>

Of course rather than enlarging the input image, you could start with a higher
quality (larger) source image, or generate one during some previous processing
step. If one is available.  </P>

This is especially useful when rotating text, which often has very fine detail
that needs to be uniformly preserved to ensure a good high quality look in the
final image.  For examples of this see the <A HREF="../transform/#polaroid"
>Polaroid Transform</A>. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As of IM v6.4.2-6, the <A HREF="#distort" >General Distortion Operator</A>,
  can directly generate an enlarged output image, which you can scale (or
  resize) back down so as to merge and super-sample the resulting pixels. See
  <A HREF="#distort_scale" >Distortion Scale Setting</A>, as well as the next
  example.

</I></FONT></TD></TR></TABLE></P>

This is only one method of <I>super sampling</I> (known as the 'grid' method),
there are however many other variations on this method.  Eventually these
methods may be implemented more directly in ImageMagick, but for now simple
enlargement and scaling of images work quite well, without any additional
coding need.  </P>

One final word of warning. Super-sampling is limited by the number of samples
that was used for each pixel in the final image, and thus the amount of
scaling used in the final resize.  This determines the final 'quality' of the
distorted image. But by using larger scaling factors, the distorted image will
of course be much much slower to generate. But have even higher quality, has
its limits. </P>

In the extreme, super-sampling will not handle any image distortion that
involves infinities (such as in the center of an imploded image).  In such
cases a completely different technique is needed, such as one that is provided
by <A HREF="#area_resample">Area Resampling</A> (see below). </P>

In summary, super-sampling can improve the look of images with only minor
distortions, such as rotations, shears, affine, and simple perspective. But it
has limits to the types of distortions that it can improve. </P>

<B>Adaptive Super-Sampling</B> </P>

The super-sampling technique can be expanded further.  Rather than just using
a fixed number of color lookups for each pixel, a check is made on either the
distance between the lookups in the source image, or on how close the colors
returned from a low level sampling, to see it should make more samples for
that specific pixel.  </P>

That is the amount of super-sampling could be made responsive to needs of the
distortion, without knowing anything about the specifics of the distortion
itself. This is known as <I>Adaptive Super-Sampling</I>. </P>

This technique is actually very common in Ray Tracers, where it is next to
impossible to determine just how complex the resulting image is at any
specific point. In this case it is often restricted to the use of 'color
differences' around the specific location, to determine when more samples are
needed. if a pixel is very different to its neighbours, then more samples are
used in that area to refine what is probably the edge of some 3 dimentional
object.</P>

IM does not currently support adaptive super-sampling at this time. Though it
is quite possible to add alternative sampling methods into the <A
HREF="#distort" >General Distortion Operator</A> (see below). It will require
some functional rearrangement of the code, so may not be added anytime soon.
</P>

<B>Super-Sampling Summary</B> </P>

The difficulty with super-sampling is in determining just how many 'point
samples' is needed, and how those samples should be arranged with the
sub-pixel bounds.  Also what sort of 'weighting' should be applied.  See the
<A HREF="http://en.wikipedia.org/wiki/Super-sampling" >Wikipedia Entry on
Super-Sampling</A>. </P> </P>


<A NAME="area_resample"></A>
<H3>Area Resampling, for better Distortions</H3>

One of the best alternatives to super-sampling methods is <B>Area
Re-sampling</B>.  </P>

Rather than distorting a larger image and averaging the results by resizing,
which is just taking and averaging more samples from the image, we actually
determine exactly how many pixels from the source image should be merged
together (based on the 'scale' of the distortion at that point) to generate
each specific output pixel.  That is figure out a rough 'area' within the
source image, each output pixel represents, and merge (filter) all the pixels
in that area according to a resampling filter. </P>

In fact this is exactly what the ImageMagick <A HREF="../resize/" >Resize
Operator</A> (in reality a very specific type of image distortion) does to
generate such good results. However for resize, you only need to calculate the
scale of the area needing to be sampled for each pixel, once for the whole
image. The area it needs to 'sample' is fixed size rectange (window) in the
source image, making the re-sampling process easy, and providing a short-cut
in the distortion process.  </P>

When area re-sampling a distorted image, the area of pixel (window) to get
samples from will not only change position, but also will change size.  As
such one pixel in the destination may only need to merge a few source image
colors, or even just one single interpolated color lookup (such as in
enlargments). While another pixel elsewhere in the destination image, may need
to sample a very very large number of pixels to generate the correct final
color. Close to infinities it may even have to incluce all the pixels in the
source image as part of the the sampling process. </P>

Also the area that a destination pixel represents in the source image, may not
be a simple square, circle, or even ellipse but may actually be a highly
distorted shape, according to the distortion being used.  Calculating and
handling such awkward shapes can be very time consuming, or near impossible to
achieve. </P>

<IMG SRC="../img_diagrams/ewa_mapping.gif"        WIDTH=309  HEIGHT=384
     ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[Diagram]"></A>

Using an elliptical area of the source image to calculate colors for each
destination pixel, is a method known as Elliptical Weighted Average (EWA)
Re-sampling, and was outlined in the PDF research paper "<A
HREF="http://www.cs.cmu.edu/~ph/texfund/texfund.pdf" >Fundamentals of Texture
Mapping and Image Warping</A>" by <I>Paul Heckbert</I> (who also wrote the
'zoom' program from which practically all image resize algorithms are derived).
This was then used to define the new <A HREF="#distort" >Generalized
Distortion Operator</A> (see below). </P>

An ellipse is the perfect shape for either <A HREF="#affine" >Affine
Distortions</A> or  <A HREF="#perspective" >Perspective Distortions</A>.  It
is especially good for extreme scale reductions (see example below).  And
while not perfect for other distortions, it is generally a reasonable fit for
many other distortions, such as <A HREF="#arc" >Arc and Polar Distortions</A>
(but not their reverse), as well a radial distortions like the <A
HREF="barrel" >Barrel Distortion</A>. </P>

But it is a poor fit for non-linear distortion mappings such as <A
HREF="depolar" >De-Polar</A> and <A HREF="shepards" >Shepards Distortion</A>,
as such it is not used for these distortions. </P>

Super Sample does not have this shape problem as each 'sample' is reverse
mapped onto the destination. So it becomes the better sampling method in such
cases.  But as mentioned it may not sample all the pixels needed, or even
sample too many pixels. </P>

<A NAME="area_vs_super"></A>
<H3>Area Sampling vs Super Sampling</H3>

Here are all three sampling methods IM currently provides, when applied to
an extreme infinitely tiled perspective image.  See <A HREF="#horizon" >Viewing
Distant Horizons</A> below for details, of this distortion.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  # input image:  special checkerboard with a gold outline.
  convert -size 90x90 pattern:checkerboard -normalize -fill none \
          -stroke gold -strokewidth 3 -draw 'rectangle 0,0 89,89' \
          -fill red        -draw 'color 20,20 floodfill' \
          -fill lime       -draw 'color 40,70 floodfill' \
          -fill dodgerblue -draw 'color 70,40 floodfill' \
          checks.png

  # Using Interpolated Lookup
  convert checks.png -filter point \
          -virtual-pixel tile -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          horizon_tile_point.png

  # Using Grid Super Sampling
  convert checks.png  -filter point  -set option:distort:scale 10 \
          -virtual-pixel tile -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          -scale 10%    horizon_tile_super.png

  # Using Area Resampling (default)
  convert checks.png       -virtual-pixel tile -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          horizon_tile.png
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5><TR VALIGN=top>
<TD ALIGN=center><FONT SIZE=-1>
  <A HREF="checks.png"
     ><IMG SRC="checks.png"        WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
<BR>Check Image
<NOBR></FONT></TD>
<TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=45 ALT="==>">
</TD>
<TD ALIGN=center><FONT SIZE=-1>
  <A HREF="horizon_tile_point.png"
     ><IMG SRC="horizon_tile_point.png"        WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
<BR>Interpolated</BR>Lookup</FONT></TD>
<TD ALIGN=center><FONT SIZE=-1>
  <A HREF="horizon_tile_super.png"
     ><IMG SRC="horizon_tile_super.png"        WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
<BR>Super Sampling<BR>x10</FONT></TD>
<TD ALIGN=center><FONT SIZE=-1>
  <A HREF="horizon_tile.png"
     ><IMG SRC="horizon_tile.png"        WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
<BR>Elliptical Weighted Area<BR>(EWA) Resampling</FONT></TD>
</TR></TABLE></DIV></P>

All the images are exactly the same distortion, just using different
're-sampling' techniques. </P>

The last image in the above used the default EWA settings of the <A
HREF="#distort" >Generalized Distortion Operator</A>, and as you can see it
produced an extremely high quality result. However it took 4.6 seconds to
generate this image, Which is not too bad if a little slow (due to the unusual
extremes involved). </P>

The first image has the default EWA resampling turned off by using a "<CODE><A
HREF="../option_link.cgi?filter" >-filter</A> point</CODE>" setting. This
forces it to use <A HREF="#lookup" >Direct Interpolated Lookup</A> for each
pixel.  As such this image was generated extremely fast in comparison (.51
seconds), but as you can see produces a horible result as 'minification'
(downsampling) increases with 'distance'. </P>

The middle image is as the first image but with the distorted output image
being enlarged by a factor of 10, before being scaled back (grid resampling)
to match the other images.  That is more than 100 pixels were looked up and
averaged together for each destination pixel, so as to <A HREF="#super_sample"
>Super Sample</A> the result.  It is quite fast to generate (1.2 seconds), and
while it improves the quality of the image in general, that improvement is
limited.  The &times;10 used in the above example is very heavy, far exceeding
the more typical 3 or 4 times scaling used for most super-sampling usage. </P>

The biggest difference between the results is that super-sampling only does
a general improvement in quality uniformly over the whole image.  As the
distortion gets more sever it starts to break down. The result is the highly
visible <A HREF="../filter/#artefacts" >Resampling Artifacts</A> in the middle
ground, and more specifically a line of server moire effects just before the
horizon. The moire effect is caused when when the 10 samples across per pixel
nearly matches the checker board pattern of the image, producing distorted
color effects. </P>

On the other hand area-resampling concentrates more on the problem pixels
closer to the horizon (where it spends almost all of its time), than on
foreground pixels, where it does actually out perform super-sampling. </P>

Basically the above is a very extreme distortion, and the time EWA lookup
takes is commensurate. More commonly it generates much better results than
a single interpolated lookup, as it efficentally looks are every pixel
involved, while not using too many samples is areas that don't need it, as
super-sampling does. </P>

<B>In Summary...</B></P>

Using a simple ellipse (EWA resampling) or a rectangle (Resize), to do 'area
resampling' does produce good results, as all the source pixels involved in
scaled, affine or perspective distortions, will be merged to produce the final
color of an individual destination pixel. </P>

In cases of very non-linear distortions, such as in <A HREF="#depolar"
>DePolar Distorts</A>, or indeterminanate distortions, such as <A
HREF="#shepards" >Shepard's Distortion</A> or even ray-tracing, finding the
correct 'Area' to resample all the source pixels needed, becomes
prohibitive, and super-sampling is the best method to improve results. </P>

But for straight tiling, enlargements, and unscaled rotations, a very fast
single 'point' interpolated lookup is probably all that is required, and may
even be recommended to ensure perfect no-op (no change) distortions (see
below). </P>

Remember however all resampling techniques are just methods for determining
the color of each individual pixel.  It is not actually part of the how an
image is distorted, except with regard to the mapping of locations between
destination and source (or visa-versa if posible). </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="distort"></A>
<H2>Generalized Distortion Operator</H2>

With the generation of these examples, the ensuing discussions in the <A
HREF="forum_link.cgi?f=1" >IM Forums</A>, and multiple requests from users for
easier and faster ways to do perspective and other distortions, a new operator
was added to IM v6.3.5-1 to allow us to more easily add image distortions, of
many different types. </P>

This <I>Generalized Distortion Operator</I> is called "<CODE><A
HREF="../option_link.cgi?distort" >-distort</A></CODE>", and you can see what
distortion methods it has available on your IM version using "<CODE><A
HREF="../option_link.cgi?list" >-list</A> Distort</CODE>".

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert -list distort
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The "<CODE><A HREF="../option_link.cgi?distort" >-distort</A></CODE>" operator
takes two arguments, one of the distortion <I>methods</I> as given by the
above, and a second string argument consisting of comma or space separated
list of floating point values, that is used to control the specific distortion
method. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert ... -distort  {<I>method</I>} <!--
       --> "{<I>list_of_floating_point_values</I>}" ...
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The number floating point values given is however highly dependant on the
distortion method being used, and their meanings also depend not only on the
<I>method</I> chosen, but can also depend on the exact number of control
points or attributes needed for a particular method.  </P>

This is especially the case for the '<CODE><A HREF="#srt"
>Scale-Rotate-Translate</A></CODE>' (or '<CODE><A HREF="#srt" >SRT</A></CODE>'
for short) distortion, which really combines three separate '<CODE><A
HREF="#affine" >Affine</A></CODE>' distortions into a single distortion.  </P>

Many distortion <I>methods</I> take a list of control points (in <A
HREF="#control_coordinates" >Image Coordinates</A>),  and typically these are
given as <I>pairs of coordinates</I> which control how the distortion is to
modify the image.  These pairs of coordinates are detailed more fully later in
<A HREF="#control_points" >Distortions Using Control Points</A>. </P>


<A NAME="distort_options"></A>
<H3>Distortion Options, Controls and Settings</H3>

<A NAME="distort_bestfit"></A>
<H3>Best Fit +Distort Flag</H3>

By default "<CODE><A HREF="../option_link.cgi?distort" >-distort</A></CODE>"
will usually distort the source image(s) into an image that is the same size
as the original image.  There are exceptions to this, such as the '<CODE><A
HREF="#arc" >Arc</A></CODE>' distortion (a polar mapping variant) where the
input source image size really does not have much meaning in the distorted
form of the image (see <A HREF="#arc" >Arc Distortion</A> below for details).
</P>

The other form of the operator, "<CODE><A HREF="../option_link.cgi?distort"
>+distort</A></CODE>" (Added to IM v6.3.5-7), will attempt resize the
distorted image so it will contain the whole of the input image (if possible),
much like what the older <A HREF="#rot_n_shear" >Rotate and Shearing</A>
operators do. </P>

However this particular 'mode' of operation also goes further and also sets
the <A HREF="../basics/#page" >Virtual Canvas Offset (page)</A> of the
resulting image.  This way you can later <A HREF="../layers/#merge" >Layers
Merge</A> this image onto another image, at the correct position according to
your control points, using the appropriate <A HREF="../compose/" >Alpha
Composition</A> (see <A HREF="#cube3d" >3d Cubes, using Affine Layering</A> as
a basic example. </P>

Also (depending on the distortion method) a "<CODE><A
HREF="../option_link.cgi?distort" >+distort</A></CODE>" will attempt to take
into account any existing <A HREF="../basics/#page" >Virtual Canvas Offset</A>
that may be present in the source image, and use it as part of the distortion
process.  See the notes about the individual disortion methods.  </P>

As such you may need to make judicious use of the "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>" attribute setting
operator to clear or adjust that offset <I>before</I> using the 'best-fit'
"<CODE><A HREF="../option_link.cgi?distort" >+distort</A></CODE>" form of the
General Distortion Operator.  You also may need to use it <I>after</I> if the
virtual canvas and offset is not required.  See also <A
HREF="../crop/#crop_repage" >Removing Canvas/Page Geometry</A>. </P>

The normal "<CODE><A HREF="../option_link.cgi?distort" >-distort</A></CODE>"
will just ignore any existing offset present in the source image in terms of
the distortion itself, but will copy that offset unchanged to the distorted
image.  </P>

In Summary...  Use "<CODE><A HREF="../option_link.cgi?distort"
>-distort</A></CODE>" to have results mapped into an image of the same size.
And use "<CODE><A HREF="../option_link.cgi?distort" >+distort</A></CODE>" to
try and automatically set the output image size, BUT also use and generate
Virtual Canvas Offsets (page attributes).  </P>

Also see <A HREF="#distort_viewport" >Distort Viewport</A> (below) if you want
to override this general viewport selection, and exactly control of what size
and what part of the distorted image you want to see in your results.</P>

<BR>

Note... The best-fit viewport generated by "<CODE><A
HREF="../option_link.cgi?distort" >+distort</A></CODE>" is 2 pixels larger
than what users would typically expect.  The reason is that these pixels
contain semi-transparent pixels that result from the area resampling filter,
and these pixels are vital to correct 'edge joining' and overlaying of the
distorted image. </P>

Technically the number of pixels added should depend on the output scaling of
<A HREF="../filter/#support" >Resampling Filter Support</A>.  That is how much
a pixel's area could 'spread' due to the resampling filter.  However as the
scaling of each pixel can be variable, calculation of the absolutely correct
number of additional pixels needed is a very tricky matter, and usually not
worth the effort. </P>

The 2 pixel added is thus a 'fudge', as distortions rarely enlarge images
which causes pixels to 'spread' more.  Also as most standard resampling
filters has a support of 2 units, the addition of 2 pixels a reasonable one.
Also as this addition is 'fixed' it allows users the option to simply <A
<A HREF="../crop/" >Crop Image Size</A> (in various ways), if that is their
wish.  </P>

The 2 pixel 'fudge' does become obviously too small when doing enlargments of
images.  But those are fairly rare distortions, and users can define there own
<A HREF="#distort_viewport" >Viewport</A> (see below) if this is a problem.
</P>

The virtual offset of the distorted image on the virtual canvas, is adjusted
to account for these 2 extra pixels, so the distorted image is correct for
overlaying, though not for simple composition.  But be warned that while <A
HREF="../crop/#crop" >Crop</A>, <A HREF="../crop/#trim" >Trim</A> will
preserve the layered image location, <A HREF="../crop/#shave" >Shave</A>, and
<A HREF="../crop/#chop" >Chop</A>, will shift the layer image, relative to
this offset. </P>

<BR>

<A NAME="distort_filter"></A>
<H3>Distort Pixel Color Determination</H3>

As discussed above in <A HREF="#mapping" >Reversed Pixel Mapping</A> above,
each point in the resulting image is determined by first mapping that pixels
location in the destination image, to the equivalent (reverse distorted)
location in the source image, according to the distortion method chosen.
However the final color of the pixel is not so simple to determine, as it is
effected by a large number of factors. </P>

<A NAME="distort_virtual"></A>
<H4>Virtual Pixels and Tiling</H4>

The distortion mapped point may not hit the actual source image, but somewhere
beside it, or even a lot way from the actual image.  The solution to this is
to pretend the source image surrounded by an 'infinite' or 'virtual' surface,
which is defined by the current "<CODE><A
HREF="../option_link.cgi?virtual-pixel" >-virtual-pixel</A></CODE>" setting.
For details and examples of the effect of this setting see <A
HREF="../misc/#virtual-pixel" >Virtual Pixel</A> examples.  </P>

This can be very useful for generating distorted, or even undistorted tile
patterns of the source image.  Techniques for this are shown in the <A
HREF="../misc/#virtual-pixel" >Virtual Pixel</A> section itself (undistorted)
and in <A HREF="#affine_tile" >Affine Tiling</A> and <A HREF="#horizon"
>View Distant Horizons</A> below. </P>


<A NAME="distort_invalid"></A>
<H4>Invalid Distortion Pixels</H4>

Sometimes the distortion of a destination pixel does not even 'hit' the
vitrual tiled image!  This generally happens when you distort the image using
some type of 3-dimensional space distortion method and the pixel 'vector' does
not even hit the source plane in which the image lies.  Basically the the
result of the distortion becomes 'undefined' mathematically.  In that case the
color will be determined from the "<CODE><A
HREF="../option_link.cgi?mattecolor" >-mattecolor</A></CODE>" setting. </P>

For example when you see 'sky' in a  <A HREF="#perspective" >Perspective
Distortion</A> (for example see <A HREF="#horizon" >View Distant
Horizons</A>), the mathematics for determining the source image location
became 'undefined' (actually it is defined, but it is not valid from an users
forward viewing perspective). As such the "<CODE><A
HREF="../option_link.cgi?mattecolor" >-mattecolor</A></CODE>" is output for
the 'sky'. </P>

Actually the perspective distortion algorithm also manages to include some
'anti-aliasing' information for pixels close to the horizon, though that is
uncommon for such situations.  </P>

<A NAME="distort_ewa"></A>
<H4>EWA Resampling and Filters</H4>

Once you know where a destination pixel 'hits' the source image, you need
to determine the color to make the destination pixel, using the pixels near
the 'hit' point in the source image. </P>

Normally the <A HREF="#distort" >Distort Operator</A> will use the <A
HREF="#area_resample" >Area Resampling</A> method EWA (Elliptical Weighted
Average) to average out a larger area of the source image to work out the
right color of for this pixel. </P>

You can change the filter using by EWA resampling using the "<CODE><A
HREF="../option_link.cgi?resize" >-filter</A></CODE>" setting. See <A
HREF="../filter/#filter" >Resampling Filters</A>, and more specifically <A
HREF="../filter/#cylindrical" >Cylindrical Filters</A> for more details. </P>

Originally a <A HREF="../filter/#cyl_gaussian" >Cylindrical Gaussian</A>
filter was used for EWA resampling, as this was what was defined in the
original research paper for EWA resampling. But this tends to produce very
blurry result, though it also does not produce aliasing effects. This used to
be the default filter, along with an implementation bug that caused extreme
blurriness before that version (now fixed) </P>

From IM v6.6.5-0 after major discussions with Nicolas Robidoux, Professor of
Mathematics at Laurentian University, the default filter for image distortions
was replaced with the '<CODE><B>Robidoux</B></CODE>' filter, which is a very
'Mitchell-like' cubic filter, designed specifically for EWA resampling.  See
<A HREF="../filter/#cylindrical" >Cylindrical Filters</A>, for
information on this and other cylindrical filters. </P>

Note however that any underlying Windowed Sinc filter function is replaced by
the more circular Windowed Jinc filter function.  As such selecting
a 'Lanczos' filter will return a "Jinc windowed Jinc" filter, rather than
a "Sinc windowed Sinc" filter. See <A HREF="../filter/#jinc" >Windowed Jinc
Cylindrical Filters</A> for more details. </P>

ASIDE: '<CODE>Sinc</CODE>' functions are NOT really usable as a cylindrical
function, as the function interaction with radial disances on a grid, causes
the filter weights into form that tends to cancel itself out (zero weight sum)
whenever an even number of 'lobes' are used. This in turn causes it to try and
generate near infinite colors when used with a pixel-level checkerboard 'hash'
pattern. </P>

Basically EWA uses resampling filters, much like the <A
HREF="../resize/#resize" >Resize Operator</A>, and as such you can also modify
the filters using the special <A HREF="../filter/#options" >Expert
Filter Options</A>.  The blurriness of the a '<CODE>Gaussian</CODE>' and
Gaussian-like filters for example can be controlled by the <A
HREF="../filter/#blur" >Filter Blur Setting</A>.   Similarly you can
use the <A HREF="../filter/#lobes" >Lobes Support Setting</A>, to
control the size and power of the Windowed Jinc Filters, such as
a '<CODE>Lanczos</CODE>' filter. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  There are number of extreme distortion methods, which automatically turn off
  EWA re-sampling, and only use the more direct <A HREF="../misc/#interpolate"
  >Interpolated Lookup</A>.  </P>

  For example the <A HREF="#depolar" >Depolar</A> distortion, produces
  resampling areas in the shape of circular arcs that do not fit 'elliptical'
  (EWA) resampling very well.  Other distortions such as <A HREF="#shepards"
  >Shepards</A> make the calculation of 'scaling factors' extremely difficult,
  though a future improvement of the distort operator could make it possible).
  </P>

  A <A HREF="#super_sample" >Super Sampling</A> technique is recommended for
  these distortion methods to prevent generating severe <A
  HREF="../filter/#aliasing" >Aliasing Artefacts</A> in areas of image
  compression (down sampling) in the results. </P>

</I></FONT></TD></TR></TABLE></P>

<A NAME="distort_failure"></A>
<H4>Resampling Failure</H4>

In some special situations the EWA resampling Ellipse may fail to actually
'hit' any real pixel for it to create a weighted average. Basically the
ellipse is so small, or so thin, that it falls completely between every pixel
in the image. And without any pixel colors, it can not generate a color for
the output image at that point. </P>

This is an extreme situation, and generally is imposible to achieve unless you
are playing with <A HREF="../filter/#options" >Expert Filter Settings</A>.
But in the unlikely event that no pixels are hit, or the filter weights add up
to zero, the resampling will fail.   In that case IM will fall back to using
a simple direct interpolated lookup, just like you would get if you turn of
EWA filtering (see next). </P>

If you want to check if this is happening you can use the special <A
HREF="../misc/#background_ic" >Background Interpolation</A> with
an unusual background color (like 'red') so as to highlight any such resampling
failures. </P>

For example, here I purposfully set the support of a box filter too small,
and thus making the resampling ellipse so small.  I also greatly enlarge the
image so you can see what parts 'hit a pixel' and which didn't.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert \( xc:red   xc:white xc:black +append \) \
          \( xc:blue  xc:lime  xc:white +append \) \
          \( xc:black xc:red   xc:blue  +append \) -append \
          -filter Box -define filter:support=0.4 \
          +distort SRT 30,0  bad_box_distort.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="bad_box_distort.png"
      ><IMG SRC="bad_box_distort.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE> </P>

In the greatly enlarged image, the resampling circle will either hit only one
pixel (producing an aliased cicle of solid color.  Or it will fail to match any
pixel as the circular sampling area falls completely between the pixels, and
thus the filter will fall back to an interpolated gradient of color (<A
HREF="../misc/#bilinear" >Bilinear Interpolation</A> by default), to get at
least some reasonably valid color for the resulting image.  </P>

Here is the same example, but replacing the interpolation method with the
special (and normally useless) <A HREF="../misc/#background_ic" >Background
Interpolation</A> (just return the background color, which was set to 'gray').

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert \( xc:red   xc:white xc:black +append \) \
          \( xc:blue  xc:lime  xc:white +append \) \
          \( xc:black xc:red   xc:blue  +append \) -append \
          -filter Box -define filter:support=0.4 \
          -interpolate background -background Gray \
          +distort SRT 30,0   bad_box_distort_gray.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="bad_box_distort_gray.png"
      ><IMG SRC="bad_box_distort_gray.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE> </P>

For complete coverage (so it always finds at least one pixel) a cylindrical
resampling filter needs a 'support' of at least about 0.707 (sqrt(2)/2)
(default for a box filter). All filters are typically much larger than this
minimal support size. For examples of this see the section on <A
HREF="../filter/#cyl_interpolated" >Cylindrical Filters</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center> <TR
       VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26 ><IMG
    SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD> <TD ALIGN=justify
    WIDTH=100%><FONT SIZE=-1><I> The small colored dots in the corners is
    caused by a resampling optimization for virtual pixels (aborting an
    expensive EWA resampling when sampling VP areas of solid color).  They
    will disappear or change with a different selection of the "<CODE><A
    HREF="../option_link.cgi?virtual-pixel" >-virtual-pixel</A></CODE>"
    setting. </P>

    Normally this is not a problem, and only seen here because distort uses
    a '<A HREF="#distort_bestfit" >Best Fit Viewport</A>' that is slightly
    larger than the original image, and thus includes a few extra pixels
    around the edge which in this case samples vitural pixel. </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="distort_interpolate"></A>
<H4>Interpolated, or Direct Color Lookup</H4>

<B>You can use "<CODE><A HREF="../option_link.cgi?filter" >-filter</A>
point</CODE>", to turn off filtering, and hence EWA resampling.</B></P>

When this is done Imagemagick will switch color lookups to use fast and
simplier <A HREF="../misc/#interpolate" >Pixel Interpolation</A>.  That is it
will look up a color using only a 'single point' referance to the source image
without any 'resampling area'.  The color of the resulting pixels will use
an interpolated color based only on nearest neighbours to point.</P>

<DIV ALIGN=center><B>
          Interpolation will generally cause sever aliasing effects
<BR>  when any form of minification or down-sampling of the image occurs.
</B></DIV></P>

But it does work extremely well for images containing minimal distortions such
as rotations, tiling, or for <I>image enlargement</I> (magnification or
up-sampling).  </P>

A <A HREF="#super_sample" >Super Sampling</A> technique can be combined with
interpolation, to improve the results in areas of strong compression,
minification or down-sampling.  See <A HREF="#polar_problems" >Depolar-Polar
Cycle Problems</A> (a distort that can not use EWA resampling) for an example
of using super-sampling to resolve interpolated aliasing. </P>

<BR>

<A NAME="distort_verbose"></A>
<H3>Verbose Distortion Summery</H3>

By setting "<CODE><A HREF="../option_link.cgi?verbose" >-verbose</A></CODE>"
before running "<CODE><A HREF="../option_link.cgi?distort"
>-distort</A></CODE>" (use "<CODE><A HREF="../option_link.cgi?verbose"
>+verbose</A></CODE>" to turn off again), distort will output to the standard
error channel, information on the algorithm and internal coefficients it
calculates, and uses when distorting the given image, in the way specified.
</P>

You can use this information to look at and understand how the distortion
works and is applied. It is also a debugging tool we can use to figure out
what is going wrong, and as part of the implementation process for new
distortions. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=distort_verbose.txt>
  convert koala.gif -verbose -distort SRT 0 +verbose  koala_noop.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD>
  <A HREF="../images/koala.gif"
     ><IMG SRC="../images/koala.gif"       WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
</TD><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="distort_verbose.txt"
     ><IMG SRC="distort_verbose.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD><TD>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
</TD><TD>
  <A HREF="koala_noop.gif"
     ><IMG SRC="koala_noop.gif"  WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>
<!-- <CODE EXECUTE ASSERT>
  [ "`compare -metric PAE koala.gif koala_noop.gif null: 2>&1 |
        sed 's/ .*//'`" -gt '9600' ] && echo >&2 \
    "ASSERTION FAILURE: Distort SRT no-op is VERY different\!"
</CODE> -->

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  NOTE: The resulting image is almost but not quite exactly the same as the
  input image (see "no-op distortions" next).
</I></FONT></TD></TR></TABLE></P>

The verbose output details the two alternative distortion techniques for the
given distortion.  One is an '<CODE><A HREF="#affineprojection"
>AffineProjection</A></CODE>' distortion, while the other shows a <A
HREF="../transform/#fx" >DIY FX Operator</A> alternative detailing exactly how
it maps a given pixel in the output image (i,j) to an interpolated lookup in
the input image (xx,yy), so as to transform the image. It does the resampling
ellipse calculates which uses complex mathemathics (eigan values) to figure
out, It only calculates the un-scaled interpolated lookup point in source
image from which to determine the color of the (i,j) pixel. </P>

Both give information on the distortion process and can be used to extract
extra information for use in other distortions of the same type. For a more
complex example of using this information see <A HREF="#perspective_internals"
>Perspective Internals</A> and <A HREF="#bilinear_internals" >Bilinear
Internals</A> below.

Also for an example of using an FX command for image distortion see <A
HREF="../transform/#fx_resize" >FX Image Resizing</A>. </P>

The extra '<CODE>0.5</CODE>' additions and subtractions in the above is needed
to convert 'pixel coordinates' into 'image coordinates', and is required for
correct mathematical handling of image distortions.  See <A
HREF="#control_coordinates" >Image vs Pixel Coordinates</A> below. </P>



<A NAME="distort_noop"></A>
<H4>No-Op Distortions</H4>

The above example shows the results of doing a no-op distort. That is running
an image through distort (for some secondary effect) but without any actual
distort involved (just a 1 to 1 mapping of pixels). </P>

The EWA resampling filter will not reproduce the exactly the same colors as
the original, but will blur the individual pixels very slightly with its
neighbours.  This is due to the 2 dimensional filter being used, and while the
color blurring is minimal it can never be eliminated. </P>

As such to do a true 'no-op' we must also turn off EWA filtering and use <A
HREF="#distort_interpolate" >Interpolated, or Direct Color Lookup</A> (see
above).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -filter point -distort SRT 0  koala_noop_perfect.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_noop_perfect.gif"
     ><IMG SRC="koala_noop_perfect.gif"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Almost all the <A HREF="../misc/#interpolate" >Interpolative Settings</A> will
generally extract an exact copy of the source pixel when it is exactly
referenced.  However as a precaution, you can also specify <A
HREF="../misc/#nearest-neighbor" >Nearest-Neighbor</A> interpolation, for
speed and assurance that only an exact color match is returned, regardless of
any floating-point errors that distort may produce.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif   -filter point  -interpolate nearest \
          -distort SRT 0  koala_noop_perfect_2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_noop_perfect_2.gif"
     ><IMG SRC="koala_noop_perfect_2.gif"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This may seem counter-productive, but it can be a very useful method of
enlarging an images area, or tiling images (using <A HREF="../misc/#virtual"
>Virtual Pixel Methods</A>), without actually resizing the original image
data.  See <A HREF="../canvas/#tile_distort" >Tiling using Virtual Pixels via
Distort</A> for examples of this.</P>

That is using the <A HREF="#distort" >Distort Operator</A> for its secondary
effects, such as multi-image virtual pixel tiling, image size enlarging or
cropping, adding borders, or even translation (by integer or even sub-pixel
amounts). None of which actually requires the image to be 'distorted' just
'modified' in some 'programmed' way.  </P>

<BR>

<A NAME="distort_viewport"></A>
<H3>Viewport, Where Distort Looks</H3>

As mentioned above using "<CODE><A HREF="../option_link.cgi?distort"
>-distort</A></CODE>" or "<CODE><A HREF="../option_link.cgi?distort"
>+distort</A></CODE>" changes what the resulting size and location of
the 'destination image' to either be: the same as the source image (ignoring
any virtual canvas settings), or, a best fit calculation for the distorted
source image (if possible), respectively. </P>

These two things basically define what part of the resulting 'distorted space'
that the destination image is seeing.  Another way to think of it is that the
destination image is a 'window' looking at the resulting distorted image, or,
a 'viewport' into the distorted space. </P>

The "<CODE>distort:viewport</CODE>" setting overrides both of these defaults,
and allow you directly specify what part of the distorted space you want to
see...

<BLOCKQUOTE><PRE><A HREF="../option_link.cgi?define"
>-define</A> distort:viewport=WxH+X+Y
<A HREF="../option_link.cgi?set"
>-set</A> option:distort:viewport WxH+X+Y</PRE></BLOCKQUOTE>

These were added in IM v6.3.6-1.  It does not enlarge or scale the distorted
image, just specify the location and area being viewed (the viewport) in the
distorted image space.</P>

This can be used to create a destination image of a specific size, or shift
the view to a specific area in the distorted image space.  It is very similar
to using '<A HREF="../crop/#crop_viewport" >Viewport Crop</A>', of
an infinitely sized (virtual pixel defined) distorted image. </P>

For example, here we crop the output to just the koala head (with a no-op
distortion).  In other words just a direct 'viewport crop' of the original
un-distorted image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -define distort:viewport=44x44+15+0 \
          -filter point -distort SRT 0  +repage koala_viewport.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_viewport.gif"
     ><IMG SRC="koala_viewport.gif"   WIDTH=44  HEIGHT=44
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

And here we expand the view, to look at the extra space surrounding the
distorted image, and showing the effects the <A HREF="../misc/#virtual-pixel"
>Virtual Pixel</A> setting has on the infinite space surrounding the
original source image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -define distort:viewport=125x125-25-25 \
          -filter point -distort SRT 0  +repage koala_viewport_2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_viewport_2.gif"
     ><IMG SRC="koala_viewport_2.gif"   WIDTH=125  HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In this case it is more like using the <A HREF="../crop/#extent" >Extent
Operator</A> to enlarge the image.  However instead of simply filling with the
background color, distort fills the added area with the <A
HREF="../misc/#virtual" >Virtual Pixel Setting</A>.  In this case using the
default  '<CODE><A HREF="../misc/#edge" >Edge</A></CODE>' virtual pixel
setting, which results in the horizontal and vertical lines of pixels,
replicated from the pixels along the edge of the original image. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

You may like to make a better choice for the <A HREF="../misc/#virtual"
>Virtual Pixel Setting</A>. For example using a '<CODE><A
HREF="../misc/#background" >Background</A></CODE>' setting will make this
no-op distort work pretty much exactly like the <A HREF="../crop/#extent"
>Extent Operator</A>. </P>

For this image '<CODE><A HREF="../misc/#white" >White</A></CODE>' Virtual
Pixel setting would probably be a better choice.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -define distort:viewport=125x125-25-25 \
          -virtual-pixel White -distort SRT 0  +repage koala_viewport_3.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_viewport_3.gif"
     ><IMG SRC="koala_viewport_3.gif"   WIDTH=125  HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The final "<CODE><A HREF="../option_link.cgi?repage" >+repage</A></CODE>" in
the previous examples is needed to remove the viewport's virtual canvas offset
that "<CODE><A HREF="../option_link.cgi?distort" >-distort</A></CODE>" will
leave in place when the viewport setting is used. This information is just not
wanted in this case.  In other cases, such as when layering distorted images,
you would want that offset information.</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The viewport option is particularly useful with a '<CODE><A
HREF="../misc/#tile" >Tile</A></CODE>' or even a '<CODE><A
HREF="../misc/#mirror" >Mirror</A></CODE>' virtual pixel setting, allowing you
generate tiled, image of any size and in different styles.  You can even use
distort to distort those tiled images, such as exampled in <A
HREF="#affine_tile" >Affine Tiling</A> below.  </P>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -define distort:viewport=125x125-25-25 \
          -virtual-pixel Mirror -distort SRT 0  +repage koala_viewport_4.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_viewport_4.gif"
     ><IMG SRC="koala_viewport_4.gif"   WIDTH=125  HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="centered_square"></A>
<H4>Centered Square Crop</H4>

If you use the "<CODE><A HREF="../option_link.cgi?set" >-set</A></CODE>"
option to set the 'viewport' of the resulting image, you can include <A
HREF="../basics/#arg_escape" >Percent Escapes</A> in the assigned value. More
specifically you can include <A HREF="../transform/#fx_escapes" >FX Percent
Escapes</A> that can do mathematical calculations. </P>

This means the 'viewport' can be calculated, while making use of the
attributes of say the size of the current image in memory, to specify the
final size of the resulting image.  </P>

What does that mean?  Well it means the 'viewport' can be used to generate
special types of <A HREF="../crop/#crop" >Crop</A> that normally requires one
or more pre-reads, of an image, (or a more advanced API programming
interface), and external calculations to achieve. </P>

For example you can crop out a 'center square' of an image without needing to
know the original images size or orientation, before hand.  This is complex,
so I placed the viewport expression in variables so as to make it easier to
read, code, and debug, though it is really just a constant (fixed) expression.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=viewport_square.gif>
  size='%[fx: w>h ? h : w ]'
  offset_x='%[fx: w>h ? (w-h)/2 : 0 ]'
  offset_y='%[fx: w>h ? 0 : (h-w)/2 ]'
  viewport="${size}x${size}+${offset_x}+${offset_y}"

  convert worldmap_sm.jpg  -set option:distort:viewport "$viewport" \
          -filter point -distort SRT 0  +repage   viewport_square.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/worldmap_sm.jpg"
     ><IMG SRC="../img_photos/worldmap_sm.jpg"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="viewport_square.gif"
     ><IMG SRC="viewport_square.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The resulting image is the largest centered square that can be extracted from
any input source image, regardless of that images size.  The distort itself
does not actually distort the image, only copy the area covered by the
viewport. </P>

Note that ALL four numbers needs to be calculated to produce a "centered
square crop" as all values are dependant on the images orientation.  As such
each expression uses a 'image orientation' test of the form
'<NOBR><CODE>w&gt;h ? ... : ...</CODE></NOBR>', so the resulting value depends
on the images orientation.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

This is an alternative form using "min()" and "max()" functions, instead of
image orientation tests.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert worldmap_sm.jpg  -set option:distort:viewport \
    "%[fx:min(w,h)]x%[fx:min(w,h)]+%[fx:max((w-h)/2,0)]+%[fx:max((h-w)/2,0)]" \
    -filter point -distort SRT 0  +repage  viewport_square_2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="viewport_square_2.gif"
     ><IMG SRC="viewport_square_2.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Courtesy of <A
HREF="http://www.fmwconcepts.com/imagemagick/tidbits/image.php#pad_crop_square"
>Fred Weinhaus's Tidbits Page</A>. </P>

A technique using multiple image processing techniques for doing the same
thing is shown in <A HREF="../thumbnails/#square" >Thumbnails, Square Padding
and Cropping</A>.  </P>


<A NAME="aspect_ratio_crop"></A>
<H4>Aspect Ratio Crop</H4>

This technique can be expanded so you center crop an image to fit a given
aspect ratio. </P>

Also see Forum Discussion <A HREF="../forum_link.cgi?t=33448" >Crop
to Aspect Ratio</A>. </P>


<A NAME="viewport_other"></A>
<H4>Other Viewport Examples</H4>

Also see <A HREF="#rotate_methods" >Methods of Rotating Images</A> below for
other examples of using a viewport to control what part of the distorted space
is visible in the results. </P>


<A NAME="distort_scale"></A>
<H3>Output Scaling, and Super-Sampling</H3>

<BLOCKQUOTE><PRE><A HREF="../option_link.cgi?define"
>-define</A> distort:scale=N
<A HREF="../option_link.cgi?set"
>-set</A> option:distort:scale N</PRE></BLOCKQUOTE>

Was added in IM v6.4.2-6, as a general output image scaling factor.  This
enlarges the output image by the factor given and thus the "<CODE><A
HREF="../option_link.cgi?distort" >-distort</A></CODE>" will need to generate
<CODE>N<sup>2</sup></CODE> more distorted lookup 'samples'. The number is
usually an integer, but can be a floating point enlargement factor. </P>

Note that many distortions also allow you to 'scale' the size of resulting
distorted image, however the resulting image size would be unaffected by that
scaling (unless a 'best-fit' "<CODE><A HREF="../option_link.cgi?distort"
>+distort</A></CODE>" was used).  This 'scale' setting however does not change
the contents of resulting image at all, just enlarges or shrinks the resulting
output image. </P>

This can be used for example with an appropriate 'viewport' to produce an image
that you can easily "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>" to a specific size, allowing you generate a controlled
'zoom' into the distorted image, without loss of quality. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

For example, we 'zoom' in on the head of the koala.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -set option:distort:scale 2.5 \
          -set option:distort:viewport 44x44+15+0 \
          -distort SRT 0  +repage koala_zoom.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_zoom.gif"
     ><IMG SRC="koala_zoom.gif"   WIDTH=110  HEIGHT=110
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that while the viewport was requested to be <CODE>44x44</CODE> pixels,
the actual output image has been scaled to <CODE>110x110</CODE> pixels. </P>

More commonly, it is used as a simple means of '<A HREF="#super_sample" >Super
Sampling</A>' (see above) the distortion operation.  For this an integer
'super-sampling' scale factor is used, and after distorting the image is
scaled back to its original size, to merge the extra samples together, and
produce a higher quality result. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -filter point -set option:distort:scale 10 \
          -distort SRT 0  -scale 10%   koala_super.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_super.gif"
     ><IMG SRC="koala_super.gif"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Also as '<A HREF="#area_resample" >Area Re-Sampling</A>' is not needed when
using '<A HREF="#super_sample" >Super Sampling</A>' for improving image
quality (it only slows it down), it is typically turned off by using a
"<CODE><A HREF="../option_link.cgi?filter" >-filter</A> point</CODE>" option
(see previous section). </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="methods"></A>
<H2>Introduction to Distortion Methods</H2>


<A NAME="srt"></A>
<H3>Scale-Rotate-Translate (SRT) Distortion</H3>

One of the simplest distortion, but probably one of the most versatile, is the
'<CODE>SRT</CODE> or '<CODE>Scale-Rotate-Translate</CODE>' distortion.  (SRT
is just a quick short-hand) </P>

You have already seen the 'no-op' example of this distortion in the above
examples, where the image is processed without any actual distortion being
applied to the image, though it will still be filtered which can induce some
very minor blurring. </P>

Here is a repeat the results of the above 'no-op' distort...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert koala.gif    -distort SRT 0    koala_noop.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD>
  <A HREF="../images/koala.gif"
     ><IMG SRC="../images/koala.gif"       WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
</TD><TD>
  <A HREF="koala_noop.gif"
     ><IMG SRC="koala_noop.gif"  WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that the image will be blurred very slightly as consequence of using <A
  HREF="#area_resample" >Area Resampling</A>. However IM resampling filters
  have been purposefully designed to minimise this blurring for the No-Op
  distortion, and is needed for normal use. </P>

  If you want perfect 'no-op' distort for special purposes, then turn off EWA
  resampling.  That is specify the 'no-op' filter <NOBR>"<CODE>-filter
  Point</CODE>"</NOBR> to the above before the distort operator. </P>

</I></FONT></TD></TR></TABLE></P>

The '<CODE>SRT</CODE> distortion is actually three separate, distortions in
a single distortion method, which is why it is called
a '<CODE>Scale-Rotate-Translate</CODE>' distortion.  All arguments, except the
<I>angle</I> rotation, are optional and this makes the arguments highly
variable, depending on exactly how many comma or space separated arguments you
give, up to the maximum of 7 floating point numbers.  </P>

<TABLE ALIGN=center BORDER=0 CELLPADDING=0 CELLSPACING=0>
<TR>
<TD ROWSPAN=7><CODE><B>-distort SRT "</B>&nbsp;</CODE></TD>
<TD><FONT SIZE=-1><PRE
>                  Angle </PRE></FONT></TD>
<TD ROWSPAN=7><CODE>&nbsp;<B>"</B></CODE></TD>
<TD>&nbsp; -&gt;  centered rotate </TD>
<TR><TD><FONT SIZE=-1><PRE
>        Scale     Angle </PRE></FONT></TD>
<TD>&nbsp; -&gt;  centered scale and rotate </TD></TR>
<TR><TD><FONT SIZE=-1><PRE
>X,Y               Angle </PRE></FONT></TD>
<TD>&nbsp; -&gt;  rotate about given coordinate </TD></TR>
<TR><TD><FONT SIZE=-1><PRE
>X,Y     Scale     Angle </PRE></FONT></TD>
<TD>&nbsp; -&gt;  scale and rotate about coordinate </TD></TR>
<TR><TD><FONT SIZE=-1><PRE
>X,Y ScaleX,ScaleY Angle </PRE></FONT></TD>
<TD>&nbsp; -&gt;   ditto </TD></TR>
<TR><TD><FONT SIZE=-1><PRE
>X,Y     Scale     Angle  NewX,NewY</PRE></FONT></TD>
<TD>&nbsp; -&gt;  scale, rotate and translate coord </TD></TR>
<TR><TD><FONT SIZE=-1><PRE
>X,Y ScaleX,ScaleY Angle  NewX,NewY</PRE></FONT></TD>
<TD>&nbsp; -&gt;  ditto </TD></TR>
</TABLE></P>

What this does is take an image in which you have selected, and an optional
control point.  If no control point is given, the exact center of the input
source image is used.  Around that point the distortion will, in sequence...
<B>Scale</B> the image, <B>Rotate</B> it, then <B>Translate</B> or move the
selected control point to a new position. Hence the name of this distortion.
</P>

The argument order shown above reflects the order of operations that are
actually applied to the image.  <B>X,Y</B> to translate the 'center' of the
transformations to the origin, <B>ScaleX,ScaleY</B> the image,  <B>Angle</B>
rotate the image, then <B>NewX,NewY</B> translate the 'center' to these
coordinates.  That is the operator really represents 4 internal distortion
operations all applied simultaneously as a single distortion. Though to us
humans only 3 distinct distortions are involved. </P>

So lets take a simple example using the 'koala' image... </P>

One argument is just a simple rotation about the images center, basically
producing a similar result to the older <A HREF="../warping/#rotate" >Rotate
Operator</A>, but without any image size increase.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -background skyblue  -virtual-pixel background \
          -distort ScaleRotateTranslate -110 koala_srt_rotate.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_srt_rotate.png"
     ><IMG SRC="koala_srt_rotate.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that by default the size of the input image us also used for the output
image, as such the rotated image may be clipped. It is also perfectly
centered regardless of if the image has an odd or even number of pixels. </P>

Using the 'plus' form of "<A HREF="../option_link.cgi?distort"
><CODE>+distort</CODE></A>", and a clean up of resulting virtual canvas
offsets, we can generate something very similar to the normal <A
HREF="../warping/#rotate" >Rotate Operator</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -background skyblue  -virtual-pixel background \
          +distort ScaleRotateTranslate -110 +repage koala_srt_rotate2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_srt_rotate2.png"
     ><IMG SRC="koala_srt_rotate2.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
    As of IM 6.7.3-4 the <A HREF="../warping/#rotate" >Rotate Operator</A> is
    now using Distort SRT Distortion.  Before this it was using <A
    HREF="./warping/#shear" >Shear Operations</A>, whcih did not produce
    a good a result.
</I></FONT></TD></TR></TABLE></P>

Lets shrink it by 30% as well, but use a transparent background.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -matte -virtual-pixel transparent \
          +distort ScaleRotateTranslate '.7,-110' +repage koala_srt_scale.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_srt_scale.png"
     ><IMG SRC="koala_srt_scale.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The next set of arguments will specify the 'center' around which the image is
rotated and scaled.  This point is called a 'control point' or 'handle' in the
image which is a location used to control the distortion.  As we are using a
specific point for this distortion, lets not use the 'best-fit' mode to avoid
the complications of 'virtual offsets'.  </P>

For example lets rotate and scale the koala around its 'nose', which is
located at <CODE>28,24</CODE> in the source image. While we are at it lets
distort the X and Y scales different.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -background skyblue -virtual-pixel background \
          -distort ScaleRotateTranslate '28,24  .4,.8  -110' \
          koala_srt_center.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_srt_center.png"
     ><IMG SRC="koala_srt_center.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And as a final example, lets also move the 'nose' to near the bottom of the
image, and set background to a matching white background.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -virtual-pixel white \
          -distort ScaleRotateTranslate '28,24  .4,.8  -110  37.5,60' \
          koala_srt_trans.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_srt_trans.png"
     ><IMG SRC="koala_srt_trans.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the final position is also a floating point value. In fact all the
arguments can be floating point values and the distortion will do the right
thing. </P>

Remember each of the operations, Scale, Rotate, and Translate are performed in
that order. </P>

As you can see this distortion is very versatile, and while you can think of
it as distorting the image using three different methods in sequence, in
reality it is applying all three distortions simultaneously to produce the
shown result. This makes it faster than doing multiple individual operators,
and generally produces a better final result. </P>

The above also demonstrates the use of different <A
HREF="../misc/#virtual-pixel" >Virtual Pixel</A> settings to define the color
used for the areas referenced outside the actual source image.  To see the
effect of <A HREF="../misc/#interpolation" >Interpolation</A> on rotations see
<A HREF="../misc/#interpolate_line" >Interpolation of a Rotated Line and
Edge</A>. </P>

This distortion specifically designed to take an image and generate an
animation based on the movements and rotation of that object.  </P>

For example here I create a stylized space ship, which I then animate in a
very rough way.  The ship sits on its base at <CODE>20,75</CODE> (for the
initial 'hunker-down' scaling) while the normal 'handle' for movement and
rotations is the ships center which is located at <CODE>20,60</CODE> in the
original image.  These points represent control points by which the object can
then be animated in simple terms.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 80x80 xc:skyblue -fill yellow -stroke black \
          -draw 'path "M 15,75 20,45 25,75 Z  M 10,55 30,55" ' \
          spaceship.gif
  convert spaceship.gif \
          \( -clone 0  -distort SRT '20,75  1.0,0.6  0' \) \
          \( -clone 0  -distort SRT '20,60     1     0  20,49' \) \
          \( -clone 0  -distort SRT '20,60    0.9   20  27,35' \) \
          \( -clone 0  -distort SRT '20,60    0.8   45  40,23' \) \
          \( -clone 0  -distort SRT '20,60    0.5   70  55,15' \) \
          \( -clone 0  -distort SRT '20,60    0.3   75  72,11' \) \
          \( -clone 0  -distort SRT '20,60    0.1   80  100,8' \) \
          -set delay 50  -loop 0  spaceship_launch.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="spaceship.gif"
     ><IMG SRC="spaceship.gif"   WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="spaceship_launch.gif"
     ><IMG SRC="spaceship_launch.gif"   WIDTH=80  HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Of course it is a very rough example of how you can use a '<CODE><A
HREF="#srt" >SRT</A></CODE>' distortion to animated a static image, but you
should get the idea.  You can add more frames, and perhaps some flames and
smoke to improve it further (submissions welcome and best result will be added
here with your name). </P>


<A NAME="rotate_methods"></A>
<H3>Methods of Rotating Images</H3>

Images can be rotated in many ways. But just simple rotations may not be what
you are looking for.</P>

Rotate image without changing size...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -virtual-pixel black -distort SRT '20'  rotate_normal.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rotate_normal.png"
     ><IMG SRC="rotate_normal.png"      WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Or rotate so as not to clip any of the rotated image...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -virtual-pixel black +distort SRT '20'  rotate_noclip.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rotate_noclip.png"
     ><IMG SRC="rotate_noclip.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However typically you do not want to see the 'black' <A
HREF="../misc/#virtual-pixel" >Virtual_Pixel</A> (or whatever other non-image
color) surrounding the image proper. </P>

One solution is to crop the image (using a <A HREF="#distort_viewport"
>Distort Viewport Setting</A>) to the largest rectangle of the same aspect
ratio, such that it only contains real image pixels resulting from the
rotation. </P>

However calculating this rectangle is rather tricky, and was heavily
discussion on the <A HREF="../forum_link.cgi?t=18862&p=73079" >ImageMagick
Forum</A> using some equations found on the <A
HREF="http://www.mathhelpforum.com/math-help/f13/finding-scale-rectangle-inside-larger-rotated-rectangle-102791.html"
>Math Help Forum</A>. </P>

Here we rotate and do an internal crop at as close to the original aspect ratio
as possible.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  angle=20
  ratio=`convert rose: -format \
     "%[fx:aa=$angle*pi/180; min(w,h)/(w*abs(sin(aa))+h*abs(cos(aa)))]" \
     info:`
  crop="%[fx:floor(w*$ratio)]x%[fx:floor(h*$ratio)]"
  crop="$crop+%[fx:ceil((w-w*$ratio)/2)]+%[fx:ceil((h-h*$ratio)/2)]"
  convert rose: -set option:distort:viewport "$crop" \
          +distort SRT $angle +repage   rotate_internal.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rotate_internal.png"
     ><IMG SRC="rotate_internal.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This looks complex but that is because it actually has to calculate
4 separate values to define <A HREF="#distort_viewport" >Viewport Setting</A>,
Width, Height, and offset in the original image. </P>

Another alternative is to not only rotate, but also scale the image slightly
larger so as to 'fill' the original images bounds.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  angle=20
  convert rose: -distort SRT \
     "%[fx:aa=$angle*pi/180;(w*abs(sin(aa))+h*abs(cos(aa)))/min(w,h)], $angle" \
     rotate_correction.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rotate_correction.png"
     ><IMG SRC="rotate_correction.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This last is ideal for a <A HREF="../photos/#rotation" >Minor Rotation
Correction of Photos</A>, so as to preserve the images original size. </P>

The only reason this method is simpler, is because only one 'scale' value
needs to be calculated, and as such can be done 'in-line'.  </P>


<A NAME="control_points"></A>
<H3>Distortions Using Control Points</H3>

While the '<CODE><A HREF="#srt" >SRT</A></CODE>' distortion method is defined
by specifying rotation angles and scaling factors, most distortions are
defined by moving 'points' on the source image, and moving them to a new
position in the resulting image.   This is a bit like the movement of the
'center' point when defining a '<CODE><A HREF="#srt" >SRT</A></CODE>'
translation.  </P>

These points are called control points, and are more usually defined by giving
4 floating point values (2 pairs of coordinates) for each single control
point.  So often a distortion is defined in terms of multiple sets of 4
values.  For example....

<DIV ALIGN=center><CODE>
     X<sub>1</sub>,Y<sub>1</sub> I<sub>1</sub>,J<sub>1</sub> &nbsp; &nbsp;
     X<sub>2</sub>,Y<sub>2</sub> I<sub>2</sub>,J<sub>2</sub> &nbsp; &nbsp;
     X<sub>3</sub>,Y<sub>3</sub> I<sub>3</sub>,J<sub>3</sub> &nbsp; &nbsp;
     X<sub>4</sub>,Y<sub>4</sub> I<sub>4</sub>,J<sub>4</sub> . . . .
</CODE></DIV>

Where the control point X<sub>i</sub>,X<sub>i</sub> in the source image
(relative it its virtual canvas), is mapped to I<sub>i</sub>,J<sub>i</sub> on
the distorted destination image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  However as the <A HREF="#distort" >Distort Operator</A> is actually mapping
  destination coordinates to source coordinates (see <A HREF="#mapping"
  >Reverse Pixel Mapping</A>), the internal use of the above is to map I,J
  coordinates to X,Y coordinates.  The result however should be the same, just
  a different way of thinking.

</I></FONT></TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM version 6.3.6-0 when the <A HREF="#distort" >Distort Operator</A>
  operator was first introduced, the coordinate ordering for control points
  was defined as all the source coordinates, followed by all the destination
  coordinates.  This however made it very hard to determine which source and
  destination coordinates corresponded to each other, and did not allow for
  the simple appending of more control points to further refine a distortion.
</I></FONT></TD></TR></TABLE></P>

It is defined in this way so that the movement of each individual control
point is kept together in the comma (or space) separated list of floating
point values.  It also allows for the future use of external 'control point
files'.  </P>

The simplest distortion using control points is the '<CODE><A HREF="#affine"
>Affine</A></CODE>' distortion, though this as you will see later is usually
defined in terms of three points, you can use just one or two control point
movements. In actual fact '<CODE><A HREF="#srt" >SRT</A></CODE>' is simply a
two or one point sub-set of a '<CODE><A HREF="#affine" >Affine</A></CODE>'
distortion. </P>

For example here we move the 'nose' of our koala image at '<CODE>28,24</CODE>'
to the new position '<CODE>45,40</CODE>' (as indicated by the red arrow),
which results in a simple 'translation' of the image location.

<!-- <CODE EXECUTE>
  convert koala.gif -fill none -stroke red \
            -draw 'path "M 28,24 45,40  M 41,32 45,40 36,37 ' \
          koala_arrow.png
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -virtual-pixel white \
          -distort Affine '28,24 45,40'   koala_one_point.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="koala_arrow.png"
     ><IMG SRC="koala_arrow.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_one_point.png"
     ><IMG SRC="koala_one_point.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

With two points, the '<CODE><A HREF="#affine" >Affine</A></CODE>' distortion
can not only translate an image but scale and rotate it as well (the full range
of a  '<CODE><A HREF="#srt" >SRT</A></CODE>' distortion. </P>

For example here I map the 'ears' to the koala (the red line from
'<CODE>30,11</CODE>' and '<CODE>48,29</CODE>'), to a larger horizontal
position (a blue line from '<CODE>15,15</CODE>' to '<CODE>60,15</CODE>'),
requiring the image to be scaled, rotated and translated so the control points
are moved to this new position.

<!-- <CODE EXECUTE>
  convert koala.gif -fill none \
            -draw 'stroke red  line 30,11  48,29' \
            -draw 'stroke blue line 15,15  60,15' \
          koala_lines.png
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -virtual-pixel white \
          -distort Affine '30,11 15,15  48,29 60,15'   koala_two_point.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_lines.png"
     ><IMG SRC="koala_lines.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_two_point.png"
     ><IMG SRC="koala_two_point.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Of course a '<CODE><A HREF="#srt" >SRT</A></CODE>' distortion could have
reproduced the above two point '<CODE><A HREF="#affine" >Affine</A></CODE>'
distortion, except that here we defined the distortion in a different way.
Which form you should use is up to you, depending on what you are trying to
achieve.  </P>

<A NAME="control_coordinates"></A>
<H3>Image Coordinates vs Pixel Coordinates</H3>

The use of control points in the general case is straight forward, but becomes
more difficult when you need to align a distorted image, with another image or
drawn constructions. </P>

The reason is that while most operators in IM handle coordinates in terms of
a '<I>Pixel Positions</I>' (for example when <A HREF="../crop/#crop"
>Cropping</A>,  <A HREF="../draw/#draw" >Drawing</A>, etc) distortions deal
with coordinates in mathematical '<I>Image Coordinates</I>'. </P>

What you need to remember is that pixels in an image are not a 'point' but
actually an 'area', 1 pixel unit in size.   That is a pixel located at
<CODE>10,10</CODE> defines a square area of color, going from <CODE>10</CODE>
units down/across to <CODE>11</CODE> units down and across.

In terms of <I>image coordinates</I> the 'pixel' center is actually located at
<CODE>10.5,10.5</CODE> .  That is 0.5 needs to be added when you are
distorting an image to move the center of a 'pixel' to a specific location. </P>

So to re-position the corner 'pixels' of an image you would thus need
to move the image in terms of the pixels located at <CODE>0.5,0,5</CODE> and
<CODE><I>Width</I>-0.5,<I>Height</I>-0.5</CODE>.   On the other hand to
reposition the image in terms of the actual 'edges' of the image you would
simply use the coordinates <CODE>0.0,0,0</CODE> and
<CODE><I>Width</I>,<I>Height</I></CODE> . </P>

You just need to think about what you actually wanting to position, the
center of an images 'pixels' or the 'edges' of the image.  Or if it actually
even matters for your particular problem. </P>

Remember that if you want to <A HREF="../draw/#draw" >draw</A> other elements
onto your distorted image, you will need to give draw positions in terms of
'<I>Pixel Positions</I>'.  And yes  the "<A HREF="../option_link.cgi?draw"
><CODE>-draw</CODE></A>" operator can draw lines, circles, and other shapes
using floating point values.  Similarly the stroke width and/or radii of the
objects can also be given as floating point values. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  A draw stroke width of less than 1.0 does not work well, (See <A
  HREF="../draw/#strokewidth" >Drawing Lines</A>). Also the area fill adds an
  extra 0.5 (matching the stroke width addition) to the edges of the fill area
  (See <A HREF="../draw/#bounds" >Draw Fill Bounds</A>). This is done
  regardless of the actual strokewidth used. </P>

  For more information see <A HREF="../draw/#bounds" >Draw Fill Bounds</A>.
  Something I regard as a bug.

</I></FONT></TD></TR></TABLE></P>



<A NAME="control_escapes"></A>
<H3>Control Points using Percent Escapes</H3>

You can also use <A HREF="../basics/#arg_percent" >Percent Escapes</A> within
the distort arguments. </P>

For example you can extract image attributes for one image, then use them to
resize another image to match the first image.  Here I grab the size of the
"<CODE>rose:</CODE>" built-in image, then use a '<CODE><A HREF="#affine"
>Affine</A></CODE>' distortion to resize the larger "<CODE>logo:</CODE>" image
to the same size (without preserving the aspect ratio).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
   convert rose: -set option:rw %w -set option:rh %h +delete \
           logo: -alpha set -virtual-pixel transparent \
           +distort Affine '0,0 0,0     %w,0 %[rw],0   0,%h  0,%[rh]' \
           +repage logo_sized_as_rose.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="logo_sized_as_rose.png"
     ><IMG SRC="logo_sized_as_rose.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that distort will generate slightly larger 'layered image' on a virtual
canvas, (including a negative offset) which is why I needed to include
a "<CODE><A HREF="../option_link.cgi?repage" >+repage</A></CODE>" in the above
example.  It also will have fuzzy edges too, as distort is generating an exact
or true distortion of the image, and not a sanitised orthogonal <A
HREF="../resize/#resize" >Resized Image</A>. </P>

For a more advance examples on using the <A HREF="#distort" >Distort
Operator</A> to resize images, exactly as the <A HREF="../resize/#resize"
>Resize Operator</A> does, see <A HREF="../resize/#distort_resize" >Distort vs
Resize</A>, as well as the <A HREF="#resize" >Distort Resize Method</A> below.
</P>

You can also use percent escapes to calculate distortions based on an images
position within the current image list.  Examples of this are given in <A
HREF="../anim_mods/#distort" >Animated Distorts</A>. </P>


<A NAME="control_leastsq"></A>
<H3>Control Point Least Squares Fit</H3>

If you supply more than 3 control points for '<CODE><A HREF="#affine"
>Affine</A></CODE>' distortion, or more than 4 points for '<CODE><A
HREF="#perspective" >Perspective</A></CODE>' or the '<CODE><A HREF="#bilinear"
>Bilinear</A></CODE>' distortions, ImageMagick will perform an least squares
average over all the given points to find an 'average' representation for
those distortions. </P>

This means if you are trying to match up one image with another image (a
technique known as '<I>Image Registration</I>'), you can define more than the
minimum number of points needed so that the result will be a more precise
distortion. </P>

Of course if one or more of those points do not 'fit' well with the other
points, then the result will be skewed by the 'odd' point, as IM tries to find
the best fit using all the control points given, including the bad one.  Some
check to find and remove 'bad coodinate pairs' may be needed for some
situations. </P>


<A NAME="control_files"></A>
<H3>Control Point from Files</H3>


The list of numbers (arguments) to a distortion can also be read from a file
by using a '<CODE>@filename</CODE>' syntax, just as you can input text for
things like "<CODE><A HREF="../option_link.cgi?annotate"
>-annotate</A></CODE></A>" and "<CODE><A HREF="../text/#label"
>label:</A></CODE>" (see <A HREF="../text/#escape_chars" >Escape Characters in
Text Arguments</A>). </P>

For example you can specify a distortion like this...
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert input.png  -distort Perspective '@file_of_coords.txt' output.png
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The filename can be just a '<CODE>@-</CODE>' to mean read the file from
standard input. </P>

The file itself will be read in as a string and treated as the list of
coordinates (arguments) needed by the distortion involved.  As numbers can be
either comma or white-space separated, that means the coordinate pairs can be
cleanly ordered as one pair of coordinates per line in the form...

<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE>
   X<sub>1</sub>   Y<sub>1</sub>   I<sub>1</sub>   J<sub>1</sub>
   X<sub>2</sub>   Y<sub>2</sub>   I<sub>2</sub>   J<sub>2</sub>
   X<sub>3</sub>   Y<sub>3</sub>   I<sub>3</sub>   J<sub>3</sub>
   X<sub>4</sub>   Y<sub>4</sub>   I<sub>4</sub>   J<sub>4</sub>
   ....
</PRE></TD></TR></TABLE>
</DIV></P>

That with the <A HREF="#control_leastsq" >Least Squares Fitting</A> makes the
use of image registration very practical. </P>

As the file is just a list of four numbers per line, you can use other text
processing scripting tools such as "<CODE>cut</CODE>", "<CODE>paste</CODE>",
"<CODE>column</CODE>", and more advanced text processing scripting tools such
as "<CODE>sed</CODE>", "<CODE>awk</CODE>", "<CODE>perl</CODE>", etc to
manipulate the coordinates.  </P>

The use of coordinate and distortion argument files will become more important
with more advanced distortions, such as '<CODE><A HREF="#shepards"
>Shepards</A></CODE>' distortion, and the planned future distortions of
'<CODE>Grid</CODE>' and "<CODE>Mesh</CODE>' where hundreds of coordinate pairs
may be involved. </P>

<!--
<A NAME="image_registration"></A>
<H3>Image Registration <FONT SIZE=-1>(Using more control points)</H3>

<BR>
-->



<BR>
<HR><!-- ---------------------------------------------------------------- -->

<A NAME="affine"></A>
<H2>Affine (Three Point) Distortion Methods</H2>

<H3>Affine Distortion</H3>

Both the '<CODE><A HREF="#srt" >SRT</A></CODE>' distortion, and the one and
two point forms of the '<CODE>Affine</CODE>' distortion shown above are
actually simplifications of a full 3 point form of the '<CODE>Affine</CODE>'
distortion. In fact if you study the "<A HREF="../option_link.cgi?verbose"
><CODE>-verbose</CODE></A>" output of any '<CODE><A HREF="#srt"
>SRT</A></CODE>' distortion (see <A HREF="#distort_verbose" >verbose distort
setting</A> for an example) you will find that internally it really is
a '<CODE><A HREF="#affine_projection" >AffineProjection</A></CODE>' distortion
(see below). </P>

The only distortion effect that the above methods could not handle fully was
'shears' similar to what the <A HREF="../warping/#shear" >Shear Operator</A>
would provide.  For that you need to use a three point affine distortion.  You
can think of this as being a three point distortion, by imagining the first
coordinate mapping as a 'origin' with the other two coordinate mappings as
vectors from that origin. </P>

For example here I draw some text, and overlay a red and blue 'vector' to
define the three control points relative to that text.  Now by moving the
coordinates (as <A HREF="#control_coordinates" >Image Coordinates</A> of those
two lines, we can translate, rotate, scale and shear that text image, to fit
the new location of those lines.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert -background lightblue -fill Gray -font Candice \
      -size 100x100 -gravity center label:Affine\! \
      -draw 'fill blue stroke blue path "M 3,60 32,60 M 27,58 27,62 32,60 Z"' \
      -draw 'fill red  stroke red  path "M 3,60  3,30 M  1,35  5,35  3,30 Z"' \
      label_axis.png
  convert label_axis.png \
          -distort Affine ' 3.5,60.5   3.5,60.5
                           32.5,60.5  32.5,60.5
                            3.5,30.5  33.5,20.5' label_axis_distort_shear.png
  convert label_axis.png \
          -distort Affine ' 3.5,60.5   3.5,60.5
                           32.5,60.5  27.5,85.5
                            3.5,30.5  27.5,35.5' label_axis_distort_rotate.png
  convert label_axis.png \
          -distort Affine ' 3.5,60.5  30.5,50.5
                           32.5,60.5  60.5,80.5
                            3.5,30.5  30.5,5.5' label_axis_distort_affine.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="label_axis.png"
     ><IMG SRC="label_axis.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="label_axis_distort_shear.png"
     ><IMG SRC="label_axis_distort_shear.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="label_axis_distort_rotate.png"
     ><IMG SRC="label_axis_distort_rotate.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="label_axis_distort_affine.png"
     ><IMG SRC="label_axis_distort_affine.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In the first example only the third coordinate (for the vertical red line) was
modified causing the image to be sheared, and stretched along the Y axis.  Of
course it does not have to be limited to just the Y axis.  Later examples make
more radical changes to the image, including rotations, and translations. </P>

Of course the <A HREF="../text/#annotate" >Annotate Text</A> operator can also
skew actual text in this same way, though only with changes to the angle.
That operator will not scale or enlarge the text in some particular direction.
That is to say it can rotate a 'vector' but it can not stretch it longer or
shorter.  See <A HREF="../misc/#annotate" >Annotate Argument Usage</A> for
a table of examples. </P>

Affine distortion can do this type of distortion for any image, and not just
drawn text.  </P>


<B>Affine using less or more that three coordinate pairs</B> </P>

If only 1 or 2 control point pairs are provided, IM will use a more limited
form of affine distortion to match the movement of those fewer points.  For
example with only 1 coordinate pair, it limits itself to unscaled translations
of the image.  With 2 points it will limit itself to a '<CODE><A HREF="#srt"
>Scale-Rotate-Translation</A></CODE>' distortions (no shears).  See the
previous discussion on <A HREF="#control_points" >Distortions Using Control
Points</A> for examples. </P>

If more than 3 control points is given to an  '<CODE><A HREF="#affine"
>Affine</A></CODE>' distortion, then IM will use <A HREF="#control_leastsq"
>Least Squares Fitting</A> to find the best '3 point' affine distortion
matching <I>all</I> the coordinate pairs given.  That means the source image
control points may not map exactly to destination image control points, but
a best-fit 'average' of all the points given. <?P>

For example if you have a scan of a document, you could locate and map all
4 corners of the document for an affine distortion to correct for rotation and
scaling of the document. In this way you can get a better 'average' fit based
of 4 points rather than 3 points. </P>

Note that while more coordinates can produce a better and more accurate
distortion, if one coordinate pair is very bad, then the least squares fit may
not produce a very good fit at all.  Some check to eliminate 'bad coordinate
pairs' may be needed. </P>

<CODE>Future: Add some code to IM to report how 'accurate' each input
coordinate pair is relative to the others to help determine what 'bad points'
should be eliminated by the user.</CODE> </P>

<A NAME="affine_projection"></A>
<H3>Affine Projection Distortion</H3>

As I have already mentioned, the various arguments of an '<CODE><A HREF="#srt"
>SRT</A></CODE>' distortion and the control points of an '<CODE><A
HREF="#affine" >Affine</A></CODE>' distortion, are mathematically transformed
into 6 special numbers which represent the 'coefficients' of an  '<CODE>Affine
Projection</CODE>'. </P>

These numbers in an Affine Projection is the coefficients used for the
<A HREF="#forward_mapping" >Forward Mapping</A> of points in the source image
to the destination image. That is they are the mathematical values used to map
a source image <CODE>x,y</CODE> to a destination image <CODE>i,j</CODE>. </P>

The 6 floating point arguments are (in the order to be given)...
<DIV ALIGN=center><CODE>
  s<sub>x</sub>, r<sub>x</sub>,
  r<sub>y</sub>, s<sub>y</sub>,
  t<sub>x</sub>, t<sub>y</sub>
</CODE></DIV></P>

These in turn form the distortion expressions..
<TABLE ALIGN=center CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=center>
<TD ROWSPAN=3><CODE>X<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> s<sub>x</sub>*X<sub>s</sub> +
               r<sub>y</sub>*Y<sub>s</sub> + t<sub>x</sub> </CODE></TD>
<TD ROWSPAN=3>&nbsp; , &nbsp; &nbsp; &nbsp;</TD>
<TD ROWSPAN=3><CODE>Y<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> r<sub>x</sub>*X<sub>s</sub> +
               s<sub>y</sub>*Y<sub>s</sub> + t<sub>y</sub> <TD></TR>
</TABLE></P>

Where "<CODE>X<sub>s</sub>,Y<sub>s</sub></CODE>" are source image coordinates
and "<CODE>X<sub>d</sub>,Y<sub>d</sub></CODE>" are destination image
coordinates.  Internally ImageMagick Distort will reverse the above equations
so as to do the appropriate <A HREF="#mapping" >Pixel Mapping</A> to map
"<CODE>X<sub>d</sub>,Y<sub>d</sub></CODE>" coordinates to lookup the color at
"<CODE>X<sub>s</sub>,Y<sub>s</sub></CODE>" in the source image. </P>

For more information on how the various Affine Projection Matrix values effect
the image see the <A HREF="affine/" >Affine Matrix Transforms</A> sub-page.
</P>

If you already have these coefficients pre-calculated (say extracted from the
<A HREF="#distort_verbose" >Verbose Output</A> of distort, or calculated them
yourself using other methods from other forms of input arguments, then you can
directly supply them to IM to distort the image. </P>

For example, here I 'shear' the image but using an angle to calculate the
coefficients, rather than the movement of control points.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=koala_affine_proj.png>
   angle=-20
   tan=`convert xc: -format "%[fx:tan( $angle *pi/180)]" info:`
   convert koala.gif -matte -virtual-pixel Transparent \
           +distort AffineProjection "1,$tan,0,1,0,0" +repage \
           koala_affine_proj.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_affine_proj.png"
     ><IMG SRC="koala_affine_proj.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The older way of doing this distortion in ImageMagick was to use the "<A
HREF="../option_link.cgi?affine" ><CODE>-affine</CODE></A>" and "<A
HREF="../option_link.cgi?transform" ><CODE>-transform</CODE></A>" operational
pair.  However as of IM v6.4.2-8 this is just a simple call to
'<CODE>AffineProjection</CODE>' using the 'plus' or 'bestfit' form of the <A
HREF="#distort" >Distort Operator</A>.  See the <A HREF="affine/" >Affine
Matrix Transforms</A> sub-page for more details. </P>


<A NAME="affine_examples"></A>
<H3>Affine Distortion Examples</H3>

<A NAME="affine_tile"></A>
<H4>Affine Tiling</H4>

All three of the above affine-like distortion methods we have looked at so
far, also provides interesting ways to generate various tiling patterns, based
on a distorted image. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks.png    -matte    -virtual-pixel tile \
          -distort  ScaleRotateTranslate  '20,20  .5  30' \
          checks_srt_tile.png
  convert checks.png    -matte    -virtual-pixel tile \
          -distort  Affine  '0,0 10,10   0,89 10,50   89,0 50,0' \
          checks_affine_tile.png
  convert checks.png    -matte    -virtual-pixel tile \
          -distort  AffineProjection  '0.9,0.3,-0.2,0.7,20,15' \
          checks_amatrix_tile.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="checks.png"
     ><IMG SRC="checks.png"                WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="checks_srt_tile.png"
     ><IMG SRC="checks_srt_tile.png"       WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="checks_affine_tile.png"
     ><IMG SRC="checks_affine_tile.png"    WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="checks_amatrix_tile.png"
     ><IMG SRC="checks_amatrix_tile.png"         WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Using a distortion mapping in this way is actually how 'texture mapping' works
in 3D graphic libraries and games.  The only difference is that they map 3
dimensional coordinates of surfaces, back to a two dimensional image.  </P>

Even the 'no-op' distortion ("<CODE>-distort SRT 0</CODE>"), with an
appropriate <A HREF="#distort_viewport" >Distort Viewport</A> provides a
useful way of tiling whole sequence of images such as <A
HREF="../anim_mods/#glitter_tiles" >Animated Glitter Tiles</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert glitter_blue.gif -virtual-pixel tile \
          -filter point -set option:distort:viewport 100x100 -distort SRT 0 \
          glitter_blue_tiled.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/glitter_blue.gif"
     ><IMG SRC="../images/glitter_blue.gif"                WIDTH=48 HEIGHT=48
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="glitter_blue_tiled.gif"
     ><IMG SRC="glitter_blue_tiled.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that I also used a "<CODE><A HREF="../option_link.cgi?filter"
>-filter</A> point</CODE>" to turn off <A HREF="#distort_ewa" >EWA
Resampling</A>, so as speed up the operation, as well as ensure a perfect
(unsampled) copy of the source image pixels. </P>

The <A HREF="#distort_viewport" >Distort Viewport</A> can also specify
an offset, so as to 'roll' the tiled images on the resulting image. </P>


<A NAME="cube3d"></A>
<H4>3d Cubes, using Affine Layering</H4>

The '<CODE><A HREF="#affine" >Affine</A></CODE>' distortion, with its control
points is ideal for generating Orthographic, and Isometric Cubes (see
Wikipedia, <A HREF="http://en.wikipedia.org/wiki/Orthographic_projection"
>Orthographic Projection</A> and <A
HREF="http://en.wikipedia.org/wiki/Isometric_projection" >Isometric
Projection</A> for definitions), from three images.  All that you need to do
is figure out four control points on a destination image. </P>

As we will be using a <A HREF="../layers/#merge" >Image Layering
Technique</A> the points can even have negative values, and allows IM to
adjust the final image size accordingly to the generated warped images. </P>

For this example I'll choose the control points '<CODE>0,0</CODE>' for the
center of the cube, and three points equally spaced around that central
point, at  '<CODE>-87,-50</CODE>', '<CODE>87,-50</CODE>', and
'<CODE>0,100</CODE>'.  All that I then need to to is map the appropriate
corners of three (preferably square) images to these control points.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=isometric_cube.png>
  convert \
     \( lena_orig.png -alpha set -virtual-pixel transparent \
        +distort Affine '0,512 0,0   0,0 -87,-50  512,512 87,-50' \) \
     \( mandrill_orig.png -alpha set -virtual-pixel transparent \
        +distort Affine '512,0 0,0   0,0 -87,-50  512,512 0,100' \) \
     \( pagoda_sm.jpg -alpha set -virtual-pixel transparent \
        +distort Affine '  0,0 0,0   0,320 0,100    320,0 87,-50' \) \
     \
     -background none -compose plus -layers merge +repage \
     -bordercolor black -compose over -border 5x2     isometric_cube.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="isometric_cube.png"
     ><IMG SRC="isometric_cube.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that I used the <A HREF="#control_coordinates" >Coordinates</A> of the
actual edges of the image when distorting the image This means in mathematical
terms the images should fit exactly together. </P>

Also note that I did not simply 'compose' (using the default <A
HREF="../compose/#over" >Over Alpha Composition</A>) the images together.  If
you did that you will get slightly transparent 'gaps' between the images.  The
correct way (as shown) is to use <A HREF="../compose/#plus" >Plus Alpha
Composition</A> to join 'edge connected' pieces, which will result in
a perfect join without transparent gaps. For more information see <A
HREF="../masking/#aligning" >Aligning Two Masked Images</A>. </P>

Afterwards I added an extra border, and removed all transparency.  It is not
required, and you could easily use any background (or "<CODE>none</CODE>")
but doing so will highlight any 'gap' you may have in your images.
</BR>

<!-- <CODE EXECUTE>
  convert isometric_cube.png -crop 20x20+150+55\! -scale 500% \
          isometric_cube_zoom.png
</CODE> -->
  <A HREF="isometric_cube_zoom.png"
     ><IMG SRC="isometric_cube_zoom.png"  WIDTH=100 HEIGHT=100
           ALIGN=right VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</P>

Shown to the right is an enlargement of one such join in the image, showing
the lack of any 'black-filled' gap along the join. </P>


For an alternative method of creating an isometric cube, without using "<A
HREF="../option_link.cgi?distort" ><CODE>-distort</CODE></A>", is given in <A
HREF="../warping/#sheared_cube" >Isometric Cube using Shears</A>. However this
technique does not allow you use sub-pixel coordinates (not that I used any in
the above, but I could have), but is restricted to positioning images using
whole pixel (integers) coordinates. </P>

<A NAME="shadow3d"></A>
<H4>3d Shadows, using Affine Shears</H4>

The same layering methods used above can also be used to generate cool
3-dimensional shadows of odd shapes.  That add a shadow of any 'flat' shape
that is standing upright. </P>

For example lets create a shape with a flat base, so it could possibly
stand upright.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -background None -virtual-pixel Transparent -fill DodgerBlue \
          -pointsize 72 -font Ravie  label:A   -trim +repage \
          -gravity South -chop 0x5  standing_shape.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="standing_shape.png"
     ><IMG SRC="standing_shape.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the 'shape' has a flat base which is also the last row of the image.
This is important as we will distort the shape along that row, so that the
shadow will connect to standing shape alone that row. </P>

Here is the command to generate the 3-D shadow from this 'standing shape'

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert standing_shape.png   -flip +distort SRT '0,0 1,-1 0' \
          \( +clone -background Black -shadow 60x5+0+0 \
             -virtual-pixel Transparent \
             +distort Affine '0,0 0,0  100,0 100,0  0,100 100,50' \
          \) +swap -background white -layers merge \
          -fuzz 2% -trim +repage   standing_shadow.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="standing_shadow.jpg"
     ><IMG SRC="standing_shadow.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The above does quite a few steps to achieve the result shown. The trickiest
however is that first line.  This flips the image then does a 'distort flip'
back again.  The result of this is that the bottom row is now located so that
it has a value of Y=0 on the virtual canvas.  That is the whole image was
given a negative offset to position it so that the bottom row passes through
the origin of the virtual canvas. </P>

By doing this 'trick' we can use a very simple 'affine shear' on the extracted
'shadow' to distort it.  We thus do not need to know the size of the shape
image to distort the shadow, but still manage to keep everything 'lined up',
as they all remain in-sync along the bottom (Y=0) row of the original image.
</P>

You can adjust the direction the shadow falls and its length simply by
adjusting the final coordinate ('<CODE>100,50</CODE>') of the 'affine shear'.
The first two 'coordinate pairs' should not be modified as these 'lock' the
shadow to the original image along the bottom row. </P>

Note however that right up until the last step all the images will contain
negative virtual canvas offsets, so caution is advised if you plan to view or
save the intermediate processing images. </P>

The only problem with this shadowing effect is that it is a 'universal blur'.
That is the shadow is not realistic.   In reality the shadow should be sharp
where it joins the 'standing shape' and getting more blurry as the shadow gets
further way.  This however can be done using a <A HREF="../mapping/#blur"
>Variable Blur Mapping</A>, such as used in <A HREF="../fonts/#var_blur"
>Distance Blurred Shadow Font</A>. </P>

<A NAME="shadow3d_var"></A>
<H4>3D Shadow, using Perspective Compression</H4>

This is another way to add variable blur to the shadow, though I don't
actually recommend it, it is fairly simple to implement.  This example was
developed before <A HREF="../mapping/#blur" >Variable Blur Mapping</A> was
added to ImageMagick. </P>

Basically you first distort the initial shadow shape using a <A
HREF="#perspective" >Perspective Distortions</A> (which is looked at in detail
below), so as to heavily compress the 'distant part' of the shadow, blurring
it, then expanding that compression by distorting it to its final 'Affine
Shear' position that we used above.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert standing_shape.png   -flip +distort SRT '0,0 1,-1 0' \
          \( +clone   -virtual-pixel Transparent -mattecolor None \
             +distort Perspective \
                '0,0 0,0  100,0 100,0   0,-100 45,-100   100,-100 60,-100' \
             -fuzz 2% -trim   -background Black -shadow 60x3+0+0 \
             +distort Perspective \
                '0,0 0,0  100,0 100,0   45,-100 -100,-50   60,-100 0,-50' \
          \) +swap -background white -layers merge \
          -fuzz 2% -trim +repage     standing_shadow_var.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="standing_shadow_var.jpg"
     ><IMG SRC="standing_shadow_var.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is almost exactly the same as the original <A HREF="#shadow3d" >3D
Shadowing Example</A>,  but with some extra steps. </P>

The original shape is first distorted into a trapezoid, then any excess space
is trimmed to speed up the next step.  We then extract a blurred shadow from
the distorted shape.  Once the shadow image has been created from the
distorted image, the same control points are used to un-distort the shadow
image, and move it to its position as an Affine Shear.  </P>

The key is that the shadow blurring happens to a distorted image, which is
then un-distorted (and in this case Affine Sheared, at the same time).  As a
result the blur is also distorted and expanded so as to blur more around the
top part of the shadow, and much less along the base line.  </P>

As a result of the perspective blurring, we get a variable blur that should
peak at about 100 pixels away from the ground base-line. As defined by the
initial perspective blur control points. </P>

<A NAME="resize"></A>
<H3>Resize Images using Distort</H3>

Both <A HREF="#distort" >Distort</A> and <A HREF="../resize/" >Resize</A> are
actually very similar in many aspects. They are both image distortion
operators, and both use <A HREf="#mapping" >Reverse Pixel Mapping</A> to
create the resulting image.  They also both make use of the "<CODE><A
HREF="../option_link.cgi?resize" >-filter</A></CODE>" setting and its expert
controls, for color determination, though they do so in a very different way.
</P>

The <A HREF="../resize/" >Resize</A> is a simplified (and much more common)
image distortion operation, allowing you to make many optimizations.  It is
orthogonally aligned, allowing you to use a 2 pass orthogonal image filtering
method in resize.  That is to say it first sizes in one dimension, then in the
other, using an intermediate temporary image. </P>

Also as the scaling factor is constant over the whole destination image, with
edges aligned to a whole pixel (integer) dimension, the algorithm can greatly
simplify its processing and the caching requirements of the filter it uses.
All these limitations allow for various optimizations that make it very fast
in comparison to the work distort needs to do.  </P>

Distort can also <A HREF="../resize/" >Resize Images</A>, but does so in
a single pass, that directly converts from the original image to the resulting
new image.  It does not need to align the edges to integer pixel positions,
and could rotate, and scale each pixel position.  In other words it is a much
more general operator that requires it to do lot of extra processing for each
pixel in the final result, with fewer places for optimization. </P>

To make <A HREF="#distort" >Distort</A> generate an equivalent image as <A
HREF="../resize/" >Resize</A>, it needs to follow the exact same limitations,
and use some complex image processing trickery.  This was discussed on the IM
forums, in <A HREF="../forum_link.cgi?p=68362" >Correct Resize (using
distorts)</A>, and resulted in an equivalent distort resize technique based on
the use of the <A HREF="#affine" >Affine Distortion Method</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The resulting '<B><CODE>Resize</CODE></B>' distortion method was added to
ImageMagick version 6.6.9-2.  The command line interface (CLI) version of this
distortion will accept and convert the exact same <A
HREF="../basics/#arg_geometry" >Geometry Argument</A> as <A HREF="../resize/"
>Resize</A> does, including the slight discrepancy in scaling factors for the
two dimensions, making this a direct resize alternative.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert logo:  -distort Resize 150x  logo_resized.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="logo_resized.png"
     ><IMG SRC="logo_resized.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Other API interfaces to the '<B><CODE>Resize</CODE></B>' distortion method,
  will only accept two numbers as arguments, which are treated as the final
  integer size for the resulting image.  At this time they will not accept an
  actual geometry argument with its various resize control flags, that modify
  the final image size.  That is flags such as percentage, only resize
  larger/smaller, or even aspect ratio preservation is not available. </P>

  It is left to maintainers of those API's to add such support for this
  special image distortion method.
</I></FONT></TD></TR></TABLE></P>

The real difference between the above <A HREF="#resize" >Distort Resize</A>
and the normal <A HREF="../resize/" >Resize Operator</A>, is that the distort
version uses a much slower single pass <A HREF="../filter/#cylindrical"
>Cylindrical (elliptical) Filter</A>, for determining the final color of each
and every pixel.  In other words it provides a direct comparision of 2 pass
orthogonal filters (resize), verses, an one pass but 2 dimentional cylindrical
filters (distort resize).  </P>

See <A HREF="../resize/#distort_resize" >Distort vs Resize</A> for one just
such comparison. </P>

<A NAME="resize_internals"></A>
<H4>Distort Resize Internals</H4>

The following is the equivalent operations that the above <A HREF="#resize"
>Distort Resize</A> performed internally.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTED>
  convert logo:  -alpha set -virtual-pixel transparent \
          +distort Affine '0,0 0,0   %w,0 150,0   0,%h 0,113' \
          -alpha off  -crop 150x113+0+0 +repage   distort_resize.png
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The values '<CODE>150</CODE>' and '<CODE>113</CODE>' (used in two places) is
the desired size of the final image to the nearest integer. It was calculated
to try and best preserve the image aspect ratio, while keeping to the final
integer size limitation.  They are normally calculated by ImageMagick from the
given resize <A HREF="../basics/#arg_geometry" >Geometry Argument</A>, using
a separate API function. </P>

It then enables transparency and transparent <A HREF="../misc/#virtual"
>Virtual Pixels</A>, so that external 'virtual pixels' do not take part in the
calculation of the final pixel color.  When the distortion is complete the
transparency is again removed (turned off), and the 'buffer' pixels added by
distort, is removed using a <A HREF="../crop/#crop" >Image Crop</A>. </P>

Because of the use of transparent pixels, the above command will only work
correctly for images that do not contain any transparency, such as the
"<CODE>logo:</CODE>" built in image exampled above. </P>

This is the much more complex version, that is required to separate the
effects of <A HREF="../misc/#virtual" >Virtual Pixels</A> from any possible
existing transparency in the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE EXECUTED>
  convert logo: -alpha set -virtual-pixel transparent \
          \( +clone -alpha extract -alpha opaque \) \
          +distort Affine '0,0 0,0   %w,0 150,0   0,%h 0,113' \
          -alpha off -crop 150x113+0+0 +repage \
          -compose CopyOpacity -composite      distort_resize_trans.png
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

This does two distorts: first to distort the image and then to distort the
alpha (transparency) channel separately, in each case using transparent to
remove virtual-pixel effects. As a result it is at least twice as slow as the
one when no transparency is present in the original image. </P>

Both the these techniques are implemented internally by the <A HREF="#resize"
>Distort Resize Method</A>.  As such this 'method' is really a convenience
'macro' for users, an not actually a real distortion method, which is an
'affine' distortion. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="perspective"></A>
<H2>Four Point Distortion Methods</H2>

<H3>Perspective Distortion</H3>

Probably the most common requested type of distortion, has been for a fast
perspective distortion operation.  This is a 4 point distortion, so requires
at least  4 sets of control point pairs, or 16 floating point values. </P>

For example, here I have an image building.  From this image I manually
discovered the location of 4 points (red). I also defined the final location
to which I those points transformed to in the final image (blue), so as to
'straighten' or 'rectify' the face of the building.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert building.jpg \
          -draw 'fill none stroke red polygon 7,40 4,124, 85,122, 85,2' \
          building_before.jpg
  convert building.jpg \
          -draw 'fill none stroke blue polygon 4,30 4,123, 100,123, 100,30' \
          building_after.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/building.jpg"
     ><IMG SRC="../img_photos/building.jpg"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="building_before.jpg"
     ><IMG SRC="building_before.jpg"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="building_after.jpg"
     ><IMG SRC="building_after.jpg"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

To do the actual image distortion, you only need to feed those coordinates
into the '<CODE>perspective</CODE>' method of "<A
HREF="../option_link.cgi?distort" ><CODE>-distort</CODE></A>".

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert building.jpg -matte -virtual-pixel transparent \
         -distort Perspective \
              '7,40 4,30   4,124 4,123   85,122 100,123   85,2 100,30' \
          building_pers.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/building.jpg"
     ><IMG SRC="../img_photos/building.jpg"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="building_pers.png"
     ><IMG SRC="building_pers.png"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Notice the blank area on the top right, where the distortion 'missed' the
pixel data in the source image.  What IM does in this situation is controlled
by the "<A HREF="../option_link.cgi?virtual-pixel"
><CODE>-virtual-pixel</CODE></A>" setting (see <A
HREF="../misc/#virtual-pixel" >Virtual Pixel</A>). </P>

What is less noticeable is that a small amount of the left-most edge of the
original image is also 'lost' for the same reason. </P>

As a matter of interest lets also reverse the distortion, by swapping the
coordinates of each mapping pair.  This lets us see just how much of the
image is degraded by the distortion.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert building_pers.png  -matte -virtual-pixel transparent \
         -distort Perspective \
              '4,30 7,40   4,123 4,124   100,123 85,122   100,30 85,2' \
          building_pers_rev.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/building.jpg"
     ><IMG SRC="../img_photos/building.jpg"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="building_pers.png"
     ><IMG SRC="building_pers.png"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="building_pers_rev.png"
     ><IMG SRC="building_pers_rev.png"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Not bad. A lot of 'fuzziness' is present, but that can't be helped.  Notice
that the 'fuzziness' is worse on the right side of the image where it was
compressed the most.   All distorts suffer from this compression problem, as
such you should always try to distort from an original image, rather than
distorting an already distorted image. </P>

Here is another example, of using this transform, using the special
checkerboard test image we created above, which we distort then reverse the
distortion.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks.png        -matte    -virtual-pixel transparent \
          -distort Perspective '0,0,0,0  0,90,0,90  90,0,90,25  90,90,90,65' \
          checks_pers.png
  convert checks_pers.png   -matte    -virtual-pixel transparent \
          -distort Perspective '0,0,0,0  0,90,0,90  90,25,90,0  90,65,90,90' \
          checks_pers_rev.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="checks.png"
     ><IMG SRC="checks.png"               WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="checks_pers.png"
     ><IMG SRC="checks_pers.png"          WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="checks_pers_rev.png"
     ><IMG SRC="checks_pers_rev.png"          WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

You can see the slight fuzziness caused by image compression, but the image is
basically restored. </P>

What actually happens is that IM uses all the control point pairs given to
calculate the appropriate coefficients for a '<CODE><A
HREF="#perspectiveprojection" >Perspective Projection</A></CODE>' (see next).
If you include a <A HREF="#distort_verbose" >Verbose</A> setting, you can see
both the coefficients, and the <A HREF="../transform/#fx" >DIY FX
Equivalent</A> that is being used internally by IM to perform this distortion.
</P>

If only 3 or less control point pairs are provided, IM will automatically fall
back to the simpler '<CODE><A HREF="#affine" >Affine</A></CODE>' distortion.
While more that 4 points (for '<I>Image Registration</I>') will be <A
HREF="#control_leastsq" >Least Squares Fitted</A> to find the best fitting
distortion for all the given control points. </P>


<I>FUTURE: Alternative.  The four coordinates could also represent a triangle
and center point.  You can fix the triangle and move the center point, or fix
that center and move the other three coordinates, to generate the perspective
view.  </I></P>

If you like to see more detail of how the distortion works, look at the <A
HREF="#perspective_internals" >Perspective Internals</A> below.  You can also
look at a Postscript implementation that was presented in a PDF paper <A
HREF="http://www.fho-emden.de/~hoffmann/persprect13052005.pdf" >Perspective
Rectification</A>, by <I>Gernot Hoffmann</I>.  Also have a look at <A
HREF="http://www.leptonica.com/affine.html" >Leptonica Affine and Perspective
Transforms</A>. </P>

<BR>

<A NAME="horizon"></A>
<H3>Viewing Distant Horizons</H3>

You can produce some very unusual effects using <A HREF="#perspective"
>Perspective Distortions</A> if you adjust the coordinates to produce a
'vanishing point' within the boundaries of the image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks.png -mattecolor DodgerBlue \
          -virtual-pixel background -background Green \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          checks_horizon.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="checks_horizon.png"
     ><IMG SRC="checks_horizon.png"        WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Well we used '<CODE>Green</CODE>' for the virtual pixels that 'surround' the
original image image, which we enabled using <A HREF="../misc/#background"
>Virtual Pixel Background Settings</A>.  But what is more interesting is the
appearance of the 'blue' color that was defined using the "<CODE><A
HREF="../option_link.cgi?mattecolor" >-mattecolor</A></CODE>" setting.  </P>

This 'blue' color represents an area where the pixels generated by the
distortion is <I>invalid</I>, and in such areas the "<A
HREF="../option_link.cgi?distort" ><CODE>-distort</CODE></A>" operator will
just output the "<CODE><A HREF="../option_link.cgi?mattecolor"
>-mattecolor</A></CODE>" setting.  </P>

For a <A HREF="#perspective" >Perspective Distortion</A>, any pixel ending up
in the 'sky' of the resulting image will be classed as invalid. Also it
defines the 'sky' as being the side of the 'horizon' on which the source image
will not appear.  The 'sky' will only appear in perspective distorted images
when the resulting image is highly foreshortened by the distortion. </P>

If you don't want a 'sky' in your final image result then the best idea is to
set both "<CODE><A HREF="../option_link.cgi?background"
>-background</A></CODE>" and "<CODE><A HREF="../option_link.cgi?mattecolor"
>-mattecolor</A></CODE>" to use the same color. </P>

The <A HREF="#perspective" >Perspective Distortion</A> gets more interesting
when one of the special infinite tiling <A HREF="../misc/#virtual-pixel"
>Virtual Pixel</A> settings are used.  For example here we used a '<CODE><A
HREF="../misc/#tile" >tile</A></CODE>' setting to generate an infinitely
tiled plane.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert checks.png  -virtual-pixel tile -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          horizon_tile.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="horizon_tile.png"
     ><IMG SRC="horizon_tile.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

A word of warning about this image. Asking for an infinitely tiled image is
<I>very slow</I> to generate.  The larger the image the slower it gets.  You
can monitor the progress of the "<CODE><A HREF="../option_link.cgi?distort"
>-distort</A></CODE>" (or any other slow image processing task) using the
"<CODE><A HREF="../option_link.cgi?monitor" >-monitor</A></CODE>" <A
HREF="../basics/#controls" >Operational Control Setting</A>.  </P>

Basically for a single pixel that is close to the horizon, ImageMagick will
need to average a huge number of pixels from the original image to figure out
the appropriate color.  This can take a very long time.  ImageMagick does try
to limit the amount of time it uses to handle these near-horizon pixels, by
caching information, and using some in-built knowledge of various <A
HREF="../misc/#virtual-pixel" >Virtual Pixel</A> settings, but it can still
take a long time. </P>

For more details of this method see <A HREF="#area_resample" >Area
Resampling</A> above. </P>

Another infinitely tiled perspective image can be generated by using a <A
HREF="../misc/#random" >Random Virtual Pixel Setting</A>...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert checks.png  -virtual-pixel random -mattecolor DodgerBlue \
          -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          horizon_random.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="horizon_random.png"
     ><IMG SRC="horizon_random.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

What is happening is that all virtual pixels surrounding the image are just
random picks of any pixel within the image itself.  The result is a ground
consisting of random noise that gets smoother and more blurred as you look
toward the horizon of the image. It gives a natural feeling of depth, without
any specific repeating pattern. </P>

Here I repeated the above but with a pure black and white source image.
However I am not interested in the actual distorted image, only the <A
HREF="../misc/#virtual-pixel" >Virtual Pixel</A> '<CODE>random</CODE>' pattern
that was generated, so I changed what part of the 'distorted image space' I am
looking at, by using a special
'<CODE>-set&nbsp;option:distort:viewport</CODE>' setting.  This setting
overrides the normal size and location of the area of distorted space being
viewed.  In this case an area only containing virtual pixels, and not the
distorted image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 90x90 pattern:gray50 -matte \
       -virtual-pixel random -mattecolor none \
       -set option:distort:viewport 120x120+100-15 \
       -distort Perspective '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
       +repage -size 120x50 gradient:dodgerblue-tomato \
       -compose DstOver -composite    sunset_horizon.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sunset_horizon.png"
     ><IMG SRC="sunset_horizon.png"   WIDTH=120  HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

To complete the image I removed the viewport offset (using "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>" ), and <A
HREF="../compose/#dstover" >Underlaid or DstOver</A> a gradient of sunset
colors into the  transparent 'sky' (set using "<CODE><A
HREF="../option_link.cgi?mattecolor" >-mattecolor</A></CODE>") . </P>

A very interesting image that could be used as a backdrop for some other image
processing work.  You can adjust the distortion parameters to adjust the
height and slope of the horizon. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here is a more traditional test of a tiled perspective distortion.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pattern:checkerboard -scale 120x120 -normalize \
          -virtual-pixel tile  -distort Perspective \
             '0,0 10,61   119,0 60,60   0,119 5,114   119,119 125,110' \
          checkered_plain.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="checkered_plain.gif"
     ><IMG SRC="checkered_plain.gif"   WIDTH=120  HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In my studies I found the above test to be misleading, as it gives no real
indication of the quality of the area resampling technique for near unity
scales of an image (foreground area, rather than distant areas).  That is
a close look at the resampling problems such as described in <A
HREF="../filter/#artefacts" >Resampling Artefacts</A>. </P>

This last image also shows a 'cutoff' point close to the horizon where
ImageMagick decided that it was not worth attempting to determine the
appropriate color for a pixel (with consideration of the current virtual pixel
setting), but short-circuit the EWA algorithm and use the average color of the
whole image. It is only visible in this image because of the large scale
diagonal pattern of color that is present in the image. </P>

The average color of an image is only calculated once per distortion
operation, and only when first needed. By using it ImageMagick saves a huge
amount of time calculating colors close to the horizon when typically the
result will be the images average color. This happens when either the ellipse
become so elongated as to exceed floating point limits, or the number of
sampling pixels (bounding parallelogram of elipse) becomes 4 times larger than
the input source image.  This is currently not user setable.  </P>

<BR>

<A NAME="box3d"></A>
<H3>3d Boxes, Perspective Layering</H3>

The 'plus' form of "<A HREF="../option_link.cgi?distort"
><CODE>+distort</CODE></A>" which ensures the whole distorted image is
preserved in a correctly positioned layer (or 'virtual-canvas') is designed so
that if the same 'control points' used to distort images, those point will
line up in 'virtual-space'.  This means that if the images are <A
HREF="../layers/#merge/" >Layer Merged</A> together, those images will also
line-up according to the control points. </P>

For example here we generate two images, a 'front' and a 'spine' image, so
that two edge control points are lined with each other, to form the spine of a
box.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  # Generate a Spine Image
  convert -size 200x40 xc:skyblue \
    -pointsize 20 -gravity north -annotate +5+0 'IM Examples' \
    -pointsize 10 -gravity south -annotate +0+0 'ImageMagick' \
    -stroke blue -strokewidth 2 -draw 'line 30,0 30,40' \
    -rotate -90 box_spine.jpg

  # generate the front cover
  convert -size 150x200 xc:skyblue \
    -fill black -pointsize 20 -gravity north -annotate +0+5 'IM Examples' \
    -fill blue -pointsize 15 -gravity northeast -annotate +5+28 'Box Set' \
    -fill black -pointsize 15 -gravity south -annotate +0+5 'ImageMagick' \
    -stroke blue -strokewidth 2 -draw 'line 0,169 150,169' \
    \( logo.gif -resize 100x100 \) \
    -gravity center -compose multiply -composite box_front.jpg

  # Distort both images and merge using common points.
  convert \
    \( box_spine.jpg -alpha set -virtual-pixel transparent \
       +distort Perspective \
           '0,0 -30,20  0,200 -30,179  40,200 0,200  40,0 0,0' \) \
    \( box_front.jpg -alpha set -virtual-pixel transparent \
       +distort Perspective \
           '0,0 0,0  0,200  0,200  150,200 100,156  150,0 100,30' \) \
    \
    -background black -compose plus -layers merge  +repage \
    -bordercolor black -compose over -border 15x2    box_set.jpg
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="box_spine.jpg"
     ><IMG SRC="box_spine.jpg"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="box_front.jpg"
     ><IMG SRC="box_front.jpg"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="box_set.jpg"
     ><IMG SRC="box_set.jpg"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

Also note the use of <A HREF="../compose/#plus" >Plus Alpha Composition</A> to
join 'edge connected' pieces.  This is required to prevent the generation of
a 'semi-transparent gap' between the two images.  For more information see <A
HREF="#cube3d" >3D Cube</A> example above, as well as <A
HREF="../masking/#aligning" >Aligning Two Masked Images</A>. </P>

Using positions like this means that almost all the 'spine' image is actually
distorted into a negative 'x' position.  The resulting image thus has
a negative offset on the virtual canvas.   IM has no problems doing this when
using the layering "<A HREF="../option_link.cgi?distort"
><CODE>+distort</CODE></A>" version of the operator.   The <A
HREF="../layers/#merge" >Layers Merge</A> operator also is designed to handle
layering images with negative offsets, 'stitching' the two images together
cleanly. </P>

I still need to use a final "<A HREF="../option_link.cgi?repage"
><CODE>+repage</CODE></A>" to remove that negative offset from the final
image, after they have been 'merged' together. If I don't other programs like
web browsers may not understand such negative offsets, and cause undefined
effects. </P>

The above is example has also been placed in the shell script "<B><CODE><A
HREF="../scripts/box_set_example" >box_set_example</A></CODE></B>" so that you
can download and play with it more conveniently. </P>

You can take this further to also add mirror images of the 'box' being
reflected by surface on which it sits, though you may also like to recolor or
dim that image in some way to make it more realistic. See <A
HREF="../advanced/#reflections" >Reflections</A> for such mirror techniques.
</P>

<BR>

A further example in PHP, was developed in a discussion on Wrapping 'photos'
over a borderless canvas frame. See <A HREF="../forum_link.cgi?f=1&t=21239"
>Canvas wrap transformation</A>, for more details. </P>

<BR>

To finish off with here is a fantastic example by Jean-Franois Hren for <A
HREF="http://www.animecoversfan.com/" >www.animecoversfan.com</A>  which was
heavily discussed on the <A HREF="../forum_link.cgi?t=11726" >IM Discussion
Forums</A>. </P>

<DIV ALIGN=center>
  <IMG SRC="../img_diagrams/video_box_example.png"  WIDTH=419 HEIGHT=253
       ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[Diagram]"></A>
</DIV></P>

This image was created by taking an artistic image of an anime video box cover,
splitting up that cover into 3 segments ('cover', 'spine', and 'back'),
distorting each separately, into layered images, adding a fourth 'disk' image,
and merged together.  The image was then finished by the addition of
highlights and shading effects (using <A HREF="../compose/#hardlight"
>HardLight</A> image composition), and the addition of border and
semi-transparent shadow effects (using <A HREF="../compose/#copyopacity"
>CopyOpacity</A>). </P>

What is more amazing is the whole process was done by a single
"<CODE>convert</CODE>" command, from the input images.  It is an excellent
example of just what IM can do, and the process by which a complex command
script can be generated.  I recommend reading the <A
HREF="../forum_link.cgi?t=11726" >forum discussion</A> as it contains a lot of
hints, tips, and general debugging techniques.  </P>


<I>(More Contributed examples welcome)</I> </P>

<A NAME="perspective_projection"></A>
<H3>Perspective Projection Distortion</H3>

Just as the '<CODE><A HREF="#affine" >Affine</A></CODE>' distortion can be
handled directly giving the mathematical coefficients for a '<CODE><A
HREF="#affine_projection" >Affine Projection</A></CODE>', so to '<CODE><A
HREF="#perspective" >Perspective</A></CODE>' can also be handled by
8 coefficients of a '<CODE>Perspective Projection</CODE>' distortion. </P>

</TABLE></TABLE></TABLE>

As before, these numbers represent the coefficents used for the <A
HREF="#forward_mapping" >Forward Mapping</A> of points in the source image to
the destination image.  That is they are the mathematical values used to map
a source image <CODE>x,y</CODE> to a destination image <CODE>i,j</CODE>. </P>


The 8 floating point arguments are (in the order given)...
<TABLE ALIGN=center><TR><TD><CODE>
  s<sub>x</sub>, r<sub>y</sub>, t<sub>x</sub>, <br>
  r<sub>x</sub>, s<sub>y</sub>, t<sub>y</sub>, <br>
  p<sub>x</sub>, p<sub>y</sub>
</CODE></TD></TR></TABLE></P>

These coefficient values in turn form the expression..
<TABLE ALIGN=center CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=center>
<TD ROWSPAN=3><CODE>X<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> s<sub>x</sub>*X<sub>s</sub> +
               r<sub>y</sub>*Y<sub>s</sub> + t<sub>x</sub> </CODE></TD>
<TD ROWSPAN=3>&nbsp; , &nbsp; &nbsp; &nbsp;</TD>
<TD ROWSPAN=3><CODE>Y<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> r<sub>x</sub>*X<sub>s</sub> +
               s<sub>y</sub>*Y<sub>s</sub> + t<sub>y</sub> </CODE><TD></TR>
<TR><TD><FONT SIZE=0><HR></FONT></TD>
    <TD><FONT SIZE=0><HR></FONT></TD></TR>
<TR><TD ALIGN=center>
    <CODE>&nbsp;p<sub>x</sub>*X<sub>s</sub> +
                p<sub>y</sub>*Y<sub>s</sub> + 1.0&nbsp;</CODE></TD>
    <TD ALIGN=center>
    <CODE>&nbsp;p<sub>x</sub>*X<sub>s</sub> +
                p<sub>y</sub>*Y<sub>s</sub> + 1.0&nbsp;</CODE></TD></TR>
</TABLE></P>

Where "<CODE>X<sub>s</sub>,Y<sub>s</sub></CODE>" are source image coordinates
and "<CODE>X<sub>d</sub>,Y<sub>d</sub></CODE>" are destination image
coordinates.  Internally ImageMagick Distort will reverse the above equations
so as to do the appropriate <A HREF="#mapping" >Reverse Pixel Mapping</A> to
map "<CODE>X<sub>d</sub>,Y<sub>d</sub></CODE>" coordinates to lookup the color
at "<CODE>X<sub>s</sub>,Y<sub>s</sub></CODE>" in the source image. </P>

The first 6 values of the '<CODE>Perspective Projection</CODE>' is in fact the
same coefficients to that of the '<CODE><A HREF="#affine_projection" >Affine
Projection</A></CODE>', though they are slightly reordered to be more logical
(in 'matrix math' terms, the first 6 elements have been diagonally
transposed).  </P>

The extra two arguments <CODE>p<sub>x</sub>,p<sub>y</sub></CODE> form a
scaling divisor to the whole distortion which causes the image to look smaller
in the specific direction according to the values given, and thus giving the
distorted image the perspective 'distance' effect. If these two values are set
to zero, the '<CODE>Perspective Projection</CODE>' distortion becomes
equivalent to a '<CODE>Affine Projection</CODE>' </P>

For example...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR<TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD><TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -alpha set -virtual-pixel transparent \
          -distort Perspective-Projection \
             '1.40, 0.25, 3.0    0.15, 1.30, 0.0    0.007, 0.009' \
          perspective_projection_rose.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="perspective_projection_rose.png"
     ><IMG SRC="perspective_projection_rose.png"    WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Remember the matrix you give is the forward projective matrix, that will map
source image coordinates to destination image coordinates.  Internally
ImageMagick will reverse the matrix so it can map destination image coordinates
to source image coordinates.  If you like to see what those values are use the
<A HREF="#distort_verbose" >Verbose Distortion Option</A>, to get IM output
its internal coefficients as a <A HREF="../transform/#fx" >FX Operator
Expression</A> (see next). </P>


<A NAME="perspective_internals"></A>
<H3>Perspective Internals</H3>

If you add "<A HREF="../option_link.cgi?verbose" ><CODE>-verbose</CODE></A>"
(see <A HREF="#distort_verbose" >Verbose Distortion Summery</A> above) just
before the Perspective distortion IM will output two operators that should be
near equivalent replacements to the "<A HREF="../option_link.cgi?distort"
><CODE>-distort</CODE></A>"  operator.  One is a VERY SLOW "<A
HREF="../option_link.cgi?fx" ><CODE>-fx</CODE></A>" version (See <A
HREF="../transform/#fx" >FX DIY operator</A>.  The other will be the Forward
mapping Perspective_Projection matrix.  </P>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR<TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD><TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=perspective_verbose.txt>
  convert rose: -matte -virtual-pixel transparent -verbose \
          -distort Perspective "0,0,3,0 0,46,10,46 70,0,70,7 70,46,60,40" \
          +verbose perspective_rose.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="perspective_rose.png"
     ><IMG SRC="perspective_rose.png"    WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="perspective_verbose.txt"
     ><IMG SRC="perspective_verbose.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

The first section <I>Perspective Projection</I> can be used to map source
coordinates into destination coordinates.  The formula is as above. </P>

<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
<TR><TD><CODE>
&nbsp; i = ( 1.430099*x +0.246650*y +3 )/( 0.006757*x + 0.009448*y +1 ) &nbsp;<BR>
&nbsp; j = ( 0.147296*x +1.434591*y +0 )/( 0.006757*x + 0.009448*y +1 ) &nbsp;
</CODE></TD></TR></TABLE>
</DIV></P>

An example of extracting and using these values is showing in the last set of
examples in <A HREF="../layers/#layer_distort" >Positioning Distorted Layer
Images</A>. </P>


On the other hand the second FX equivalent section uses a different set of
8 coefficients, which performs the <A HREF="#mapping" >Reverse Pixel
Mapping</A> an image distortion actually needs to apply. Namely...

<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
<TR><TD><CODE>
&nbsp; x = ( 0.711858*i -0.108326*j -2.135575 )/(-0.004119*i -0.005877*j +1 ) &nbsp;<BR>
&nbsp; y = (-0.073090*i +0.699571*j +0.219269 )/(-0.004119*i -0.005877*j +1 ) &nbsp;
</CODE></TD></TR></TABLE>
</DIV></P>

Note in the output <I>FX equivelent</I> formula the divisor coefficients are
used first as they are common to both X and Y coordinate equations. </P>

Remember all the coordinates that you give are in image coordinates, not pixel
coordinates, see <A HREF="#control_coordinates" >Image Coordinates vs Pixel
Coordinates</A> for details.  As such any pixel position will need 0.5 added
to the input pixel coordinate, before applying the above, and then subtract
0.5 from the final coordinate, to  convert it back into pixel (draw)
coordinates.  You can see this being applied in the <i>FX equivalent</I> code
above. </P>

The final test in the FX equivalent, just before the source image lookup,
handles the invalid 'sky' pixels, where the destination fails to map to the
source image correctly. However it will just substitute '<CODE>blue</CODE>'
for such pixels instead of the "<A HREF="../option_link.cgi?mattecolor"
><CODE>-mattecolor</CODE></A>", and does not provide any horizon anti-aliasing
that the internal algorithm provides for the perspective distortion. </P>

<BR>
<B>Example of perspective forward mapping...</B>

These mappings let you convert a specific coordinate in one image to
a location in the other image (either direction).  For example, a dark point
in the center of the source rose image is at pixel coordinates
'<CODE>39,20</CODE>'.  Mapping that to image coordinates by adding &frac12; to
get '<CODE>39.5,20.5</CODE>'. Now we can use the x,y to i,j equations to map
that to destination image coordinates '<CODE>44.2,24.1</CODE>'.  And finally to
'draw' pixel coordinates by subtracting &frac12; and we get the final position
of '<CODE>43.7,23.6</CODE>'. </P>

And here I mark that coordinate using a circle on both the input and output
images..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -fill none -stroke black \
          -draw 'circle 39,20 39,24'    rose_marked.png

  convert perspective_rose.png -fill none -stroke black \
          -draw 'circle 43.7,23.6 43.7,26.6'  perspective_rose_marked.png
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="rose_marked.png"
     ><IMG SRC="rose_marked.png"     WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="perspective_rose_marked.png"
     ><IMG SRC="perspective_rose_marked.png"     WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

As you can see the same point in the perspective distorted image has been
correctly located in both images (even down to a sub-pixel level)! </P>


<A NAME="bilinear"></A>
<H3>Bilinear Distortions</H3>

The '<CODE>Bilinear</CODE>' distortion methods implements another, type of
4 point distortion. However this are not nearly as straight forward as
a '<CODE><A HREF="#perspective" >Perspective</A></CODE>' distortion we looked
at above. But as you will see it is a very useful alternative distortion. </P>


<A NAME="bilinear_forward"></A>
<H4>Forward Bilinear Distortion</H4>

For example lets take a special test image of a mandrill that has had a
grid overlaid on it, and distort it with perspective and bilinear.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mandrill_grid.jpg -matte -virtual-pixel black \
       -distort Perspective \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_pers.jpg
  convert mandrill_grid.jpg -matte -virtual-pixel black -interpolate Spline \
       -distort BilinearForward \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_blin.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR>
<TD ALIGN=center>
  <A HREF="../img_photos/mandrill_grid.jpg"
     ><IMG SRC="../img_photos/mandrill_grid.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Original</FONT>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="mandrill_pers.jpg"
     ><IMG SRC="mandrill_pers.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Perspective</FONT>
</TD><TD ALIGN=center>
  <A HREF="mandrill_blin.jpg"
     ><IMG SRC="mandrill_blin.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Bilinear</FONT>
</TD></TR></TABLE>
</DIV></P>

First you should notice that both distortions correctly mapped the image from
one set of control points to the other set of points. Also all horizontal and
vertical lines in the source image also remain straight, in both distortions.
</P>

However there the simalities end.  Perspective will reduce the spacing
between lines so that even the diagonal lines remain straight. This results in
the areas of the squares becomming smaller, and thus giving the top-right
corner a realistic 'in the distance' look. </P>

Bilinear on the other hand does not make one side of the image look 'further
away', nor does it try to keep lines straight.  What it tries to do is keep
all the spacings between the lines constant, but this results in the diagonal
line becomming curved. </P>

That is it preserves the distance ratios along any given line. That is the
relative lengths each line segment remains the same along the whole length of
the line, even though the line itself may be bent, curved, or shortened as
a whole.  That means the grid spacing in the above example remains constant
scale across the whole image, and the distorted square at the top-right is
still about the same size as the distorted square at the bottom-left.  The
image remains 'flat looking', just distorted into a different shape. </P>

Note that (forward) bilinear does ensure that any horizontal or vertical lines
in the original image will remain straight in the final image.  That is it
will take an orthogonally aligned rectangle and transform it into the specified
quadrilateral, so that each of the sides of the original rectangle remains
straight with constant scaling over the whole line. </P>

It is this aspect of the distort that makes a '<CODE>BilinearForward</CODE>'
distortion useful in much more complex 'grid' distortions. That is because two
neighbouring 'quadrilaterals' even though they may be distorted very
differently will still correctly line up correctly edge-to-edge. </P>

Here is another comparison between '<CODE><A HREF="#perspective"
>Perspective</A></CODE>' and '<CODE><A HREF="#bilinear_forward"
>BilinearForward</A></CODE>', using a very severe distortion of the built-in
rose image...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert rose: -matte -virtual-pixel transparent \
          -distort Perspective "0,0,3,0 0,46,10,46 70,0,70,7 70,46,60,40" \
          perspective_rose.png
  convert rose: -matte -virtual-pixel transparent -interpolate Spline \
          -distort BilinearForward "0,0,3,0 0,46,10,46 70,0,70,7 70,46,60,40" \
          bilinear_rose.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR>
<TD ALIGN=center>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"         WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Original</FONT>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="perspective_rose.png"
     ><IMG SRC="perspective_rose.png"         WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Perspective</FONT>
</TD><TD ALIGN=center>
  <A HREF="bilinear_rose.png"
     ><IMG SRC="bilinear_rose.png"    WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Bilinear</FONT>
</TD></TR></TABLE>
</DIV></P>

To achieve its goals (preserving all straight lines) the Perspective
Distortion seems to 'suck' just about the whole image into the smaller area to
the right, while the Bilinear distortion kept the centered rose, centered in
its results.  Again it preserved distance ratios, keeping the rose equally
spaced between the left and right edges.  All in did was to simply vertically
compress the height of the image linearly along its length. </P>

This aspect of a '<CODE>BilinearForward</CODE>' distortion makes it also known
as a 'Trapezoidal' distortion. That is simply compress the image linearly in
one direction, when only one direction being scaled.  that compression
direction can even be angled, rather than aligned along one axis. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that due to the complexity of the reverse pixel mapping needed to
  perform a '<CODE>BilinearForward</CODE>' distortion, the <A
  HREF="#area_resample" >Area Resampling</A> is currently turned off. </P>

  As such areas of extreme compression (more than a factor of 2) will likely
  show some aliasing effects (see the edges of the lines in the examples
  above.  However using <A HREF="#super_sample" >Super-Sampling</A>, or
  '<CODE>-interpolate Spline</CODE>' can be used to improve the quality of the
  final image.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.5.7-0 the '<CODE>BilinearForward</CODE>' distortion was still
  in development and had problems with specific 'degenerate' cases, that could
  cause a 'black' error image in specific situations.
</I></FONT></TD></TR></TABLE></P>


<A NAME="bilinear_reverse"></A>
<H4>Reversed Bilinear Distortion</H4>

Because only horizontal and vertical lines remain straight you can not use
a '<CODE>BilinearForward</CODE> distortion to reverse the distortion. As the
grid lines in the transformed image are no longer horizontal or vertical, they
will no longer remain straight in the resulting image!  </P>

For example swapping coordinate pairs, and re-applying the 'forward'
distortion (such as we did using the '<CODE><A HREF="#perspective"
>Perspective</A></CODE>' distortion above) will fail to recover the original
image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mandrill_blin.jpg -matte -virtual-pixel black \
       -distort BilinearForward \
              '26,0 0,0   114,23 128,0   128,100 128,128  0,123 0,128' \
       mandrill_blin_back.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="mandrill_blin.jpg"
     ><IMG SRC="mandrill_blin.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="mandrill_blin_back.jpg"
     ><IMG SRC="mandrill_blin_back.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the actual coordinates specified did actually position themselves
correctly, but the image distortion has not been reversed. </P>

In summery a '<CODE><A HREF="#bilinear_forward" >BilinearForward</A></CODE>'
distortion is NOT its own reverse. </P>

To restore the image you need to use a slightly different but closely related
distortion.  The mathematical reverse of the 'geometric transformation' has
been implemented as a '<CODE>BilinearReverse</CODE>' distortion.  </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mandrill_blin.jpg -matte -virtual-pixel black \
       -distort BilinearReverse \
              '26,0 0,0   114,23 128,0   128,100 128,128  0,123 0,128' \
       mandrill_blin_rev.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="mandrill_blin.jpg"
     ><IMG SRC="mandrill_blin.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="mandrill_blin_rev.jpg"
     ><IMG SRC="mandrill_blin_rev.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As previously stated, due to the complexity of a '<CODE><A
  HREF="#bilinear_forward" >BilinearForward</A></CODE>' distortion, the <A
  HREF="#area_resample" >Area Resampling</A> is currently turned off, which in
  the above causes sever aliasing effects.

</I></FONT></TD></TR></TABLE></P>


The '<CODE><A HREF="#bilinear_reverse" >BilinearReverse</A></CODE>'has the
same distance ratio preserving features of a '<CODE>BilinearFoward</CODE>' but
will convert any quadrilateral into an orthogonally aligned rectangle, ensuring
the sides of the quadrilateral remain straight when mapped to a vertical and
horizontal alignment. As you can see in the above. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.5.1-2 the '<CODE>BilinearReverse</CODE>' distortion was
  implemented simply as '<CODE>Bilinear</CODE>'.
</I></FONT></TD></TR></TABLE></P>

Some implementations of a bilinear distortion (including older versions of IM
and the <A HREF="http://www.leptonica.com/local-sources.html" >Leptonica
Library</A>) only implemented the above simpler (reversed) version of Bilinear
distortion.  However such a distortion is not very well suited to 'forward
mapping' a rectangular image. </P>

For example here I try to use a '<CODE><A HREF="#bilinear_reverse"
>BilinearReverse</A></CODE>' for an distortion which should probably have used
a '<CODE><A HREF="#bilinear_forward" >BilinearForward</A></CODE>' distortion.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mandrill_grid.jpg -matte -virtual-pixel black \
       -distort BilinearReverse \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_blin_rev2.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/mandrill_grid.jpg"
     ><IMG SRC="../img_photos/mandrill_grid.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="mandrill_blin_rev2.jpg"
     ><IMG SRC="mandrill_blin_rev2.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see as the destination quadratrial was not an orthogonal rectangle
the image was severely distorted producing lots of inward curving lines. </P>


<A NAME="bilinear_tiling"></A>
<H4>Tiled Bilinear Distortions</H4>

Now while a '<CODE><A HREF="#bilinear_reverse" >BilinearReverse</A></CODE>'
produces 'curved' images from rectangular ones.  The effect does produce
interesting tile patterns that seem to generate curved 3-dimentional looking
surfaces. </P>

For example by applying the same transformation as was used for <A
HREF="#horizon" >Viewing Distant Horizons</A> above we get this interesting
result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks.png  -virtual-pixel tile  -mattecolor DodgerBlue \
          -distort BilinearReverse \
               '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          bilinear_rev_tile.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bilinear_rev_tile.png"
     ><IMG SRC="bilinear_rev_tile.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In actual fact '<CODE><A HREF="#bilinear_reverse" >BilinearReverse</A></CODE>'
will never produce a 'horizon' (invalid pixels). </P>

On the other hand, using '<CODE><A HREF="#bilinear_forward"
>BilinearForward</A></CODE>' tends to produce 'sky' or 'invalid pixels'
(filled with the current "<CODE><A HREF="../option_link.cgi?mattecolor"
>-mattecolor</A></CODE>") quite regularly. In fact the tile pattern tends to
go rather crazy...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks.png  -virtual-pixel tile  -mattecolor DodgerBlue \
          -interpolate Spline  -distort BilinearForward \
               '0,0 20,60  90,0 70,63  0,90 5,83  90,90 85,88' \
          bilinear_fwd_tile.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bilinear_fwd_tile.png"
     ><IMG SRC="bilinear_fwd_tile.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As previously stated, due to the complexity of a '<CODE><A
  HREF="#bilinear_forward" >BilinearForward</A></CODE>' distortion, the <A
  HREF="#area_resample" >Area Resampling</A> is currently turned off, which in
  the above causes sever aliasing effects.

</I></FONT></TD></TR></TABLE></P>

As such I do not recommend using a tiled form of '<CODE><A
HREF="#bilinear_forward" >BilinearForward</A></CODE>'.  However I do recommend
you define an appropriate "<CODE><A HREF="../option_link.cgi?mattecolor"
>-mattecolor</A></CODE>" when using the forward distortion, to prevent the
appearance of unexpected gray patches of 'sky'. </P>


<A NAME="bilinear_internals"></A>
<H4>Bilinear Internals</H4>

The actual formula for mapping a coordinate in the source image to
a destination image using a '<A HREF="#bilinear_forward" >Forward Mapped
Bilinear Distortion</A> is... </P>

<TABLE ALIGN=center CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=center>
<TD ROWSPAN=3><CODE>X<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> C<sub>0</sub>*X<sub>s</sub> + C<sub>1</sub>*Y<sub>s</sub> +
               C<sub>2</sub>*X<sub>s</sub>*Y<sub>s</sub> + C<sub>3</sub>
        </CODE></TD>
<TD ROWSPAN=3>&nbsp; , &nbsp; &nbsp; &nbsp;</TD>
<TD ROWSPAN=3><CODE>Y<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> C<sub>4</sub>*X<sub>s</sub> + C<sub>5</sub>*Y<sub>s</sub> +
               C<sub>6</sub>*X<sub>s</sub>*Y<sub>s</sub> + C<sub>7</sub>
        </CODE></TD>
</TR></TABLE></P>

However because IM implements distortions using the <A HREF="#mapping"
>Reversed Pixel Mapping</A> technique, the above formula needs to be reversed.
A complex process that requires the solving of a quadratic equation, square
roots, and a whole page fill of algebra. </P>

If you ask IM to <A HREF="#distort_verbose" >Verbosely</A> output the FX
equivalent, you will see this complexity.  For example using the checks image
we created previously...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR<TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD><TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=bilinear_verbose.txt>
  convert checks.png -matte -virtual-pixel transparent -mattecolor none \
      -interpolate Spline -verbose -distort BilinearForward \
                   '0,0,0,0  0,90,0,90  90,0,60,30  90,90,90,90' \
      +verbose bilinear_checks.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bilinear_checks.png"
     ><IMG SRC="bilinear_checks.png"    WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="bilinear_verbose.txt"
     ><IMG SRC="bilinear_verbose.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

The '<CODE>(rt &gt; 0 ) ? red :</CODE>' check in the final line of the '<I>FX
equivalent</I>' is to avoid an invalid negative square root.  This is the check
that creates the 'sky' effect that was shown in the previous examples.</P>

On the other hand, as the <A HREF="#bilinear_reverse" >Reversed Bilineaer
Distortion</A> is much simpler, as you can directly apply the simpler
polynomial equation, to reverse the previous distortion...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR<TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD><TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=bilinear_rev_verbose.txt>
  convert bilinear_checks.png  -virtual-pixel transparent \
      -verbose -distort BilinearReverse \
                   '0,0,0,0  0,90,0,90  60,30,90,0  90,90,90,90' \
      +verbose bilinear_checks_rev.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bilinear_checks_rev.png"
     ><IMG SRC="bilinear_checks_rev.png"    WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="bilinear_rev_verbose.txt"
     ><IMG SRC="bilinear_rev_verbose.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

As you can see the resulting equations is very simple, as we are now applying
it to do a <A HREF="#mapping" >Reversed Pixel Mapping</A> of destination
coordinates to source image coordinates. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The aliasing effects seen in the above is being cause by '<CODE><A
  HREF="#bilinear_forward" >BilinearForward</A></CODE>', and not by the
  '<CODE><A HREF="#bilinear_reverse" >BilinearReverse</A></CODE>' distort.
  This is because currently <A HREF="#area_resample" >Area Resampling</A> is
  turned off for the 'forward' mapped version due to its complexity.
</I></FONT></TD></TR></TABLE></P>

For further reading I direct you to <A
HREF="http://www.leptonica.com/affine.html" >Leptonica Affine and Perspective
Transforms</A>. </P>


<A NAME="bilinear"></A>
<H4>Combined Bilinear Distortion</H4>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

The two Bilinear Distortion methods together will allow you to directly
distort ANY quadrilateral into any other quadrilateral, while keeping the
sides of the quadrilateral straight.  Essentially you can first 'Reverse'
distort one quadrilateral into a rectangular image, then you can 'Forward'
distort that rectangle into the final quadrilateral.  </P>

This type of distortion also means that you can take any rectangular grid of
coordinates, and distort them to another rectangular grid of coordinates.
This is known a 'Grid' Distortion. this technique is the primary basis of
Image Morphing, where you define a rectangular grid of lines over two images
and use them to merge the images into an intermediate composite, or even
generate an animation that properly morphs from one image into another. </P>

This however has not been implemented yet, though is a planned addition. </P>

<BR>
<HR><!-- ---------------------------------------------------------------- -->

<A NAME="polynomial"></A>
<H3>Polynomial Distortion
<FONT SIZE=-1>(distorts using a polynomial fit)</FONT></H3>

The '<CODE>Polynomial</CODE>' distortion like most of the previous distortion
methods also maps pairs of control points, but uses a standard polynomial
equation.  This means one extra argument is needed before the control points
are given.

<DIV ALIGN=center><CODE>
     Order &nbsp; &nbsp;
     X<sub>1</sub>,Y<sub>1</sub> I<sub>1</sub>,J<sub>1</sub> &nbsp; &nbsp;
     X<sub>2</sub>,Y<sub>2</sub> I<sub>2</sub>,J<sub>2</sub> &nbsp; &nbsp;
     X<sub>3</sub>,Y<sub>3</sub> I<sub>3</sub>,J<sub>3</sub> &nbsp; &nbsp;
     X<sub>4</sub>,Y<sub>4</sub> I<sub>4</sub>,J<sub>4</sub> . . . .
</CODE></DIV>

The '<I>Order</I>' argument is usually an integer from '<CODE>1</CODE>' onward,
though a special value of '<CODE>1.5</CODE>' can also be used.  This defines
the 'order' or complexity of the 2-dimensional mathematical equation (using
both 'x' and 'y') , that will be applied. </P>

For example an order '<CODE>1</CODE>' polynomial will fit an equation
of the form...

<TABLE ALIGN=center CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=center>
<TD ROWSPAN=3><CODE>X<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> C<sub>2x</sub>*X<sub>s</sub>
             + C<sub>1x</sub>*Y<sub>s</sub>
             + C<sub>0x</sub> </CODE></TD>
<TD ROWSPAN=3>&nbsp; , &nbsp; &nbsp; &nbsp;</TD>
<TD ROWSPAN=3><CODE>Y<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> C<sub>2y</sub>*X<sub>s</sub>
             + C<sub>1y</sub>*Y<sub>s</sub>
             + C<sub>0y</sub> <TD></TR>
</TABLE></P>

Which if you compare with the equation used for <A HREF="#affine_projection"
>Affine Projection</A> you will see that it is the equivalent.  As 3 constants
is needed for each X and Y formula, you also need to provide at least 3 X,Y
coordinate pairs. Any more will cause the equation to be least-squares fitted
to the coordinates given.  </P>

The next 'order' or '<CODE>1.5</CODE>' is equivalent to a '<CODE><A
HREF="#bilinear_reverse" >BilinearReverse</A></CODE>' (remember the equation
is used to map destination coordinates to the source image).

<TABLE ALIGN=center CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=center>
<TD ROWSPAN=3><CODE>X<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> C<sub>3x</sub>*X<sub>s</sub>*Y<sub>s</sub>
             + C<sub>2x</sub>*X<sub>s</sub>
             + C<sub>1x</sub>*Y<sub>s</sub>
             + C<sub>0x</sub> </CODE></TD>
<TD ROWSPAN=3>&nbsp; , &nbsp; &nbsp; &nbsp;</TD>
<TD ROWSPAN=3><CODE>Y<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> C<sub>3x</sub>*X<sub>s</sub>*Y<sub>s</sub>
             + C<sub>2y</sub>*X<sub>s</sub>
             + C<sub>1y</sub>*Y<sub>s</sub>
             + C<sub>0y</sub> <TD></TR>
</TABLE></P>

Just like  '<CODE><A
HREF="#bilinear_reverse" >BilinearReverse</A></CODE>' distortion, it needs
a minimum of 4 coordinates. For example...

Basically this is exactly the same as the order '<CODE>1</CODE>' equations but
with 1 extra term added to the polynomial equations.  That is as each equation
now has 4 terms per axis, with 4 constants, so you now need at least
4 coordinate pairs, to allow IM to determine those constants.  </P>


<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mandrill_grid.jpg -matte -virtual-pixel black \
       -distort Polynomial \
              '1.5   0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_poly_1.5.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/mandrill_grid.jpg"
     ><IMG SRC="../img_photos/mandrill_grid.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="mandrill_poly_1.5.jpg"
     ><IMG SRC="mandrill_poly_1.5.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

With an order '<CODE>2</CODE>' the polynomial equations is expanded further to
become a full quadratic fit, requiring a minimum of least 6 coordinate pairs.
</P>

<TABLE ALIGN=center CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=center>
<TD><CODE>X<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> C<sub>5x</sub>*X<sub>s</sub><sup>2</sup>
             + C<sub>4x</sub>*X<sub>s</sub>*Y<sub>s</sub>
             + C<sub>3x</sub>*Y<sub>s</sub><sup>2</sup> &nbsp;
             + C<sub>2x</sub>*X<sub>s</sub>
             + C<sub>1x</sub>*Y<sub>s</sub>
             + C<sub>0x</sub> </CODE></TD>
<TR VALIGN=center>
<TD><CODE>Y<sub>d</sub> =&nbsp;</CODE></TD>
    <TD ALIGN=center>
        <CODE> C<sub>5y</sub>*X<sub>s</sub><sup>2</sup>
             + C<sub>4y</sub>*X<sub>s</sub>*Y<sub>s</sub>
             + C<sub>3y</sub>*Y<sub>s</sub><sup>2</sup> &nbsp;
             + C<sub>2y</sub>*X<sub>s</sub>
             + C<sub>1y</sub>*Y<sub>s</sub>
             + C<sub>0y</sub> <TD></TR>
</TABLE></P>

Basically this is exactly the same as the order '<CODE>1</CODE>' equations but
with 3 extra terms  (order 2 + 1) pre-pended to the polynomial equations.
that is as each equation now has 6 terms with 6 constants you now need at
least 6 coordinates to allow IM to determine those constants.  </P>

Each successive order polynomial after this adds another
<CODE>'order'+1</CODE> terms to each of the pair of equations.  As such an
order '<CODE>3</CODE>' cubic-fit polynomial requires a minimum of 10
coordinate pairs to fully define, and an order '<CODE>4</CODE>' quintic-fit
polynomial needs 15 coordinate pairs. </P>

You can use a <A HREF="#distort_verbose" >Verbose Distortion Summery</A> to
see the resulting equation that the polynomial distortion fitted to the
coordinates specified. </P>

As an larger example I have an image of a grid.  I also have a large set of
coordinates (stored in the file "<CODE><A HREF="../images/grid16_control_points.txt"
>grid16_control_points.txt</A></CODE>") on how I what to warp that grid.
I then requested IM to generate a cubic polynomial to 'best-fit' the input
coordinates.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  # warp image
  convert grid16.png -virtual-pixel gray \
          -distort polynomial "3 $(cat grid16_control_points.txt)" \
          grid16_polynomial.png

  # reverse image coordinate order
  awk '{print $3, $4, $1, $2}' grid16_control_points.txt \
                             > grid16_cp_inverse.txt

  # warp image back again
  convert grid16_polynomial.png -virtual-pixel gray \
          -distort polynomial "3 $(cat grid16_cp_inverse.txt)" \
          grid16_restored.png
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="../images/grid16.png"
     ><IMG SRC="../images/grid16.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="grid16_polynomial.png"
     ><IMG SRC="grid16_polynomial.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="grid16_restored.png"
     ><IMG SRC="grid16_restored.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

The small "<CODE>awk</CODE>" script takes the original set of X,Y control
point pairs and reverses the order, so that we can then use the new file to
try to 'undo' the distortion. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The coordinates in the control-point file "<CODE><A
  HREF="../images/grid16_control_points.txt" >grid16_control_points.txt</A></CODE>" are
  in image coordinates, meaning each number refers to the center of the pixel
  it refers to. Without the additional 0.5, the values would be in interger
  'pixel coordinates'.  See <A HREF="#control_coordinates" >Image Coordinates
  vs Pixel Coordinates</A> above. </P>

  The values were determined purely by hand lookup using an image viewer, and
  as such are not really very exact. This may be the source of some of the
  reverse distortion artifacts, though the functional 'best-fit' of the
  polynomial equations would have reduced the overall distortion effects. </P>
</I></FONT></TD></TR></TABLE></P>

This shows that while a polynomial distortion works, and works well, it is not
an exact or reversible distortion.  Essentially the 81 coordinates are
'averaged' together so as to generate a mathematical 'best-fit' of the input
coordinates. </P>

Because more control-points (81) have been provided rather than the minimum
(10) needed, none of the control points are guaranteed to exactly match the
coordinates requested.  However for this specific example, where the
coordinaites are close to the expected distorted result, it should be
reasonably close. </P>

The polynomial function will generally have the most errors along the edges
and especially in the corners of the image.  This not only effects the pixel
locations but also the sampling area (EWA) at the edges.  </P>

This is a natural result of the approximation used. A higher order polynomial
could have been used, but in this case it does not make any great
improvements.  For this specific case, the polynomial is actually trying to
fit itself to a non-polynomial trigonometric function. Due to the nature of
those functions, the second distort will be more inaccurate than the first.
</P>

This example is actually very closely related to a radial <A HREF="#barrel"
>Barrel Distortion</A> method which we will look at below. </P>

Note however that the coordinates being mapped do not actually need to be in
a grid arrangement, but can be any set of coordinate mapping. Because of this
it is often used by geographers for aligning (and overlaying) aerial photos
with geo-physical maps, using known locations of towns, cross-roads, mountain
peaks, and other landmarks as the control points. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Due <A HREF="#polynomial" >Polynomial Distortion</A> being generally
  non-reversible, it isn't posible for IM to calculate the 'best-fit' of the
  destination image's viewport, for the given source image.  As such the
  "<CODE><A HREF="#distort_bestfit" >+distort</A></CODE>" form of the operator
  does not work, and falls back to a normal "<CODE><A
  HREF="../option_link.cgi?distort" >-distort</A></CODE>" operation.  You can
  however still use the <A HREF="#distort_viewport" >Distort Viewport</A>
  option to define the viewport of the destination image.

</I></FONT></TD></TR></TABLE></P>

<BR>
<HR><!-- ---------------------------------------------------------------- -->

<A NAME="circular_distorts"></A>
<H2>Circular and Radial Distortion Methods</H2>

This are distortions that involve the use of radial vectors as the major
component of the distortion process. </P>

<A NAME="arc"></A>
<H3>Arc Distortion
<FONT SIZE=-1>(curving images into circular arcs)</FONT></H3>

The '<CODE>Arc</CODE>' distortion (as of IM v6.3.5-5) is a simple variation of
a much more complex, <A HREF="#polar" >polar distortion</A> (see below). </P>

By default it will curve the given image into a perfectly circular arc over
the angle given, and without other arguments it will try to preserve the
scaling of both the horizontal center-line of the image, and the image's
aspect ratio, as much as possible. </P>

To do this it takes up to four arguments.

<DIV ALIGN=center><CODE>
<I>arc_angle &nbsp; rotate_angle &nbsp; top_radius &nbsp; bottom_radius</I>
</CODE></DIV>

However only the "<CODE><I>arc_angle</I></CODE>" is required, the other
arguments are optional, and can be added as needed, in the sequence given.
</P>

For example '<CODE>Arc</CODE>' an image over an angle of 60 degrees...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -virtual-pixel White -distort Arc 60  arc_rose.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="arc_rose.jpg"
       ><IMG SRC="arc_rose.jpg"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that unlike the other image distortion operators, an '<CODE>Arc</CODE>'
  distort will always set the size of the resulting image so that the complete
  source image is present. This includes any anti-aliasing edge pixels. As
  such the resulting image will rarely match the size of the input image. </P>

  Only a the <A HREF="#distort_viewport" >Viewport Distort Options</A>, will
  allow you to change the resulting image size for a specific distortion.

</I></FONT></TD></TR></TABLE></P>

Adding the second argument "<CODE><I>rotate_agle</I></CODE>" allows you to
rotate the image around the circle.  For example rotate it by 90 degrees.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -virtual-pixel White -distort Arc '60 90'  arc_rose_rot.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="arc_rose_rot.jpg"
       ><IMG SRC="arc_rose_rot.jpg"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As no specific radius argument has be mentioned, the '<CODE>Arc</CODE>'
distortion method takes great pains to try to ensure the original images scale
is preserved as much as possible.  To do this the horizontal center line of
the image is set to the 'ideal radius' for the width and the given
"<CODE><I>arc_angle</I></CODE>" of the source image. </P>

This means that if you arc the image over a larger
"<CODE><I>arc_angle</I></CODE>", the radius of the center-line used will also
shrink by the same factor.  As such the radius of the center-line will be
smaller and tighter.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert rose:  -virtual-pixel White -distort Arc 120  arc_rose_3.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="arc_rose_3.jpg"
       ><IMG SRC="arc_rose_3.jpg"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note how the image will now fit into a smaller circle,  but that the bottom
edge of the image is an even smaller circle still! </P>

If you set an even larger angle over which to arc the image, the bottom edge
will hit the center of the distortion, and beyond, which results in
the lower part of the source image disappearing into oblivion.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -virtual-pixel White -distort Arc 60   arc_rose_1.jpg
  convert rose: -virtual-pixel White -distort Arc 90   arc_rose_2.jpg
  convert rose: -virtual-pixel White -distort Arc 120  arc_rose_3.jpg
  convert rose: -virtual-pixel White -distort Arc 180  arc_rose_4.jpg
  convert rose: -virtual-pixel White -distort Arc 240  arc_rose_5.jpg
  convert rose: -virtual-pixel White -distort Arc 300  arc_rose_6.jpg
  convert rose: -virtual-pixel White -distort Arc 360  arc_rose_7.jpg
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="arc_rose_1.jpg"
     ><IMG SRC="arc_rose_1.jpg"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_rose_2.jpg"
     ><IMG SRC="arc_rose_2.jpg"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_rose_3.jpg"
     ><IMG SRC="arc_rose_3.jpg"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_rose_4.jpg"
     ><IMG SRC="arc_rose_4.jpg"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_rose_5.jpg"
     ><IMG SRC="arc_rose_5.jpg"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_rose_6.jpg"
     ><IMG SRC="arc_rose_6.jpg"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_rose_7.jpg"
     ><IMG SRC="arc_rose_7.jpg"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>


<A NAME="arc_rings"></A>
<H4>Arc into Full Circle Rings</H4>

Longer images will '<CODE>Arc</CODE>' distort a lot better over very large
angles.  For example you can wrap long images (like text messages) into rings.
And just so you can truly see what is happening here I set a different <A
HREF="../misc/#virtual-pixel" >Virtual Pixel</A> background color, so you can
see the boundary of the original image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 60     arc_circle_1.jpg
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 120    arc_circle_2.jpg
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 180    arc_circle_3.jpg
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 270    arc_circle_4.jpg
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background  -background SkyBlue \
          -distort Arc 360    arc_circle_5.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="arc_circle_1.jpg"
     ><IMG SRC="arc_circle_1.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_circle_2.jpg"
     ><IMG SRC="arc_circle_2.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_circle_3.jpg"
     ><IMG SRC="arc_circle_3.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_circle_4.jpg"
     ><IMG SRC="arc_circle_4.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="arc_circle_5.jpg"
     ><IMG SRC="arc_circle_5.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

And hey presto we have 'arc'ed the label image into a full circle. </P>

If you look closely at the join of the full circle image you may see a small
line of pixels, where the join is not quite complete.  This is caused by the
effect of the surrounding '<CODE>SkyBlue</CODE>' <A
HREF="../misc/#virtual-pixel" >Virtual Pixel</A> background, as we are
effectively joining two edges of an image. </P>

When generating a full circle, you need to use a virtual pixel method that
will 'join' these two edges correctly.   This is generally done by using one
of the tiling <A HREF="../misc/#virtual-pixel" >Virtual Pixel</A> methods,
such as <A HREF="../misc/#tile" >Tile</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Tile -background SkyBlue \
          -distort Arc 360   arc_circle_tile.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="arc_circle_tile.jpg"
     ><IMG SRC="arc_circle_tile.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Unfortunately, as you can see, this not only joins the image together
properly, but also generates duplicate lines of the image into and out-of
the primary ring.  Not good. </P>

As of IM v6.4.2-6 a new <A HREF="../misc/#virtual-pixel" >Virtual Pixel</A>
method, <A HREF="../misc/#horizontal_tile" >HorizontalTile</A>, solves this
problem.  This method tiles the image sideways only, so it creates a good join
for our circled image, but fills the areas above and below the tiles with the
current background color, producing a perfect circle of text.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc 360   arc_circle.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="arc_circle.jpg"
     ><IMG SRC="arc_circle.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If before 'arc'ing an image you rotate the input image upside-down, you can
place the original 'top' of the image on the inside edge of the circle. Of
course you may like to 'rotate' the result back upright again afterward, but
that capability is already built into the '<CODE>Arc</CODE>' distortion
method.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel Background -background SkyBlue \
          -rotate 180 -distort Arc '270 180'  arc_flip.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="arc_flip.jpg"
       ><IMG SRC="arc_flip.jpg"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The third argument "<CODE><I>top_radius</I></CODE>" will override the 'ideal'
center line radius that is calculated, so that the top of the image will
become a circle of the radius given.  This creates a ring that is 100 pixels
wide, though the accomidating image is 102 pixels wide to allow for
anti-aliasing effects.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc '360 0 50'  arc_radius.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
    <A HREF="arc_radius.jpg"
       ><IMG SRC="arc_radius.jpg"
             ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The image still remains the same aspect ratio, so the above has essentially
the same as before, just scaled so as to fit the circle of the radius
requested. Remember the radius can be floating point, but the center of an arc
will always be aligned to a pixel 'corner', so the reulting image will still
be an even number of pixels wide. </P>

If you provide the fourth "<CODE><I>bottom_radius</I></CODE>" argument, you
can get complete control of the width of the ring, or its 'radial height'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc '360 0 45 30'   arc_inner.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="arc_inner.jpg"
     ><IMG SRC="arc_inner.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This will distort the radial scaling of the image, and effectivally separates
the radial scaling from the 'arc width' or angle of the resulting image.  In
other words the original image aspect ratio will no longer be preserved.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

You can even force it to completely fill the inside of the circle, wrapping
the bottom edge of the input image at the center, or 'pole' of the distrotion.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font Candice -pointsize 20 label:' Around the World ' \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc '360 0 45 0'   arc_fill.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="arc_fill.jpg"
     ><IMG SRC="arc_fill.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="arc_examples"></A>
<H4>Arc Distortion Examples</H4>

You can generate interesting effects using a <A HREF="#arc" >Arc
Distortion</A>, for example arcing a longish checkerboard pattern into the ring
(using the  <A HREF="../misc/#virtual-pixel" >Virtual Pixel</A> setting
'<CODE><A HREF="../misc/#horizontal_tile" >HorizontalTile</A></CODE>'
produces...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 210x30 pattern:checkerboard -matte \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -distort Arc 360   arc_checks.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="arc_checks.png"
     ><IMG SRC="arc_checks.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

By using the default <A HREF="../misc/#virtual-pixel" >Virtual Pixel</A>
setting of '<CODE><A HREF="../misc/#edge" >Edge</A></CODE>' you can produce a
more interesting effect.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 210x30 pattern:checkerboard  -virtual-pixel Edge \
          -distort Arc 360   arc_checks_edge.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="arc_checks_edge.png"
     ><IMG SRC="arc_checks_edge.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Of course a '<CODE><A HREF="../misc/#edge" >Tile</A></CODE>' setting generated
interesting 'radial' effects too, allowing you to generate a circular
checkerboard pattern.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 210x30 pattern:checkerboard  -virtual-pixel Tile \
          -distort Arc 360   arc_checks_tile.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="arc_checks_tile.png"
     ><IMG SRC="arc_checks_tile.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The above can be refined further by controling the top and bottom radius of
the resulting image. </P>

Here are some more '<CODE><A HREF="#arc" >Arc</A></CODE>' distort examples,
but I let you play with them to figure out how they work.  What can you come
up with?

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 90x1 pattern:gray50 -scale 900x100 -normalize \
          -virtual-pixel Tile  -set option:distort:viewport 100x100-50-50 \
          -distort Arc 360  +repage  arc_radii.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="arc_radii.gif"
     ><IMG SRC="arc_radii.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 400x100 pattern:hs_diagcross \
          -virtual-pixel Tile  -set option:distort:viewport 100x100-50-50 \
          -distort Arc '360 0 80 0' +repage  arc_cross.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="arc_cross.gif"
     ><IMG SRC="arc_cross.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 360x80 xc: -draw "fill none stroke black line 0,5 360,80" \
          -virtual-pixel White  -distort Arc '360 0 50 0'  arc_spiral.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="arc_spiral.gif"
     ><IMG SRC="arc_spiral.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tree.gif -set option:distort:viewport 120x60-60-60 \
          -virtual-pixel Dither  +distort Arc '180 0 25 0' \
          +repage arc_rays.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="arc_rays.gif"
     ><IMG SRC="arc_rays.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

The 'rays' in this last example are a by-product of the pseudo-random
'<CODE><A HREF="../misc/#dither" >Dither</A></CODE>' <A
HREF="../misc/#virtual-pixel" >Virtual Pixel</A> setting, resulting in an odd
pixel pattern of the 'sun' color from the top-left corner from the original
image.  The same dithering effects also produces the circular line of 'dashes'
surrounding the 'tree' image.  </P>

You can achieve a similar and more controlled version of this effect
by using a '<CODE><A HREF="../misc/#edge" >Edge</A></CODE>' setting with image
that has been modified to add interesting edge pixels. </P>


<A NAME="arc_center"></A>
<H4>Arc Center Point Placement</H4>

By default '<CODE><A HREF="#arc" >Arc</A></CODE>' will completely ignore any <A
HREF="../basics/#page" >Virtual Canvas</A> offset the image may have or
even not report the location of the 'center' around which the image was
arc'ed. However knowing the location of the 'center point' can be very useful.
</P>

If instead of using "<A HREF="../option_link.cgi?distort"
><CODE>-distort</CODE></A>"  you use the special plus form, "<A
HREF="../option_link.cgi?distort" ><CODE>+distort</CODE></A>", the image will
be given a <A HREF="../basics/#page" >Virtual Canvas</A>, so that center is
located at the virtual canvas origin.  In other words the '<CODE>0,0</CODE>'
point of the image is set to be the 'center' of the arc. </P>

This is especially useful for positioning an arc'ed image with a smaller angle
than the full circle, where the arc 'center' is not the center of the image.
</P>

For an example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert logo: -resize x150 -gravity NorthEast -crop 100x100+10+0! \
          \( -background none label:'IM Examples' \
             -virtual-pixel Background +distort Arc '270 50 20' \
             -repage +75+21\! \)  -flatten  arc_overlay.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="arc_overlay.jpg"
     ><IMG SRC="arc_overlay.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here I create a text label '<CODE><A HREF="#arc" >Arc</A></CODE>' distorted it
into an incomplete circle using the plus "<A HREF="../option_link.cgi?distort"
><CODE>+distort</CODE></A>" form of the operator.  The 'center' of the arc was
carefully preserved by IM using the images virtual canvas offset. </P>

This means that by simply doing a relative adjustment of the offset using "<A
HREF="../option_link.cgi?repage" ><CODE>-repage</CODE></A>" with a
'<CODE>!</CODE>' flag, we can position the resulting circle of text anywhere
we want!   Such as the point of the wizard hat, which is located at the pixel
coordinated 75,21, in the above example. </P>

Unfortunatally as virtual offsets are used to position the image, the exact
positioning is limited to integer pixel sizes. You can not position a <A
HREF="#arc" >Arc Distortion</A> to a sub-pixel defined location without doing
a second distortion.  However you can do this for a <A HREF="#polar" >Polar
Distortion</A> (see next). </P>

<BR>

<A NAME="polar"></A>
<H3>Polar Distortion
<FONT SIZE=-1>(full circle distorts)</FONT></H3>

The '<CODE>Polar</CODE>' distort (Added IM v6.4.2-6) is a more low level
version of the '<CODE><A HREF="#arc" >Arc</A></CODE>' distortion above. But it
will not automatically do 'bestfit', nor does it try to preserve the aspect
ratios of images. </P>

The 6  optional floating point arguments are...
<TABLE ALIGN=center><TR><TD><CODE>
  Radius_Max   Radius_Min   Center_X,Center_Y   Start_Angle,End_Angle
</CODE></TD></TR></TABLE></P>

All the arguments are optional at the spaced positions. </P>

By default the '<I>CenterX,Y</I>' will default to the very middle of the input
image area. Then a full circle polar image will be generated such that the
whole top edge becomes the center, while the bottom edge is wrapped completely
around the outside of the circle.  The  left and right edges meeting will meet
at above the center point at angles '<CODE>-180</CODE>' to '<CODE>+180</CODE>'
image. </P>

As the '<I>Radius_Max</I>' must be given, it should some positive value.
&nbsp; However if you give a value of '<CODE>0</CODE>' it will be set to the
distance between the center and the closest edge, so that if the other values
are not given (defaults), the whole input image is mapped into a circle in the
middle of the image. </P>

For example, lets convert a map of the world into a polar view, using all the
defaults. Of course you should specify a  <A HREF="../misc/#virtual-pixel"
>Virtual Pixel</A> setting of '<CODE><A HREF="../misc/#horizontal_tile"
>HorizontalTile</A></CODE>' when producing a full circle polar mapping...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert worldmap_sm.jpg -virtual-pixel HorizontalTile  \
          -background Black   -distort Polar 0   polar_arctic.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/worldmap_sm.jpg"
     ><IMG SRC="../img_photos/worldmap_sm.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="polar_arctic.jpg"
     ><IMG SRC="polar_arctic.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Of course this distorts the southern hemisphere severely, wrapping the
Antarctica completely around the circumference of the 'diskworld'. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

By rotating the source image, and cropping it so to just show the polar cap,
we can generate a nice  map of the Antarctic Continent. I also specified a
larger output radius, to make more visible, and asked IM to 'fit' the output
image to this size by using the 'plus' form of the <A HREF="#distort" >Distort
Operator</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert worldmap_md.jpg -rotate 180 -crop 100%x25%+0+0 +repage \
          -virtual-pixel HorizontalTile -background Black \
          +distort Polar 80 +repage  polar_antarctica.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="polar_antarctica.jpg"
     ><IMG SRC="polar_antarctica.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the above are not strictly correct views of the earth, as the
Cartesian map is a representation of a sphere, and not an image in polar
coordinates. </P>

If you use a special '<I>Radius_Max</I>' value of exactly '<CODE>-1</CODE>'
the radius of the distorted image is set to the distance from the center to
the furthest corner (diagonal).  This is to provide an ideal 'reverse' for
a full image '<CODE><A HREF="#depolar" >DePolar</A></CODE>' distortion which
we look at next. (See <A HREF="#polar_tricks" >(De)Polar Tricks</A> below for
examples of use).  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Remember, unlike an '<CODE><A HREF="#arc" >Arc</A></CODE>' distortion,
  '<CODE><A HREF="#polar" >Polar</A></CODE>' (also known as a 'Cartesian to
  Polar' distortion) makes no attempt to preserve the 'ideal' aspect ratio of
  the source image.  Caution is advised.
</I></FONT></TD></TR></TABLE></P>

The '<I>CenterX,Y</I>' arguments are most useful is positioning the center of
the resulting image at a sub-pixel offset.  That is whether the center is at
the boundary of a pixel (whole number) or the center of a pixel (with 0.5
offsets). Of course it also determines the location of the virtual canvas
'layer'. </P>

By default however it is assigned a value the middle of the image
(for "<CODE>-distort</CODE>" which uses the input image as the viewport)
or <CODE>0,0</CODE> (for "<CODE>+distort</CODE>" layer image). </P>

The next arguments '<I>Start_Angle,End_Angle</I> are even less commonly used,
and limit angles the input image covers, defaulting to a value of -180 to 180
degress (0 is straight down).  Like '<CODE><A HREF="#arc" >Arc</A></CODE>'
distortion you could use this to rotate the resulting polar image. But it can
also be used to generate 'arcs'.

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert worldmap_sm.jpg -virtual-pixel Black -background Black \
          +distort Polar  '60,20 0,0 -60,60' +repage  polar_arc.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/worldmap_sm.jpg"
     ><IMG SRC="../img_photos/worldmap_sm.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="polar_arc.jpg"
     ><IMG SRC="polar_arc.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that currently IM does not reduce the size of the resulting layer
image, which is aligned so that the virtual images origin is at coordinates
<CODE>0,0</CODE>, as requested. Other than argument style, this is the biggest
difference between '<CODE><A HREF="#arc" >Arc</A></CODE>' and '<CODE><A
HREF="#polar" >Polar</A></CODE>' distortion. </P>

Also note that the left edge (angle -60) is to the left.  This is
mathematically correct when you consider that the 'Y' axis is downward (same
as for all image rotates). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Of course like Arc you can use Virtual-Pixel tiling effects to generate
repeated patterns.  For example, this is exactly the same as the last example,
just with a '<CODE><A HREF="../misc/#horizontal_tile"
>HorizontalTileEdge</A></CODE>' setting...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert worldmap_sm.jpg -virtual-pixel HorizontalTile -background Black \
          +distort Polar  '60,20 0,0 -60,60' +repage  polar_arc_tiled.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="polar_arc_tiled.jpg"
     ><IMG SRC="polar_arc_tiled.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="depolar"></A>
<H3>DePolar Distortion
<FONT SIZE=-1>(Polar to Cartesian)</FONT></H3>

This is essentially the inverse of a '<CODE><A HREF="#polar"
>Polar</A></CODE>' distortion, and has exactly the same set of optional
arguments. </P>

The 6 optional floating point arguments are...
<DIV ALIGN=center><CODE>
  Radius_Max &nbsp; Radius_Min &nbsp;
  Center_X,Center_Y  &nbsp;
  Start_Angle,End_Angle
</CODE></DIV>

Again if '<I>Radius_Max</I>' is set to '<CODE>0</CODE>' the distance the
'<I>CenterX,Y</I>' to the nearest edge is used which means anything in the
largest whole circle, will be mapped to fit into an image the same size as the
input image. </P>

For example, lets reverse the previous 'diskworld' back into a Cartesian Map.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert polar_arctic.jpg  -distort DePolar 0  world_restored.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="polar_arctic.jpg"
     ><IMG SRC="polar_arctic.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="world_restored.jpg"
     ><IMG SRC="world_restored.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As the input image size has been preserved all the way though the two
distortions, the result of the above is basically exactly the same as the
original map.  Of course as the image was compressed both at the top 'pole'
and in radius, the output is a lot fuzzier than you may expect. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Actually it is made worse in that the <A HREF="#area_resample" >Area
  Resampling</A> algorithm (EWA) can not sample pixels in a circular arc. As
  such <A HREF="#area_resample" >Area Resampling</A> is turned off for
  "<CODE><A HREF="#depolar" >DePolar</A></CODE>" distortions. It is
  recommended that some form of <A HREF="#super_sample" >Super-Sampling</A>
  technique be used instead, such as shown in the next section.

</I></FONT></TD></TR></TABLE></P>

If you allow IM to use 'bestfit' (using the "<A
HREF="../option_link.cgi?distort" ><CODE>+distort</CODE></A>" form of the
operator), then it will resize the output image so as keep the
'<I>Radius_Max</I>' at unity scaling, and set the width to the circumference
distance of the radius midway between '<I>Radius_Max</I>' and
'<I>Radius_Min</I>'.  This essentially tries to best preserve the Aspect Ratio
of the polar image, though this may produce a longer thinner image than
expected.

For example.
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert polar_arctic.jpg  +distort DePolar 0  world_restored_2.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="polar_arctic.jpg"
     ><IMG SRC="polar_arctic.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="world_restored_2.jpg"
     ><IMG SRC="world_restored_2.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<A NAME="polar_tricks"></A>
<H3>(De)Polar Cycle Tricks
<FONT SIZE=-1>(radial/angular blurs)</FONT></H3>

As we saw above using a '<I>Radius_Max</I>' of '<CODE>0</CODE>' will ensure
that the whole image will be mapped into a circle when using a '<CODE><A
HREF="#polar" >Polar</A></CODE>' (<I>Cartesian to Polar</I>) distortion, and
the same setting will map that circle back into a rectangular image by using
'<CODE><A HREF="#depolar" >DePolar</A></CODE>' (<I>Polar to Cartesian</I>).
</P>

However this will not work very well if you what to '<CODE><A HREF="#depolar"
>DePolar</A></CODE>' a rectangular image, and then reverse the distortion
again using '<CODE><A HREF="#polar" >Polar</A></CODE>'.  For example lets take
a flower image, de-polar, then restore it using the special
'<I>Radius_Max</I>' value of '<CODE>0</CODE>' (radius = nearest edge).

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert flower_sm.jpg -virtual-pixel Black \
          -distort DePolar 0  flower_depolar.jpg
  convert flower_depolar.jpg \
          -virtual-pixel HorizontalTile -background black \
          -distort  Polar  0  flower_circle.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="flower_sm.jpg"
     ><IMG SRC="flower_sm.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="flower_depolar.jpg"
     ><IMG SRC="flower_depolar.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="flower_circle.jpg"
     ><IMG SRC="flower_circle.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Now the image is not restored properly as it was clipped by the first
'<CODE><A HREF="#depolar" >DePolar</A></CODE>' distortion. Even so this itself
an useful technique, and can be used to generate perfect circular masks for an
existing image sized in a way that is completely independent of the input
image given. </P>

To do this '<CODE><A HREF="#depolar" >DePolar</A></CODE>'-'<CODE><A
HREF="#polar" >Polar</A></CODE>' cycle technique correctly we need to use
a radius that is the distance from the center to the furthest corner. The
special '<I>Radius_Max</I>' value of '<CODE>-1</CODE>', will ask IM to
calculate an use the furthest corner from the 'center point', as the radius.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert flower_sm.jpg  -virtual-pixel Black \
          -distort DePolar -1  flower_depolar-1.jpg
  convert flower_depolar-1.jpg \
          -virtual-pixel HorizontalTile -background black \
          -distort  Polar  -1  flower_restored.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="flower_sm.jpg"
     ><IMG SRC="flower_sm.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="flower_depolar-1.jpg"
     ><IMG SRC="flower_depolar-1.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="flower_restored.jpg"
     ><IMG SRC="flower_restored.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The restored image is slightly blurry, which is caused by the compression of
the radius needed to preserve the whole image during the '<CODE><A
HREF="#depolar" >DePolar</A></CODE>' operation. That however can be fixed by
using an appropriate <A HREF="#super_samping" >Super-Sampling</A> technique
(see next set of examples).  </P>

But why would you want to convert an image into this form and back again?
Well by applying other distortions on the intermediate 'DePolar' version of
the image, you can generate some very fancy radial or angular effects very
easily.  </P>

For example by rolling the intermediate image, you will rotate the output
image, though you may get some clipping of the corners...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert flower_sm.jpg -virtual-pixel Black -distort DePolar -1 \
          -roll +15+0 \
          -virtual-pixel HorizontalTile -background Black \
          -distort  Polar  -1  flower_polar_rotate.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="flower_polar_rotate.jpg"
     ><IMG SRC="flower_polar_rotate.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the direction of the rotation is reversed from that of the <A
HREF="../warping/#rotate" >Rotate Operator</A> or the <A HREF="#srt" >SRT
Distortion</A>.  </P>

<A NAME="polar_problems"></A>
<H4>Depolar-Polar Cycle problems</H4>

In the image rotation above you may have notice some 'stair case' like
distortions along the edge of the rotated image. This is a well known problem
and is caused by compressing the large circular circumfrence of the image into
the smaller 'width' of the input image. </P>

For example here I take the checker-board test image, and just run it though
a normal Depolar-Polar cycle without making any changes.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks.png   -virtual-pixel Transparent \
          -distort DePolar -1   checks_depolar.png
  convert checks_depolar.png  -virtual-pixel HorizontalTile -background None \
          -distort  Polar  -1   checks_cycled.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="checks.png"
     ><IMG SRC="checks.png"      WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="checks_depolar.png"
     ><IMG SRC="checks_depolar.png"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="checks_cycled.png"
     ><IMG SRC="checks_cycled.png"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

You can clearly see the aliasing effects caused by image compression in the
points of the intermedite image.  It is also exasperated by the fact that
normal <A HREF="#area_resample" >Area Resampling</A> is not used during that
initial '<CODE><A HREF="#depolar" >Depolar</A></CODE>' conversion of the input image.
</P>

The best way to solve this problem is to use <A HREF="#distort_scale" >Distort
Output Scaling</A> to both enlarge the intermediate image, and then shrink the
final image. This will provide a <A HREF="#super_sample" >Super-Sampled</A>
result, that will remove the compression artifacts seen above. </P>

For example, this is the better 'no-op' depolar-polar cycle, all in one
command...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks.png -virtual-pixel Background -background None \
          -set option:distort:scale 4  -distort DePolar -1 \
          -noop \
          -virtual-pixel HorizontalTile -background None \
          -set option:distort:scale .25 -distort  Polar  -1 \
          checks_cycled_ss.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="checks_cycled_ss.png"
     ><IMG SRC="checks_cycled_ss.png"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the horible aliasing effects has all but disappeared.  However
be warned that a very tall thin image could make the problem reappear.  The
best idea is to limit this to 'landscale' or wide images, with super-sampling
as shown above. </P>

All you need to do now is replace the "<A HREF="../option_link.cgi?noop"
><CODE>-noop</CODE></A>" operator with the appropriate command to generate the
radial and rotational effect you are looking for. </P>


<A NAME="polar_rotation"></A>
<H4>Example Depolar-Polar Effects</H4>

So lets again show better <B>Polar Rotation</B> of the image, this time using
super sampling. Note however that as the intermediate image is 4 times larger,
the amount of <A HREF="../warping/#roll" >Image Roll</A> also needs to be 4
times larger.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert flower_sm.jpg   -virtual-pixel Black \
          -set option:distort:scale 4   -distort DePolar -1 \
          -roll +60+0   \
          -virtual-pixel HorizontalTile -background Black \
          -set option:distort:scale .25 -distort Polar -1 \
          flower_polar_rotate_ss.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="flower_polar_rotate_ss.jpg"
     ><IMG SRC="flower_polar_rotate_ss.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the 'stair-case' effect along the edge has been removed, with a
much higher quality image result. </P>

<BR>

<A NAME="rotation_blur"></A>

Or you can apply simple linear blurring of the intermediate image (such
achieved by squeezing and enlarging the image again).
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert flower_sm.jpg -virtual-pixel Black \
          -set option:distort:scale 4   -distort DePolar -1 \
          -scale 10%x100%\! -filter Gaussian -resize 1000%x100%\! +filter \
          -virtual-pixel HorizontalTile -background Black \
          -set option:distort:scale .25 -distort Polar -1 \
          flower_angular_blur.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="flower_angular_blur.jpg"
     ><IMG SRC="flower_angular_blur.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The result is very similar to a '<B>Rotational Blur</B>' of the image.  This
is similar to but not quite the same as the mis-named <A
HREF="../blur/#radial-blur" >Radial Blur Operator</A>. Actually the results
are at a higher quality than that specialized blurring method. </P>

Note the use of a '<CODE>black</CODE>' color in the various forms of <A
HREF="../misc/#virtual-pixel" >Virtual Pixel Settings</A> that was applied, will
result in a slight darkening of the edges, but it isn't too bad in the above
case. </P>

One method to remove the 'black' edges effects, would be to use
'<CODE>transparency</CODE>' color instead, and then just turn-off the
alpha/matte channel completely when finished so as to leave just the actual
color that IM calculated. </P>

Another is to use two 'edge' virtual pixel methods ('<CODE><A
HREF="../misc/#edge" >Edge</A></CODE>' and '<CODE><A
HREF="../misc/#horizontal_edge" >HorizontalTileEdge</A></CODE>'), which
extends the edges of the image into the undefined virtual canvas space.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert flower_sm.jpg -virtual-pixel Edge \
          -set option:distort:scale 4   -distort DePolar -1 \
          -scale 10%x100%\! -filter Gaussian -resize 1000%x100%\! +filter \
          -virtual-pixel HorizontalTileEdge -background Black \
          -set option:distort:scale .25 -distort Polar -1 \
          flower_angular_blur_edge.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="flower_angular_blur_edge.jpg"
     ><IMG SRC="flower_angular_blur_edge.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Which shows a much better result near the edges. </P>

<BR>


<A NAME="radial_streaks"></A>

By blurring the polar version of the image vertically, this time using <A
HREF="../blur/#motion-blur" >Motion Blur Operator</A>, rather than resize
compression, you can generate a <B>Radial Streaks</B> that move outward from
the center of the image...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert flower_sm.jpg   -virtual-pixel Black \
          -set option:distort:scale 4   -distort DePolar -1 \
          -virtual-pixel Edge   -motion-blur 0x28-90 \
          -virtual-pixel HorizontalTile -background Black \
          -set option:distort:scale .25 -distort Polar -1 \
          flower_radial_blur.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="flower_radial_blur.jpg"
     ><IMG SRC="flower_radial_blur.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

To make the result only blur the highlights (the petals) of the image, you can
compose this with the original image using <A HREF="../compose/#lighten"
>Lighten</A>, so only the blurred lighter colors remain visible, with the dark
colors not blurring into the lighter areas, and destroying the yellow spots in
the middle of the flower.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert flower_sm.jpg  flower_radial_blur.jpg \
          -compose Lighten -composite   flower_radial_blur_lighten.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="flower_radial_blur_lighten.jpg"
     ><IMG SRC="flower_radial_blur_lighten.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

See also <A HREF="../advanced/#stars" >Stars and Comets</A> for another
example of doing this, but directly generating the intermediate 'DePolar'
image, before applying a '<CODE><A HREF="#polar" >Polar</A></CODE>'
distortion.</P>

Special thanks goes to <A HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred
Weinhaus</A> for the special uses of a DePolar-Polar cycle, and for insisting
that I ensure that these distortions were fully reversible for rectangular
images. He puts this technique to good effect in a number of his <A
HREF="http://www.fmwconcepts.com/imagemagick/index.html" >ImageMagick
Scripts</A>, including "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/bump/index.php"
>bump</A></CODE>", "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/ripples/index.php"
>ripples</A></CODE>", and "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/striations/index.php"
>striations</A></CODE>".  </P>

<BR>

<A NAME="barrel"></A>
<H3>Barrel Distortion
<FONT SIZE=-1>(correcting lens distortions)</FONT></H3>

The Barrel Distortion (added to IM v6.4.2-4) is designed specifically for
correcting the spherical distortions caused by camera lenses in photos. That
is distortions such as barrel and pincushion effects, which are effectively
the reverse of each other. </P>

For actual application of using this operator for lens distortion correction
see the section, <A HREF="../#lens" >Lens Correction</A>. </P>

The distort is implemented based on a set of 4 coefficient values, known as
<CODE>A</CODE>, <CODE>B</CODE>, <CODE>C</CODE>, and <CODE>D</CODE>, as defined
by  <A HREF="http://webuser.fh-furtwangen.de/~dersch/" >Professor Helmut
Dersch</A>, in a web size that has since vanished.  You can see a <A
HREF="http://waybackmachine.org/web/web.php" >Wayback Machine</A> archive of
the site at <A
HREF="http://replay.waybackmachine.org/20090613040829/http://www.all-in-one.ee/~dersch/barrel/barrel.html"
>Correcting Barrel Distortion</A>. </P>

The values basically form a distortion equation such that...</P>

<DIV ALIGN=center><CODE><NOBR>
<I>R<sub>src</sub></I> =
    r * ( A*<I>r<sup>3</sup></I> + B*<I>r<sup>2</sup></I> + C*<I>r</I> + D )
</NOBR></CODE></DIV></P>

Where "<CODE><I>r</I></CODE>" is the destination radius and
"<CODE><I>R<sub>src</sub></I></CODE>" is the source pixel to get the pixel
color from.  the radii are normalized so that radius = '<CODE>1.0</CODE>' for
the half minimum width or height of the input image.  This may seem reversed
but that is because the <A HREF="#mapping" >Reverse Pixel Mapping</A>
technique is used to ensure complete coverage of the resulting image. </P>

All four coefficients (<CODE>A</CODE>, <CODE>B</CODE>, <CODE>C</CODE>, and
<CODE>D</CODE>) are fixed for any specific camera, lens, and zoom,
combination. All three of which is typically stored with the image in a <A
HREF="../photos/#exif" >EXIF Profile</A>.  This is important as it means that
once you have these values for your camera you can use them to remove the
spherical lens distortion that is present in all the photos taken by that
camera and lens combination. </P>

The arguments needed for the '<CODE><B>Barrel</B></CODE>' distort method.
Generally you supply 3 or 4 values only... </P>

<DIV ALIGN=center><CODE>
<I>A &nbsp; B &nbsp; C</I> &nbsp; [ <I>D</I> &nbsp; [ <I>X</I> , <I>Y</I> ] ]
</CODE></DIV></P>

The optional <I>X</I>,<I>Y</I> arguments provide an optional 'center' for the
radial distortion, otherwise it defaults to the exact center of the image
given (regardless of its virtual offset). </P>

The coefficients are designed so that if all four <I>A</I> to <I>D</I> values,
add up to '<CODE>1.0</CODE>', the minimal width/height of the image will not
change. For this reason if <I>D</I> (which controls the overall scaling of the
image) is not supplied it will be set so all four values do add up to
'<CODE>1.0</CODE>'. </P>

Using the parameters '<CODE>0.0 0.0 0.0</CODE>' (equivalent to
<CODE><I>A</I>=<I>B</I>=<I>C</I>=0.0</CODE> and <CODE><I>D</I>=1.0</CODE>')
will produce no change to the input image, and is the 'no-op' argument for
this distortion. </P>

Here is an example from the original web site, using the supplied coefficients
for the camera that was used to take the photo.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert barrel_distorted.jpg -virtual-pixel black \
          -distort Barrel "0.0 0.0 -0.075 1.1" \
          barrel_distorted_fixed.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../img_photos/barrel_distorted.jpg"
     ><IMG SRC="../img_photos/barrel_distorted.jpg"   WIDTH=300  HEIGHT=225
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="barrel_distorted_fixed.jpg"
     ><IMG SRC="barrel_distorted_fixed.jpg"   WIDTH=300  HEIGHT=225
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note how the distortion in the image was corrected making the pillars of the
building straight.  However as the 4 coefficients added up to a value that was
greater than <CODE>1.0</CODE> the image was shrunk by a small amount,
producing the small black areas at the middle top and bottom edges (according
to the given <A HREF="../misc/#virtual-pixel" >Virtual Pixel Setting</A>). </P>

Here is the effect of adding 0.2 to each of the input coefficients, again the
values add up greater than <CODE>1.0</CODE> so the resulting distorted image
will be smaller.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks.png -virtual-pixel gray \
          -distort Barrel "0.2 0.0 0.0 1.0"   barrel_checks_A.png
  convert checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.2 0.0 1.0"   barrel_checks_B.png
  convert checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.0 0.2 1.0"   barrel_checks_C.png
  convert checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.0 0.0 1.2"   barrel_checks_D.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="barrel_checks_A.png"
     ><IMG SRC="barrel_checks_A.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="barrel_checks_B.png"
     ><IMG SRC="barrel_checks_B.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="barrel_checks_C.png"
     ><IMG SRC="barrel_checks_C.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="barrel_checks_D.png"
     ><IMG SRC="barrel_checks_D.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Subtracting <CODE>0.2</CODE> produces the opposite effect, though I offset the
effect using a larger '<I>D</I>' value (to shrink the image) so you can
see the results better.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks.png -virtual-pixel gray \
          -distort Barrel "-0.2 0.0 0.0 1.3"   barrel_checks-A.png
  convert checks.png -virtual-pixel gray \
          -distort Barrel "0.0 -0.2 0.0 1.3"   barrel_checks-B.png
  convert checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.0 -0.2 1.3"   barrel_checks-C.png
  convert checks.png -virtual-pixel gray \
          -distort Barrel "0.0 0.0 0.0 1.3"    barrel_checks-D.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="barrel_checks-A.png"
     ><IMG SRC="barrel_checks-A.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="barrel_checks-B.png"
     ><IMG SRC="barrel_checks-B.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="barrel_checks-C.png"
     ><IMG SRC="barrel_checks-C.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="barrel_checks-D.png"
     ><IMG SRC="barrel_checks-D.png"   WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note how the value of <I>A</I> produces a larger effect than <I>B</I>, and
<I>B</I> a larger effect than <I>C</I>, while <I>D</I> provides an overall
scaling of the result. This allows you to use each coefficient to adjust the
image so that you can correct for one distortion around the outer edge, and
another distortion toward the middle, be it pincushion for one, and barrel for
the other.  Very versatile.</P>

The above coefficients (<I>A</I>, <I>B</I>, <I>C</I>, and <I>D</I>) are
designed to work with a 'normalized' radius that is half the minimum width or
height of the image (like the '0' radius setting for <A HREF="#polar" >Polar
Distort</A>.  That is they are image size independent.  As such you can use
the same set of values for any image that a specific camera generates,
regardless of its quality size (camera setting), or if you resized the image
smaller. </P>

It is possible to adjust the coefficient values to use other 'normalized'
radius values using the appropriate multipliers/divisors to each coefficient.
Such as using half the maximum width/height, or using the diagonal radius.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Helmut Dersch also notes that you should consider using a LAB colorspace for
  distortion correction in photos, as it produces better color interpolation.
  This may actually be true of all distortions (including <A
  HREF="../resize/#resize" >Resize</A>. </P>

  Testing show that LAB space is just as non-linear as sRGB, but does avoid
  the posiblity of color distions when extreme values are clipped. See <A
  HREF="../color_basics/#perception" >Human Color Perception</A>, and the
  practical examples in <A HREF="../resize/#resize_colorspace" >Resizing with
  Colorspace Correction</A>.

</I></FONT></TD></TR></TABLE></P>

<BR>

You can also declare a different set of coefficients for the x and y axis,
allowing you to generate some unusual distortions.

<DIV ALIGN=center><CODE>
<I>A<sub>x</sub> B<sub>x</sub> C<sub>x</sub> D<sub>x</sub> &nbsp;
A<sub>y</sub> B<sub>y</sub> C<sub>y</sub> D<sub>y</sub></I> &nbsp;
[ <I>X</I> , <I>Y</I> ]
</CODE></DIV></P>

The use of separate X and Y arguments was prototyped in Fred Weinhaus's <A
HREF="http://www.fmwconcepts.com/imagemagick/pinbarrel/" >pinbarrel</A> script
though his arguments are in the reverse order with <CODE>D</CODE> first and
<CODE>A</CODE> last. </P>

By using a positive <I>C</I> value, with appropriate <I>D</I> value for just
the 'y' set of coefficients you can distort images so that they bulge
vertically in the middle.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -matte -virtual-pixel transparent \
          -distort Barrel "0.0 0.0 0.0 1.0   0.0 0.0 0.5 0.5" \
          barrel_bulge.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="barrel_bulge.png"
     ><IMG SRC="barrel_bulge.png"   WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Similarly using a negative <I>C</I> value you can 'pinch' an image in the
middle.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -matte -virtual-pixel transparent \
          -distort Barrel "0.0 0.0 0.0 1.0   0.0 0.0 -0.5 1.9" \
          barrel_pinch.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="barrel_pinch.png"
     ><IMG SRC="barrel_pinch.png"   WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Or by adding the opposite effect for the X coefficients, make it look like
your squeezing the image between your fingers, making it bulge out the sides.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -matte -virtual-pixel transparent \
          -distort Barrel "0.0 0.0 0.5 0.5   0.0 0.0 -0.5 1.9" \
          barrel_pinch_2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="barrel_pinch_2.png"
     ><IMG SRC="barrel_pinch_2.png"   WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>

</TD></TR></TABLE></P>


<BR>

<A NAME="barrelinverse"></A>
<H3>BarrelInverse Distortion
<FONT SIZE=-1>(alternative barrel distortion)</FONT></H3>

The '<CODE>BarrelInverse</CODE>' distortion method is very similar to the
previous <A HREF="#barrel" >Barrel Distortion</A> distortion method, and in
fact takes the same set of arguments.  However the formula that is applied is
slightly different, with the main part of the equation dividing the radius.
that is the Equation has been inverted.

<DIV ALIGN=center><CODE><NOBR>
<I>R<sub>src</sub></I> =
    r / ( A*<I>r<sup>3</sup></I> + B*<I>r<sup>2</sup></I> + C*<I>r</I> + D )
</NOBR></CODE></DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  This equation does NOT produce the 'reverse' the '<CODE>Barrel</CODE>'
  distortion. You can NOT use it to 'undo' the previous distortion.
</I></FONT></TD></TR></TABLE></P>

The result of this is that you would use the 'negative' form of the <I>A</I>,
<I>B</I>, <I>C</I>, with an equivalent adjustment in <I>D</I> to achieve a
similar but slightly different result.   Some sources such the research paper
<A HREF="http://www.fieldrobotics.org/~cgeyer/OMNIVIS05/final/Li.pdf" >Method
for Correcting Lens Distortion (PDF)</A> suggest that a better result can
be achieved with a lens correction distortion of this form. </P>

For example here is the equivalent of the last 'Pinch' example using this
form of distortion.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -matte -virtual-pixel transparent \
          -distort BarrelInverse "0.0 0.0 -0.5 1.5   0.0 0.0 0.3 0.5" \
          barrel_inv_pinch.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="barrel_inv_pinch.png"
     ><IMG SRC="barrel_inv_pinch.png"   WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<BR>
<HR><!-- ---------------------------------------------------------------- -->

<A NAME="projective_distorts"></A>
<H2>Projective Distortions</H2>

These are distortions that is used to project or map images that exist on one
surface, onto another surface.  The projective lines may be parallel, or
radiate from some specific location. </P>

While technically <A HREF="#affine" >Affine</A> and <A HREF="#perspective"
>Perspective Distortions</A> are also 'projective' in that they 'project'
images on one flat surface onto another flat surface (using parallel, and
radial projections respectivally), they are so common they are looking at in
greater detail in their own example areas above. </P>

Here are the more unusual 'Projective Distortions' that have been implemented,
typically with the help of the <A HREF="../forum_link.cgi?f=1" >IM Discussion
Forum</A>. </P>

<A NAME="cylinder2plane"></A>
<H3>Cylinder 2 Plane</H3>

The '<CODE>Cylinder2Plane</CODE>' distort is a radial projective distortion
from a point in the center of a cylinder to a flat plane that is at a tangent
to that cylinder.

<DIV ALIGN=center>
<IMG SRC="cylinder2plane.png" WIDTH=383 HEIGHT=275
     BORDER=1 ALT="[diagram]">
</DIV></P>

This arrangement is typical of a special pinhole camera known as a <A
HREF="http://mottweilerstudio.com/wordpress/cameras/" >P.90 camera</A>.  where
a photo of 90 degree arc is captured on a film that forms a cylinder in the
camera. </P>

Here is an example photo from such a camera...

<DIV ALIGN=center>
<IMG SRC="../img_photos/p90_orig.jpg" WIDTH=512 HEIGHT=328 BORDER=1 ALT="[photo]">
</DIV></P>

The problem with this is that the resulting image is distorted, so that
straight lines become curved arcs, due to the physical arrangement of the
film.  Essentually a curved surface wrapping itself around 'point' projection
source (a pinhole). </P>

Note that normal pin hole camera does not have this problem as you are
projecting onto a flat surface from a point source. </P>

The '<CODE>Cylinder2Plane</CODE>' distort fixes this by projecting the image
from its cylindrical arrangement onto a flat plane.  It takes the
parameters...

<DIV ALIGN=center><CODE>
<I>fov_angle &nbsp; center_x,y &nbsp; fov_output &nbsp; dest_center_x,y</I>
</CODE></DIV>

Only the first parameter the angle of the cameras field of view is required.
For a P.90 camera it used a 90mm (radial) focal length and standard 57mm wide
film, which in turn produces produces a 'field of view' of <CODE><NOBR> 90
/ 57 * 180/pi </NOBR></CODE> or 90.467 degrees. </P>

Here for example I project a P90 photo onto a plane to make the image look
more 'normal' and make straight lines straight again.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert p90_orig.jpg -virtual-pixel Gray \
          +distort Cylinder2Plane 90.467  p90_plane.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="p90_plane.png"
     ><IMG SRC="p90_plane.png"
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!--
 This produces a black middle line!
   convert p90_sm.png -virtual-pixel Gray \
             +distort Cylinder2Plane 90.467  p90_plane.png
-->
Note that the both the width and the height of the image has changed, as we
are using the 'plus' version of the distort, so as to show all the distorted
pixels in the original image. It is wider because of the projection, while the
height of that actual image along the vertical center line did not change.
</P>

The photo and algorithm was from an IM discussion <A
HREF="../forum_link.cgi?f=1&t=18864" >Correcting for a curved film plane</A>.
The discussion also flowed into another discussion on <A
HREF="../forum_link.cgi?f=1&t=18944" >Algorithmic vignetting correction for
pinhole cameras</A>. </P>

<BR>

The special '<I>fov_output</I>' if given will scale the resulting output image
so the width of the output image (typically a viewport size) will exactly
match this angle.  If no viewport is given, a best match is enabled, to best
approximate a 1:1 scaling of the image image, while still aligning the image
edges to whole integers. </P>

The center-point parameter of the distortion (tangent and horizon point of the
input).  The last 'center' parameter controls precise floating point
positioning of the results in the viewport image 'layer' (that is sub-pixel
translations). </P>

This with the '<I>center_x,y</I>' parameter allows you to extract parts from
a larger image.  For example extracting a small 90-degree view from a larger
360 degree panorama image. </P>

<I>FUTURE: extracting smaller flat 'viewing' images from a 360 panorama, as
well as an animation that slowly pans around those 360 degrees. </I> </P>

<!--
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mars_panorama_sm.jpg \
          -define distort:viewport=100x100 \
          +distort Cylinder2Plane  '360  %[fx:w*3/4],%[h/2]  90' \
          mars_cube_face.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="mars_pano_orig.jpg"
     ><IMG SRC="../img_photos/p90_sm.png"  WIDTH=800  HEIGHT=200
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="p90_plane.png"
     ><IMG SRC="p90_plane.png"
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
-->


<A NAME="plane2cylinder"></A>
<H3>Plane 2 Cylinder</H3>

The '<CODE>Plane2Cylinder</CODE>' distort is the reverse of the above
projection, and takes the parameters...

<DIV ALIGN=center><CODE>
<I>fov_angle &nbsp; center_x,y</I>
</CODE></DIV>

For example, this un-does the previous P.90 camera example.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert p90_plane.png -virtual-pixel Black \
          +distort Plane2Cylinder 90.467  p90_restored.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="p90_restored.png"
     ><IMG SRC="p90_restored.png"
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The results still contain the extra pixels that were added previously, and
adds even more.  These should be trimmed from the above result. </P>

Here I use this distortion to generate an animation of a 'film-strip' complete
with film sprocket edge holes. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 12x12 xc: -draw 'circle 6,6 6,2' -negate \
          -duplicate 5 +append +duplicate \
          rose: +swap -background black -append \
          -duplicate 3 +append \
          -virtual-pixel HorizontalTile -background SkyBlue \
          -duplicate 19  -distort SRT '%[fx:72*t/n],0 1 0 0,0' \
          -distort Plane2cylinder 115 \
          -bordercolor Skyblue -border 0x3 -set delay 5 \
          film_strip_anim.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="film_strip_anim.gif"
     ><IMG SRC="film_strip_anim.gif"
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<B>Explanation:</B><UL>
<LI>First a hole image is drawn, which is duplicated and appended to
    make a sequence of 6 holes.  Then duplicated again.
<LI>A built-in rose image is then added and sandwiched between the two copies
    of these sprocket holes and appended together (with black fill) to create
    a single frame of the final film strip.
<LI>This is duplicated to create a film strip of 4 frames, that will define
    the length of the final image.
<LI>A 20 frame animation is created using SRT 'translation' distortions
    See <A HREF="../anim_mods/#distort" >Distort Animations</A>.
<LI>Then each of those 20 frames is then distorted onto a cylinder over an arc
    of 115 degrees, using a virtual pixel setting to generate an infinite
    horizontale tile of the film strip
<LI>The angle in this case is for just for the width of the input image the
    width of the final image is more than 180 degrees, as I did not use
    a 'plus' version of the distort. So while the distorted width shrinks
    width wise, the output image does not.
<LI>A final border is added, and animation settings applied.  </P>
</UL></P>

<BR>
<HR><!-- ---------------------------------------------------------------- -->

<A NAME="freeform_distorts"></A>
<H2>Multi-Point and Freeform Distorts</H2>

<A NAME="shepards"></A>
<H3>Shepard's Distortion
<FONT SIZE=-1>(taffy-like distort)</FONT></H3>

Shepard's method (added to IM v6.4.2-4) uses the movement of the given control
points to distort the image in terms of 'local' effects.  You can think of
this as equivalent to a thick block of 'taffy' representing the source image,
having pins driven into it and then the pins moved around.  </P>

More technically it moves points in terms of a <A
HREF="http://www.ems-i.com/smshelp/Data_Module/Interpolation/Inverse_Distance_Weighted.htm"
>Inverse Squared Distance Interpolation</A>. </P>

If only one control point is used, naturally the whole image is moved
(translated), just as you would get for an one point '<CODE><A HREF="#affine"
>Affine</A></CODE>' distortion.  Not very interesting. </P>

So lets try moving two control points.  For example lets torture the 'koala'
by pulling on his ears (at '<CODE>30,11</CODE>' and '<CODE>48,29</CODE>')...

<!-- <CODE EXECUTE>
  convert koala.gif -fill none \
          -draw "stroke red  path 'M 30,11 15,11 M 20,8  15,11 20,14'" \
          -draw "stroke lime path 'M 48,29 63,29 M 58,26 63,29 58,32'" \
          koala_ears.png
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -virtual-pixel Black \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="koala_ears.png"
     ><IMG SRC="koala_ears.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_ear_pull.png"
     ><IMG SRC="koala_ear_pull.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the parts of the image between the two control points were
stretched out because of the control point movement.  However all the other
parts of the image was left pretty much intact, including the image close to
the control point itself, the bottom of the image, and so on. </P>

The area that lies in the middle between the control points were pulled and
stretched out to ensure the control points are positioned where you requested.
What may not be so noticable is that the parts on the far-side of the control
points are also compressed, so that as you get further away, the control
points have less influence on the result. </P>

That is this distortion generates a 'localized' distortion. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Lets expand our view (using a <A HREF="#distort_viewport" >Distortion
Viewport</A>) so we can see this better...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -virtual-pixel Black \
          -set option:distort:viewport 115x115-20-20 \
          -distort Shepards '30,11 15,11  48,29 58,29' \
          +repage koala_ear_pull_2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_ear_pull_2.png"
     ><IMG SRC="koala_ear_pull_2.png"   WIDTH=115  HEIGHT=115
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the shape of the image was also distorted to accommodate the
stretched 'head' of the koala. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

To avoid this effect it is more typical to also 'pin' the corners and
possibility some of the edges of the image, so that they don't move.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=koala_ear_pull_3.png>
  convert koala.gif -virtual-pixel Black \
          -set option:distort:viewport 115x115-20-20 \
          -distort Shepards '30,11 15,11  48,29 58,29
              0,0 0,0  0,74 0,74   74,0 74,0  74,74 74,74' \
          +repage koala_ear_pull_3.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_ear_pull_3.png"
     ><IMG SRC="koala_ear_pull_3.png"   WIDTH=115  HEIGHT=115
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Even just moving one point, while pinning other points (just the corners in
this case) can be useful.  For example lets just move the koala's nose (at
'<CODE>28,24</CODE>') into the middle of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=koala_move_nose.png>
  convert koala.gif -virtual-pixel Black \
          -distort Shepards '28,24 37,37
              0,0 0,0  0,74 0,74   74,0 74,0  74,74 74,74' \
          +repage koala_move_nose.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_move_nose.png"
     ><IMG SRC="koala_move_nose.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This specific example is special as it is the distortion used by Fred Weinhaus
for his single point 'animated morphing' script "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/shapemorph/"
>shapemorph</A></CODE>". However his original script used a slow <A
HREF="../transform/#fx">DIY FX Operator</A>, as <A HREF="#shepards"
>Shepards Distortion</A> had yet to be added to IM.  This script was actually
where the original idea for <A HREF="#shepards" >Shepards Distortion</A> came
from. </P>

<H4>Moving areas of an image</H4>

You can even move a whole sections of the image by moving a set of points
around that section all together.  For example lets move the koala's head
sideways by using points around the head (red line), but also pinning the
parts of the image we don't want to move (green line).

<!-- <CODE EXECUTE>
  convert koala.gif -fill none \
     -draw "stroke red  path 'M 19,8  19,27 26,34 36,37 53,37 58,25'" \
     -draw "stroke lime path 'M 13,20 17,28 25,36 35,39 46,40 50,43'" \
     koala_head.png
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=koala_head_move.png>
  convert koala.gif -virtual-pixel Black -distort Shepards \
            '19,8, 29,8   19,27 29,27   26,34 36,34
                 33,37 43,37   36,37 46,37   53,37 63,37   58,25 68,25
             13,20 13,20  17,28 17,28  25,36 25,36
                 35,39 35,39   46,40 46,40   50,43 50,43 ' \
          +repage koala_head_move.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="koala_head.png"
     ><IMG SRC="koala_head.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_head_move.png"
     ><IMG SRC="koala_head_move.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that while the head was moved, the edge of the head does get badly
distorted. The reason is that the distort does not move areas, but points.  If
those edge marking points are too far apart, then the image will sort of drip,
leak, or bend between those points, just like taffy, or jello.  (ASIDE: the
actual term is stretching a 'rubber sheet' or 'balloon'). </P>

Also if two control points are close together, but which move in different
directions or amounts, the image could locally swirl and bend around them. The
control points still end up in the right locations, but everthing else around
them gets severly warped to acheive that goal.  And that is what happening
along the edge of the head. </P>

So how close should edge marking points be?  Basically at least half the
distance to any other points which are moving differently.  So either add more
edge points, or put some extra distance between the fixed points, and the
moving points.  By doing this, you will better define the space in which the
image can be stretch and compressed. </P>

Also note that the whole image in general also moved to the left, along with
the head.  Only the control points which were either fixed or moved to
specific destinations are guaranteed to be placed correctly.  Any parts of the
image further away from any control points will also move based on a rough
average of all the control point movements. </P>

It is thus better to have a lot more 'fixed' points, spread throughout the
image, or even some negative moved points some distance outside the image, so
as to offset the general average movement.  You can also duplicate or double
up control points (list them twice) to give specific points more influence or
'power' over the distortion in that area. </P>

Here is another version of the 'move head sideways', however this time I gave
some extra separation between the moving (red) and fixed (green) points. I
also added a lot more fixed points to reduce the average general movement of
the distorted image.

<!-- <CODE EXECUTE SCRIPT IMAGE=koala_head_2.png>
  convert koala.gif -fill none \
     -draw "stroke red  path
               'M 15,15  19,27  26,34  36,37  53,37'" \
     -draw "stroke lime path 'M 10,2  2,10
                M  4,55   14,47  25,47  45,51  55,45
                M  5,70  15,60  55,60  70,70 '" \
     koala_head_2.png
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=koala_head_move_2.png>
  convert koala.gif -virtual-pixel Black -distort Shepards \
            '15,15, 25,15   19,27 29,27   26,34 36,34
                33,37 43,37   36,37 46,37    53,37 63,37
             10,2 10,2   2,10 2,10   4,55 4,55   14,47 14,47
                25,47 25,47 45,51 45,51   55,45 55,45
                5,70 5,70  15,60 15,60   55,60 55,60   70,70 70,70' \
          +repage koala_head_move_2.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="koala_head_2.png"
     ><IMG SRC="koala_head_2.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_head_move_2.png"
     ><IMG SRC="koala_head_move_2.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The final thing to do in the above is to simply set a better  "<CODE><A
HREF="../option_link.cgi?virtual-pixel" >-virtual-pixel</A></CODE>" setting to
set what color the undefined black areas in the above should be. </P>

<A NAME="shepards_rotation"></A>
<H4>Shepards and Image Rotations</H4>

One aspect of this distortion is that it does not like any form of rotation!
</P>

For example here is a repeat of the <A HREF="#perspective" >Perspective</A>,
and <A HREF="#bilinear_forward" >BilinearForward</A>, along side the <A
HREF="#shepards" >Shepards Distortion</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert mandrill_grid.jpg -matte -virtual-pixel black \
       -distort Perspective \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_pers.jpg
<c>  convert mandrill_grid.jpg -matte -virtual-pixel black -interpolate Spline \
       -distort BilinearForward \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_blin.jpg
  convert mandrill_grid.jpg -matte -virtual-pixel black -interpolate Spline \
       -distort Shepards \
              '0,0 26,0   128,0 114,23   128,128 128,100   0,128 0,123' \
       mandrill_shep.jpg
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR>
<TD ALIGN=center>
  <A HREF="../img_photos/mandrill_grid.jpg"
     ><IMG SRC="../img_photos/mandrill_grid.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Original</FONT>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="mandrill_pers.jpg"
     ><IMG SRC="mandrill_pers.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Perspective</FONT>
</TD><TD ALIGN=center>
  <A HREF="mandrill_blin.jpg"
     ><IMG SRC="mandrill_blin.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Bilinear</FONT>
</TD><TD ALIGN=center>
  <A HREF="mandrill_shep.jpg"
     ><IMG SRC="mandrill_shep.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Shepards</FONT>
</TD></TR></TABLE>
</DIV></P>

Note how <A HREF="#shepards" >Shepards Distortion</A> produced
a very curvy image when compared to the other two distortion methods.  That is
because it tries to preserve the image exactly in the area close-in to the
given control points.  And that includes the rotation of the image. </P>

As a result of this 'preservation' the grid is curved so that it remaines
'orthoginal' at the actual control point. It is a bit like those 'pins' at the
control points are not actually round pins, but 'crosses', forcing the 'jelly'
or 'rubber sheet' holding the image to also preserve the rotation of the
image.  </P>

This is also the source of many of the 'swirling' effects this distortion can
produce.   For example, if we take two points in the image and push them past
each other.  The image will swirl, not rotate. </P>

For example lets try to push the koala's ears toward each other rather than
apart.

<!-- <CODE EXECUTE>
  convert koala.gif -fill none \
          -draw "stroke red  path 'M 30,11 45,11 M 40,8  45,11 40,14'" \
          -draw "stroke lime path 'M 48,29 33,29 M 38,26 33,29 38,32'" \
          koala_push.png
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -virtual-pixel Black \
          -distort Shepards '30,11 40,11  48,29 38,29' \
          koala_ear_push.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="koala_push.png"
     ><IMG SRC="koala_push.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="koala_ear_push.png"
     ><IMG SRC="koala_ear_push.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<A NAME="shepards_power"></A>
<H4>Shepard's Power Factor</H4>

Normally the distance weights of a shepard's IWD (Inverse Weighted Distance)
follows an inverse square law (<SUP>1</SUP>/<SUB>r<SUP>2</SUP></SUB>), however
as of IM v6.8.0-10  you can now use the expert <A HREF="../basics/#define"
>define</A> '<CODE>shepards:power</CODE>' to control the 'power-level' of the
global weights. </P>

If not defined it has a value of 2.0, but by defining it smaller you can
general more localized distortions around the moved control points from the
overall average displacement of the distorted image.  Using a larger value
will generate a larger area of effect around the control points. </P>

For example, here is a repeat of the 'koala ear pulling' example, with
different power levels applied to distortion weights.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -virtual-pixel Black -define shepards:power=0.5 \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull_pow0.5.png
  convert koala.gif -virtual-pixel Black -define shepards:power=1.0 \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull_pow1.png
<c>  convert koala.gif -virtual-pixel Black \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull.png
  convert koala.gif -virtual-pixel Black -define shepards:power=3.0 \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull_pow3.png
  convert koala.gif -virtual-pixel Black -define shepards:power=8.0 \
          -distort Shepards '30,11 20,11  48,29 58,29' \
          koala_ear_pull_pow8.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="koala_ears.png"
     ><IMG SRC="koala_ears.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>Original<BR>&amp; action</FONT>
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=30 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="koala_ear_pull_pow0.5.png"
     ><IMG SRC="koala_ear_pull_pow0.5.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 0.5</FONT>
</TD><TD ALIGN=center>
  <A HREF="koala_ear_pull_pow1.png"
     ><IMG SRC="koala_ear_pull_pow1.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 1.0</FONT>
</TD><TD ALIGN=center>
  <A HREF="koala_ear_pull.png"
     ><IMG SRC="koala_ear_pull.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 2.0<BR>(default)</FONT>
</TD><TD ALIGN=center>
  <A HREF="koala_ear_pull_pow3.png"
     ><IMG SRC="koala_ear_pull_pow3.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 3.0</FONT>
</TD><TD ALIGN=center>
  <A HREF="koala_ear_pull_pow8.png"
     ><IMG SRC="koala_ear_pull_pow8.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 8.0</FONT>
</TD></TR></TABLE>
</DIV></P>

All the above image results use exactly the same set of control point
movements. The only difference is the area of effect around those control
points.  A small power will 'localise the movements to only the area close
into the control point, while larger powers will drag more of the image around
the control point with it.  At very larger powers, this pull will tend to
'rip' the image into separate areas along the lines midway between the control
points.  </P>

You could even use much larger powers, which will simply translate regions
around the source control point, into areas around the destination control
point.  These areas will form a pattern of 'voronoi regions' and can contain
a duplicate copies of the source image. </P>

For example here I map the area around the koala's nose (at coordinates 28,24),
into 7 different areas in a hexagonal pattern, producing a 'insect eye' like
effect in a very efficent manner. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=koala_move_nose.png>
  convert koala.gif -virtual-pixel Black -define shepards:power=25 \
          -distort Shepards '28,24 35,35 \
                      28,24 20,10   28,24 50,10 \
                      28,24 20,60   28,24 50,60 \
                      28,24 10,35   28,24 60,35'  koala_hexagonal.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_hexagonal.png"
     ><IMG SRC="koala_hexagonal.png"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Remember <A HREF="#shepards" >Shepards Distortion</A> is actually equivelent
to a displacement map (mapping destination pixels to the source image)
generated using the same technique as the <A HREF="../canvas/#shepards"
>Shepards, Sparse Color Operator</A>, which is also effected by this same
power factor define. </P>


<A NAME="shepards_summary"></A>
<H4>Shepard's Distortion, in sumary</H4>

The <A HREF="#shepards" >Shepards Distortion</A> is a very versatile and free
form method, limiting its distortions to areas marked by the movements, or
non-movements of the given points.  Its distortions are localized and
restricted according to the distances between neighboring control-points,
though all points still do have an averaged global effect.  </P>

Just remember that this distortion is point driven, not line or area driven,
so parts between the points can bulge, or swirl unexpectedly when control
points, that move differently, are positioned too close together. </P>

It will swirl and stretch and compress the image between the control points,
but it tries hard not to rotate or scale the image near the control points.
And finally it may produce an overall average translation of the image far
away from any control point. </P>

However if blocks of control points can be moved, preserving their general
relative positions, it does provide a way to implement a general and very
simple point driven 'Image Morphing' technique. </P>

Fred Weinhaus script '<A
HREF="http://www.fmwconcepts.com/imagemagick/shapemorph2/" >shapemorph2</A>'
uses <A HREF="#shepards" >Shepards Distortion</A> to provide a good general
purpose 'Animated Image Morphing' program. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Internally this distort is equivalent to using the <A
  HREF="../canvas/#shepards" >Shepards Sparse Color</A> gradient generator to
  create two <A HREF="../mapping/#displace" >Relative Displacement Maps</A> to
  distort the image.  This is what  Fred Weinhaus's original "<CODE><A
  HREF="http://www.fmwconcepts.com/imagemagick/shapemorph/"
  >shapemorph</A></CODE>" script does, and was the source of the distortion
  technique.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Due to the complexity of calculations needed in using <A HREF="#shepards"
  >Shepards Distortion</A>, IM does not provide any form of 'best-fit'
  destination viewport using the plus "<CODE><A HREF="#distort_bestfit"
  >+distort</A></CODE>" form of the operator.  You can however still use the
  <A HREF="#distort_viewport" >Distort Viewport</A> option to define a larger
  output image.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  For the same reasons the <A HREF="#area_resample" >Area Resampling</A> is
  turned off.  As such areas of extreme compression (more than a factor of 2)
  will likely show some aliasing effects. For example, see the edges of the
  hexagon pattern in the last example.  However <A HREF="#super_sample"
  >Super-Sampling</A> can be used to improve the final image quality of
  results, and reduce such aliasing effects.

</I></FONT></TD></TR></TABLE></P>


<BR>
<BR>
<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 14 January 2009 (distorts/warping sub-division) <BR>
Updated: 21 March 2012 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/distorts/</CODE>
</ADDRESS></BODY></HTML>
