<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Thumbnails -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/thumbnails/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Creating Thumbnails and Framing</H1>

<DIV ALIGN=justify>

<TABLE BORDER=0 CELLSPACING=0 WIDTH=100%>
<TR VALIGN=top><TD COLSPAN=3>
<A HREF="../"
   ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
   > ImageMagick Examples Preface and Index</A>
</TD></TR>
<TR VALIGN=top><TD><DL>

<DT><A HREF="#storage"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Thumbnail Storage</A>
    <UL>
    <LI><A HREF="#formats"  >Image Format Choice</A>
    <LI><A HREF="#profiles" >Profiles, and JPEG Images</A>
    </UL>
<DT><A HREF="#creation"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > General Thumbnail Creation</A>
    <UL>
    <LI><A HREF="#height"      ><B>Thumbnails of Specific Height</B></A>
    <LI><A HREF="#fit"         >Resize Thumbnail to Fit</A>
    <LI><A HREF="#pad"         >Pad Out Thumbnail</A>
    <LI><A HREF="#cut"         >Cut the Thumbnail to Fit</A>
    <LI><A HREF="#areafit"     >Area Fit Thumbnail Size</A>
    <LI><A HREF="#fit_summery" ><B>Fit to a Given Space Summary</B></A>
    <LI><A HREF="#square"      >Square Padding or Cropping</A>
    <LI><A HREF="#manual"      >Manual Cropping</A>
    <LI><A HREF="#html"        >HTML thumbnail pages</A>
    <LI><A HREF="#favicon"     >FavIcon Web Page Link Thumbnail</A>
    </UL>
<DT><A HREF="#non-im"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Other Non-IM Techniques</A>
</DL></TD>
<TD><DL>
<DT><A HREF="#fluff"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Adding Fluff</A>
    <UL>
    <LI><A HREF="#labels"       >Adding Image Labels</A>
    <LI><A HREF="#button"       >Raised Button</A>
    <LI><A HREF="#bubble"       >Bubble Button</A>
    <LI><A HREF="#border"       >Adding Borders</A>
    <LI><A HREF="#frame"        >Simple Frame</A>
    <LI><A HREF="#montage"      >Montage Framing</A>
    <LI><A HREF="#soft_edges"   >Soft and Blurred Edges</A>
    <LI><A HREF="#rounded"      >Rounded and Shaped Corners</A>
    <LI><A HREF="#torn"         >Torn Paper Edge</A>
    <LI><A HREF="#shadow"       >Adding a Shadow</A>
    <LI><A HREF="#thickness"    >Adding Some Thickness</A>
    <LI><A HREF="#polaroid"     >Polaroid-like Thumbnails</A>
    </UL>
</DL></TD>
<TD><DL>
<DT><A HREF="#framing"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Framing Techniques</A>
    <UL>
    <LI><A HREF="#self_frame"        ><B>Self Framing</B> (External)</A>
    <LI><A HREF="#self_frame_inside" >Self Framing (Internal)</A>
    <LI><A HREF="#border_overlay"    ><B>Simple Border Overlay</B></A>
    <LI><A HREF="#badge_overlay"     >Badge using Overlay</A>
    <LI><A HREF="#mask_paint"        ><B>Mask 'n' Paint Technique</B></A>
    <LI><A HREF="#rounded_border"    >Rounded Border</A>
    <LI><A HREF="#badge_mask_paint"  >Badge using Mask 'n' Paint</A>
    <LI><A HREF="#paint_mask"        ><B>Paint 'n' Mask Technique</B></A>
    <LI><A HREF="#pagecurl"          >Page Curl Corners</A>
    <LI><A HREF="#fancy"             >Fancy Corner Overlay</A>
    <LI><A HREF="#badge_paint_mask"  >Badge using Paint 'n' Mask</A>
    <LI><A HREF="#lighting_mask"     ><B>Lighting Mask Technique</B></A>
    <LI><A HREF="#glass_bubble"      >Glass Bubble</A>
    <LI><A HREF="#badge_lighting"    >Badge with Lighting Mask</A>
    </UL>
<DT><A HREF="#frame_edge"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Framing using Edge Images</A>
    <UL>
    <LI><A HREF="#frame_append"   >Over-simplistic Append</A>
    <LI><A HREF="#frame_extended" >Extended Overlay Framing</A>
    <LI><A HREF="#frame_joints"   >45 degree corner joints</A>
    </UL>
</DL>
</TD></TR></TABLE></P>

One of the biggest uses ImageMagick is put to is the creation of thumbnails
for family photo albums, sports and hobby pages, catalogs, and so on.
Typically for use on the world wide web or in photo CDs. </P>

This page provides examples and techniques used to generate thumbnails. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="storage"></A>
<H2>Thumbnail Storage</H2>

I would like to first start with one very important point. </P>

The original image from video cameras and photo scanning should be kept in
a safe place in the original format, preferably a non-lossy format (not the
JPEG image format), without any modification resizing or other change, except
possibly a file name change. Of course a scanned image can be re-scanned, but
it is far better to re-use your original source than to re-do it from a already
degraded copy later.  </P>

This is VERY important as any form of modification will mean a loss of some
information in the image, and provides a source from which you can re-work your
image for other uses.  The original image does not have to be your working
image, which may be resized or color adjusted for display, just be sure to have
your image saved and backed up somewhere safe for future use.  </P>

The next thing to do, even before you create any thumbnails, is to decide how
you want to save your thumbnail relative to your normal sized image format,
then stick to that scheme.  This is especially important for web pages. </P>

Schemes include...
<UL>
<LI>Save the main photo image in the lossy JPEG format at the size you
    want or need, then use the same name for the generated thumbnail but using
    the GIF image format. EG Same filename but a different format and suffix.
    </P>

    <NOBR>Main Image: <CODE ->photo_name.jpg</CODE>
    <IMG SRC="../img_www/space.gif" WIDTH=80 HEIGHT=1>
    Thumbnail: <CODE ->photo_name.gif</CODE></NOBR> </P>

<LI>Store the thumbnails with the same name in a sub-directory called for
    example "<CODE ->thumbs</CODE>" or whatever is convenient for you. </P>

    <NOBR>Main Image: <CODE ->photo_name.jpg</CODE>
    <IMG SRC="../img_www/space.gif" WIDTH=80 HEIGHT=1>
    Thumbnail: <CODE ->thumbs/photo_name.jpg</CODE></NOBR> </P>


<LI>Use the same format as the original image, but with an extra string added
    to the file name.  Typical string additions include "<CODE ->_tn</CODE>",
    "<CODE ->_small</CODE>",  "<CODE ->_thumb</CODE>", etc... </P>


    <NOBR>Main Image: <CODE ->photo_name.jpg</CODE>
    <IMG SRC="../img_www/space.gif" WIDTH=80 HEIGHT=1>
    Thumbnail: <CODE ->photo_name_tn.jpg</CODE></NOBR> </P>


<LI>Some combination of the above. </P>

    There is no reason why you cannot save thumbnails in different image
    format, with an extra image suffix appended to the filename, and saved in a
    subdirectory!  </P>

    <NOBR>Main Image: <CODE ->images/photo_name.jpg</CODE>
    <IMG SRC="../img_www/space.gif" WIDTH=30 HEIGHT=1>
    Thumbnail: <CODE ->thumbs/photo_name.jpg.gif</CODE></NOBR> </P>

    This is actually quite common on the WWW, and I have even seen the
    the two directories stored on completely separate machines! </P>

</UL>

The first scheme can use "<CODE>mogrify</CODE>" to generate all your
thumbnails, without destroying the original image, by using a "<CODE><A
HREF="../option_link.cgi?format" >-format</A></CODE>" setting to specify the
output image format. </P>

As of IM v3.2.0, the second scheme is now also possible to do with
"<CODE>mogrify</CODE>" thanks to the addition of a special "<CODE><A
HREF="../option_link.cgi?path" >-path</A></CODE>" setting that specifies a
different directory in which to save the modified images. </P>

For example, this converts JPG images into GIF thumbnails in a
"<CODE>thumbs</CODE>" sub-directory that was just created.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  mkdir thumbs
  mogrify  -format gif -path thumbs -thumbnail 100x100 *.jpg
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The other methods will require you to either, first make a copy of the
original image, before running "<CODE>mogrify</CODE>", create a special script
to process the images, or some other DIY method.  A number of the simpler
non-IM techniques are detailed at the end of the example section for <A
HREF="../basics/#mogrify_not" >Batch Processing - Without using
"<CODE>mogrify</CODE>"</A>. </P>

Whatever method you choose the important thing is to choose a scheme for
thumbnail storage, and then stick with it.  By using the same scheme for all
your thumbnails you can then write shell or Perl scripts to make thumbnail
generation and even generation of the HTML links easy. More on this later.
</P>


<A NAME="formats"></A>
<H3>Selection of the Thumbnail format</H3>

The format in which you save a thumbnail can make a big difference to its
final size on disk and download speed for web pages.  In this regard I
recommend you study the summary of the various <A HREF="../formats/#summary"
>Common File Formats</A>. </P>

Specifically you should note... <DL>
<DD><B>JPEG</B> compresses well and is lossy, but is designed for large real
    world images, not small thumbnails.  It also does NOT allow any form of
    transparency.  In summary, the format is good for large images, bad for
    thumbnails.  Watch out for profiles (see next section). </P>

    While JPG is not recommended for thumbnails, for viewing images on the WWW
    it is recommended you use smaller 800x600 pixel image, at a much lower
    "<CODE><A HREF="../option_link.cgi?quality" >-quality</A></CODE>"
    percentage (say 50 or even 30%), though it will not look very good. </P>

    It has also been suggested that using "<CODE><A
    HREF="../option_link.cgi?sampling-factor" >-sampling-factor</A>
    2x1</CODE>" will also produce a smaller JPEG image size. </P>

    I do not recommend the full original image never be placed directly on the
    web, unless temporarily (at a referenced location) for a friend to
    download.  Remember do not link to it, (even by directory indexing), and
    never for more than a day, or it may be Googled.  </P>

<DD><B>GIF</B> works for simple small images, and compresses okay.  It has a
    color limit of 256, but for small images this is rarely noticeable. It can
    also do cartoon like animations of images, not that that is needed for
    thumbnails, unless you really what to get fancy. </P>

    What is a problem is that the format only has Boolean (on/off)
    transparency, which makes for horrible looking borders on shaped images.
    The solutions to that is to design the thumbnail to only use Boolean
    transparency, or arrange it so it can only be used on a specific
    background color.  For details see the examples on <A
    HREF="../formats/#bgnd" >GIF's on a background color or pattern</A>. </P>

<DD><B>PNG</B> is the modern ideal format for thumbnails. It has a good
    compression, and internal format styles.  It is non-lossy, and can display
    all colors, and these days it is understood by almost all browsers,
    (though for Microsoft Internet Explorer, before v7, needs some java
    scripting added to web pages). </P>

    More importunately this format understands semi-transparent color, making
    shadows and edges sharp and clear, or faded and blurry as you wish.  This
    format however does not do animations, though the related MNG format does.
    Very few browsers seem to support that format however. </P>

    For thumbnails you can reduce the size of the final image by reducing the
    depth and number of colors, as well as setting a higher
    "<CODE>bzip</CODE>" compression quality (first digit in "<CODE><A
    HREF="../option_link.cgi?quality" >-quality</A></CODE>") for your final
    thumbnail image.  </P>

    For example, the following is suggested for small PNG thumbnails that does
    not involve transparency.

    <DIV ALIGN=center>
    <TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
    <TR><TD><PRE><CODE DO_NOT_EXECUTE>
        -strip  -quality 95  PNG8:thumbnail.png
    </CODE></PRE></TD></TR></TABLE>
    </DIV></P>

    Which uses a smaller, 8 bit, or 256 color limited, PNG format. </P>

    You can also re-process the final image though secondary applications
    (See <A HREF="../formats/#png_non-im" >Non-IM PNG Processing</A>) which
    can automatically find the best PNG compression for that specific image.
    There are also programs to do that color reduction to the smaller internal
    PNG format, while preserving semi-transparent colors. This is something IM
    currently does not handle.  . </P>

</DL>

<B>One final word about formats...</B>  No matter what format you use for your
thumbnails, if you must save an intermediate unfinished image, use a PNG
(without any color reduction) or MIFF image format.  Doing this will preserve
as much color information about the image as possible in the intermediate
stage. Only do color reduction, or save to GIF or JPEG formats as an absolute
final step. </P>

This is important, so I repeat...
<DIV ALIGN=center><B>
      Do NOT use JPEG, PNG8, or GIF for intermediate working images!
<BR>             Better to use PNG or MIFF.
</B></DIV></P>



<A NAME="profiles"></A>
<H3>Profiles, Stripping, and JPEG Handling </H3>

Many images from digital cameras, scanning software, and some paint programs
(photoshop is notorious for this), save extra information about the image in
the form of <B>profiles</B>.  This includes image formats such a JPEG, PNG,
TIFF and as of IM v6.2.4-1 GIF. Of course the IM specific format, MIFF also
does this. (See <A HREF="../formats/#profiles" >Image Profiles</A> for more
detailed information). </P>

These profiles can be up to 60 Kb in size, so can make a big difference to
your file size, and by default IM will preserve this profile information.
Thumbnails have no need for this data and often not even the main image needs
it.  </P>

You can also remove the profiles from your images with the IM commands...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert input.jpg  -strip output.jpg

  mogrify -strip  *.jpg
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

You can also use the option "<CODE><A HREF="../option_link.cgi?profile"
>-profile</A> '*' </CODE>" to remove the profiles. </P>

It is however recommended you only strip profiles when you modify an image,
especially if reducing it in size for web displays, or thumbnail images. </P>

Stripping profiles while resizing, particularly for generating smaller
thumbnail images, is so common that both "<CODE><A
HREF="../option_link.cgi?resize" >-resize</A></CODE>" and  "<CODE><A
HREF="../option_link.cgi?strip" >-strip</A></CODE>" were combined into a new
operation, just for this very purpose.  Naturally enough this resize operation
is called "<CODE><A HREF="../option_link.cgi?thumbnail"
>-thumbnail</A></CODE>".  </P>

For example...
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert -define jpeg:size=240x180 image.jpg -thumbnail 120x90 thumbs/image.gif

  mogrify -path thumbs -format gif -define jpeg:size=240x180 -thumbnail 120x90 '*.jpg'
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before  IM v6.5.4-7 the "<CODE><A HREF="../option_link.cgi?thumbnail"
  >-thumbnail</A></CODE>" would strip ALL profiles from the image, including
  the ICC color profiles.  From this version onward the color profiles will be
  preserved.  If the color profile is not wanted then "<CODE><A
  HREF="../option_link.cgi?strip" >-strip</A></CODE>" all profiles.
</I></FONT></TD></TR></TABLE></P>


The "<CODE><A HREF="../basics/#mogrify" >mogrify</A></CODE>" will of course
generate thumbnails for a whole directory of JPEG images, but be careful it
does not overwrite any thumbnails you want to keep.   For a number of other
non-IM methods for looping over a large number of images see the example
section for <A HREF="../basics/#mogrify_not" >Batch Processing - Without using
Mogrify</A>.  </P>

For very large images the "<CODE><A HREF="../option_link.cgi?thumbnail"
>-thumbnail</A></CODE>" resize operator goes further and first scales the
image down to 5 times the final thumbnail size first, before doing the actual
resize operation. This speeds up the thumbnail generation further. </P>

However for thumbnailing JPEG images, an even better method of limiting the
initial image size can be used, by just not reading the whole image into memory
in the first place. </P>

The "<CODE><A HREF="../option_link.cgi?define" >-define</A> jpeg:size=</CODE>"
setting (as shown in the above example) is a special hint to the JPEG image
library to reduce the amount data that is read in from VERY BIG JPEG images.
See <A HREF="../formats/#jpg_read" >Reading JPEG Files</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
    Before IM v6.5.6-0  this coder setting was extracted from the "<CODE><A
    HREF="../option_link.cgi?size" >-size</A></CODE>" setting.  This caused
    problems when users used "<CODE><A HREF="../option_link.cgi?size"
    >-size</A></CODE>" for image creation but then had JPEG reading produce
    unexpected results. As such this was changed to be a special coder setting
    instead. </P>

    In older versions of IM you may need to reset the setting using "<CODE><A
    HREF="../option_link.cgi?size" >+size</A></CODE> before reading JPEG
    images, because of this 'dual' role.

</I></FONT></TD></TR></TABLE></P>

From IM version 6.2.6-2, a new <A HREF="../files/#read_mods" >Read Image
Modifier</A> was added, which lets you resize the input image immediately
after it is read in.  This option will work with ANY image format, not just
JPEG image.  It is however no substitute for using a "<CODE><A
HREF="../option_link.cgi?define" >-define</A> jpeg:size=</CODE>" setting for
JPEG images. </P>

As such the recommended way of resizing ANY input image format is now... </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert -define jpeg:size=240x180 input.img'[120x90]' \
          -strip  output_thumbnail.gif
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

Well on with the practical IM thumbnail examples... </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="creation"></A>
<H2>General Thumbnail Creation</H2>

<A NAME="height"></A>
<H3>Generate Thumbnails in General (specific height)</H3> </P>

Lets convert a <A HREF="../img_photos/hatching_orig.jpg" >large sample JPEG image</A> to a
GIF thumbnail 90 pixels high with the width automatically adjusted (within
the 250 pixel width limit) to preserve the aspect ratio of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -define jpeg:size=500x180  hatching_orig.jpg  -auto-orient \
          -thumbnail 250x90   -unsharp 0x.5  thumbnail.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="thumbnail.gif"
     ><IMG SRC="thumbnail.gif"      HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that I used the "<CODE><A HREF="../option_link.cgi?thumbnail"
>-thumbnail</A></CODE>" option above.  This not only resizes the image, but
strips any and all profile and comment information that may be present in the
original JPEG image. Also as it uses the "<CODE><A
HREF="../option_link.cgi?sample" >-sample</A></CODE>" resize operator for the
initial downsizing of the image, it is faster, while producing reasonable
results for small thumbnails. </P>

I also set a minimum "<CODE><A HREF="../option_link.cgi?define" >-define</A>
jpeg:size=</CODE>" for the image being read in.  This is passed to the JPEG
library, which will return an image somewhere between this size and double
this size (if possible), rather that the whole very large original image.
Basically don't overflow the computers memory with an huge image when it isn't
needed.  </P>

The JPEG size hint I use is at least double that of the final thumbnail so
that resize will still generate a reasonable looking result. </P>

The "<CODE><A HREF="../option_link.cgi?auto-orient" >-auto-orient</A></CODE>"
operator ensures that the image, if from a digital camera, is rotated correctly
according to the camera's orientation.  This is not needed for the 'desktop'
image I am using, but I included it in the above for digital camera users.
Note however that orientation can still go wrong, especially for photos viewing
directly down or up, such as when taking photos of documents.</P>

The result is a thumbnail of a specific height, but variable width.  I use
this thumbnail for my own web pages so that a series of image in a row, will
all match up height wise, forming a neat look. </P>

The 250 pixel width limit in the above is important. If left unset, (EG: using
"<CODE>-thumbnail x90</CODE>" ) IM would could have problems when generating
thumbnails of very long thin images such as those shown in <A
HREF="http://www.ict.griffith.edu.au/images/FancyLines/Images.html" >Web Line
Images</A>.  The result in that case would be very very long,
<I>enlargement</I> of the image, instead of a small thumbnail. </P>

Some people (including myself) find that while IM's resize is one of the best
implementations (See <A HREF="../filter/#photoshop" >IM Resize vs Other
Programs</A>), the result is still a little blurry.  As such you can improve
the above result by sharpening the image slightly (using "<CODE><A
HREF="../option_link.cgi?auto-orient" >-unsharp</A></CODE>") after the
"<CODE><A HREF="../option_link.cgi?thumbnail" >-thumbnail</A></CODE>" resize
operation. For more information see <A HREF="../resize/#resize_unsharp"
>Sharpen Resized Images -- Photoshop Resize Technique</A>, But really it all
comes down to a matter of personal taste. </P>

<BR>

The "<CODE>mogrify</CODE>" version is the same as the "<CODE>convert</CODE>"
command (with no initial input images), but will but will generate automatic
thumbnails of <I>every</I> JPEG image in the current directory.  The image
argument is quoted so that IM itself will scan the directory, and not the
command line shell.  This prevents 'line limit overflow errors' on directories
containing a huge number of images.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  mogrify  -format gif -define jpeg:size=500x180 -auto-orient \
                -thumbnail 250x90 -unsharp 0x.5  '*.jpg'
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that "<CODE>mogrify</CODE>" will blindly create thumbnails, replacing
  any existing images of the same name. GIF images in this case.  Extreme
  caution is always advised when using this command. </P>

  Backup copies are always recommended before doing any processing.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Instead of specifying a different format (using "<CODE><A
  HREF="../option_link.cgi?format" >-format</A></CODE>") so as to prevent
  "<CODE>mogrify</CODE>" from overwriting the original source images, you can
  use a "<CODE><A HREF="../option_link.cgi?path" >-path</A></CODE>" setting to
  define a separate thumbnail directory. You can use both output
  options.
</I></FONT></TD></TR></TABLE></P>

While "<CODE>mogrify</CODE>" can output the new images with a different suffix
("<CODE><A HREF="../option_link.cgi?format" >-format</A></CODE>") or directory
("<CODE><A HREF="../option_link.cgi?path" >-path</A></CODE>"), they are your
only options using this command. </P>

If you are also wanting to change the name of the image, such as adding a
"<CODE>_tn</CODE>" or "<CODE>_sm</CODE>" to denote thumbnail or small versions
of the image, then I recommend you create a shell script to do the job for
you, processing them one at a time using "<CODE>convert</CODE>". &nbsp; &nbsp;
<I>I wrote such a script to do this, while simultaneously generating HTML
indexes at the same time. </I>

<BR>

<A NAME="fit"></A>
<H3>Resize Thumbnail to Fit</H3>

Another form of automatic thumbnail generation is shrink image to fit a fixed
sized box, say "<CODE>100x100</CODE>" but keeping the images aspect ratio.
Well that is the default meaning for a resize geometry setting. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

However I prefer not to enlarge images which already fit such a box.  For that
you need to add a "<CODE>&gt;</CODE>" to the geometry string.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -define jpeg:size=200x200 hatching_orig.jpg \
          -thumbnail '100x100>' rectangle.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rectangle.gif"
     ><IMG SRC="rectangle.gif"      WIDTH=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As before the aspect ratio of the image is preserved, as such the thumbnail
is unlikely to be exact 100 pixels square.  However at least one of the images
dimensions will be 100 pixels. </P>

<A NAME="pad"></A>
<H3>Pad Out the Thumbnail</H3>

The next most common request is to generate thumbnails that fill out the image
with borders of a specific color (usually '<CODE>black</CODE>', or
'<CODE>transparent</CODE>' but for these examples I will use
'<CODE>skyblue</CODE>') so the thumbnail is exactly the size you wanted. </P>

For example:  An image which is 400x300 pixels shrunk to fit a 100x100 pixel
box will normal (with the above) have a size of 100x75 pixels. We want to add
some padding borders to the top and bottom of the image (and to the sides to
be sure) to make the final thumbnail image always 100x100 pixels in size. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

There are a number of ways to do this, and as of IM v6.3.2 the best way is
using the <A HREF="../crop/#extent" >Extent Operator</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -define jpeg:size=200x200 hatching_orig.jpg -thumbnail '100x100>' \
          -background skyblue -gravity center -extent 100x100 pad_extent.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pad_extent.gif"
     ><IMG SRC="pad_extent.gif"        WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

As of IM version 6.2.5, you can also use a <A HREF="../crop/#crop_viewport"
>Viewport Crop</A>, and flatten the result onto a background color.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -define jpeg:size=200x200 hatching_orig.jpg -thumbnail '100x100>' \
          -gravity center  -crop 120x120+0+0\! \
          -background skyblue  -flatten    pad_view.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pad_view.gif"
     ><IMG SRC="pad_view.gif"        WIDTH=120  HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The key difference between using<A HREF="../crop/#extent" >Extent</A> and a <A
HREF="../crop/#crop_viewport" >Viewport Crop</A> is weather you want a minimal
<A HREF="../basics/#virtual_canvas" >Virtual Canvas</A> or have the whole area
'padded out'. </P>

Another method to pad out an image is to overlay the thumbnail onto a
background image (actual image, solid color or tiled canvas) that is the right
size, in this case the 128x128 "<CODE>granite:</CODE>" built-in image. </P>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -define jpeg:size=200x200 hatching_orig.jpg -thumbnail '100x100>' \
          granite: +swap -gravity center -composite pad_compose.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pad_compose.gif"
     ><IMG SRC="pad_compose.gif"     WIDTH=128  HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This method is probably the best method to use with older versions of IM (such
as IM v5), though the "<CODE><A HREF="../option_link.cgi?composite"
>-composite</A></CODE>" operation will need to be done by the separate
"<CODE><A HREF="../basics/#composite" >composite</A></CODE>" command, rather
than the above single command method. </P>

However an image processing point of view all the above are actually doing the
same thing. </P>


<A NAME="cut"></A>
<H3>Cut the Thumbnail to Fit</H3>

An alternative, is rather than pad out the image to fit the specific thumbnail
size we want, is to instead cut off the parts of the image that does not fit
the final size. </P>

Of course this means you actually lose some parts of the original image,
particularly the edges of the image, but the result is an enlarged thumbnail of
the center part of the image.  This is usually (but not always) the main
subject of the image, so it is a practical method of thumbnail creation. </P>

As of IM v6.3.8-3 the special resize option flag '<CODE>^</CODE>' was added to
make this easier.  We just resize using this flag then crop off the parts of
the image that overflows the desired size.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -define jpeg:size=200x200 hatching_orig.jpg  -thumbnail 100x100^ \
          -gravity center -extent 100x100  cut_to_fit.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="cut_to_fit.gif"
     ><IMG SRC="cut_to_fit.gif"     WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the thumbnail of the image is much larger and more detailed,
but at a cost of cutting off the sides off the original image. </P>

For more information on this option see <A HREF="../resize/#fill"
>Resize to Fill Given Area</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before  IM v6.3.8-3 when this special flag was added, you would have needed
  some very complex trickiness to achieve the same result.  See <A
  HREF="../resize/#space_fill" >Resizing to Fill a Given Space</A> for
  details.
</I></FONT></TD></TR></TABLE></P>

<A NAME="areafit"></A>
<H3>Area Fit Thumbnail Size</H3>

The last two methods will often make an image very small with a lot of extra
padding, or, it will cut off a lot of the image so as to completely fill the
space. However by using a different resize flag, it is possible to get a
thumbnail that is between these two extremes.  </P>

For example a 100x100 pixel thumbnail has 10,000 pixels.  Now if we ask resize
to size out image to something around that many pixels in size (using the <A
HREF="../resize/#pixel" >resize '<CODE>@</CODE>' flag</A>), you will have an
image that will need both a little padding and a little cutting.  This
maximizes the size of the resulting thumbnail, while not cutting away too
much.  </P>

For example...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -define jpeg:size=200x200 hatching_orig.jpg  -thumbnail 10000@ \
          -gravity center -background skyblue -extent 100x100  area_fit.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="area_fit.gif"
     ><IMG SRC="area_fit.gif"     WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the thumbnail has some padding, and the image has some
cropping, but the result is probably about the best fit of image to a given
thumbnail space. </P>

<A NAME="fit_summery"></A>
<H3>Fit to a Given Space Summary</H3>

In summary, here are the results of the three methods for thumbnailing an
image to a specific sized area.  All three methods use exactly the same code,
with just with a slight change in the resize argument/flag used. </P>

<TABLE BORDER=0 ALIGN=center>
</TD><TD ALIGN=middle>
  <A HREF="pad_extent.gif"
     ><IMG SRC="pad_extent.gif"     WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <BR>Padded Fit<BR><FONT SIZE=-2>resize, no flag</FONT>
</TD><TD ALIGN=middle>
  <A HREF="area_fit.gif"
     ><IMG SRC="area_fit.gif"     WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <BR>Area Fit<BR><FONT SIZE=-2>resize, '@' flag</FONT>
</TD><TD ALIGN=middle>
  <A HREF="cut_to_fit.gif"
     ><IMG SRC="cut_to_fit.gif"     WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <BR>Cut to Fit<BR><FONT SIZE=-2>resize, '^' flag</FONT>
</TD></TR></TABLE></P>

<BR>

<A NAME="square"></A>
<H3>Square Padding and Cropping</H3>

The above padding and cropping methods assume you know the final size of the
area in which you want the image to fit. But that is not always the case. </P>

Sometimes you want to simply 'square an image', either by 'padding' it out
(external square), or 'shaving' the edges (internal square). </P>

From the IM Discussion Forums on <A HREF="../forum_link.cgi?f=1&t=20601"
>Squaring Images</A> a number of methods were developed. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

External Squaring can be done using <A HREF="../layers/#mosaic" >Mosaic</A> to
create a larger background canvas using a rotated copy of the image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          \( +clone -rotate 90 +clone -mosaic +level-colors white \) \
          +swap -gravity center -composite    square_padded.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="square_padded.gif"
     ><IMG SRC="square_padded.gif"     WIDTH=120  HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Internal Squaring on the other hand is a little harder and requires
more work to achieve.  This one uses some heavy mask handling to generate
a smaller canvas.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          \( +clone +level-colors white \
             \( +clone -rotate 90 +level-colors black \) \
             -composite -bordercolor white -border 1 -trim +repage \) \
          +swap -compose Src -gravity center -composite \
          square_cropped.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="square_cropped.gif"
     ><IMG SRC="square_cropped.gif"     WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

An alturnative way is to use a no-op distort using a distort viewport crop/pad
the image (See <A HREF="../distorts/#centered_square" >Distort Viewport
Centered Square Crop</A>). Essentually it uses a 'percent escapes' to do the
calculations needed for an <A HREF="../crop/#extent" >Extent</A> type of
operation. </P>

External (padding) square...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif  -virtual-pixel white -set option:distort:viewport \
     "%[fx:max(w,h)]x%[fx:max(w,h)]-%[fx:max((h-w)/2,0)]-%[fx:max((w-h)/2,0)]" \
     -filter point -distort SRT 0  +repage  square_external.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="square_external.gif"
     ><IMG SRC="square_external.gif"     WIDTH=120  HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
The <A HREF="../misc/#virtual" >Virtual Pixel</A> setting is used to specify
the padding color. </P>

Internal (cropped) square...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif   -set option:distort:viewport \
     "%[fx:min(w,h)]x%[fx:min(w,h)]+%[fx:max((w-h)/2,0)]+%[fx:max((h-w)/2,0)]" \
     -filter point -distort SRT 0  +repage  square_internal.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="square_internal.gif"
     ><IMG SRC="square_internal.gif"     WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Curtisy of <A
HREF="http://www.fmwconcepts.com/imagemagick/tidbits/image.php#pad_crop_square"
>Fred Weinhaus's Tidbits Page</A>. </P>

This is a simplier version, but will lose any meta-data (like comment
strings or profiles) the image may have.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -set option:size '%[fx:min(w,h)]x%[fx:min(w,h)]' \
          xc:none +swap -gravity center -composite square_internal_2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="square_internal_2.gif"
     ><IMG SRC="square_internal_2.gif"     WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  IMv7 will allow you to do the above mathematics directly as part of
  a crop or extent argument, which will prevent loss of image meta-data.
</I></FONT></TD></TR></TABLE></P>


<A NAME="manual"></A>
<H3>Manual Cropping</H3>

The normal way I generate thumbnail images for use on my web pages, is a
mix of automatic and manual scripts. The final setup of my images are..
<UL>
<LI>I use a PNG or TIFF for the original ,VERY large, scan of the photo.  OR
    the original JPEG image downloaded from a digital camera.  Basically for
    the unmodified original source image, for archiving.  I also now like to
    include the string "<CODE>_orig</CODE>" in this images filename. </P>

<LI>A smaller JPEG image format for a web viewable image when the thumbnail
    is clicked or selected.  This image is resized to fit a 800x800 pixel box,
    which is a size suitable for viewing by most web users.  I typically add a
    "<CODE>_md</CODE>" for medium sized image, in the filename. </P>

<LI>And lastly a GIF thumbnail resized to a fixed 90 pixel high, and variable
    width.  This allows centered rows of thumbnails on web pages to look
    reasonable neat and tidy, but which automatically fills the browser
    windows width, no matter what size browser they are using.  Again I
    typically now include a "<CODE>_tn</CODE>" in the images filename, to
    denote that it is a thumbnail. </P>

</UL></P>

I first generate the web viewable JPEG images (medium size) using
"<CODE>mogrify</CODE>" from the original scanned image. This is reduces the
download time and viewing size of the image to something that is practical for
the typical web user (who could be logged in via modem). </P>

From these images I generate an initial set of thumbnails, again using
"<CODE>mogrify</CODE>".  However I often find in typical photos that the
subject of the thumbnails becomes too small to make an effective thumbnail,
when viewed. </P>

To fix this I examine the automatically generated thumbnails, and in about
half the cases manually create my own 'zoomed in on subject' thumbnail. </P>

I read in the JPEG image, and crop it down the main subject of the image
effectively 'zooming in' on the subject of the photo, and removing bulk of the
background context of the image.  This is then smoothed and thumbnailed,
either using a "<CODE>convert -thumbnail</CODE>", or more often in the same
graphic program I am viewing and cropping the images with (usually
"<CODE>XV</CODE>", see below).  </P>

So instead of a thumbnail where the people in the photo are hardly visible
(left), I have manually cropping around the subject, highlighting the main
point of the photo (right), before thumbnailing.  That allows users to see the
image content more clearly and thus better decide if they actually want to
download and look at the larger JPEG version of the image. </P>

<!-- kiteflyer photos were cropped and resized and stored in "images" -->
<TABLE ALIGN=center>
<TR><TD ALIGN=center COLSPAN=3>
  <B>Queensland KiteFlyers, Ron and Val Field</B>
<TR><TD ALIGN=center><FONT SIZE=-1>
  <A HREF="../img_photos/kiteflyers_orig.jpg"
     ><IMG SRC="../img_photos/kiteflyers_auto.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 ALT="[IM Output]"></A>
  <BR>Automatically<BR>Generated</BR>Thumbnail
</FONT></TD><TD><IMG SRC="../img_www/space.gif" WIDTH=50 HEIGHT=1>
</TD><TD ALIGN=center><FONT SIZE=-1>
  <A HREF="../img_photos/kiteflyers_orig.jpg"
     ><IMG SRC="../img_photos/kiteflyers_man.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 ALT="[IM Output]"></A>
  <BR>Manually Cropped<BR>and Resized<BR>Thumbnail
</FONT></TD></TR>
<TR><TD ALIGN=center COLSPAN=3><FONT SIZE=-1>
  <B>(Click on either image for original scanned photo)</B>
</FONT></TD></TR></TABLE></P>

This is of course more manually intensive, but only needs to be done once per
image, and only on images that have a lot of space such as in the above
example.  Also I only do this for images I am putting the web. </P>

Of course as "<CODE>mogrify</CODE>" will overwrite any existing, possibly hand
generated thumbnails, you cannot use it again after you perform any manual
thumbnail generation. The "<CODE>mogrify</CODE>" command is useful, but also
very dangerous as it overwrites lots of images.  Always think before you run
"<CODE>mogrify</CODE>" globally across all your images. </P>


<A NAME="html"></A>
<H3>HTML Thumbnail Pages</H3>

Once I have all the thumbnail images sorted out in the directory I use a
special perl script called "<CODE>thumblinks</CODE>" I wrote that look for the
images (JPEG photos and GIF thumbnails), and generate HTML links, and even
full HTML photo pages. </P>

The script will read and include size of the GIF thumbnail size in the HTML,
and attach pre-prepared header and footer files around the thumbnail links.
The script will also remove any thumbnail links from the list it generates, if
it finds an existing link in the header or footer file itself. </P>

This may sound complex, but it makes my HTML page generation very fast and
flexible, and ensures ALL image thumbnailed images in a directory have been
added to that directories index page, while still letting me comment on
specific images in the index header.  It also makes the page independent of
the users window size, automatically adjusting to suit. </P>

For a simple example of my "<CODE>thumblinks</CODE>" script output see <A
HREF="https://antofthy.gitlab.io/info/art/" >Tomb of Castle
Artworks</A>.  </P>

For a quick example and starting point for generating such links look at the
examples of using the <A HREF="../basics/#identify" >identify command</A>.
</P>

<A NAME="favicon"></A>
<H3>FavIcon Web Page Link Thumbnail</H3>

The "<CODE>favion.ico</CODE>" icon often looked for by web browsers on the top
level web page of a web site, for that whole site.  That image is a special
multi-resolution image format and can be created as follows. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert image.png -alpha off -resize 256x256 \
          -define icon:auto-resize="256,128,96,64,48,32,16" \
          favicon.ico
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The '<CODE>image.png</CODE>' can be anything you like, but should be
square.  If it isn't that should also be the first step in the above. </P>

You can also include larger resolutions such as 128 or 256 pixels, but few
browsers would make use of them.  The 16 and 32 pixel sizes are much more
commonly used in such ICO files so special emphesis on those my be useful.
Also remember that many browsers will color reduce the images so are to reduce
the space used to store it in an users bookmarks file. </P>

This brings us to one other point. As only the smallest of images are
typically used, with further color reduction, it is recommented to keep the
images as small and as well defined as posible. </P>

Here is an example of manually resizing images for an ICO file format.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert image.png  -background white \
          \( -clone 0 -resize 16x16 -extent 16x16 \) \
          \( -clone 0 -resize 32x32 -extent 32x32 \) \
          \( -clone 0 -resize 48x48 -extent 48x48 \) \
          \( -clone 0 -resize 64x64 -extent 64x64 \) \
          -delete 0 -alpha off -colors 256 favicon.ico
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

<BR>

As mentioned only the "<CODE>favion.ico</CODE>" image found on the top level
directory of a web site is generally used, however you can also specify the
location of the link thumbnail image by adding the following HTML tag to the
headers of your pages...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  &lt;LINK REL="icon" HREF="/path/to/favicon.ico" type="image/x-icon"&gt;
  &lt;LINK REL="shortcut" HREF="/path/to/favicon.ico" type="image/x-icon"&gt;
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The "<CODE>/path/to/favicon.ico</CODE>" can be an absolute or partical URL/URI
to the location from which the browser should pick up the web pages thumbnail
image.  The use of '<CODE>REL="shortcut"</CODE>' is specific to Internet
Explorer (before IE9), and not offically part of the HTML specification. </P>

It is posible to merge the two HTML tags together using '<CODE>REL="shortcut
icon"</CODE>' however by keeping the tags separate you can make use of
a non-ICO image file format (such as SVG) for non-IE browsers, such as
firefox. </P>

Remember if this html element is not used the "<CODE>favicon.ico</CODE>" file
found on the top level directory of the web site is used instead (if present).
</P>

The ICO image format is universally understood by all modern browsers. All
except Internet Explorer also can use JPEG, PNG, and GIF image file formats,
for the link thumbnail.  A few like FireFox can even make use of animated
GIF's or SVG image file formats.  However as these latter formats can not
typically hold multiple images at different resolutions and color counts, it
is probably better to stick with the ICO file format for the
"<CODE>favion.ico</CODE>" image. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="non-im"></A>
<H2>Other Non-IM Techniques</H2>

The "<CODE>XV</CODE>" program I use for manual image processing also generates
thumbnail images, in a sub-directory called "<CODE>.xvpics</CODE>".  The
format of the images in this directory is the programs own special thumbnail
format (ignoring the filename suffix in that directory).  These thumbnails are
limited to 80x60 pixels so are a little on the "small" size (unless you hack
"<CODE>xv</CODE>" to use larger thumbnails -- see link below). </P>

IM understands the "<CODE>xv</CODE>" thumbnail format (which is based on the
"<CODE>NetPBM</CODE>" image format), so you can generate all the thumbnails
quickly using XV, then convert the XV thumbnails of the JPEG images, into GIF
images for further processing...

<PRE>
   xv -vsmap &               # generate thumbs with the "Update" button
   rm .xvpics/*.gif          # delete XV thumbs of existing "gif" thumbnails
   mogrify -format gif .xvpics/*.jpg
   mv .xvpics/*.gif .        # move the new "gif" thumbnails to original dir
</PRE>

If you are sick of the small size of XV thumbnails, particularly with larger
modern displays, you can hack the XV code.  See my <A
HREF="http://www.ict.griffith.edu.au/anthony/info/graphics/xv_mods.hints" >XV
modification notes</A>, which allows you to get XV to use a larger thumbnail
size.  I myself use 120x90 pixel thumbnails. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="fluff"></A>
<H2>Further Processing -- Adding Fluff</H2>

The above is only the beginning of what you can do to make your thumbnails
more interesting. Beyond the basic thumbnail image you can add borders,
rotations even with some random selection of style to make your thumbnail
gallery that much more interesting. </P>

Additions to thumbnails like this, is what I term 'fluff', as in the extra
lint you find covering your clothes after you wash your clothes. That is, it
adds unnecessary extras to the thumbnail, but which can make web pages and
index images that much more interesting. </P>

Be warned that many of the following methods and processing is very complex
and my require a deeper knowledge of the various image processing options
options of ImageMagick. </P>

<A NAME="labels"></A>
<H3>Adding image labels</H3>

During your thumbnail creation you can also add labels either above, below or
even on top of your thumbnail. </P>

This sort of image processing is however covered more thoroughly in <A
HREF="../annotating/#labeling" >Annotating Images with Labels</A>. Just
remember to use the "<CODE><A HREF="../option_link.cgi?thumbnail"
>-thumbnail</A></CODE>" or "<CODE><A HREF="../option_link.cgi?strip"
>-strip</A></CODE>" rather than a "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>" in those examples.</P>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          -background Lavender -fill navy -font Candice -pointsize 24 \
          label:Hatching   -gravity South -append \
          labeled.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="labeled.gif"
     ><IMG SRC="labeled.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

With the use of <A HREF="../fonts/" >Compound Fonts</A> you can overlay
some very fancy labels onto the image itself. </P>

Here for example I used a <A HREF="../fonts/#denser_soft_outline" >Denser Soft
Outline Font</A> technique to annotate the thumbnail, darkening the area
around the text to ensure it always remains readable.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -define jpeg:size=400x400  hatching_orig.jpg  -resize '120x200>' \
      \( +clone -sample 1x1\! -alpha transparent -sample 1000x200\! \
         -font SheerBeauty -pointsize 72 -gravity Center \
         -strokewidth 8 -stroke black  -fill black  -annotate 0,0 '%c' \
         -channel RGBA -blur 0x8 \
         -strokewidth 1 -stroke white  -fill white  -annotate 0,0 '%c' \
         -fuzz 1% -trim +repage -resize 115x \
      \) -gravity North -composite           -strip annotated.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="annotated.gif"
     ><IMG SRC="annotated.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note how I do not use the pre-generated "<CODE>thumbnail.gif</CODE>" image, or
use the <A HREF="../resize/#thumbnail" >Thumbnail Resize Operator</A> to strip
the profiles and comments from the image. </P>

I then used "<CODE><A HREF="../option_link.cgi?clone" >+clone</A></CODE>",
"<CODE><A HREF="../option_link.cgi?sample" >+sample</A></CODE>", and "<CODE><A
HREF="../option_link.cgi?alpha" >-alpha</A></CODE>", to generate a larger
transparent working canvas, which also contains a copy of the original image's
meta-data. This lets me use the images 'comment' string with the annotate
"<CODE><A HREF="../option_link.cgi?annotate" >-annotate</A></CODE>" operator,
to supply the text to overlay on the image. </P>

Only at the end after I have composed the text overlay do I clean up and
"<CODE><A HREF="../option_link.cgi?strip" >-strip</A></CODE>" that
information. </P>


<A NAME="button"></A>
<H3>Raised Button</H3> </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The "<CODE><A HREF="../option_link.cgi?raise" >-raise</A></CODE>" operator was
basically created with the one purpose of highlighting the edges of
rectangular images to form a raised button.  It is a simple, fast, and
effective thumbnail transformation.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif  -raise 8   raised_button.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="raised_button.gif"
     ><IMG SRC="raised_button.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The same operator has a 'plus' form that can be used to make a sunken
highlighting effect.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif  +raise 8   sunken_button.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sunken_button.gif"
     ><IMG SRC="sunken_button.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="bubble"></A>
<H3>Bubble Button</H3> </P>

With some trickiness the "<CODE><A HREF="../option_link.cgi?raise"
>-raise</A></CODE>" operator can be used to produce a smooth 'bubble-like'
raised button.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -fill gray50 -colorize 100% \
          -raise 8 -normalize -blur 0x8  bubble_overlay.png
  convert thumbnail.gif bubble_overlay.png \
          -compose hardlight -composite  bubble_button.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="thumbnail.gif"
     ><IMG SRC="thumbnail.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="bubble_overlay.png"
     ><IMG SRC="bubble_overlay.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="bubble_button.png"
     ><IMG SRC="bubble_button.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

See <A HREF="../compose/#light" >Light Composition Methods</A> for more
information about this type of technique. </P>

For more effects like this see <A HREF="#self_frame_inside" >Self Framing
(Internal)</A> below, and to take it to the next level see <A
HREF="#lighting_mask" >Lighting Effect Mask</A> below. </P>

<A NAME="border"></A>
<H3>Adding Borders</H3> </P>

The humble simple "<CODE><A HREF="../option_link.cgi?border"
>-border</A></CODE>" operator can be used to generate some a complex framework
around an images.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          -bordercolor black -border 3   -bordercolor white -border 2 \
          \( -background black -fill white -pointsize 24 \
             label:Hatching   -trim +repage \
             -bordercolor black -border 10 \
          \) -gravity South -append \
          -bordercolor black -border 10   -gravity South -chop 0x10 \
          border_framework.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_framework.gif"
     ><IMG SRC="border_framework.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="frame"></A>
<H3>Simple Frame</H3> </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

In a similar way the "<CODE><A HREF="../option_link.cgi?frame"
>-frame</A></CODE>" operator makes it easy to add a frame around the image

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif   -mattecolor peru  -frame 9x9+3+3  framed.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="framed.gif"
     ><IMG SRC="framed.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This operator also has a lot more options to create a dozen or so different
styles of frames. You can see examples of the possibilities in <A
HREF="../crop/#frame" >Frame, adding a 3D-like border</A>. </P>

<A NAME="montage"></A>
<H3>Montage Framing</H3> </P>

The montage command provides a much easier way of doing all the above, and
much more.  It cannot only generate thumbnails (or whole pages of
thumbnails), but it can label the thumbnails to include information like
filenames, disk size, and dimensions, or an user specified string.  </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
Here is a simple use of "<CODE>montage</CODE>" to generate a framed thumbnail.
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  montage -define jpeg:size=240x200  -label '%c'  hatching_orig.jpg \
          -frame 6  -geometry '120x100>'  montage_simple.gif
</CODE></PRE></TD></TR></TABLE>

The label comes from JPEG image file comment, which was added long ago to the
image using the Non-IM command "<CODE>wrjpgcom</CODE>". See <A
HREF="../formats/#jpg_non-im" >Non-IM JPEG Processing</A> for more details.

</TD><TD>
  <A HREF="montage_simple.gif"
     ><IMG SRC="montage_simple.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Even with just "<CODE>montage</CODE>" you can get really fancy with your
thumbnail generation.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  montage -define jpeg:size=400x180  -label '%c' hatching_orig.jpg \
          -thumbnail '200x90>' -geometry '130x100>'  -mattecolor peru \
          -frame 6  -bordercolor skyblue  -font LokiCola  -pointsize 18 \
          montage_fancy.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="montage_fancy.gif"
     ><IMG SRC="montage_fancy.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

See the "<A HREF="../montage/" >Montage, Arrays of Images</A>" for more
details. </P>

You may be especially interesting in the <A HREF="../montage/#html" >Montage
HTML Thumbnail Image Maps</A> example. This creates a HTML index page of
thumbnails in which clicking on the thumbnail will bring up the original
image, in the same directory. </P>


<A NAME="soft_edges"></A>
<H3>Soft and Blurred Edges</H3>

The <A HREF="../transform/#vignette" >Vignette Operator</A>
provides a simple means to add a blurry edge around an image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set \
          -background none  -vignette 0x4  vignette.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="vignette.png"
     ><IMG SRC="vignette.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course as this thumbnail uses semi-transparent color so it needs to be
saved in the PNG format. </P>

The <A HREF="../morphology/#distance" >Morphology Distance</A> method provides
a true transparent 'Feathering' of an image's edges.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -virtual-pixel transparent -channel A \
          -morphology Distance Euclidean:1,10\! +channel feathered.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="feathered.png"
     ><IMG SRC="feathered.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The maximum distance of the transparent area is controled by the special
<CODE>10\!</CODE>' distance scaling flag. This was only added in IM v6.6.1-6.
</P>

This has the added advantage of also working for shaped images, though a more
complex initialization is needed to correctly preserve and anti-aliased pixels
in the distance formula. See <A HREF="../morphology/#distance_feather"
>Feathering Shapes using Distance</A> for more details. </P>

The feathering here is a pure linear gradient, and can be further adjusted
using <A HREF="../color_mods/#sigmoidal" >Sigmoidal Non-linearity Contrast
Operator</A> to give it a smoother more tapered look in a number of different
ways. </P>

You can also <A HREF="../blur/#feathering" >Feather Images using Blur</A>,
using the same method of adding a transparent <A HREF="../misc/#virtual-pixel"
>Virtual Pixels</A> before bluring just the alpha channel.  This generates
a more softer feathering to the image, as well as noticeably rounded the
corners of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -virtual-pixel transparent \
          -channel A -blur 0x8  -level 50%,100% +channel  soft_edge.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="soft_edge.png"
     ><IMG SRC="soft_edge.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The extra "<CODE><A HREF="../option_link.cgi?level" >-level</A></CODE>"
operation (adjusting only the transparency channel) ensures the edge becomes
fully transparent, rather than only half transparent.  However it does fall
sharply toward zero at the actual edge, due to the sigmoidal-like curve that
blur generates. </P>

It also has an additive effect in the corners, causing them to become rounded,
while with a shaped image with a sharp concavity, it can cause
fully-transparent pixels to become semi-transparent.  As such for shapes you
may need to mask the result against the original image (using <A
HREF="../compose/#dstin" >Dst-In Composition</A>).  For rectangular thumbnails
however the result is satisfactory.</P>

You can see another example of using this type of feathering in <A
HREF="../layers/#layer_thumbnails" >Layered Thumbnails</A>. </P>

If instead of doing a level adjustment on the blurred feather, you can <A
HREF="../quantize/#threshold" >Threshold</A> the blurred alpha channel at
'<CODE>50%</CODE>', so as to add psuedo-rounded corners to the above thumbnail
image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -virtual-pixel transparent -channel A \
          -blur 0x8  -threshold 50% +channel rounded_corner_blur.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rounded_corner_blur.gif"
     ><IMG SRC="rounded_corner_blur.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

While very simple, the result is not a really nice way to round off the
corners of the image.  First the corners are not actually circular, but
a 'hyperbolic' curve. Second the result is not a smooth anti-aliased curve,
but shows 'jaggies' caused by the aliasing effect of <A
HREF="../quantize/#threshold" >Threshold Operation</A>. This image can however
be save to a GIF file format. See <A HREF="../formats/#boolean_trans" >GIF
Boolean Transparency</A> for details.  </P>

Also note that  the "<CODE><A HREF="../option_link.cgi?blur"
>-blur</A></CODE>" operation can become very slow when you work with a large
argument for generating a larger rounded corner.  As such this method of
rounding corners on a large scale is not recommended at all. </P>

For a more unusual blurred edge effect, you can use a <A
HREF="../blur/#radial-blur" >Radial Blur</A> on just the alpha channel.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -virtual-pixel transparent \
          -channel A -radial-blur 0x45 +channel  radial_blur_edge.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="radial_blur_edge.png"
     ><IMG SRC="radial_blur_edge.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This works better for perfectly square images. </P>

As the amount of angled blur becomes larger, you will eventually generate
a circular like Vignette edge.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -virtual-pixel transparent \
          -channel A -radial-blur 0x100 +channel  radial_blur_vignette.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="radial_blur_vignette.png"
     ><IMG SRC="radial_blur_vignette.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The two step-like artifacts that can be seen is caused by the two image size
dimensions.  No 'step' will be seen for a square image.  Adding a little extra
normal blur to the last example can also improve the step problem. </P>


<A NAME="rounded"></A>
<H3>Rounded and Shaped Corners</H3>

While thresholding a <A HREF="#soft_edges" >Soft Blurred Edge</A> (see above)
will generate a rounded corner suitable for the Boolean transparency of GIF,
it does not generate a smooth 'anti-aliased' corner. </P>


The proper way to generate an image with rounded corners, or of any other
shape is to actually cut out each corner using a mask of the shape wanted.
</P>

The following method from Leif strand &lt;leif&#64;sitelogic.fi&gt;
that multiplys a full image mask to generate the appropriate result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
     \( +clone  -alpha extract \
        -draw 'fill black polygon 0,0 0,15 15,0 fill white circle 15,15 15,0' \
        \( +clone -flip \) -compose Multiply -composite \
        \( +clone -flop \) -compose Multiply -composite \
     \) -alpha off -compose CopyOpacity -composite  rounded_corners.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rounded_corners.png"
     ><IMG SRC="rounded_corners.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Basically extracts the white transparency mask from the original image, with
just one black rounded corner. This is then flipped and flopped to produce
a mask with all four corners rounded.  And finally that mask is applied to the
original image.  </P>

For much larger images, you may be better off applying a much smaller mask to
each individual corner to reduce the total amount of processing needed. That
is more individual processing steps, but overall less processing of the actual
pixels.  </P>

For example, here is the same thing but cutting a simple drawn triangular
shape from each corner.  This will work with much larger images.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set  -compose DstOut \
      \( -size 20x15 xc:none -draw "polygon 0,0  0,14 19,0" \
         -write mpr:triangle  +delete \) \
      \( mpr:triangle             \) -gravity northwest -composite \
      \( mpr:triangle -flip       \) -gravity southwest -composite \
      \( mpr:triangle -flop       \) -gravity northeast -composite \
      \( mpr:triangle -rotate 180 \) -gravity southeast -composite \
      corner_cutoff.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="corner_cutoff.png"
     ><IMG SRC="corner_cutoff.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


If you don't want transparency, but some other color, you can still do the
above and then <A HREF="../masking/#remove" >Remove Transparency</A>. This can
be important for JPEG images. </P>

However an even simpler solution (in terms of complexity and memory usage) has
been found in a <A HREF="../forum_link.cgi?t=17626" >IM forum discussion</A>.
This overlays colored corners ('<CODE>Red</CODE>' in this case) rather than
making them transparent.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
    \( +clone -crop 16x16+0+0  -fill white -colorize 100% \
       -draw 'fill black circle 15,15 15,0' \
       -background Red  -alpha shape \
       \( +clone -flip \) \( +clone -flop \) \( +clone -flip \) \
     \) -flatten  rounded_corners_red.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rounded_corners_red.png"
     ><IMG SRC="rounded_corners_red.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Unfortunately this method can not be used to simply 'erase' the image corners
to transparency, due to an interaction with a 'background canvas' of the <A
HREF="../layers/#flatten" >Flatten Operation</A>, a future layering operator
may solve this. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The last example will fail for versions of IM before v6.6.6-5 due to both
  the "<CODE><A HREF="../option_link.cgi?flip" >-flip</A></CODE>" and the
  "<CODE><A HREF="../option_link.cgi?flop" >-flop</A></CODE>" operators not
  handling the virtual canvas offset correctly.
</I></FONT></TD></TR></TABLE></P>

Using a <A HREF="../distorts/#polar_tricks" >Polar Cycle Trick</A> we can
generate a perfect anti-aliased circle mask for any sized thumbnail. Of course
we will only use the distorted image as a mask for the original image, so as
to get the best result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set \
    \( +clone -distort DePolar 0 \
       -virtual-pixel HorizontalTile -background None -distort Polar 0 \) \
    -compose Dst_In -composite -trim +repage circle_masked.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="circle_masked.png"
     ><IMG SRC="circle_masked.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

We will take this style of image processing further in <A
HREF="#rounded_border" >Border with Rounded Corners</A> below. There we not
only cutting out corners, but also overlay appropriate framing images.  </P>


<A NAME="torn"></A>
<H3>Torn Paper Edge</H3>

Leif strand &lt;leif&#64;sitelogic.fi&gt;, contributed the following IM code
to generate an edge that looks like it was torn from a fibrous paper (like
newspaper)...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert thumbnail.gif \
          \( +clone -alpha extract -virtual-pixel black \
             -spread 10 -blur 0x3 -threshold 50% -spread 1 -blur 0x.7 \) \
          -alpha off -compose Copy_Opacity -composite torn_paper.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="torn_paper.png"
     ><IMG SRC="torn_paper.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

One improvement may be to make it look like you ripped it from a newspaper
corner.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert thumbnail.gif -bordercolor linen -border 8x8 \
          -background Linen  -gravity SouthEast -splice 10x10+0+0 \
          \( +clone -alpha extract -virtual-pixel black \
             -spread 10 -blur 0x3 -threshold 50% -spread 1 -blur 0x.7 \) \
          -alpha off -compose Copy_Opacity -composite \
          -gravity SouthEast -chop 10x10   torn_paper_corner.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="torn_paper_corner.png"
     ><IMG SRC="torn_paper_corner.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This could be improved by adding 'paper' colored borders and a curved shaped
mask, so that it looks like the image was ripped roughly by hand.
Adding a 'soft shadow' (see next) will also 'lift' the resulting image from
the background, making it look like it was a separate piece.  </P>

As always, suggestions and contributions are welcome. </P>


<A NAME="shadow"></A>
<H3>Adding a Shadow</H3>

The "<CODE><A HREF="../option_link.cgi?shadow" >-shadow</A></CODE>" operator
makes the <A HREF="../blur/#shadow" >Generation of Shadows</A> of any
shaped image easy. </P>

For example here an I add a semi-transparent colored shadow, to the thumbnail.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set \
          \( +clone -background navy -shadow 60x0+4+4 \) +swap \
          -background none -mosaic   shadow_hard.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="shadow_hard.gif"
     ><IMG SRC="shadow_hard.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

But you can just as easily create soft fuzzy shadows, too.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -page +4+4 thumbnail.gif -alpha set \
          \( +clone -background navy -shadow 60x4+4+4 \) +swap \
          -background none -mosaic     shadow_soft.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="shadow_soft.png"
     ><IMG SRC="shadow_soft.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that I again used a PNG format image for the thumbnails output. That is
because the shadowed image will contain a lot of semi-transparent pixels,
which GIF cannot handle.  (Yes I am repeating myself but it is important).
</P>

If you do plan to use GIF or JPG format you will need to use a more
appropriate "<CODE><A HREF="../option_link.cgi?background"
>-background</A></CODE>" color for the web page or larger canvas on which you
plan to display your thumbnail, as these formats do not handle
semi-transparent colors. </P>

Warning, while the above works for individual thumbnails, it will generally
fail when you want to layer multiple thumbnails over the top of each other.
The reason is that shadows do not accumulate together, in the same way that
normal images do. To see how to handle shadows from multiple layered images
see <A HREF="../layers/#layer_shadow" >Layers of Shadows</A>. </P>


<A NAME="thickness"></A>
<H3>Adding Some Thickness</H3>

Adding a thickness to an image or a shape look a bit like adding a hard shadow
(see above), but isn't quite the same, and needs some extra work to get right.
</P>

This is actually very tricky as we create a colored, mask of the image which
is then replicated multiple times and layered under the original image (using
'<CODE>DstOver</CODE>' composition) with increasing offsets to give the image
thickness. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set \
          \( +clone -fill DarkSlateGrey -colorize 100% -repage +0+1 \) \
          \( +clone -repage +1+2 \) \
          \( +clone -repage +1+3 \) \
          \( +clone -repage +2+4 \) \
          \( +clone -repage +2+5 \) \
          \( +clone -repage +3+6 \) \
          -background none -compose DstOver -mosaic  thickness.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="thickness.gif"
     ><IMG SRC="thickness.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You get the idea.  Each '<CODE>\( +clone ... \)</CODE>' line adds one extra
pixel to the image in a south by south-easterly direction. </P>

Also as no semi-transparent pixels are involved (at least for a rectangular
image) you can use the GIF image format for the result. </P>

The major problem with this technique is that it is hard to specify a
thickness as a variable argument or at different angles, unless you write a
specific script to add thickness.  Also the edge of the angled parts of the
thickness is not anti-aliased, so there is lots of room for improvement. </P>


<A NAME="polaroid"></A>
<H3>Polaroid-like Thumbnails</H3>

You can make your thumbnail image look like a polaroid photo, give it a
shadow, and even rotate it a little so as to appear to be just sitting on a
table. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          -bordercolor white  -border 6 \
          -bordercolor grey60 -border 1 \
          -background  none   -rotate 6 \
          -background  black  \( +clone -shadow 60x4+4+4 \) +swap \
          -background  none   -flatten \
          poloroid.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="poloroid.png"
     ><IMG SRC="poloroid.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

A more complex version of the above was added to IM v6.3.1-6 as a "<CODE><A
HREF="../option_link.cgi?polaroid" >-polaroid</A></CODE>" transformation
operator.   For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert thumbnail.gif -bordercolor snow -background black +polaroid \
          poloroid_operator.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="poloroid_operator.png"
     ><IMG SRC="poloroid_operator.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the image not only has the polaroid frame, but the photo has also
been given a bit of a 'curl' with appropriate shadow adjustments, giving the
resulting image more depth. The plus (+) form uses a randomized angle, while
the normal minus (-) form lets you provide the angle of rotation.  Special
thanks to Timothy Hunter for the idea behind this technique. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

You can even add a "<CODE><A HREF="../option_link.cgi?caption"
>-caption</A></CODE>", set your own shadow color, specify your own rotation
(or none at all).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -caption '%c' hatching_orig.jpg -thumbnail '120x120>' \
          -font Ravie -gravity center -bordercolor Lavender \
          -background navy  -polaroid -0     poloroid_caption.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="poloroid_caption.png"
     ><IMG SRC="poloroid_caption.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For more information on using this operator see <A
HREF="../transform/#polaroid" >Complex Polaroid Transformation</A>. </P>

For these examples though, I'll continue to use a DIY creation method, as I
need finer control of the borders and shadowing effects to demonstrate
proper photo 'stacking'. </P>

And here we go... By making multiple copies of the photograph, (or using other
images), and adding polaroid borders, you can then randomly rotate and stack
them up to produce a nice looking pile of photos.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert thumbnail.gif \
     -bordercolor white  -border 6 \
     -bordercolor grey60 -border 1 \
     -bordercolor none  -background  none \
     \( -clone 0 -rotate `convert null: -format '%[fx:rand()*30-15]' info:` \) \
     \( -clone 0 -rotate `convert null: -format '%[fx:rand()*30-15]' info:` \) \
     \( -clone 0 -rotate `convert null: -format '%[fx:rand()*30-15]' info:` \) \
     \( -clone 0 -rotate `convert null: -format '%[fx:rand()*30-15]' info:` \) \
     -delete 0  -border 100x80  -gravity center \
     -crop 200x160+0+0  +repage  -flatten  -trim +repage \
     -background black \( +clone -shadow 60x4+4+4 \) +swap \
     -background none  -flatten \
     poloroid_stack.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="poloroid_stack.png"
     ><IMG SRC="poloroid_stack.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The  "&nbsp;<CODE>`convert ...`</CODE>&nbsp;" embedded command in the above
  example generates a random floating point number from -15 to +15. For more
  infomation on using IM as a mathematical calculator see <A
  HREF="../transform/#fx_escapes" >FX Expressions</A>.
  An alturnative is to assign random numbers to shell variables and substitute
  them into the above command instead.
</I></FONT></TD></TR></TABLE></P>

Of course you could substitute a set of different images rather than repeating
the same image when creating the stack. Or select a set of rotates angles so
they are all reasonably different, or are more pleasing to look at. If you are
really good you can even offset the rotated images (jitter their position a
little) so they are not all stacked up perfectly centered.

But you get the basic idea. </P>

If you really want to avoid the use of the PNG format, due to its current
problems with <I>some</I> browsers, you can use the GIF image format.  To do
this you must be willing to accept some color limitations, and know the exact
background color on which the image will be displayed.  The
'<CODE>LightSteelBlue</CODE>' color in the case of these pages.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          -bordercolor white  -border 6 \
          -bordercolor grey60 -border 1 \
          -background  none   -rotate -9 \
          -background  black  \( +clone -shadow 60x4+4+4 \) +swap \
          -background  LightSteelBlue  -flatten    poloroid.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="poloroid.gif"
     ><IMG SRC="poloroid.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For details about this technique (and more) see <A HREF="../formats/#bgnd"
>GIF images on a solid color background</A>. </P>

The above 'stacked polaroid' technique graciously provided by Ally of <A
HREF="http://www.allystrip.com/" >Ally's Trip</A> and Stefan Nagtegaal for <A
HREF="http://sempre-crescendo.nl/" >Muziekvereniging Sempre Crescendo</A>,
both of which use Polaroid-like thumbnails extensively on their web sites.
</P>

In the <A HREF="../forum_link.cgi?t=7530" >IM User Forum</A>, the user <I><A
HREF="../forum_link.cgi?u=7473" >grazzman</A></I> went a little further by
overlaying images onto a rotating canvas to create a photo spread.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 150x150 xc:none -background none \
          -fill white -stroke grey60 \
          -draw "rectangle 0,0 130,100" thumbnail.gif \
                -geometry +5+5 -composite -rotate -10 \
          -draw "rectangle 0,0 130,100" thumbnail.gif \
                -geometry +5+5 -composite -rotate -10 \
          -draw "rectangle 0,0 130,100" thumbnail.gif \
                -geometry +5+5 -composite -rotate +10 \
          -trim +repage -background LightSteelBlue -flatten \
          poloroid_spread.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="poloroid_spread.gif"
     ><IMG SRC="poloroid_spread.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course for a photo spread like this you really need to use a set of
different photos rather using the same image over and over as I did here. </P>

There are a few caveats you may like to consider with this technique. <UL>
<LI>The framing has been hardcoded into the above, and depends on the size of
    the thumbnail image. In a real application the framing may be moved to the
    thumbnail generation stage rather than in the above photo spread.
<LI>As "<CODE><A HREF="../option_link.cgi?rotate" >-rotate</A></CODE>" also
    expands the size of the canvas the position in which images are added is
    changing, unless you place them using an offset from "<CODE><A
    HREF="../option_link.cgi?gravity" >-gravity</A> center</CODE>" position.
<LI>And finally, a constantly rotating the background frame is not a good
    idea in terms of quality.  Rotating an already rotated image, adds more
    pixel level distortions to the result than doing one rotate for each
    separate image before being overlaid.
</UL></P>

A similar randomized stacking of photos over a larger area was developed for
<A HREF="http://stason.org/photos/gallery/" >Stas Bekman's Photography</A>,
but with a different bordering technique.  </P>

A more generalized method for creating some sort of ordered or programmed
layout of photos and images, is shown and described in <A
HREF="../layers/#layer_examples" >Examples of Image Layering</A>, as well as in
<A HREF="../photos/#overlap" >Overlapping Photos</A>. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="framing"></A>
<H2>Framing Techniques</H2>

Here we will look at some advanced framing techniques that use some very
advanced knowledge of how IM works to achieve the desired results. </P>

<A NAME="self_frame"></A>
<H3>Self Framing (External)</H3>

<B>Self Framing</B> is a technique that can be used to frame an image, using
the image itself to generate the framing colors and patterns. That is to say
the added frame is not fixed, but varies so as to roughly match the image
being framed. </P>

You can do this in two ways.  Extend the original image so as to create, an
<I>External Frame</I>, or use part of the actual image itself to create an
<I>Internal Frame</I>. </P>

For example, if we enlarge the image and dim it, before overlaying the
original image on top, we get a very nice looking frame.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          \( -clone 0 -resize 130% +level 20%x100% \) \
          \( -clone 0 -bordercolor black -border 1x1 \) \
          -delete 0 -gravity center -composite  self_bordered.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="self_bordered.gif"
     ><IMG SRC="self_bordered.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Instead of using <A HREF="../color_mods/#level_plus" >Level Adjustments</A>
  to brighten (or darken) the framing image, an alturnative way of making the
  border a lighter or darker color is to <A HREF="../color_mods/#colorize"
  >Color Tint</A> the frame using something like...<BR>

     "<CODE>-fill white -colorize 30%</CODE>"

</I></FONT></TD></TR></TABLE></P>

Another way of color tinting the image to generate the frame, you can simply
get IM to overlay a semi-transparent <A HREF="../crop/#frame" >Frame</A> on
top of the enlarged image.  However this requires you to know the size of the
thumbnail so as to exactly resize it exactly the right amount to accommodate
the generated frame.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          \( -clone 0 -resize 140x110\! \) \
          \( -clone 0 -bordercolor black -border 1x1 \
                      -mattecolor '#8884' -frame 9x9+0+9 \) \
          -delete 0 -composite  self_framed.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="self_framed.gif"
     ><IMG SRC="self_framed.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

A variation of the above uses the special <A
HREF="../distorts/#distort_viewport" >viewport</A> control and the default <A
HREF="../misc/#edge" >Virtual Pixel, Edge</A> setting to extend the edge of a
blurred image to generate the extenal frame. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \( +clone \
             -set option:distort:viewport 150x120-15-15 \
             -virtual-pixel Edge    -distort SRT 0  +repage \
             -blur 0x3 +level 20%,100% \) \
          \( -clone 0 -bordercolor white -border 1 \) \
          -delete 0 -gravity center -compose over -composite \
          self_blurred_edge.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="self_blurred_edge.gif"
     ><IMG SRC="self_blurred_edge.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Just a word of warning. A small edge defect (such as a tree or leaf) can
produce some undesirable results in a frame that was generated using only the
edge of the image. </P>

The viewport does need to know the size of the original image to enlarge and
offset that viewport the appropriate amount.  However you can use <A
HREF="../transform/#fx_escapes" >FX Escape Expressions</A> to calculate the
viewport size (see examples below).  </P>

An alternative is to use a blurred <A HREF="../misc/#dither" >Virtual Pixel,
Dither</A> in the above example.  This will spread the colors further and be
not quite so 'edgy'.  But if you add blurs before and after the expansion you
use the dither to produce a cloth-like effect. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \( +clone  -blur 0x3 \
             -set option:distort:viewport '%[fx:w+30]x%[fx:h+30]-15-15' \
             -virtual-pixel Dither  -distort SRT 0  +repage \
             -blur 0x0.8  +level 20%,100% \) \
          \( -clone 0 -bordercolor white -border 1 \) \
          -delete 0 -gravity center -compose over -composite \
          self_blurred_dither.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="self_blurred_dither.gif"
     ><IMG SRC="self_blurred_dither.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The first blur modulates the average color, while the second adjusts how
'pixelated' or smooth the dither pattern is. </P>

Here is another example, this time using <A HREF="../misc/#mirror" >Virtual
Pixel, Mirror</A>, with a <A HREF="#soft_edges" >Soft Edge</A> (blackened)
which turned out to work very well for this specific image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif  \( +clone \
             -set option:distort:viewport '%[fx:w+30]x%[fx:h+30]-15-15' \
             -virtual-pixel Mirror -distort SRT 0 +repage \
             -alpha set -virtual-pixel transparent \
                 -channel A -blur 0x8 +channel \
             -background Black -flatten \) \
          +swap -gravity center -compose over -composite \
          self_mirror.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="self_mirror.gif"
     ><IMG SRC="self_mirror.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In all the above cases the frames are generated from the same image, which is
then combined together to produce a frame based on the colors coming from the
original image.  The framing border is thus unique and matches each thumbnail
image that is framed. </P>

Fred Weinhaus has created a script "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/imageborder/"
>imageborder</A></CODE>" to make self framing images easier, with borders
being generated from blurred magnifications of the original image, or some
form of <A HREF="../misc/#virtual-pixel" >Virtual Pixel</A> setting defining
the contents. </P>


<A NAME="self_frame_inside"></A>
<H3>Self Framing (Internal)</H3>

Rather than enlarging the image to add the new border, we can convert parts of
the image itself into a border. </P>

We have already seen some techniques of adding a frame, inside the image
itself.  The <A HREF="#button" >Raised Button</A> and <A HREF="#bubble"
>Bubble Button</A> techniques do this, using the "<CODE><A
HREF="../option_link.cgi?raise" >-raise</A></CODE>" operator. </P>

Here we generate a lighter blurred version of the original image which is then
overlaid using a mask also generated from the original image. A white edge is
then added to separate that lighter blured version from the center un-modified
part of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \( +clone -blur 0x3 +level 20%,100% \) \
          \( +clone -gamma 0 -shave 10x10 \
             -bordercolor white -border 10x10 \) \
          -composite \
          \( +clone -gamma 0 -shave 10x10 \
             -bordercolor white -border 1x1 \
             -bordercolor black -border 9x9 \) \
          -compose screen -composite \
          self_blurred_border.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="self_blurred_border.gif"
     ><IMG SRC="self_blurred_border.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can also use the <A HREF="../crop/#frame" >Frame Operator</A> to achieve
something a little different to the previously seen <A HREF="#button"
>Button</A> effects. The trick is to first <A HREF="../crop/#shave" >Shave</A>
the original image before applying. </P>

For example here I make a copy of the original image, shave and frame it
using transparent frame, before overlaying that over the original image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \( +clone -shave 10x10 \
            -alpha set -mattecolor '#AAA6' -frame 10x10+3+4 \
          \) -composite  inside_frame_trans.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="inside_frame_trans.gif"
     ><IMG SRC="inside_frame_trans.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The problem with this is that you will always 'lighten' or 'darken'
(de-contrast) the flat parts of frame around the original image. </P>

To avoid this we can use the same technique as the <A HREF="#bubble" >Bubble
Button</A> technqiue.  We generate a frame on a perfect grey canvas, and modiy
it so as to generate a <A HREF="../compose/#light" >Lighting Effects
Composition Mask</A>, to adjust the colors of the original image. </P>

For example here I use a '<CODE><A HREF="../compose/#vividlight"
>VividLight</A></CODE>' composition with the framed mask image to better
preserve primary colors.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          \( +clone -shave 10x10 -fill gray50 -colorize 100% \
            -mattecolor gray50 -frame 10x10+3+4 \
          \) -compose VividLight -composite  inside_frame_light.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="inside_frame_light.gif"
     ><IMG SRC="inside_frame_light.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Like the <A HREF="#bubble" >Bubble Button</A> you can also blur the lighting
mask before applying.  Here I used more normal  '<CODE><A
HREF="../compose/#hardlight" >HardLight</A></CODE>' compose which does not
enhance primary colors, with a blurred frame lighting mask.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          \( +clone -shave 10x10 -fill gray50 -colorize 100% \
            -mattecolor gray50 -frame 10x10+3+4 -blur 0x2 \
          \) -compose HardLight -composite  inside_frame_blur.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="inside_frame_blur.gif"
     ><IMG SRC="inside_frame_blur.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Some <A HREF="../compose/#light" >Light Composition Methods</A> may require
  you to <A HREF="../basics/#swap" >Swap the Images</A> before you compose
  them to get the correct lighting effect.
</I></FONT></TD></TR></TABLE></P>

To take this type of effect even further, producing much more complex results
see the advanced <A HREF="#lighting_mask" >Lighting Effect Mask</A>. </P>


<A NAME="border_overlay"></A>
<H3>Simple Border Overlay</H3>

One simple type of framing is to create a fancy frame, or shaped image into
which you can place your image, under the frame. </P>

For example here we generate a simple frame slightly larger than our image
with a fancy shaped hole. The shape was extracted from the
'<CODE>WebDings</CODE>' font (character '<CODE>Y</CODE>'), but there are a lot
of possible sources for fancy shapes that could be used for picture framing.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 120x140 -gravity center -font WebDings label:Y \
          -negate -channel A -combine +channel -fill LightCoral -colorize 100% \
          -background none -fill none -stroke firebrick -strokewidth 3 label:Y \
          -flatten +gravity -chop 0x10+0+0 -shave 0x10 +repage border_heart.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_heart.png"
     ><IMG SRC="border_heart.png"       WIDTH=120  HEIGHT=110
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For other ways of generating an edge on an existing shaped image see the
<A HREF="../transform/#edge" >Edge Transform</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

You can also optionally give the frame a little depth by using a <A
HREF="../blur/#shadow" >Shadow Effect</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert border_heart.png  \( +clone -background black -shadow 60x3+3+3 \) \
          -background none -compose DstOver -flatten   border_overlay.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_overlay.png"
     ><IMG SRC="border_overlay.png"      WIDTH=120  HEIGHT=110
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Now that we have a simple overlay frame, we can underlay the image in the
center, underneath the frame by using a '<CODE><A HREF="../compose/dstover"
>DstOver</A></CODE>' composition.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert border_overlay.png  thumbnail.gif \
          -gravity center -compose DstOver -composite   border_overlaid.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_overlaid.jpg"
     ><IMG SRC="border_overlaid.jpg"      WIDTH=120  HEIGHT=110
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now you can generate a library of pre-prepared frames to use with your images,
such as this <A HREF="../images/autumn_leaves.png" >Autumn Leaves Image</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    convert thumbnail.gif  autumn_leaves.png +swap \
            -gravity center -compose DstOver -composite \
            border_leaves.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="thumbnail.gif"
      ><IMG SRC="thumbnail.gif"             WIDTH=120  HEIGHT=90
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Text]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="../images/autumn_leaves.png"
      ><IMG SRC="../images/autumn_leaves.png"         WIDTH=140  HEIGHT=105
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Text]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="border_leaves.gif"
      ><IMG SRC="border_leaves.gif"         WIDTH=140  HEIGHT=105
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Text]"></A>
</DIV></P>

Note that I swapped the order of the images and used '<CODE><A
HREF="../compose/#dstover" >DstOver</A></CODE>' to place the second, main
image 'under' the frame.  That way it is the frame that determines the final
size of the image, and not the original image.  However doing this would also
loose any meta-data the main image has (for the same reason). </P>

If you really want to preserve the thumbnails meta-data (such as labels and
comments, such as a copyright message), then the best idea is to <A
HREF="#pad" >Pad Out the Thumbnail</A> to the same size as the frame, than
this use the default '<CODE><A HREF="../compose/#over" >Over</A></CODE>'
composition to overlay the frame.  That way the thumbnail is the 'destination'
image and its image meta-data is preserved. </P>

<A NAME="badge_overlay"></A>
<H3>Badge Overlay Example</H3>

Here is another more complex pre-prepared overlay example this time using
a correctly sized image (using extent as a crop method), from the IM Forum
Discussion <A HREF="../forum_link.cgi?f=1&t=19116" >Composite Overlay and
Masking</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    convert thumbnail.gif  -gravity center -extent 90x90 \
            badge_overlay.png -composite     badge.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="thumbnail.gif"
      ><IMG SRC="thumbnail.gif"             WIDTH=120  HEIGHT=90
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Text]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="../images/badge_overlay.png"
      ><IMG SRC="../images/badge_overlay.png"         WIDTH=90  HEIGHT=90
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Text]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="badge.png"
      ><IMG SRC="badge.png"         WIDTH=90  HEIGHT=90
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Text]"></A>
</DIV></P>

Note that the image itself is not distorted, just lightened and darkened
slightly, a circle cut out and shadow added, all in the one overlay image.  If
this was a real badge, or 'glass bubble' then the image should also be
distorted a little too (perhaps using a <A HREF="../distorts/#barrel" >Barrel
Distortion</A>), but it works well without needing such distortion. </P>

For the next step in the 'badge' example, see <A HREF="#badge_mask_paint"
>Badge using Mask and Paint</A>, which adds background transparency around the
outside of the badge. </P>


<BR>

<A NAME="mask_paint"></A>
<H3>Mask 'n' Paint Technique</H3>

In many cases you don't just want to overlay a square border around an image,
but also want to cut out the image edges, to transparency.  For this you would
typically use at least two images.  One is the masked overlay containing the
colors, shadows and highlights you want to add to the existing image. And
a second image containing the parts you want to remove from the original
image. </P>

The two images can be applied in two different ways.  You can either 'mask'
first to remove the unwanted parts from the image, then overlay the frame,
<I>or</I> you can overlay a frame, and then mask the unwanted parts of both
the original image and overlaid colors to transparency. </P>

Which method you use is critical, and the images involved will be designed for
a specific technique. You can not use images for one method in the wrong order
or things will not work properly. </P>

For example lets create more complex shaped border but this time don't worry
about setting the background.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 120x100 xc:none -fill none -stroke black -strokewidth 3 \
          -draw 'ellipse 60,50 30,45 0,360  ellipse 60,50 55,30 0,360' \
          -strokewidth 3  -draw 'ellipse 60,50 57,47 0,360' \
          -channel RGBA  -blur 2x1    border_ellipse.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_ellipse.png"
     ><IMG SRC="border_ellipse.png"       WIDTH=120  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now I purposely made this border blurry, to make the edge components much more
semi-transparent.  Even without that extra fuzziness, a border also contains a
lot of semi-transparent anti-aliasing pixels, that make the edge look smoother
and less jagged looking.  It is vital when image processing that you consider
these semi-transparent pixels, so as to preserve and set them correctly. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

To make it more interesting give this 'fuzzy' border a random bit of
coloring.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert border_ellipse.png \
          \( -size 120x100 plasma:Tomato-FireBrick -alpha set -blur 0x1 \) \
          -compose SrcIn -composite     border_ellipse_red.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_ellipse_red.png"
     ><IMG SRC="border_ellipse_red.png"       WIDTH=120  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Okay we have a border, but we still need some way of defining what should
represent the outside and inside of the border.  Basically we need a mask to
define these two areas.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 120x100  xc:none -fill black \
          -draw 'ellipse 60,50 30,45 0,360  ellipse 60,50 55,30 0,360' \
          border_ellipse_mask.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_ellipse_mask.png"
     ><IMG SRC="border_ellipse_mask.png"       WIDTH=120  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The color of this 'mask' image is not important, just its shape, as it
basically defined what parts will be classed as inside and what will be
outside.  The mask can be a gray-scale mask, or it can be a shape mask such as
shown above.  Though the later is typically more useful, and can even be a
shape of the parts to erase, or the parts to be kept (as above). </P>

In this case the images are designed as a "<I>mask 'n' paint</I>" technique,
meaning you should first erase the unwanted parts, then overlay the additional
border colors (which also has a transparency mask involved). </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set  -gravity center -extent 120x100 \
          border_ellipse_mask.png  -compose DstIn -composite \
          border_ellipse_red.png   -compose Over  -composite \
          border_mask_paint.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="thumbnail.gif"
     ><IMG SRC="thumbnail.gif"       WIDTH=120  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="border_ellipse_mask.png"
     ><IMG SRC="border_ellipse_mask.png"       WIDTH=120  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="border_ellipse_red.png"
     ><IMG SRC="border_ellipse_red.png"       WIDTH=120  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="border_mask_paint.png"
     ><IMG SRC="border_mask_paint.png"       WIDTH=120  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Two <A HREF="../compose/#duff-porter"> Duff-Porter Alpha Composition
Operations</A> are always is needed.  One to make parts transparent, and
another to overlay the additional colors to outline the border or frame.  Two
images are needed and as such be kept separate.  Some formats like MIFF and
GIF do allow you to save both images into the same file, for easier storage.
</P>

Of course you can combine the two images to create a single simple overlay
framing image, but only if you want to use a fixed non-transparency color
for the outside parts of the result. </P>

For example pre-define the outside as a DodgerBlue color...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert border_ellipse_mask.png -alpha extract -negate \
          -background DodgerBlue -alpha shape \
          border_ellipse_red.png   -compose Over -composite \
          border_ellipse_overlay.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_ellipse_overlay.png"
     ><IMG SRC="border_ellipse_overlay.png"       WIDTH=120  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

But in that case you could simply underlay a solid color or some other
background image under the previously generated double masked image...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert border_double_masked.png \
          \( -size 120x100 plasma:Green-Green -blur 0x1 \) \
          +swap  -compose Over  -composite     border_background.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_background.png"
     ><IMG SRC="border_background.png"       WIDTH=120  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The point is with two images, a 'mask' and 'overlay' image, you have a lot
more freedom in how you add the border to the image.   You could even define
multiple 'mask' images, to define the different 'windows' of the 'overlaid'
border image.  You can also add optional highlights and shadows, rather than
hard coding them into a single overlay framing image.  </P>

Now for an important caveat.  The edges of the masking image <B>must not</B>
coincide with the edges of the overlay image. </P>

If they match up, you will not get the correct handling of colors along the
coinciding edges, or generate other weird 'halo' effects.  As such you need to
make sure the mask edges fall somewhere within the fully-opaque region of the
overlay image. </P>

Caution and fore-thought with the two masking operations is needed. </P>

<A NAME="rounded_border"></A>
<H3>Border with Rounded Corners</H3>

As you saw above the <A HREF="#mask_paint" >Mask 'n' Paint Technique</A> can
be used to both add extra colors or 'fluff' to an image, but also remove
parts, so as to shape the final image. This presents us with an alternative
way of adding rounded corners to an image. </P>

The IM "<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>" operator
comes with a '<CODE>roundrectangle</CODE>' method that can be used to provide
an interesting frame around the image.  However you need to size the
dimensions of this draw method to match the image.  IM does provide methods to
extract and even do mathematical calculations based on the image size.  </P>

The coordinates at which to locate the rectangle is for the exact 'center' of
the stroke-width used to define the rectangle (it can be a floating point
value).  Also it is given in terms of 'pixel coordinates' (see <A
HREF="../distorts/#control_coordinates" >Pixel vs Image coordinates</A>),
which means that a value of 1,1 refers to the second pixel form the top and
left edges, but more importantly it refers to the 'center' of the pixel
which is in reality 1.5 units from the real top and left edges. </P>

Now we will use a stoke width (SW) of 3,  that makes the image 3 pixels larger
on all sides.  It then means the rectangle will be positioned  <CODE>SW/2
- 0.5</CODE>  or 1.0 pixels from the top left, and   <CODE>ImageSize + SW*1.5
- 0.5</CODE> or Image size + 4 pixels  at the bottom right.  </P>

Here we use IM itself to do these calculations, generating the exact draw
command that are need using fancy <A HREF="../transform/#fx_escapes" >FX
escapes</A>.  This is saved as a <A HREF="../draw/#mvg_file" >Magick Vector
Graphics File</A> that can be directly used by draw in later commands.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE TXT2GIF>
  convert thumbnail.gif \
          -format 'roundrectangle 1,1 %[fx:w+4],%[fx:h+4] 15,15'\
          info: > rounded_corner.mvg
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="rounded_corner.mvg"
      ><IMG SRC="rounded_corner.mvg.gif"
            ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  If you can figure out the image size in a different way (using the shell, or
  other API language wrapper) you can substitute the appropriate draw
  parameters directly into the next examples, rather then use an FX
  mathematical expression.  Basically the above makes this whole process
  independent of the actual size of the thumbnail.  Any other way, including
  direct hard coding is also acceptable.
</I></FONT></TD></TR></TABLE></P>

Now we can use this to generate overlay and a mask image. As part of this we
create a <A HREF="../canvas/#transparent" >Transparent Canvas</A> using the
original image (which is first enlarged by the stroke-width), to get the size
right.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -border 3 -alpha transparent \
          -background none -fill white -stroke none -strokewidth 0 \
          -draw "@rounded_corner.mvg"    rounded_corner_mask.png
  convert thumbnail.gif -border 3 -alpha transparent \
          -background none -fill none -stroke black -strokewidth 3 \
          -draw "@rounded_corner.mvg"    rounded_corner_overlay.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rounded_corner_mask.png"
      ><IMG SRC="rounded_corner_mask.png"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
  <A HREF="rounded_corner_overlay.png"
      ><IMG SRC="rounded_corner_overlay.png"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</DIV></P>

And there we have the overlay border image, and transparency mask image, we
need for the double masking technique. Note that the masks are for an image
that is stroke width larger than the original image, and that the erasing
shape mask (in white) does not cover the whole of the enlarged area, as there
is a 1 pixel gap all around it.</P>

So lets apply it using the <A HREF="#double" >Double Masking</A> technique...
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -bordercolor none -border 3  \
          rounded_corner_mask.png -compose DstIn -composite \
          rounded_corner_overlay.png -compose Over -composite \
          rounded_border.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="rounded_border.png"
     ><IMG SRC="rounded_border.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And there we have have a bordered our image with rounded corners. </P>

The following is how you can do the above all in a single command with a
little extra fanciness.  However this all-in-one command will still generate a
temporary file holding the generated draw commands needed for an image of the
size given.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
      -format 'roundrectangle 1,1 %[fx:w+4],%[fx:h+4] 15,15' \
      -write info:tmp.mvg \
      -alpha set -bordercolor none -border 3 \
      \( +clone -alpha transparent -background none \
         -fill white -stroke none -strokewidth 0 -draw @tmp.mvg \) \
      -compose DstIn -composite \
      \( +clone -alpha transparent -background none \
         -fill none -stroke black -strokewidth 3 -draw @tmp.mvg \
         -fill none -stroke white -strokewidth 1 -draw @tmp.mvg \) \
      -compose Over -composite               rounded_border_in_one.png
  rm -f tmp.mvg      # Cleanup of temporary file
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="rounded_border_in_one.png"
     ><IMG SRC="rounded_border_in_one.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

A better way for doing rounded corners, especially with very large images will
be to use a separate corner masking image technique, which we will look at
below in <A HREF="#fancy" >Fancy Corner Overlays</A>.  In many ways this is an
extension of the above method, but using separate masking for each corner of
the image, so as to keep the working images small in size. </P>

<A NAME="badge_mask_paint"</A>
<H3>Badge using Mask 'n' Paint</H3>

Here is a much more complex "mask 'n' paint" example, that was developed from
the image used previously in the <A HREF="#badge_overlay" >Badge Overlay</A>
example above. The generation of the two images was 'fudged', and was
discussed IM forums <A HREF="../forum_link.cgi?f=1&t=19116" >Composite Overlay
and Masking</A>. Idealy the two images would have been developed together.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -gravity center -extent 90x90 \
          badge_mask.png -compose DstIn -composite \
          badge_shading.png -compose Over -composite \
          badge_trans_bg.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="thumbnail.gif"
     ><IMG SRC="thumbnail.gif"             WIDTH=120  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Text]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="../images/badge_mask.png"
     ><IMG SRC="../images/badge_mask.png"         WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Text]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="../images/badge_shading.png"
     ><IMG SRC="../images/badge_shading.png"         WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Text]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="badge_trans_bg.png"
     ><IMG SRC="badge_trans_bg.png"         WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Text]"></A>
</DIV></P>

Note that above I said that the you should avoid trying to align transparency
edges and the mask edges.  In the above example I did just that, and the edges
of the resulting image will not be quite correct.  However as the coloring is
really only a subtile shading rather that a strong edge, it seems to work okay
in this example. Caution however should be exercised. </P>

For the next step in the 'badge' examples, see <A HREF="#badge_paint_mask"
>Badge using Paint and Mask</A>, which reverses the order of the two
composition operations, requiring a different set of images.  </P>

<BR>

<A NAME="paint_mask"></A>
<H3>Paint 'n' Mask Technique</H3>

Rather than '<I>Mask then Paint</I>' you can use a different set of images
and overlay the additional colors first, before masking out the background.
That is you can perform a '<I>Paint then Mask</I>'. </P>

That is you would take your image, and overlay the border which sets not only
all of the final border colors, but also masks and colors some or all the
parts outside parts the original image.   You then use a separate 'outside' or
'clipping' mask to remove all the unwanted parts of the resulting image.  </P>

Also note that both 'overlay' and 'masking' image defines the inside edge
separately to the outside edge of the border.  As a result one image does not
completely define the whole border in a single image, which can make it
a little harder to use. However it can be simpler to implement. </P>

For example...
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 120x90 xc:none -fill black -stroke black -strokewidth 0 \
          -draw 'ellipse 45,45 55,37 0,360' \
          -channel RGBA -negate -blur 0x3  +channel \
          \( granite: -auto-level -blur 0,0.7 \) \
          -compose ATop -composite border_paint.png

  convert -size 120x90 xc:none -fill black -stroke black -strokewidth 5 \
          -draw 'ellipse 59,45 56,40 0,360' border_mask.png

  convert thumbnail.gif -alpha set \
          border_paint.png -compose Over  -composite \
          border_mask.png  -compose DstIn -composite \
          border_paint_mask.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="thumbnail.gif"
     ><IMG SRC="thumbnail.gif"       WIDTH=120  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="border_paint.png"
     ><IMG SRC="border_paint.png"         WIDTH=120  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="border_mask.png"
     ><IMG SRC="border_mask.png"          WIDTH=120  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="border_paint_mask.png"
     ><IMG SRC="border_paint_mask.png"    WIDTH=120  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note how some parts of the overlaid colors are removed. This is the key
feature of the <I>Paint 'n' Mask</I> technique, allowing you to use a simpler
overlay, which is then adjusted by the mask. </P>

This method of image masking is what is used in the next <A HREF="#pagecurl"
>Page Curl Corners</A> example set, and again later in <A HREF="#fancy" >Fancy
Corner Borders</A> below. </P>

<A NAME="pagecurl"></A>
<H3>Page Curl Corners</H3>

<A HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred Weinhaus</A> created
a special shell script called <A
HREF="http://www.fmwconcepts.com/imagemagick/pagecurl/index.php" >PageCurl</A>
which will, add a simple page curl to an existing image, using some very
complex mathematics (in shell).  For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  pagecurl thumbnail.gif  pagecurl.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="pagecurl.png"
     ><IMG SRC="pagecurl.png"             WIDTH=120  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Internally it is actually using the <A HREF="#paint_mask" >Paint 'n' Mask</A>
technique. That is first overlays a slightly too large 'curl overlay', then
erases (masks) the rest of the image, including a small amount of the overlay,
that will become the transparent corner. </P>

However if you want to apply a page curl to a lot of images, using the full
script (above) is a rather slow technique.  It does after all do a huge amount
of mathematical processing (using IM itself as a floating point calculator),
to actually calculate and generate the appropriate overlay and masking images.
</P>

To apply a pagecurl to a lot of images it is better to use the script once so
as to generate the overlay and transparency mask image once only.  So lets
extract those two images for a smaller 64x64 pixel images (using a special
'<CODE>-i "pagecurl"</CODE> option added to the script for this purpose).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE IMAGE="curl_overlay.png">
  convert -size 64x64 xc: miff:- | pagecurl -e 0.3 -i "pagecurl" - null:
</CODE></PRE></TD></TR></TABLE>
</TD><TD><NOBR>
  <A HREF="pagecurl_overlay.png"
     ><IMG SRC="pagecurl_overlay.png"     WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="pagecurl_mask.png"
     ><IMG SRC="pagecurl_mask.png"             WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</NOBR>
</TD></TR></TABLE></P>

The above command creates two image files: "<CODE>pagecurl_overlay.png</CODE>"
and "<CODE>pagecurl_mask.png</CODE>" shown.  The input image itself does not
matter as it is the masking images that we want.  The 'page curled' result is
just junked using the special "<CODE><A HREF="../files/#null"
>null:</A></CODE>" image file format. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE IMAGE="curl_overlay.png">
  convert thumbnail.gif -alpha set -gravity SouthEast \
          -define compose:outside-overlay=false \
          pagecurl_overlay.png -composite \
          pagecurl_mask.png  -compose DstIn -composite \
          pagecurl_thumbnail.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD><NOBR>
  <A HREF="pagecurl_thumbnail.png"
     ><IMG SRC="pagecurl_thumbnail.png"   WIDTH=120  HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</NOBR>
</TD></TR></TABLE></P>

Of course these images are not the same size as our thumbnail or probably any
image you are wanting to apply it to, but that does not matter, as we can use
a couple of extra options to ensure they work as expected.  Specifically, the
"<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" setting
ensures that the two overlay images are positioned in the lower right corner.
And the special <A HREF="../basics/#define" >Define Setting</A>
'<CODE>compose:outside-overlay=false</CODE>' will prevent the mask image from
erasing the parts of the image not covered by the smaller image.  See <A
HREF="../compose/#outside-overlay" >Outside-Overlay Setting</A> for a full
description. </P>

If you like to apply this to a lot of images you can use the
"<CODE>mogrify</CODE>", using a special technique involving using "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" to do the <A
HREF="../basics/#mogrify_compose" >Mogrify Alpha Composition</A>.  However
this method of composition does not understand the special define setting,
so it will only work with images, overlays, and masks that are all the same
size.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  pagecurl -e 0.5 -i /tmp/pagecurl  {<I>one image</I>} null:
  mogrify {<I>mogrify -format and -path options</I>} -alpha set \
          -draw 'image Over 0,0 0,0 "/tmp/pagecurl_overlay.png"' \
          -draw 'image DstIn 0,0 0,0 "/tmp/pagecurl_mask.png"' \
          {<I>all images to be pagecurled</I>}...
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

<A NAME="fancy"></A> <H3>Fancy Corner Overlay</H3>

Here we look a bit deeper into used this 'double masking' technique to modify
an image in different ways in different areas, rather than applying a single
large mask or frame to the whole image.  In this case we will only double mask
the corners.  The rest of the border (to match) is added separatally. </P>

<A HREF="../images/fancy_orig.gif"
   ><IMG SRC="../images/fancy_orig.gif"
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

The corner images I will use was generated from the original source (shown
right) which I found in the <A
HREF="http://www.ict.griffith.edu.au/anthony/icons/prog/frames/Icons.html" >DIY
Frames Section</A> of <A HREF="http://www.ict.griffith.edu.au/anthony/icons/"
>Anthony's Icon Library</A>. There are others in this section, so you may like
to have a look. If you find something on the net, please let me know as I like
to collect interesting corners, and edging techniques. </P>

<A HREF="../images/fancy_sub.gif"
   ><IMG SRC="../images/fancy_sub.gif"
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<A HREF="../images/fancy_add.gif"
   ><IMG SRC="../images/fancy_add.gif"
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

A color overlay and masking image was generated, from that initial image, so
that we could use a <A HREF="#paint_mask" >Paint 'n' Mask</A> technique, for
overlaying the corner onto the image. </P>

Notice that these images, did not actually use any semi-transparent pixels, or
even any shading of colors. As such this fancy border can be used to produce
clean looking 'GIF' thumbnails for web pages.  </P>

The complication with using corner masks, is that they only mask the corners
of the original image.  Because of this the original image first needs to be
given the appropriate set of extra border colors.  After that the two corner
masks, must be composted onto each of the corners of the expanded image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif   -alpha set  -compose Copy \
          -bordercolor Black  -border 2 \
          -bordercolor Sienna -border 3 \
          -bordercolor Black  -border 1 \
          -bordercolor None   -border 2 \
          -bordercolor Black  -border 2 \
          -bordercolor Peru   -border 3 \
          -bordercolor Black  -border 1 \
          \
          -compose Over \
          \( fancy_add.gif             \) -gravity NorthWest -composite \
          \( fancy_add.gif -flip       \) -gravity SouthWest -composite \
          \( fancy_add.gif       -flop \) -gravity NorthEast -composite \
          \( fancy_add.gif -flip -flop \) -gravity SouthEast -composite \
          -compose DstOut \
          \( fancy_sub.gif             \) -gravity NorthWest -composite \
          \( fancy_sub.gif -flip       \) -gravity SouthWest -composite \
          \( fancy_sub.gif       -flop \) -gravity NorthEast -composite \
          \( fancy_sub.gif -flip -flop \) -gravity SouthEast -composite \
          fancy_border.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
   <A HREF="fancy_border.gif"
      ><IMG SRC="fancy_border.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that to preserve the transparent border that is being added, you must
  set "<CODE><A HREF="../option_link.cgi?compose" >-compose</A></CODE>"
  setting to '<CODE>Copy</CODE>' rather than the default of
  '<CODE>Over</CODE>'.  If you don't then the transparency will be filled by
  the next border color added, in this case with 'Black'. See the <A
  HREF="../crop/#border" >Border Operator</A> for details.
</I></FONT></TD></TR></TABLE></P>


The beauty of only using corner masks is that any size image can be framed
using this technique, as long as it is large enough for the corner masks being
added. That is you are not limited by the size of the framing images you have
available. </P>

Of course each of the four corner images and the borders is the same all the
way around the image, just rotated.  That is the shadow or thickness effect is
all 'inward'. </P>

To fix this you would need to generate a different corner peice for each and
every corner, and the addition of the extra edges around the original image
would need to be asymetrical.  Basically it becomes much more complex, so as
to produce true shadowing effects. A better solution may be to remove the
shadow effect from the corner piece, apply it as before, but then add shadow
effects globally.  Caution is needed. </P>

<A NAME="badge_paint_mask"</A>
<H3>Badge using Paint 'n' Mask</H3>

The same badge image processing seen previously in
<A HREF="#badge_overlay" >Badge Overlay</A> and <A HREF="#badge_mask_paint"
>Badge Mask 'n' Paint</A>, can also be performed by painting then masking.
</P>

<!-- <CODE EXECUTE>
  # get transparency mask, as a shaped image
  convert badge_mask.png badge_shading.png -composite \
          -evaluate set 0  badge_shape.png
  # get transparency mask, as a gray scale image.
  convert badge_mask.png badge_shading.png -composite \
          -alpha extract  badge_graymask.png

  # generate the paint overlay,
  # However we need to extract all fully transparent colors from shade image
  convert badge_mask.png -channel A -negate -threshold 0 +channel \
          badge_shading.png +swap -channel A -compose Screen -composite \
          badge_paint.png

</CODE>

  # Removing the +swap in the above should produce the same result
  # as -compose Plus is a communicative composition.
  # BUT it produces a negated image!

  convert badge_mask.png -channel A -negate -threshold 0 +channel \
          badge_shading.png -channel A -compose Screen -composite \
          badge_paint.png

-->
Here we first paint all the colors an shades onto the then mask out
the final transparency of the image.
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -gravity center -extent 90x90 \
          badge_paint.png -composite badge_shape.png -compose DstIn -composite \
          badge_paint_mask.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="thumbnail.gif"
     ><IMG SRC="thumbnail.gif"             WIDTH=120  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Text]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="badge_paint.png"
     ><IMG SRC="badge_paint.png"         WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Text]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="badge_shape.png"
     ><IMG SRC="badge_shape.png"         WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Text]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="badge_paint_mask.png"
     ><IMG SRC="badge_paint_mask.png"         WIDTH=90  HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Text]"></A>
</DIV></P>

If this seems awkward for this specific image, you are right, it is. </P>

The reason that that we not only need to shade and highlight the original
image, but we also need to fill out any areas that will contain shadow effects
with black.  Specifically any parts that will become fully transparent (and
only pixels that really are fully transparent) will need to be painted with
black. </P>

On the other hand semi-transparent pixels with shadow effects will have
both a partial shade effect and a partial transparency mask.  In other words
shadows make an otherwise simple paint and mask technique awkward in the
division of painting and masking effects. </P>

This is why a paint and mask technique is typically not used when dealing with
semi-transparent additions to an image, such as when adding shadows or a flare
stars.  </P>

If the image did not contain any transparency-effects, than the paint process
does not look so horrible, and can in many case be simplier than other
techniques, as you can 'cut off' the painted overalys with the mask when
finished.  The <A HREF="#pagecurl" >Page Curl</A> example was such a case, as
we use the mask to trim the page curl overlay to make a seemless whole.</P>

Also note the gap between the hard black region and the shading effects in the
paint image.  This gap reflects warning I have mentioned before about ensuring
that you do not overlap the results of any internal masking with the edges of
any paint/overlay external mask.  It is only in this specific case that
this required gap becomes so obvious. </P>

For the next step in the 'badge' examples, see <A HREF="#badge_lighting"
>Badge using Lighting Effects</A>, which merges the two masking images into
a single mask/shading image. </P>

<BR>

<A NAME="lighting_mask"></A>
<A NAME="glass_bubble"></A>
<H2>Lighting Mask Technique</H2>

<H3>Glass Bubble Button</H3>

The next level of complexity in thumbnail processing is the application of
very complex lighting effects. The trickiness here is not so much the
application of a lighting effect to an image, but the generation of the
appropriate shading effect. </P>

For example using a <A HREF="../advanced/#aqua_effects" >Aqua Effect</A> you
can give an thumbnail a very complex shading effect that makes it look like it
has been enclosed by a 'bubble' of glass.  Also this works better with a
thumbnail that has <A HREF="#rounded" >Rounded Corners</A>. </P>

For lets generate a rounded corners mask for our thumbnail image, using a pure
gray color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert thumbnail.gif -alpha off -fill white -colorize 100% \
     -draw 'fill black polygon 0,0 0,15 15,0 fill white circle 15,15 15,0' \
     \( +clone -flip \) -compose Multiply -composite \
     \( +clone -flop \) -compose Multiply -composite \
     -background Gray50 -alpha Shape    thumbnail_mask.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="thumbnail_mask.png"
     ><IMG SRC="thumbnail_mask.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now that we have a pure gray 'shape mask' we want to use, I can apply the <A
HREF="../advanced/#aqua_effects" >Aqua Effect</A> effect to generate
a lighting overlay, for this shape.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert thumbnail_mask.png -bordercolor None -border 1x1 \
          -alpha Extract -blur 0x10  -shade 130x30 -alpha On \
          -background gray50 -alpha background -auto-level \
          -function polynomial  3.5,-5.05,2.05,0.3 \
          \( +clone -alpha extract  -blur 0x2 \) \
          -channel RGB -compose multiply -composite \
          +channel +compose -chop 1x1 \
          thumbnail_lighting.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="thumbnail_lighting.png"
     ><IMG SRC="thumbnail_lighting.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

With a final light/shade overlay image such as the above we can easily apply
it to any thumbnail image of the right size.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert thumbnail.gif -alpha Set thumbnail_lighting.png \
          \( -clone 0,1 -alpha Opaque -compose Hardlight -composite \) \
          -delete 0 -compose In -composite \
          glass_bubble.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="glass_bubble.png"
     ><IMG SRC="glass_bubble.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Not only does this add the appropriate shading effects to any thumbnail of
this size, but the same lighting image masks the thumbnail into the proper
shape. </P>

It is important to note that only the color channels are used to apply the
lighting effect, the alpha channel is not used in this process.  Similarly
when masking only the alpha channel is used, not the color channels.  Without
this seperation of channels for different effects, you will not get the
correct result. </P>

For a discussion on extracting a lighting effect from images see the IM user
forum topic <A HREF="../forum_link.cgi?f=1&t=19337" >Extracting light layer
from two images</A>. </P>

<BR>

This can be taken much further however in that we can also directly add
shadow effects to this lighting mask.  The added color however must be pure
black, and you need to ensure the lighting effect composition chosen will
make an image perfectly black is the lighting mask is black. </P>

However this is actually how shadow effects are normally added to an image,
as such you can just add shadows to the "lighting effect mask" directly, and
all will be well! </P>

The same thing is true for adding lighting 'flares', but only using white
pixels for the flare overlay. </P>

In essence a "</I>lighting effect image</I>" can again actually merge the two
<A HREF="#mask_paint" >Mask 'n' Paint</A> images back into a single image. As
you will see in the next example.
</P>

<A NAME="badge_lighting"></A>
<H3>Badge using Lighting Effects</H3>

Using the images from <A HREF="#badge_mask_paint" >Badge using Mask 'n'
Paint</A> technique, I applied them to a pure gray canvas image, so as to
quickly generate a "masked lighting effect" image, Actually I could also have
used the other style of masking (<A HREF="#badge_paint_mask" >Badge using
Paint 'n' Mask</A>) just as easily. </P>

I then apply the single masking image to the thumbnail reproducing the
desired result.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  # merge "mask 'n' paint" images with a gray image,
  # to create a "lighting mask"
  convert -size 90x90 xc:gray50 -alpha set \
          badge_mask.png -compose DstIn -composite \
          badge_shading.png -compose Over -composite \
          badge_lighting.png

  # Apply the single "lighting mask"
  convert thumbnail.gif -alpha set -gravity center -extent 90x90 \
          badge_lighting.png \
          \( -clone 0,1 -alpha Opaque -compose Hardlight -composite \) \
          -delete 0 -compose In -composite \
          badge_final.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="thumbnail.gif"
      ><IMG SRC="thumbnail.gif"             WIDTH=120  HEIGHT=90
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Text]"></A>
<IMG SRC="../img_www/plus.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT=" + ">
  <A HREF="badge_lighting.png"
      ><IMG SRC="badge_lighting.png"         WIDTH=90  HEIGHT=90
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Text]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="badge_final.png"
      ><IMG SRC="badge_final.png"         WIDTH=90  HEIGHT=90
            ALIGN=middle VSPACE=5 HSPACE=10 BORDER=0 ALT="[IM Text]"></A>
</DIV></P>

Actually I rather like this form of masking as the mask image itself looks
almost identical to the image you are after, just the colors are missing.
That is after all how a lighting mask is created, just apply the effects to
a perfect gray image, and you get a "lighting mask" image.  </P>

Just remember that with this particular technique, the semi-transparent shadow
must be pure black for it to work properly.  You can not use a gray colored
for any pixel that does not contain at least part of the original image. All
transparent and semi-transparent areas must be pure white or black in color,
with the appropriate level of alpha transparency.  </P>

<B>Why does only one image work?</B> Previously we needed two images! </P>

The answer is that the masking image is limited only to only adding either
pure black or white shades of color.  By doing this the shading (lighting)
effect, and its mask, is essentially merged into the color component of the
"<I>Lighting Effect Mask</I>".  </P>

As a result of this the alpha channel becomes free to hold the previously
separate transparency mask for the final image. </P>

The limitation of this however is that you can only add white and black shades
to the image.  You can not add for example a gray color to the image being
masked.  Note however that it is posible to add some tints of primary and
secondary colors of some color space, but only in a limited way, and I have
never seen it used. </P>

In summery you can not add specific colors or fancy borders to the image, only
shades and shadows, highlights and flares, or simple black or white text.

However you should not attempt to mix or overlap added white and black
effects, as the resulting gray anti-aliasing pixels between the two produces
a shaded color from the underlying image, and not the expected gray color.
That is the drawback with this technique! </P>

<H3>Masking images with distortions...</H3>

What is more incredible is that as as the shading colors is just a gray-scale
image, you can compress the lighting effects to just one color channel and the
alpha channel mask. </P>

This can then be used to free two color image channels for other image
processing effects!  That is you can store other things into the single
'masking image'.  </P>

Specifically you can add distortion effects into the same mask image!  For
more information on this see <A HREF="../mapping/#distortion_unified" >Unified
Distortion Image</A> which does exactly this! A sort of ultimate masking
image. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="frame_edge"></A>
<H2>Framing using Edge Images</H2>

<A HREF="../images/oak_frame_sample.jpg"
   ><IMG SRC="../images/oak_frame_sample.jpg"
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Image]"></A>

One common way to add a complex border to an image is to use a pre-prepared
framing images, to produce a frame such as the example shown (right). </P>

However you also need to be careful with generating frames.  If you look at
the given example carefully you will notice that it is not quite right.  The
shading of the generated frame is actually incorrect.  The left and bottom frame
edges should be swapped to produce a correctly shaded frame for a typical
top-left light source. </P>

As such before we even begin, I would like to stress the importance of using
the correct image, or the correctly modified image for each edge while framing
your thumbnail or photo.  It is very easy to get wrong, so double check your
results when you think you have it right. </P>

<H3>The Frame Edge Images</H3>

There are may types of images that can be used to frame an image. </P>

For example here is 'thin black with gold trim' frame that was modified from
images provided by Michael Slate &lt;slatem_AT_posters2prints.com&gt;.

<DIV ALIGN=center>
  <A HREF="../images/blackthin_top.gif"
     ><IMG SRC="../images/blackthin_top.gif"         WIDTH=50  HEIGHT=15
           ALIGN=middle VSPACE=0 HSPACE=30 BORDER=0 ALT="[IM Image]"></A>
  <A HREF="../images/blackthin_btm.gif"
     ><IMG SRC="../images/blackthin_btm.gif"      WIDTH=50  HEIGHT=15
           ALIGN=middle VSPACE=0 HSPACE=30 BORDER=0 ALT="[IM Image]"></A>
</DIV></P>

There are two images, to provide two different lighting effects, one for the
top and left edges, the other for the bottom and right edges. However the
colors along the length of the image does not vary. As such you can either
tile or stretch this frame to produce the length needed. </P>

A similar set of framing pieces are this 'thin ornate gold' tileable border
images.

<DIV ALIGN=center>
  <A HREF="../images/goldthin_top.png"
     ><IMG SRC="../images/goldthin_top.png"         WIDTH=34  HEIGHT=25
           ALIGN=middle VSPACE=0 HSPACE=30 BORDER=0 ALT="[IM Image]"></A>
  <A HREF="../images/goldthin_btm.png"
     ><IMG SRC="../images/goldthin_btm.png"      WIDTH=34  HEIGHT=25
           ALIGN=middle VSPACE=0 HSPACE=30 BORDER=0 ALT="[IM Image]"></A>
</DIV></P>

As these images has some fine detail you cannot just simply stretch the image
to the desired length. Nor can you just <A HREF="../warping/#rect_rotate"
>Rectangular Rotate</A> these pieces to produce the other edge pieces, as
doing so will get the shading of the fine detail wrong. </P>

A <A HREF="../warping/#transpose" >Diagonal Transpose</A> distortion should
however get the correct shading for the other edges.  Extra caution is advised
when reviewing your results, to be sure the both the overall shading and the
fine detail shading is correct on all four sides of the image. </P>

Finally a framing image may only consist of a single image that can be used to
generate all the framing edges, such as this 'bamboo' tiling frame image.

<DIV ALIGN=center>
  <A HREF="../images/bamboo.gif"
     ><IMG SRC="../images/bamboo.gif"          WIDTH=90   HEIGHT=14
           ALIGN=middle VSPACE=0 HSPACE=30 BORDER=0 ALT="[IM Image]"></A>
</DIV></P>

The reason only one image is needed is that the frame has no specific 'inside'
or 'outside' to it.  Though the frame does have both overall and fine detail
lighting effects that requires you to again be careful of how you
rotate/flip/transpose the image for the other edges. </P>

The bigger problem with this frame is that if you just tile it simply, the
macro detail becomes very regular, and as such you may need to randomise the
tile offset, or even randomise the lengths of pieces being appended togther so
as to give it a more natural look. More on this later. </P>

As you can see framing images can come in a variety of styles, and care must
be taken to handle the chosen edging images in the correct way (with regard to
lighting image), when generating the other missing edging images. </P>


<H3>Lengthening Framing Pieces</H3>

Now in any use of these framing images, we will need to create a longer pieces
that will cover the length of the image dimensions.  There are only two basic
ways in which this can be done. </P>

You can simply stretch the frame image using resize (without aspect
preservation) so as to get the right lengths.  This works for the first set of
pieces shown above, which have no internal detail, but is not appropriate for
any of the other framing images presented.  Basically it will distort the
internal detail, and may become a distraction to the look of the final image.
</P>

However the other lengthening method, tiling, can be used for any framing
image that has a repeating pattern or detail, which is the case with all the
above images presented. </P>

If you are creating your own framing pieces, please be careful that the tiles
do match up properly, and to a pixel boundary so as to ensure you have
an uniform color and proper cycling of the detail in your framing images. It
you don't you can get an artificial looking joint between the tiles, the
become obvious because of the repeation of the tiles. </P>

In the real world picture framers also have the same problem in joining pieces
together to make longer pieces. Basically it is very easy to get two different
shades of wood, or very different grain pattern, that when 'dove-tailed'
together, makes the joint very obvious.  So really your not alone in this
problem. </P>

The 'bamboo' framing images, will need to be tiled.  Though as the detail is
restricted to a small area on the image, you can get some interesting random
tiling effects, that may need some randomized lengthing and shortening of the
peices to remove.  I will not go into this however, and will leave it as
an exercise for those that are. </P>

For our examples, and because it works for just about all framing images
I will use a simple constant tiling method to generate the longer edge lengths
needed. </P>

<A NAME="frame_append"></A>
<H3>Over-simplistic Append</H3>

We can just lengthen the simple 'bamboo' frame above, by tiling it to the
right length, then <A HREF="../layers/#append" >append</A> the images
together. </P>

The tiling is done simply by the special <A HREF="../canvas/#tile" >Tiled
Canvas</A> image generator "<CODE><A HREF="../canvas/#tile" >tile:</A></CODE>"
to tile an image that is being read in.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          \( -size 90x14  tile:bamboo.gif -transpose \) \
          \( -size 90x14  tile:bamboo.gif -transpose \) -swap 0,1 +append \
          \( -size 148x14 tile:bamboo.gif \) \
          \( -size 148x14 tile:bamboo.gif \) -swap 0,1 -append \
          frame_append.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="frame_append.gif"
     ><IMG SRC="frame_append.gif"   WIDTH=148  HEIGHT=118
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the sizes used in the above two examples were calculated based on
the known width (10 pixels) of the framing image, and the size of the image
being framed (120x100 pixels). You will need to adjust the resize arguments
appropriately for your images. </P>

One problem with tiling framing pieces (like bamboo) is that all the edges
look like they are exact copies of each other!  That is the framing looks
artificial.  In real life the frame will have been cut with pretty much random
offsets, from longer pieces of real wood, or in this case bamboo. </P>

To fix that you will need to also give such tiles a slightly different <A
HREF="../canvas/#tile-offset" >Tile Offset</A> for each edge of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif \
          \( -size 90x14  -tile-offset +50+0 tile:bamboo.gif -transpose \) \
          \( -size 90x14  -tile-offset +0+0  tile:bamboo.gif -transpose \) \
          -swap 0,1 +append \
          \( -size 148x14 -tile-offset +70+0 tile:bamboo.gif \) \
          \( -size 148x14 -tile-offset +25+0 tile:bamboo.gif \) \
          -swap 0,1 -append       frame_tile_offset.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="frame_tile_offset.gif"
     ><IMG SRC="frame_tile_offset.gif"   WIDTH=148  HEIGHT=118
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This method of framing isn't too bad for this specific type of edge image,
though for other types of frames it can look very silly.  Basically the
corners are not correct, and for most frames you really want to have the edge
images meet at a 45 degree angle joint, just as you would have in a real
picture frame. </P>

One solution to this is to pre-generate by hand appropriate corner images that
we can now overlay onto this image to make it correct. This works well for a
simple stretchable framing image (like 'black thin' framing image), but it
will fail rather badly for a tileable image like 'bamboo' as the corner image
will probably not fit the tile image properly. </P>

The better way is to generate corner joints directly from the tiled edge
images.  And I'll be showing you methods of doing this later.  </P>


<A NAME="frame_extended"></A>
<H3>Extended Overlay Framing</H3>

Also you can make this type of edge framing look even better by extending the
frames beyond the bounds of the original image. This is often seen for a
'Home-Sweet-Home' type picture. </P>

To do this you will need to first enlarge the original image with lots of
extra space into which the longer frame pieces are overlaid.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -bordercolor none -border 34 \
          \( -size 144x14 -tile-offset +30+0 tile:bamboo.gif -transpose \) \
          -geometry +20+10 -composite \
          \( -size 144x14 -tile-offset +45+0 tile:bamboo.gif -transpose \) \
          -geometry +154+0 -composite \
          \( -size 178x14 -tile-offset +60+0 tile:bamboo.gif \) \
          -geometry +0+20 -composite \
          \( -size 178x14 -tile-offset +0+0  tile:bamboo.gif \) \
          -geometry +10+124 -composite \
          frame_overlaid.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="frame_overlaid.gif"
     ><IMG SRC="frame_overlaid.gif"   WIDTH=188  HEIGHT=158
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note the measurements and positioning for this type of framing is not simple,
and could use some randomization such as I hardcoded into the above example.
Also you can improve the look further by rounding of the ends of the lengths
of frame, with some additional and appropriate shading. </P>

A much better way of framing images in this manner is to generate the framing
image as a complete unit, and just overlay it on a fixed size image (see <A
HREF="#border_overlay" >Simple Border Overlay</A>). However doing this means
you can no longer slightly randomize the lengths and position of each framing
piece. </P>

<A NAME="frame_joints"></A>
<H3>45 degree corner joints</H3>

The better solution is to somehow add the framing images around the thumbnail
in such a way as to actually create a 45 degree joint in each of the corners
of the frame.  This is not easy, and I went though a number of drawing and
masking methods until I re-discovered a magical operator called <A
HREF="../crop/#frame" >Frame, 3D like Borders</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The solution then was simple.  Read in the image, and "<CODE><A
HREF="../option_link.cgi?frame" >-frame</A></CODE>" it, to create a template
which of the areas to be framed.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif -alpha set -bordercolor none \
          -compose Dst_Out -frame 15x15+15  frame_template.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="frame_template.gif"
     ><IMG SRC="frame_template.gif"   WIDTH=150  HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now note that this template as some interesting features.  First it is
transparent in the middle, where the main image will sit.  Second it has four
and only four distinct colors defining each area in which we want to place
our framing images.  It does not generate 'anti-aliaing' pixels of varing
colors in the corners.  </P>

Note that to make things easier the width of those areas (15 pixels) is width
of the framing pieces we will add to the image. if the vertical edges were
a different thickness to the horizontal edges, this technique would not work
very well.  In fact few methods would would well in such a situation. </P>

This image is the framing template and by tiling each of our framing pieces
into the four differently colored areas using <A HREF="../draw/#color" >Color
Fill Primitives</A>, we will get our 45 degree corner joints, very simply and
easily. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert frame_template.gif \
          -tile blackthin_top.gif -draw 'color 1,0 floodfill' \
          frame_top_filled.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="frame_top_filled.gif"
     ><IMG SRC="frame_top_filled.gif"   WIDTH=150  HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can repeat this process for the other three edges. Using transposes to
ensure that the highlights and shaodws of the internal detail remain correct.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert frame_template.gif \
          -tile blackthin_top.gif   -draw 'color 1,0 floodfill' \
          -tile-offset +0+105 -tile blackthin_btm.gif \
                                       -draw 'color 15,105 floodfill' \
          -transpose \
          -tile blackthin_top.gif      -draw 'color 1,0 floodfill' \
          -tile-offset +0+135 -tile blackthin_btm.gif \
                                       -draw 'color 15,135 floodfill' \
          -transpose \
          -gravity center thumbnail.gif -composite frame_filled.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="frame_filled.gif"
     ><IMG SRC="frame_filled.gif"   WIDTH=150  HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

From an IM forum discussion <A HREF="../forum_link.cgi?f=1&t=21867" >45 degree
frame joints</A> a simplier solution, involving pre-rotating the bottom edge
was found. Here is the full example using the <A HREF="../files/#mpr" >In Memory Register</A> to save intermediate images.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert thumbnail.gif                -write mpr:image    +delete \
          goldthin_top.png             -write mpr:edge_top +delete \
          goldthin_btm.png -rotate 180 -write mpr:edge_btm +delete \
          \
          mpr:image -alpha set -bordercolor none \
          -compose Dst -frame 25x25+25  -compose over \
          \
          -tile mpr:edge_btm \
          -transverse -draw 'color 1,0 floodfill' \
          -transpose  -draw 'color 1,0 floodfill' \
          -tile mpr:edge_top \
          -transverse -draw 'color 1,0 floodfill' \
          -transpose  -draw 'color 1,0 floodfill' \
          \
          mpr:image -gravity center -composite    frame_gold.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="frame_gold.png"
     ><IMG SRC="frame_gold.png"   WIDTH=170  HEIGHT=140
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see we still have a problem, it looks very artifical in the top
left and bottom right corner, due to a diagonal mirror effect that results
from the tiling.  To fix this we need to add a randomised "<CODE><A
HREF="../option_link.cgi?tile-offset" >-tile-offset</A></CODE>", so as to
remove this mirror effect. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  <A HREF="../canvas/#tile-offset" >Tile Offset</A> setting was broken before
  IM version 6.3.9-9 in that the 'X' offset was being used for both 'X' and
  'Y' offset values (the given 'Y' value was ignored).  This means that
  the above example will probably incorrectly tile the bottom and right edges,
  in older releases of IM.
</I></FONT></TD></TR></TABLE></P>


<B>Scripted Version</B></P>

<B>This needs to be re-written using the last example as template</B></P>

You can of course do all the above in a single command.  However lets do it
in a scripted way.

This version uses some in-line code to generate appropriate edging images from
the base images provided using <A HREF="../warping/#rect_rotates" >Simple
Distorts</A> and some randomized <A HREF="../warping/#roll" >Image Rolls</A>
to improve the overall look of the tiled image. These can be adjusted
depending on the type of edge framing image that was provided. </P>

The processed edging images are then tiled using an <A
HREF="../canvas/#tile_memory" >In-Memory Tile Image</A> technique and the
frame template (generated) is used to mask those images, as we did above.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT RANDOM IMAGE=framed_script.png>
  image=thumbnail.gif
     image_w=`convert $image -format %w info:`
     image_h=`convert $image -format %h info:`

  top=goldthin_top.png
  btm=goldthin_btm.png

     width=`convert $top -format %h info:`
     length=`convert $top -format %w info:`

  # Size of the new image ( using BASH integer maths)
  new_size=$(($image_w+$width*2))x$(($image_h+$width*2))

  # IM options to read a 'randomly rolled' version for the edge pieces
  lft="( $top -roll +$(($RANDOM % $length))+0  -transpose )"
  rht="( $btm -roll +$(($RANDOM % $length))+0  -transpose )"

  # IM options to 'randomly rolled' the top and bottom pieces
  top="( $top -roll +$(($RANDOM % $length))+0 )"
  btm="( $btm -roll +$(($RANDOM % $length))+0 )"

  # Frame the image in a single IM command....
  convert -page +$width+$width  $image  +page -alpha set \
    \( +clone -compose Dst -bordercolor none -frame ${width}x$width+$width \
       -fill none -draw "matte 0,0 replace" \
          -flip   -draw "matte 0,0 replace"   -flip \) \
    \( $top $btm -append -background none -splice 0x${image_h}+0+$width \
       -write mpr:horz +delete -size $new_size tile:mpr:horz +size \
       -clone 1  -compose DstOut -composite \) \
    \( $lft $rht +append -background none -splice ${image_w}x0+$width+0 \
       -write mpr:vert +delete -size $new_size tile:mpr:vert +size \
       -clone 1  -compose DstIn -composite \) \
    -delete 1  -compose Over  -mosaic   framed_script.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="framed_script.png"
     ><IMG SRC="framed_script.png"   WIDTH=170  HEIGHT=140
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

And there we have a perfectly framed image with 45 degree corner joints, with
randomized tiling offsets. </P>

Yes it is a complex example. But that is to allow the use of <A
HREF="../canvas/#tile_memory" >In-Memory Tile Images</A> so we can pre-process
the framing images, all in the one command.  This makes it more complex but
also more versatile. </P>

The above code has been built into a shell script, which you can download
("<CODE><A HREF="../scripts/frame_edges.tar.gz"
>frame_edges.tar.gz</A></CODE>" from the <A HREF="../scripts/" >IM Example
Scripts</A> directory). This tar file includes the script and a set of framing
images, that the script understands how to process and use. It also adds a
'cardboard' border between the frame and the image proper.  </P>

<H4>Future example</H4>

Using tiling edges with matching corner peices. </P>

The edge images will need to match up to pre-prepared corner pieces, but also
tile neatly across the fixed length of the image.  That means that the whole
tiled edge may need some stretching or compression so as to align the edge
tiles with its corner pieces. To work properly teh edge tiles must repeat at
least 3 or 4 times across the smallest image edge. </P>

An example of this type of tiled edge/corner is the implementation of a border
of 'leaves' or 'fleur' effects. </P>

</DIV>
<HR><!-- ---------------------------------------------------------------- -->

<ADDRESS>
Created: 8 February 2004 <BR>
Updated: 18 July 2014 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/thumbnails/</CODE>
</ADDRESS></BODY></HTML>
