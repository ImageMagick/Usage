<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Masks -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/masking/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Masks</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#alpha_channel"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Alpha (Matte) Channel</A>
    <UL>
    <LI><A HREF="#matte"
        >Internal Matte Channel</A>
    <LI><A HREF="#alpha"
        >Alpha Channel Operator</A>
        <DL><DD>
        <A HREF="#alpha_off"         ><CODE>Off</CODE></A>
           &nbsp;(or&nbsp;<A HREF="#alpha_off"<CODE>+matte</CODE></A>),&nbsp;
        <A HREF="#alpha_set"         ><CODE>Set</CODE></A>
           &nbsp;(or&nbsp;<A HREF="#alpha_set"><CODE>-matte</CODE></A>),&nbsp;
        <A HREF="#alpha_on"          ><CODE>On</CODE></A>,&nbsp;<BR>
        <A HREF="#alpha_opaque"      ><CODE>Opaque</CODE></A>,&nbsp;
        <A HREF="#alpha_transparent" ><CODE>Transparent</CODE></A>,&nbsp;
        <A HREF="#alpha_extract"     ><CODE>Extract</CODE></A>,&nbsp;
        <A HREF="#alpha_copy"        ><CODE>Copy</CODE></A>,&nbsp;<BR>
        <A HREF="#alpha_shape"       ><CODE>Shape</CODE></A>,&nbsp;
        <A HREF="#alpha_remove"      ><CODE>Remove</CODE></A>,&nbsp;
        <A HREF="#alpha_background"  ><CODE>Background</CODE></A><BR>
        </DL>
    <LI><A HREF="#remove"
        >Remove Transparency of an Image</A>
    <LI><A HREF="#boolean_transparency"
        >Boolean Alpha Transparency</A>
    <LI><A HREF="#outline"
        >Outline or Halo Transparency</A>
    </UL>
<DD><A HREF="#masks"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Using Masks with Images </A>
    <UL>
    <LI><A HREF="#editing"         >Editing an Image Mask</A>
    <LI><A HREF="#shapes"          >Masks as Colored Shapes</A>
    <LI><A HREF="#compose"         >Mathematical Composition</A>
    <LI><A HREF="#masked_compose"  >Masked Alpha Composition </A>
    <LI><A HREF="#aligning"        >Aligning Two Masked Images</A>
                                       (under construction)
    </UL>
<DD><A HREF="#special_masks"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Special Image Masks</A>
    <UL>
    <LI><A HREF="#write_mask"      >Write Mask - Protect Pixels form Change</A>
    <LI><A HREF="#clip_mask"       >Clip Mask and Clip Paths</A>
    <LI><A HREF="#read_mask"       >Read Masks - Ignore Pixel Input</A>
    </UL>

<DD><A HREF="#regions"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Regions and Region Sub-Images</A>
    <UL>
    <LI><A HREF="#region_warping"    >Warping a Local Region</A>
    <LI><A HREF="#region_internals"  >How Regions Work, and its Problems</A>
    </UL>
<DD><A HREF="#bg_remove"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Background Removal</A>
    <UL>
    <LI><A HREF="#floodfill"
        >Simple Backgrounds (floodfill)</A>
    <LI><A HREF="#border_cut"
        >Masking Bordered Objects</A>
    <LI><A HREF="#known_bgnd"
        >Removing a Known Background</A>
    <LI><A HREF="#difference"
        >Difference Image Masking and Feathering</A>
    <LI><A HREF="#semi-trans"
        >Recovering Semi-Transparent Edges</A>
    <LI><A HREF="#two_background"
        >Background Removal using Two Backgrounds</A>
    </UL>
<DD><A HREF="#hole_filling"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Hole_Filling</A>
    <UL>
    <LI><A HREF="#create_a_hole"
        >Creating a Hole to Fill</A>
    <LI><A HREF="#blur_fill"
        >Filling using a Blur</A>
    </UL>
    (Under Construction)
</DL>

In these examples we look at the special handling of transparency, the
transparency channel, using masks, and ultimately the removal of unwanted
backgrounds, or other elements, such as signs, text, spam. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="alpha_channel"></A>
<H2>Alpha (matte) Channel</H2>

The transparency (alpha) channel of an image is completely optional, and often
requires special handling separate to the normal 'color' channels. See <A
HREF="../color_basics/#colorspace" >Image Color Space</A> above. </P>

The existence of a transparency channel can also effect how the various
operators treat the other color channels, generally because
a fully-transparent color should often be completely ignored by an operation.
If this was not the case you get 'Black Halos' around images, such as was seen
in major IM Bugs in the early days of IM v6.  For example the <A
HREF="../bugs/resize_halo/" >Resize Halo Bug</A>, and the <A
HREF="../bugs/blur_trans/" >Blur with Transparency Bug</A>. </P>

To make matters worse, this channel is also sometimes referred to at an image's
'transparency' or 'opacity' channel, or even the image's 'mask'.  All however
refer to the same, special, fourth channel of the image. </P>

<A HREF="../images/moon.png"
   ><IMG SRC="../images/moon.png"  WIDTH=70 HEIGHT=70
         ALIGN=right VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>

To explain the difference we need a working example image and for this I'll
use a PNG image of a 'crescent  moon' image (from a <A
HREF="../compose/#copyopacity" >CopyOpacity Composition</A> example).

Now as you can see this image has a lot of areas which are fully transparent.
Not only that I needed to save the image using the 'PNG' image format which is
one of the small number of image formats that properly understands and handles
transparent and semi-transparent colors. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

I can demonstrate this transparency by overlaying the image onto the IM
built-in checkerboard pattern, using <A HREF="../compose/" >Alpha
Composition</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    composite -compose Dst_Over -tile pattern:checkerboard \
              moon.png  moon_background.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="moon_background.jpg"
      ><IMG SRC="moon_background.jpg"       WIDTH=70 HEIGHT=70
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="matte"></A>
<H3>Internal Matte Channel</H3>

Now internally IM v6 stores the transparency information in a 'matte' channel,
which just like the color channel is just a plain grey scale image of values
which range from white, for fully-transparent (or clear), to black for
fully-opaque.  It is sort of like what you would get if you look at a
silhouette of the original image. </P>

Now while the image transparency data is stored internally as 'matte' values,
almost all the operators will deal with transparency as 'alpha'.  As such on
very low level operators such as  "<CODE><A HREF="../option_link.cgi?level"
>-level</A></CODE>" and  "<CODE><A HREF="../option_link.cgi?threshold"
>-threshold</A></CODE>" actually handle the data as 'matte' rather than alpha.
Check the <A HREF="../option_link.cgi" >Official Option Reference</A> if you
are unsure.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Here is a very old way to extract a 'matte' transparency values from an
image.  It saves the transparency channel as a 'matte' image file format, and
required two separate steps, and commands to define the right image file
format.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert moon.png matte:moon.matte
<c>  convert MIFF:moon.matte moon_matte2.png

  # You can join those two steps in a pipeline as well...
  convert moon.png matte:- | convert - moon_matte3.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="moon_matte3.png"
     ><IMG SRC="moon_matte3.png"  WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This technique for extracting the 'matte' of an image was common when IM v5
was in use. Basically it was the only method provided to get access to the
transparency of an image.  It is now very rarely used. </P>

<A NAME="alpha"></A>
<H3>Controlling Image Transparency</H3>

There are two operators that give you low-level control of the transparency
channel of an image in memory.  The newer operator "<CODE><A
HREF="../option_link.cgi?alpha" >-alpha</A></CODE>" methods are now the
recommended method of control, though many IM Examples still show and use the
older "<CODE><A HREF="../option_link.cgi?matte" >-matte</A></CODE>" operator.
</P>

An image cannot only have alpha channel data, but it also has a 'switch' that
defines if the channel data is viewable or valid.  This means images can have
three states with regards to the alpha channel. </P>

<TABLE BORDER=0 ALIGN=center>
<TR><TH>Switch    <TD ROWSPAN=4>&nbsp;&nbsp; <TD><B>Channel Data</B>
<TR><TD>&nbsp;alpha off&nbsp;<TD>no alpha data (no memory has been allocated)
<TR><TD>&nbsp;alpha off&nbsp;<TD>old alpha data present (but not in use)
<TR><TD>&nbsp;alpha on&nbsp; <TD>alpha data that is currently in use
</TABLE></P>

This needs to be remembered as how the various methods behave depends on which
of the above three states the image was in. </P>

If the 'switch' is off operators will not touch the alpha data, as it may not
actually exist at all. In such a case old alpha could still be present,
unmodified, and thus out-of-date.  As you will see this is actually sometime
useful in some situations.  </P>

Note however that some operators may automatically turn on, or turn off the
alpha switch for one reason or another. </P>

For example, "<CODE>-compose CopyOpacity -composite</CODE>" will always turn on
the alpha channel in the resulting image, as it is the operator's job to copy
data into an alpha channel. As such it must exist in the final result. However
its existence in the input data can have other consequences.  See <A
HREF="../compose/#copyopacity" >Copy_Opacity Composition Method</A> for more
details. </P>

Similarly creating a canvas using the color '<CODE>None</CODE>' will also
automatically create and enable the transparency channel, so as to ensure the
blank image really is transparent.  On the other hand, creating a canvas using
some other <A HREF="../color_basics/#color" >Color Name</A> will generally not
create any transparency channel as images are opaque by default. </P>

<BR>

Here are the various "<CODE><A HREF="../option_link.cgi?alpha"
>-alpha</A></CODE>" methods and examples of how they effect images and their
transparency. </P>

<A NAME="alpha_off"></A>
<H4>Alpha Off <FONT SIZE=-1>or</FONT> "<CODE>+matte</CODE>"</H4>

This is just a simple switch on the image, which turns off any effect the
transparency has on the image.  It does not actually delete or destroy the
alpha channel attached to the image, it just turns off any effect that channel
has on the image.  Similarly no operator will effect the attached alpha
channel while it has been turned off. </P>

For example let's use the 'crescent  moon' image (from a <A
HREF="../compose/#copyopacity" >CopyOpacity Composition</A> example), and
simply turn the image alpha channel off.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -alpha off     alpha_off.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/moon.png"
    ><IMG SRC="../images/moon.png"          WIDTH=70 HEIGHT=70
          ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="alpha_off.png"
     ><IMG SRC="alpha_off.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the moon shape completely vanished when the transparency was turned
off, though that is actually rarely the case. Basically even the 'transparent'
areas have color, which is just not normally visible, in this case the hidden
color was the fractal canvas image that was used to create the moon image.
</P>

This hidden color could be anything, from a simple <A
HREF="../formats/#gif_trans" >GIF Transparency Color</A>, that the GIF format
uses to represent transparency in its color table, to garbage colors left
behind during the images creation, as above.  More typically the transparency
color is simply pure-black for any pixel that was fully-transparent.  Note
that pixels close to the edge may be semi-transparent, and thus still have
a valid color that is only partially visible.  </P>

The "<CODE><A HREF="../option_link.cgi?alpha" >-alpha</A> Off</CODE>"
operation in the above will have simply 'deactivate' or 'turn off' the
channel.  The transparency data itself has not been cleared or removed from
the image data stored in-memory.  It is still present, just unavailable for
the moment.  But... </P>

If the image is saved, while the transparency data is turned off, none of the
transparency data will be saved into the image file format. As such the
turned-off alpha data is not present in the saved copy of the image, even
though it is present (just turned off) in the in-memory version. </P>

Also as many file formats do not allow transparency (such as JPEG), these file
formats automatically do the equivalent of a "<CODE><A
HREF="../option_link.cgi?alpha" >-alpha</A> Off</CODE>" when the image is
saved (without actually doing so).  Generally this results in all transparent
areas typically turning black when saved as a JPEG image.  See <A
HREF="#alpha_remove" >Alpha Remove - Removing Transparency</A> below for the
correct way to remove transparency before saving to a JPEG file format. </P>

The "<CODE><A HREF="../option_link.cgi?matte" >+matte</A></CODE>" operator is
an older command that is exactly the same as "<CODE>-alpha Off</CODE>". That
is it just turns off the transparency channel. </P>

Note that turning off alpha, is often required before using a gray-scale mask
image with the <A HREF="../compose/#copyopacity" >CopyOpacity</A> Alpha
composition method. If you don't do this the compostion operator will copy
the enabled transparency (opacity channel) rather that use the intended
grayscale colors. </P>


<A NAME="alpha_set"></A>
<H4>Alpha Set <FONT SIZE=-1>or</FONT> "<CODE>-matte</CODE>"</H4>

The '<CODE>Set</CODE>' alpha method is the same as the older "<CODE><A
HREF="../option_link.cgi?matte" >-matte</A></CODE>" option. </P>

This ensures that the image has a 'transparency' or alpha/matte channel, but
if it was not present or turned off, that it is initialised to be fully-opaque
(See the <A HREF="#alpha_opaque" >Alpha Opaque</A> method below). </P>

However if the image already has an alpha channel present and enabled, it will
do nothing. </P>

In other words this operator ensures an alpha channel is present, without
modifying the look of the image as it is currently in memory.  As such on its
own this operator does not show any change to the image, but has real effects
when combined with other operators. </P>

So if you turn off the alpha channel using <A HREF="#alpha_off" >Alpha
Off</A>, and then enable it again using <A HREF="#alpha_set" >Alpha Set</A>,
the image will have an alpha channel, but it will be fully-opaque, just as the
image looked, when '<CODE>Set</CODE>' operation was requested.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -alpha off    -alpha set    alpha_set.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_set.png"
     ><IMG SRC="alpha_set.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If applied to an image that has an enabled alpha channel, no change is made.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -alpha set    alpha_noset.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_noset.png"
     ><IMG SRC="alpha_noset.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In summery, this operator should never change the appearance of the image, at
the time the operator is applied.  It just ensures the alpha channel set up
such that the image is left <I>as is</I>. </P>

This is typically used <B>after reading images</B> from an unknown image file
format, or input source, which may or may not have an alpha channel present.
This operator will then ensure that the image does have an alpha channel (for
image formats like JPEG),  but leaving any enabled and existing alpha channel
alone (such as for GIF or PNG formats). </P>

This is the recommended way of ensuring an image has an alpha channel after
reading it into memory, or more importantly, after an image has been processed
and you want to re-enable a clean alpha channel. </P>


<A NAME="alpha_on"></A>
<H4>Alpha On</H4>

The "<CODE><A HREF="../option_link.cgi?alpha" >-alpha</A> On</CODE>" is the
exact opposite to the previously looked at <A HREF="#alpha_off" >Alpha Off</A>
method.  Typically this is <I>too simplistic</I> for the purpose you are
wanting and as such <B>should be very RARELY used</B>. You should use "<CODE><A
HREF="#alpha_set" >-alpha Set</A></CODE>" in almost all cases. </P>

Basically '<CODE>On</CODE>' method just flips the switch so that the image
transparency data is visible again.  Any existing transparency data is not
modified, so if the in-memory image still has some old alpha channel data,
that data will suddenly be visible again. </P>

For example here we turn '<CODE>Off</CODE>' the transparency data, then
immediately turn it back '<CODE>On</CODE>, reproducing the original image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -alpha off  -alpha on    alpha_on.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_on.png"
     ><IMG SRC="alpha_on.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However if the image does not have any previous alpha data (yet) it will
initialize it to be fully-opaque.  Which is the logical thing to do.  As such
for new images just read into memory, it is equivalent to <A HREF="#alpha_set"
>Alpha Set</A>, but it should not be used for this purpose.  </P>

The only time <A HREF="../option_link.cgi?alpha" >Alpha On</A> should be used
is when you previously, and <I>purposefully turned off alpha</I> for some
reason, and now wish to restore that data. </P>

For example turning the alpha channel off then on can be used to preserve the
alpha channel data before applying some very specific operators, such as
"<CODE><A HREF="../option_link.cgi?shade" >-shade</A></CODE>". </P>

For an example of this special usage see <A HREF="../transform/#shade_shape"
>Shaded Shape Images</A>. </P>

<!-- <CODE EXECUTE ASSERT>
  [ "`convert xc:none +matte -matte txt:- | md5sum`" = \
      "`convert   xc:black   -matte txt:- | md5sum`" ] || echo >&2 \
  "ASSERTION FAILURE: Alpha Channel not set opaque using '-matte'"
  [ "`convert xc:none -alpha Off  txt:- | md5sum`" = \
      "`convert  xc:black txt:- | md5sum`" ] || echo >&2 \
  "ASSERTION FAILURE: Alpha Channel 'Off' did not turn off alpha"
  [ "`convert xc:none -alpha Off -alpha On txt:- | md5sum`" = \
      "`convert  xc:none txt:- | md5sum`" ] || echo >&2 \
  "ASSERTION FAILURE: Alpha Channel Incorrectly Cleared using '-alpha Off/On'"
</CODE> -->


<A NAME="alpha_opaque"></A>
<H4>Alpha Opaque</H4>

This method not only ensures the alpha channel is 'active' but that it is also
completely opaque, regardless of if the image had transparency 'activated/on'
or 'deactivated/off'.  For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -alpha opaque    alpha_opaque.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_opaque.png"
     ><IMG SRC="alpha_opaque.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

On older versions of IM, this was equivalent to using both "<CODE><A
HREF="../option_link.cgi?matte" >+matte</A></CODE>" to turn off the alpha
channel, then using "<CODE><A HREF="../option_link.cgi?matte"
>-matte</A></CODE>" to turn it on, while resetting it to be opaque.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  +matte -matte  alpha_opaque_matte.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_opaque_matte.png"
     ><IMG SRC="alpha_opaque_matte.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The original 'shape' of the image can no longer be recovered after this
operation as the original alpha channel data has been overwritten. </P>

Of course that is also equivalent to using "<CODE>-alpha off -alpha
set</CODE>", though you may as well use "<CODE>-alpha opaque</CODE>" in that
case. </P>


<A NAME="alpha_transparent"></A>
<H4>Alpha Transparent</H4>

Similarly this ensures the alpha channel is 'active' but also fully
transparent.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -alpha transparent    alpha_transparent.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_transparent.png"
     ><IMG SRC="alpha_transparent.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The color data of the image is still present, so turning off transparency
afterward will again show the images existing colors.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -alpha transparent  -alpha off  alpha_transparent_off.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_transparent_off.png"
     ><IMG SRC="alpha_transparent_off.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course the original 'shape' of the image was actually destroyed, so it can
no longer be recovered after this operation. </P>

Other ways of making an image fully transparent is presented in <A
HREF="../canvas/#transparent" >Transparent Canvas</A>. </P>


<A NAME="alpha_extract"></A>
<H4>Alpha Extract</H4>

The '<CODE>Extract</CODE>' method will simply copy the 'alpha' mask of the
image as a gray-scale channel mask.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -alpha extract    alpha_extract.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/moon.png"
    ><IMG SRC="../images/moon.png"          WIDTH=70 HEIGHT=70
          ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="alpha_extract.png"
     ><IMG SRC="alpha_extract.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that fully-opaque is white, while fully-transparent is pure black.
</P>

As image contained some semi-transparent pixels along the edges (for
anti-aliasing providing the images shape with a smoother look), this image is
not pure black and white, but also contains some gray colored pixels around
the edges. </P>


If your ImageMagick is an old IMv6 version, this is a (near) equivalent
technique, using channel extraction.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert moon.png  -channel a -separate +channel -negate alpha_extract.png
</CODE></PRE></TD></TR></TABLE>
</DIV></P>


The '<CODE><A HREF="#alpha_extract" >Extract</A></CODE>' method will also
turn '<CODE><A HREF="#alpha_extract" >Off</A></CODE>' the alpha, but it is
not cleared, so turning the alpha channel back '<CODE><A HREF="#alpha_extract"
>On</A></CODE>' will re-create a shape mask of the original image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -alpha extract -alpha on   alpha_extract_on.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_extract_on.png"
     ><IMG SRC="alpha_extract_on.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that all the original colors will have been replaced with white with
various shades grays around the edges.  We can see this if we remove the
transparency with a white background, (See <A HREF="#alpha_remove" >Alpha
Remove</A> method below)

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert alpha_extract_on.png -background white -alpha remove alpha_edge.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_edge.png"
     ><IMG SRC="alpha_edge.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

These 'gray' pixels are actually used to good effect in <A
HREF="../transform/#edge_jitter" >Edge Outlines from Anti-Aliased Shapes</A> to
generate a smooth edge or outline from an image shape. </P>

This side-effect of saving the alpha channel, has particular benefits when
Using the <A HREF="../transform/#shade" >Shade Operator</A>, which does not
understand or use the alpha channel of an image. See the sub-section, <A
HREF="../transform/#shade_mask" >Masking Shaded Shapes</A>. </P>


<A NAME="alpha_copy"></A>
<H4>Alpha Copy</H4>

The '<CODE>Copy</CODE>' method is the reverse of '<CODE><A
HREF="#alpha_extract" >Extract</A></CODE>', and essentially performs a <A
HREF="../compose/#copyopacity" >CopyOpacity</A> against itself.  That is it
will turn a gray-scale image (regardless if its alpha channel is enabled or
not) into a shape mask image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert alpha_extract.png  -alpha copy   alpha_copy.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="alpha_extract.png"
     ><IMG SRC="alpha_extract.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="alpha_copy.png"
     ><IMG SRC="alpha_copy.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

It does not matter if the image had an existing alpha channel or not, all it
does is create the images transparency from the image gray-scale values. </P>

Once you have a shape mask, you can use various <A
HREF="../color_mods/#tinting" >Color Tinting</A> or <A
HREF="../compose/#duff-porter" >Duff-Porter</A> alpha composition methods, to
color it.  For examples of using a shape mask see <A HREF="#shapes" >Masks as
Colored Shapes</A>. </P>


<A NAME="alpha_shape"></A>
<H4>Alpha Shape</H4>

To make use of a gray-scale image easier, the '<CODE>Shape</CODE>' method not
only creates a shape mask (as per <A HREF="#alpha_extract" >Alpha Extract</A>,
but will also color it using the current background color.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert alpha_extract.png -background Yellow -alpha shape   alpha_shape.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="alpha_extract.png"
     ><IMG SRC="alpha_extract.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="alpha_shape.png"
     ><IMG SRC="alpha_shape.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This means you can very quickly color a gray-scale mask simply by shaping the
image, then flattening it onto a different background color

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert alpha_extract.png -background Yellow -alpha shape \
                            -background Blue   -alpha remove alpha_colormask.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="alpha_colormask.png"
     ><IMG SRC="alpha_colormask.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Background is not actually the right color to use for this 'shape' coloring
  operation.  It should be using the 'fill' color to set the shapes foreground
  color. As such which color should be used is likely to change.  Background
  is only used due to internal difficulties in accessing the current fill
  color.  This change will likely happen as part of IMv7.
</I></FONT></TD></TR></TABLE></P>

Of course a faster and better way to map a black and white image, directly to
specific colors is by using the more specialised <A
HREF="../color_mods/#level-colors" >Level Adjustment by Color</A>. This will
avoid the need to enable or even modify the existing images transparency
channel.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert alpha_extract.png  +level-colors Blue,Yellow   level_color.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="level_color.png"
     ><IMG SRC="level_color.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The above will map the colors using a linear colorspace, and may need to be
  converted to sRGB at some point to get a more visually correct gradient of
  colors.
</I></FONT></TD></TR></TABLE></P>




<A NAME="alpha_remove"></A>
<H4>Alpha Remove</H4>

The "<CODE><A HREF="../option_link.cgi?alpha" >-alpha</A>
<B>Remove</B></CODE>" method (added to IMv6.7.5) is designed to remove the
transparency from an image, using the current "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>".

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png  -background tan  -alpha remove  alpha_remove.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="alpha_remove.png"
      ><IMG SRC="alpha_remove.png"       WIDTH=70 HEIGHT=70
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that while transparency is 'removed' the alpha channel will remain turned
on, but will now be fully-opaque.  If you no longer need the alpha channel you
can then use <A HREF="#alpha_off" >Alpha Off</A> to disable it. </P>

This operation is simple and fast, and does the job without needing any extra
memory use, or other side effects that may be associated with alternative
transparency removal techniques. It is thus the preferred way of removing image
transparency. </P>

For other techniques, or if your ImageMagick is older that v6.7.5, then look
at the larger discussion <A HREF="#remove" >Removing Transparency from
Images</A>) below. </P>


<A NAME="alpha_background"></A>
<H4>Alpha Background</H4>

As of IM v6.5.2-10, a '<CODE>Background</CODE>' method was made available that
will set the hidden color of fully-transparent pixels to the current
background color.  </P>

Normally this color is of no consequence, as it can only be seen if the alpha
channel is <A HREF="#alpha_off" >turned off</A>.  However the color of
fully-transparent pixels is saved in PNG Image file format, and for large
images, having random unknown fully-transparent colors can significantly
effect its compression handling. </P>

See <A HREF="../formats/#png_compress" >PNG with Better Compression</A> and
the IM Forum Discussion <A HREF="../forum_link.cgi?t=13746" >Eliminating alpha
channel garbage</A> for more details. </P>


Note that no color mixing is applied, only a direct color assignment to any
fully-transparent color. The pixels however will still remain
fully-transparent, and as such you will see not change to the image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%> <TR VALIGN=top><TD
       WIDTH=100% ALIGN=justify>

For example here I use it to set all fully-transparent pixels to
'<CODE>HotPink</CODE>'.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon.png -background HotPink -alpha Background moon_hotpink.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="moon_hotpink.png"
     ><IMG SRC="moon_hotpink.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

As you can see this made no change to the actual look of the image. </P>

To see the change we will now <A HREF="#alpha_off" >turn off</A> the alpha
channel.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert moon_hotpink.png -alpha off moon_hotpink_off.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="moon_hotpink_off.png"
     ><IMG SRC="moon_hotpink_off.png"          WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<DIV ALIGN=center><B>
This is not the same as <A HREF="#alpha_remove" >Removing Transparency</A>
</B></DIV></P>

The edges of the shape will have made all semi-transparent pixels opaque, and
as a result produced some strong aliasing (stair-cased) edge effects. </P>

Note that even the normally opaque only format PNG24, can still save boolean
transparency if all the fully transparent colors are the same.  For details
see the example in <A HREF="../formats/#png_formats" >PNG Sub-Formats</A>. </P>


This process of replacing the colors is actually almost the same as doing
a "<CODE>-channel RGB -fill <I>color</I> -opaque None +channel</CODE>".  See
<A HREF="../color_basics/#replace" >Direct Color Replacement</A>. </P>

Note that many other image processing operators will also convert any
fully-transparent pixels, to fully-transparent black (color
'<CODE>None</CODE>'), as this is the color equivalent of a mathematical zero.
Here is a summary of some image operations that are known to do this, though
none are as direct or as fast as using this operator.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert moon.png \( +clone -alpha off \) \
                        -compose SrcIn   -composite   moon_black.png
  convert moon.png -channel RGBA  -blur 1x.000000001  moon_black.png
  convert moon.png -channel RGBA   -gaussian 1x0      moon_black.png
  convert moon.png -fuzz 0% -transparent none         moon_black.png
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

That last method (see <A HREF="../color_basics/#fuzz_alpha" >Fuzz Factor and
Transparent colors</A> is particularly useful as you cannot only set all
transparent colors to full-transparent-black ('<CODE>None</CODE>'), but also
all near-fully-transparent colors (which otherwise does have a valid but
practically invisible color), simply by specifying a fuzz factor. It will
produce some data loss, but may improve compression in images with lots of
near-fully-transparent colors. Often these nearly total transparent pixels can
have very odd or wrong colors, and this method will allow you to remove such
odd pixels before they cause other problems. </P>

<A NAME="remove"></A>
<H3>Removing Transparency from Images</H3>

While the <A HREF="#alpha_off" >Alpha Off</A> will simply flip a switch and
turn off the transparency channel.  You can also get the same effect if you
attempt to save the image into a file format that does not allow the use of
transparency.  For example by saving to JPEG...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 70x60 xc:none -font Candice -pointsize 50 \
          -fill Black -annotate +10+45 'A' -channel RGBA  -blur 0x5 \
          -fill white -stroke black -draw "text 5,40 'A'"   a.png

  convert  a.png  a.jpg
</CODE></PRE></TD></TR></TABLE>
   <A HREF="a.png"
      ><IMG SRC="a.png"
            ALIGN=middle VSPACE=5 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="a.jpg"
      ><IMG SRC="a.jpg"
            ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Remember the <A HREF="../formats/#jpg" >JPEG File Format</A>, does not save
the alpha (transparency) channel, and as such simply turned it off.  </P>

In this case transparent parts just became black (a typical result). But
depending on the image source the transparent areas could have just as easily
become some other random, or other inappropriate color. </P>

Also in many cases semi-transparent pixels can have some very odd colors that
is typically not visible because they are almost completely transparent.
Simply turning off transparency will make these pixels stand out like a sore
thumb, making the result look even worse than you may have expected. See for
example the top-left edges of 'A' in the above.  </P>

In either case simply turning off transparency is typically NOT what is
wanted. </P>

The <I>best solution</I> is to use the <A HREF="#alpha_remove" >Alpha
Remove</A> method to quickly and simply replace the transparency with
a background color underlay...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert a.png   -background skyblue  -alpha remove -alpha off a_remove.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="a_compose.jpg"
      ><IMG SRC="a_compose.jpg"       WIDTH=70 HEIGHT=60
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Strictly speaking the <A HREF="#alpha_off" >Alpha Off</A> is not needed in
this case, as the save to JPEG does this automatically. </P>

<BR>

Alternative techniques of removing transparency, is to somehow generate a new
'background' or 'canvas' image and <A HREF="../compose/#over" >Over
Compose</A> your image onto that background so that the transparency is
replaced.  Preferably while preserving the original image's meta-data, such as
profiles, labels, captions and comments that may be present.  </P>

Methods for generating such a canvas is exampled in <A HREF="../canvas/#blank"
>Creating Image Canvases of Same Size</A>.  Here is one such method...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert a.png \( +clone -alpha opaque -fill SkyBlue -colorize 100% \) \
          +swap -geometry +0+0 -compose Over -composite  \
          -alpha off  a_compose.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="a_compose.jpg"
      ><IMG SRC="a_compose.jpg"       WIDTH=70 HEIGHT=60
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Other simpler ways to do this, is to use an operation that internally creates
a '<I>cloned background canvas</I>' for you, generating it as part of the
larger image processing operation that the operator is performing. </P>

The most common method is to <A HREF="../layers/#flatten" >Flatten</A> the
image.  This operator is so often used for this purpose that the process of
removing transparency has often erroneously been called 'flattening'.  For
example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert a.png   -background skyblue -flatten  -alpha off  a_flatten.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="a_flatten.jpg"
      ><IMG SRC="a_flatten.jpg"       WIDTH=70 HEIGHT=60
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However this will not work with "<CODE><A HREF="../basics/#mogrify"
>mogrify</A></CODE>"  or with a sequence of multiple images, basically because
the "<CODE><A HREF="../option_link.cgi?flatten">-flatten</A></CODE>" operator
is really designed to merge multiple images into a single image. </P>

The other common method that does work with multiple images is to give the
image a zero sized <A HREF="../crop/#border" >Border</A> with the appropriate
"<CODE><A HREF="../option_link.cgi?bordercolor">-bordercolor</A></CODE>". For
example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert a.png   -bordercolor skyblue -border 0  -alpha off  a_border.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="a_border.jpg"
      ><IMG SRC="a_border.jpg"       WIDTH=70 HEIGHT=60
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Other image processing operators which are closely related to the above
methods, can also remove transparency from an image. These include: <A
HREF="../layers/#mosaic" >Mosaic</A>, <A HREF="../layers/#merge" >Merge</A>,
and <A HREF="../crop/#frame" >Frame</A>. </P>

The <A HREF="../crop/#extent" >Extent</A> operator can also be used, and
allows you to expand or crop images at the same time as you remove the
transparency, but only if you know the size of final image you desire. </P>

You do not have to replace transparency with a solid color.  If you use a DIY
composition (as shown above) you can use any image for the replacement
background.  One simple example of this is to use the "<CODE><A
HREF="../basics/#composite" >composite</A></CODE>" command  to <A
HREF="../compose/#tile" >Tile</A> an image 'under' the original, (using <A
HREF="../compose/#dstover" >Dst_Over</A>).  This compose method ensures the
original images meta-data and size is preserved.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -compose Dst_Over -tile pattern:checkerboard \
                                               a.png  a_undertile.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="a_undertile.jpg"
      ><IMG SRC="a_undertile.jpg"       WIDTH=70 HEIGHT=60
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Many of the above methods, are either effected by, or may destroy any
  virtual canvas information an image may have, as part of its processing.
  When the virtual canvas is involved, you may need to look at the details of
  individual operators more closely. In many cases the virtual canvas effects
  can be useful to your overall image processing.  </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="boolean_transparency"></A>
<H3>Boolean Alpha Transparency</H3>

For some image file formats you don't need to completely remove the alpha
channel, but only allow pure on/off or boolean transparency.  Index (Palette)
image file formats such as <A HREF="../formats/#gif" >GIF</A> and <A
HREF="../formats/#png_formats" >PNG8</A>, are typical of this. </P>

Examples are currently looked at in <A HREF="../formats/#boolean_trans" >GIF
Boolean Transparency</A>, but should eventually move here. </P>


<A NAME="outline"></A>
<H3>Outline or Halo Transparency</H3>

Sometimes you will like to add an outline around an image containing
transparency. </P>

One way is to use <A HREF="../morphology/#edgeout" >EdgeOut Morphology</A>
to quickly get all the neighbouring pixels to the original image, color them,
and then <A HREF="../compose/#dstover" >Under (DstOver) Compose</A> it with
the original image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  knight.png \( +clone \
             -channel A -morphology EdgeOut Diamond +channel \
             +level-colors red \
           \) -compose DstOver -composite    knight_outlined.png
</CODE></PRE></TD></TR></TABLE>
   <A HREF="../images/knight.png"
      ><IMG SRC="../images/knight.png"
            ALIGN=middle VSPACE=5 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="knight_outlined.png"
      ><IMG SRC="knight_outlined.png"
            ALIGN=middle VSPACE=5 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This can be particularly useful when creating GIF format images from PNG images
containing semi-transparent edge pixels. It provides a minimal amount of
background color, but leave the rest of the image fully-transparent.  See <A
HREF="../formats/#bg_pattern" >GIFs on a Background Pattern</A> for more about
this problem. </P>

An alternative method is to generate a soft semi-transparent halo around the
shape.  To do this we <A HREF="../blur/#blur" >Blur</A> and recolor the image,
then again <A HREF="../compose/#dstover" >Under (DstOver) Compose</A> it with
the original.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    convert knight.png \(  +clone \
              -channel A  -blur 0x2.5 -level 0,50% +channel \
              +level-colors red \
            \) -compose DstOver  -composite    knight_halo.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="knight_halo.png"
      ><IMG SRC="knight_halo.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This last is actually similar to using a <A HREF="../fonts/#soft_outline"
>Soft Outline Compound Font</A> effect, but using a shaped image rather than
annotated text. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="masks"></A>
<H2>Using Masks with Images</H2>

<H3>Masking An Image </H3>

As shown previously there are a couple of ways to mask an image, so as to make
part of the image transparent. And which method you choose depends on the
whether your image mask is a grayscale mask, or a shaped mask. </P>

<A NAME="editing"></A>
<H3>Editing an Image Mask</H3>

The mask of an image is a really useful thing to have. </P>

We can for example erase parts of an image very easily by
modify a mask of the original image.  Remember the "<CODE><A
HREF="../option_link.cgi?draw" >-draw</A></CODE>" operator cannot draw
nothing, and currently has no erase option. </P>

Here we create an image, then by extracting and modifying its mask, before
restoring it to the original image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:none   -stroke black  -fill steelblue \
          -strokewidth 1   -draw "circle 60,60 35,35" \
          -strokewidth 2   -draw "line 10,55 85,10"      drawn.png

  convert drawn.png -alpha extract  mask.png

  convert mask.png -fill black -draw "circle 40,80 60,60" mask_bite.png

  convert drawn.png mask_bite.png \
          -alpha Off -compose CopyOpacity -composite \
          drawn_bite.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="drawn.png"
     ><IMG SRC="drawn.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="mask.png"
     ><IMG SRC="mask.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="mask_bite.png"
     ><IMG SRC="mask_bite.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="drawn_bite.png"
     ><IMG SRC="drawn_bite.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Remember "black" in a mask is transparent, while white is opaque, so all we
need to do is draw black over anything we don't want visible. </P>

Don't forget the "<CODE>-alpha Off</CODE>" operation in the above as it is
vital to ensure the grayscale image does not contain unneeded transparent
channel. </P>

And Presto we took a bite out of the original image. </P>

We can also re-add a part of the image we removed.  For example here I re-add
part of the 'bite' I removed from the original image, by drawing white area
onto the mask.  The mask is then again returned to the original image using <A
HREF="../compose/#CopyOpacity" >CopyOpacity Channel Composition</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mask_bite.png -fill white \
          -draw "circle 50,70 60,60" \
          -draw "roundRectangle  78,5 98,25 5,5" \
          -alpha off  mask_bite2.png
  composite -compose CopyOpacity mask_bite2.png drawn.png drawn_bite2.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="mask_bite.png"
     ><IMG SRC="mask_bite.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="mask_bite2.png"
     ><IMG SRC="mask_bite2.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="drawn_bite2.png"
     ><IMG SRC="drawn_bite2.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Just a word of warning about re-adding parts.  Typically ImageMagick replaces
any fully-transparent color with black, usually because that is how the
mathematics behind operators work.  It is after all fully-transparent and thus
its color should not normally matter.  That means that if we make a part of
the image we haven't drawn before opaque, then it will generally be black,
since that is the color under the image's transparency. </P>

However in the above example you will have noticed that the PNG image file
format correctly preserved the original (made transparent) color of the image.
As such the color of the re-added part remained the original
'<CODE>SteelBlue</CODE>' color of the original image.  You should not count on
this if the image was saved to some other file format or further modified.
</P>

<BR>

Here is an alternative method of erasing parts out of an image
but rather than extracting and modifying a Grayscale Mask, we instead
use a Shape mask as a sort of 'erase' tool using <A HREf="../compose/#dstout"
>DstOut Composition Method</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:none -draw "circle 40,80 60,60" mask_shape.png

  convert drawn.png mask_shape.png -compose DstOut -composite drawn_bite3.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="drawn.png"
     ><IMG SRC="drawn.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/minus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="-">
  <A HREF="mask_shape.png"
     ><IMG SRC="mask_shape.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="drawn_bite3.png"
     ><IMG SRC="drawn_bite3.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see sometimes Shape Masks are easier to handle, as you avoid the
need to extract and restore the alpha channel. </P>

However the <A HREF="../compose/#duff-porter" >Duff-Porter Alpha Composition
Methods</A>, which is what I am using, will never allow you to restore colors
that have been made transparent.  With these methods, anything that has been
made transparent (and thus undefined in color), stays transparent. </P>

In actual fact erasing parts of an image using <A
HREF="../compose/#duff-porter" >Alpha Composition Methods</A> will actually
destroy the underlying color of fully-transparent pixels.  It will not
preserve it.  After all, a transparent color is actually not a real color! </P>


<A NAME="shapes"></A>
<H3>Masks as Colored Shapes</H3>

An alternative to just using the mask to add or re-add transparency to an
image is to actually combine the mask directly with images in various ways.
</P>

For example suppose we just want to use a mask as a symbol or shape
we want to overlay onto an image in various colors.  For this we need
a mask, which I'll extract from a special 'symbol' font.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -font WebDings -pointsize 24 label:Y \
          +trim +repage  -negate   heart_mask.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="heart_mask.gif"
     ><IMG SRC="heart_mask.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that I negated the label image to make it proper mask image, consisting
of a white foreground (opaque) on black background (transparent). </P>

As of IM v6.4.3-7 the simplest way to convert a grayscale mask, into a colored
shape is to use the <A HREF="#alpha_shape" >Alpha Shape</A> operator, This is
exactly like <A HREF="#alpha_copy" >Alpha Copy</A>, but with an extra step to
color the final shape.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert heart_mask.gif  -background Red -alpha Shape  heart_red.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="heart_red.png"
      ><IMG SRC="heart_red.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note the use of 'PNG' image format for generated shaped image rather than
  GIF so as to avoid problems with <A HREF="../formats/#trans" >GIF Boolean
  Transparency</A>.
</I></FONT></TD></TR></TABLE></P>

Before this the simplest solution was to negate the alpha mask into a matte <A
HREF="../color_basics/#channels" >Channel Image</A> then use <A
HREF="../color_basics/#combine" >Combine</A> to generate the shaped image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert heart_mask.gif -negate  \
          -background Gold  -channel A  -combine   heart_gold.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="heart_gold.png"
      ><IMG SRC="heart_gold.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The color of the shaped mask in this case is defined by the "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>" color which <A
HREF="../color_basics/#combine" >Combine</A> used to fill in the undefined
channels of the new image. </P>

An older but more complicated way is to use '<CODE><A
HREF="../compose/#copyopacity" >CopyOpacity</A></CODE>' composition method to
set an image's transparency to the given mask, then use <A
HREF="../color_mods/#colorize" >Uniformly Color Tinting</A> to color the
resulting shape.  This works and for a long time was the best technique to
use, but is no longer recommended.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert heart_mask.gif \( +clone \) -alpha off \
          -compose CopyOpacity  -composite \
          -fill HotPink  -colorize 100%    heart_hotpink.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="heart_hotpink.png"
      ><IMG SRC="heart_hotpink.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now that you have a 'shaped' image, you can just simply overlay the image on
any background we want, such as the built-in rose image, using one of the many
<A HREF="../layers/" >Image Layering Techniques</A> and <A HREF="../compose/"
>Alpha Composition Methods</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -page +2+2  heart_gold.png \
                 \( +clone -repage +7+29 \)  \
                 \( +clone -repage +52+14 \)  \
          -flatten       rose_with_love.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_with_love.gif"
     ><IMG SRC="rose_with_love.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is fine if we want all our symbols the same color, but would require
multiple intermediate images if we want to use multiple colors, making it
impractical for overlaying lots of symbols with lots of different colors. </P>

One way you can make multi-colored overlays is to re-color the shaped image
immediately after reading in the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: \(  heart_gold.png           -repage +2+2   \) \
          \( +clone -fill Red     -colorize 100% -repage +7+29 \) \
          \( +clone -fill HotPink -colorize 100% -repage +52+14 \) \
          -flatten      rose_colored_love.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_colored_love.gif"
     ><IMG SRC="rose_colored_love.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note we only read in one shaped image, then recolored a <A
HREF="../basics/#clone" >Clone</A> of that image for each new 'layer' to be
overlaid.  For more examples of re-coloring a base image, see the whole
section on <A HREF="../color_mods/" >Color Modifications</A>. </P>

See also <A HREF="../draw/#symbols" >Drawing Symbols</A> for an alternative
method of marking specific locations in an image. As well as a <A
HREF="../layers/#layer_pins" >Pinning Maps Laying Example</A> for a more
automated layering techniques. </P>


<A NAME="compose"></A>
<H3>Mathematical Composition</H3>

Rather than overlaying the mask onto some background, you may only be
interested in coloring the image with just the white or black parts of the
mask itself.  This is relatively straight forward, simply by using some <A
HREF="../compose/#math" >Mathematical Alpha Composition Methods</A> to change
the color of the mask to match a color, tile or other image. </P>

For example the '<CODE><A HREF="../compose/#multiply" >Multiply</A></CODE>'
compose method will replace the white areas (multiply value of 1) with the
overlay image, while leaving the black areas (multiply value of 0), black. </P>

The '<CODE><A HREF="../compose/#screen" >Screen</A></CODE>' operator is
exactly the same as '<CODE><A HREF="../compose/#multiply"
>Multiply</A></CODE>' but with the images negated so it effectively replaces
the black areas of the image. </P>

For example, let's use the larger mask image from above, to overlay a larger
image generated with a tile pattern.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mask_bite.png -size 100x100   tile:tile_disks.jpg \
                        -compose Multiply  -composite   compose_multiply.png
  convert mask_bite.png -size 100x100   tile:tile_water.jpg  \
                        -compose Screen    -composite   compose_screen.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="mask_bite.png"
     ><IMG SRC="mask_bite.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="compose_multiply.png"
     ><IMG SRC="compose_multiply.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="compose_screen.png"
     ><IMG SRC="compose_screen.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The '<CODE><A HREF="../compose/#multiply" >Multiply</A></CODE>' alpha
composition method is especially useful for replacing the background of text
images (IE: black text on white background), such as images generated from <A
HREF="../text/#postscript" >Postscript Documents</A>. </P>

<A NAME="masked_compose"></A>
<H3>Masked Alpha Composition</H3>

The special three image form of <A HREF="../compose/#mask" >Masked Alpha
Composition</A> allows you use the same mask to directly merge two images
together.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100   tile:tile_water.jpg  tile:tile_disks.jpg \
           mask_bite.png    -composite   compose_masked.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="compose_masked.png"
     ><IMG SRC="compose_masked.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The first image will replace the black background parts of the mask, while the
second image replaces the white foreground parts of the mask.  The mask itself
is given as the third image.  </P>

The mask is used to select and mix two different images together to generate
the final result.  It is actually rather like a mapped <A
HREF="../compose/#blend" >Blend</A> of the two images. </P>

Remember the final size and meta-data of the resulting image will come from
the first 'background' image of the above operation (black parts), so swap
images and <A HREF="../color_mods/#negate" >Negate</A> the mask if you want it
the other way around.  </P>

And finally remember that if you use the "<CODE><A HREF="../basics/#composite"
>composite</A></CODE>" command instead of "<CODE><A HREF="../basics/#convert"
>convert</A></CODE>", the 'overlay' image (white parts) is given first with
the 'background' image (black parts) second. In other words the first two
images need to be swapped for that command. </P>

<A NAME="aligning"></A>
<H3>Aligning Two Masked Images</H3>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50>
</B></FONT></DIV></P>
<PRE>
On aligning two masked images...

If your masks are pure boolean, you should have no problems however you
apply them.  However masks containing 'anti-aliased', 'gray', or
'semi-transparent' edging to make them 'smooth looking' can be serious
headache if you do not handle them properly and with care.

The rest of this discussion is on 'anti-aliased' masks.

Anti-Aliased Masks which join together come in two styles...

 * Ones which fit together like jigsaw puzzle pieces OR
   like a shaped peg into a shaped hole (shared boundary)

 * Masks that are ment to overlay a solid area (layered)

The latter is easy to handle and is the normal effect you get when you overlay
some colored shape over a fully-opaque image.  Essentially you would use
'over' composition to compose the shape.

The former 'jigsaw' masks however is harder.  Such masks are not meant to
either overlap, or underlap each other.  And yet if you try to join them
using the obvious and normal 'over' composition you will end up with a
semi-transparent join where 'anti-aliased edges' are merged.

<I>Example of a bad 'jigsaw mask' join (over)</I>

The correct way to join masks and shaped 'jigsaw' images is to use
<B>Plus</B> composition to 'add' the images together, with either a
black or fully-transparent background.

<I>Example of a correct 'jigsaw mask' join (plus)</I>


For another example of DIY image joining, using 'Dst-In', 'Dst-Out', and
'Plus' composition, see examples in...
  https://legacy.imagemagick.org/Usage/compose/#dstin

I also go though this joining detail in the bug report of 3 image alpha
composition <A HREF="../bugs/composite_mask/#correct" >Composite Mask Bug
- Fixed</A>.

For more on the difference between 'over' and 'plus' see <A
HREF="../compose/#blend_dissolve" >'Blend' (plus) vs 'Dissolve' (over)</A>

Examples of correctly joining edge aligned pieces is shown in
<A HREF="../distorts/#cube3d" >3d Cubes - Affine</A> and again in <A 
HREF="../distorts/#box3d" >3d Boxes - Perspective</A>
and in Isometric Cube using Shears
  https://legacy.imagemagick.org/Usage/warping/#sheared_cube

The Major problems in these examples is that the individual parts were NOT
generated using the same mask, but distorted to their final positions.
As such they do not quite fit together properly and joined together.

These examples need to be updated to use a 'Plus' composition method.  To
generate improved results, but even then they will still probably not be quite
'right' as the masks do not exactly 'fit' together.


<H4>Generating Correct Edge Aligned Masks</H4>

The best idea is to use the same mask (negated) for BOTH pieces, rather than
attempting to draw the two masks separately. Otherwise you have the two masks
overlap, OR leave a gap, exactly as you have seen.

Correct methods of mask joining..

    * use mask to set transparency on one piece
      use negated mask to set transparency of other piece
      'Plus' the two pieces together.

    * Use mask to Add transparency to just one piece, then
      'Over' compose that piece over a complete image.

    * use a three image masked composition
      see https://legacy.imagemagick.org/Usage/compose/#mask
      and https://legacy.imagemagick.org/Usage/masking/#masked_compose
      Which uses the mask to select results from two different images.

Remember, 'Over' only needs the 'source' or 'overlay' image masked, the
background image should not have aligned semi-transparent edges.
But a 'plus' composition needs both images masked with and exact negative
mask of each other align the joined edge.

WARNING:  Draw does NOT currently allow you to generate two shapes that will
fit together properly without overlap!!!!

See <A HREF="../draw/#bounds" >Draw Fill Bounds</A> for details.

I have not checked SVG to see if it has the same problem.

</PRE>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="special_masks"></A>
<H2>Special Image Masks</H2>

<A NAME="write_mask"></A>
<H3>Write Masks - Protecting Pixels from Change</H3>

A 'write' or 'clip-mask' is a special greyscale image that is added to an
existing image of the size size.  It defines areas of the image which are
to be classed a 'immutable' or 'not-writable' by most image processing
operators. </P>

The operator "<CODE><A HREF="../option_link.cgi?mask" >-mask</A></CODE>" takes
an external image to be linked to the images in memory.  The 'plus' form of
the operator "<CODE><A HREF="../option_link.cgi?mask" >+mask</A></CODE>"
removes the mask from the image. </P>

For example here I use a 'write mask' to protect the background pixels
from being written to, while rotating the hues, to re-color a the foreground
red rose to a blue rose.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert rose: -mask rose_bg_mask.png \
          -modulate 110,100,33.3  +mask rose_blue.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="../images/rose_bg_mask.png"
     ><IMG SRC="../images/rose_bg_mask.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_blue.png"
     ><IMG SRC="rose_blue.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The mask is bit rough, but it worked well.  Just remember that a 'write mask'
is used to specify the part to be protected or preserve. Remember, in IMv6...
</P>

<DIV ALIGN=center><B> The "<CODE><A HREF="../option_link.cgi?mask"
>-mask</A></CODE>" operator defines a 'write-protect' mask</DIV></B></P>

For more advanced example see <A HREF="../photos/#chroma_key" >Chroma Key
Masking</A>, which is more about generating the mask, rather that applying it
as a write mask. </P>

Write or clip masks are designed to work when the pixels in an image are being
directly modified.  EG: negate, level, color tinting, modulate, drawing,
composite, morphology, convolutions. </P>

For operators that generate NEW images (resize, distorts, extent, etc) it will
fail to preserve original pixels, as the mask will not be able to correspond
to the new image size. Such operations will also have the side-effect of
removing or unsetting the images 'write-mask'. </P>

Here is another example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert -size 70x70 xc:red  red_image.png
  convert -size 70x70 xc: -draw 'circle 35,35 30,5'  write_mask.png

  convert red_image.png  -mask write_mask.png \
          -fill blue -opaque red   +mask    masked_color_replace.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="red_image.png"
     ><IMG SRC="red_image.png"  WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="write_mask.png"
     ><IMG SRC="write_mask.png"    WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="masked_color_replace.png"
     ><IMG SRC="masked_color_replace.png"      WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the edges of both the mask and the resulting image is smooth
(anti-aliased) that is because the mask is not simply a boolean mask but
a blending mask. </P>

The 'write-mask' is a blending mask in that 'grey' pixels in the mask will
produce a blending of the new pixels with the old image values, by the amount
of gray that is present.  This produces very smooth edges, and also allows you
to generate a gradient across the image between modified and un-modified
areas. </P>

However a blending mask while suitable for a single operation, may not be good
when used for multiple operations as its blending effect will then be applied
multiple times.  This problem is especially prevalent in a looped operation
such as morphology.  But only if you use a non-boolean blending mask. </P>

If this is a problem, it will probably be better to simply do all the
operations against a copy of the image, then use <A HREF="#masked_compose"
>Masked Alpha Composition</A> against the original image.
</P>

Caution is advised.
<BR>

This use of masking is actually exactly how <A HREF="../compose/#mask"
>Composition Masking</A> actually works! But only for the duration of the
composition operator being applied.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert -size 70x70 xc:green  green_image.png

  convert red_image.png  green_image.png  write_mask.png \
          -composite    masked_composite.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="red_image.png"
     ><IMG SRC="red_image.png"  WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="green_image.png"
     ><IMG SRC="green_image.png"  WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="write_mask.png"
     ><IMG SRC="write_mask.png"    WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="masked_composite.png"
     ><IMG SRC="masked_composite.png"      WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Is equivalent (with a negated mask) to...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert write_mask.png  -negate -write MPR:mask +delete \
          red_image.png -mask MPR:mask \
          green_image.png  -composite  +mask  masked_composite_equiv.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="masked_composite_equiv.png"
     ><IMG SRC="masked_composite_equiv.png"  WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

That is the mask is negated, then applied to the first 'destination' image.
the second is then composed over the first image, modifying only the 'white'
areas of the original mask image. </P>

<DIV ALIGN=center><B> A three image "<CODE><A
HREF="../option_link.cgi?composite" >-composite</A></CODE>" operation uses
a 'write' mask</DIV></B></P>

<BR>

In morphology write masks are typically used to generate a <A
HREF="../morphology/#conditional" >Conditional or Constrained Morphology</A>
form of an operation.  One such example was discussed in the IM Discussion
forum, <A HREF="../forum_link.cgi?f=1&t=18707" >Cleaning up noise around
text</A>, to limit the effects of a dilation. </P>

<I>NOTE: -crop should be able to preserve the image mask of individual
images, by also cropping the mask and assigning to the new images. This
however is currently not done. </I></P>


<A NAME="clip_mask"></A>
<H3>Clip Mask and Clip Paths</H3>

The "<CODE><A HREF="../option_link.cgi?clip-mask" >-clip-mask</A></CODE>" form
of this operator, is almost exactly the same as the above but only provides
a boolean (all-or-nothing) style of masking. As a result you cannot achieve
a 'blended' or smoothed result. </P>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert red_image.png  -clip-mask write_mask.png \
          -fill blue -opaque red   +clip-mask    clipped_modulate.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="clipped_modulate.png"
     ><IMG SRC="clipped_modulate.png"  WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the result is highly aliased (with stair-cased edges), as
a "<CODE><A HREF="../option_link.cgi?clip-mask" >-clip-mask</A></CODE>" does
not produce a blended result as "<CODE><A HREF="../option_link.cgi?mask"
>-mask</A></CODE>" does. </P>

The only good thing about this is that it is slightly faster (though not very
much). It was provided originally to allow the handling of <A
HREF="#clip-path" >Clip Paths in TIFF image files</A>, and is a very old
operator (IMv5). The newer "<CODE><A HREF="../option_link.cgi?mask"
>-mask</A></CODE>" operator should be used instead. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  In IMv6, a 'write-mask' and 'clip-mask' are implemented side-by-side, even
  though they technically do exactly the same function.  As such you could
  apply both masks simultaneously. </P>

  However using both at the same time is not recommended, and results are not
  defined. Also this 'boolean mask' form has been removed from IMv7. </P>

</I></FONT></TD></TR></TABLE></P>

<A NAME="clip"></A>
<A NAME="clip-path"></A>
<H3>Clip Paths for TIFF images</H3>

A 'clip path' is part of TIFF image file format, and defines a vector path
that is used define a 'shaped area' within the TIFF image. </P>

In IM the operators "<CODE><A HREF="../option_link.cgi?clip"
>-clip</A></CODE>" and "<CODE><A HREF="../option_link.cgi?clip-path"
>-clip-path</A></CODE>", reads this 'clip-path' and converts it into a <A
HREF="#clip_mask" >Clip mask</A> (above). As such it defines a 'write mask'
that will protect the shape from modification. </P>

A clip-path stored in the TIFF image is defined as a <A HREF="../draw/#paths"
>SVG Path Drawing</A>, which you can extract from a TIFF image file format
using...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  identify -format '%[8BIM:1999,2998:#1]' image_clip.tiff
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

<BR>

The biggest problem people often have is making everything that is not clipped
transparent. Which requires you to write the areas the mask write protects!
</P>

This is one solution, which converts the whole image to transparency, then
turn on the 'clip path' then make the now writable parts opaque (visible)
again.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert input.tiff -alpha transparent -clip -alpha opaque -strip out.tiff
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The "<CODE><A HREF="../option_link.cgi?clip" >+clip</A></CODE>" operator also
turns off and remove the clip mask (just as "<CODE><A
HREF="../option_link.cgi?clip_mask" >+clip_mask</A></CODE>" does).  However no
file format saves the current clip mask with the image for any image file
format. (At least in IMv6) </P>

<BR>

<A NAME="read_mask"></A>
<H3>Read Masks - Ignore Pixel Input</H3>

It is important to note that a write mask will limit what pixels will be
written to an image.  It does not however limit what pixels are being 'read'
as part of the operation being performed, to create the new pixel data being
written. </P>

This basically means that if you use a 'area effect' or 'neighbourhood' type
of operator, such as <A HREF="../blur/" >Blurs</A>, <A HREF="../morphology/"
>Morphology</A>, or <A HREF="../convolution/" >Convolution</A>, then 'writable
pixels' close to the edge may include color values from the masked, or
un-writable area. </P>

For instance, here we write protect the foreground rose, before blurring the
image.  That is we want to only blur the background part of the image, rather
heavily in this case.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert rose: -mask rose_fg_mask.png \
            -blur 0x8   +mask  rose_bg_blur_fail.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="../images/rose_fg_mask.png"
     ><IMG SRC="../images/rose_fg_mask.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_bg_blur_fail.png"
     ><IMG SRC="rose_bg_blur_fail.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><FONT SIZE=-1>
  The result is using a <B>Write-Protect Mask</B> and is not what was wanted.
  </FONT>
</DIV></P>

As you can see even though the foreground colors were protected by the mask,
the colors were still used as part of blurring the background around the rose.
Because of this the blurred background close to the foreground has a distinct
reddish tint or halo.  Put in another way the foreground colors 'leaked' into
the surrounding background.   This is generally not what people intend doing
when they want to blur the background of an image, such as part of a lens
focus effect. </P>

What people really want is to get blur to completely 'ignore' the foreground
pixels, and only allow the colors of the background to part of the blurring
process.  That is they wanted to prevent blur from 'reading' the foreground
pixels. </P>

<H4>Read Mask Solution for IMv6</H4>

In IMv6 the only way to make a pixel color pixel unreadable, is to make the
pixel transparent.  Transparent pixels have no color by definition, and as
such the 'hidden color' is not part of the calculations made by the blur
operation.  </P>

This gives us a 'cheat'.  Make foreground pixels transparent, apply the blur
(or other) operation, and turn off transparency (it isn't really wanted in
this case).  Then we can restore the foreground part of the image. </P>

If that sounds complex, it is.  Here are the steps involved, while showing
intermediate images to try and make the technique clear...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert rose: rose_bg_mask.png -alpha off \
          -compose CopyOpacity -composite   +compose  rose_bg_only.png
  convert rose_bg_only.png  -channel RGBA -blur 0x8   rose_bg_blurred.png
  convert rose_bg_blurred.png      -alpha off         rose_bg_blur_opaque.png
  convert rose_bg_blur_opaque.png \
                rose:  rose_fg_mask.png -composite    rose_bg_blur_good.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="../images/rose_bg_mask.png"
     ><IMG SRC="../images/rose_bg_mask.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_bg_only.png"
     ><IMG SRC="rose_bg_only.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_bg_blurred.png"
     ><IMG SRC="rose_bg_blurred.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="rose_bg_blurred.png"
     ><IMG SRC="rose_bg_blurred.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_bg_blur_opaque.png"
     ><IMG SRC="rose_bg_blur_opaque.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="../images/rose.png"
     ><IMG SRC="../images/rose.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="../images/rose_fg_mask.png"
     ><IMG SRC="../images/rose_fg_mask.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_bg_blur_good.png"
     ><IMG SRC="rose_bg_blur_good.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The result is the removal of the red halo effect that was previously being
'leaked' into the blurred background.  Here is a side-by-side comparison of
the write masked and read masked versions of the background blur, so you can
clearly see how we removed the 'leakage' of the foreground color into the
background. </P>

<TABLE ALIGN=center><TR>
<TD ALIGN=center>
  <A HREF="rose_bg_blur_fail.png"
     ><IMG SRC="rose_bg_blur_fail.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-2>Write</FONT></TD>
<TD ALIGN=center>
  <A HREF="rose_bg_blur_good.png"
     ><IMG SRC="rose_bg_blur_good.png"  WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-2>Read</FONT></TD>
</TR><TR>
<TD COLSPAN=2 ALIGN=center>
  <FONT SIZE=-1>
  Masking Method Differences
  </FONT></TD>
</TR></TABLE></P>

The above example assumes that original image has no alpha.  If an image also
contains an alpha channel, then you need to separate and process alpha
separately, creating double the effort. One example of this is shown in
a 'distort resize' discussion, which wanted to ignore the virtual pixels
that surround the image being resize using distort.  See <A
HREF="../forum_link.cgi?p=68362" >Correct Resize (using distorts)</A> for
detail. </P>

Note that the above is also very closely related to a blurred <A
HREF="#hole_filling" >Hole Filling</A> technique.  The only difference is that
it is the background that is being preserved from modification, not the
foreground. Which makes it a little simpler. </P>

True 'read masks' should be available IMv7 to make the above simply adding
both a 'read mask' and optionally a 'write mask'. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="regions"></A>
<H2>Regions and Region Sub-Images</H2>

Regions are another way of limiting the effects of operations to a smaller
area of an image. </P>

For example here I color tint the whole rectangular region red...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -region 40x33+15+5 -fill red -colorize 50% \
          koala_region_red.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_region_red.gif"
     ><IMG SRC="koala_region_red.gif"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can also make a region transparent...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -alpha set \
          -region 40x33+15+5 -alpha transparent   koala_region_trans.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_region_trans.gif"
     ><IMG SRC="koala_region_trans.gif"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that I needed to ensure the original image has an alpha channel enabled
before making the 'region image' transparent.  If that was not done, IM would
make any transparency in the 'region image', see-thru, and you would see no
change. See <A HREF="#region_internals" >How Regions Work</A> below for
details. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.6.9-5 transparency preservation was broken, and the results
  of transparency in a region was always "see-thru to original". As such the
  result of the above would not include any transparent pixels, even though the
  image allowed the use of transparency.
</I></FONT></TD></TR></TABLE></P>

The biggest reasons for using <A HREF="#region" >Regions</A> is that it
doesn't just simply limit its effect to a small area, it actually extracts
that rectangular area of the image, and applies all the <A
HREF="../basics/#option_simple" >Simple Operations</A> that follow to that
smaller area. </P>

This means that if your are only modifying one very small area of a very large
image, say for example doing red-eye removal, then you not only limit the
scope of the operations to that area, but perform it <I>much faster</I> too,
and the extracted region image is itself smaller.  </P>

In summary... A <A HREF="#write_mask" >Write Mask</A> will perform operations
over the whole image, but limit what pixels are actually changed, But <A
HREF="#regions" >Regions</A> use a smaller extracted sub-image.  </P>

Note that there is nothing preventing you from using both of these methods
together.  Though if you apply a clipping mask to a region, the clipping mask
should match the size of the region image that was extracted. </P>

<A NAME="region_warping"></A>
<H3>Warping a Local Region</H3>

As a 'image region' actually extracts a 'small sub-image' of the original for
processing, you can make use of the special 'localised' <A
HREF="../warping/#circular" >Circular Distortions</A> to warp small regions of
the original image. </P>

For example here we have a line of stripes.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 600x70 xc:darkred \
          -fill white -draw 'roundrectangle 5,5  595,65 5,5' \
          -fill black -draw 'rectangle 5,25 595,31' \
          -fill red -draw 'rectangle 5,39 595,45' \
          lines.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lines.gif"
     ><IMG SRC="lines.gif"          WIDTH=600 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Now by defining regions we can distort the line in different ways in different
areas.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lines.gif \
          -region 90x70+10+0    -swirl  400  \
          -region 90x70+100+0   -swirl  400 \
          -region 90x70+190+0   -swirl -400 \
          -region 120x70+280+0  -implode 1.5 \
          -region 100x70+380+0  -implode -7  \
          -region 101x70+480+0  -wave 10x50 -crop 0x70+0+10\! \
          +region lines_regions.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lines_regions.gif"
     ><IMG SRC="lines_regions.gif"          WIDTH=600 HEIGHT=70
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the "<A HREF="../option_link.cgi?implode"
><CODE>-implode</CODE></A>" and "<A HREF="../option_link.cgi?swirl"
><CODE>-swirl</CODE></A>", fit into the use of regions very well, as they have
the property that the outside edge of the distorted image matches up to the
rest of the image outside the defined region.  That is they are actually
designed to perform '<I>localized image warping</I>'. </P>

Note that when I used the <A HREF="#wave" >Wave Distortion</A>, I had to crop
the size of the resulting 'wave' image so that it would again fit into the
original area from which it was extracted. </P>

Remember <A HREF="#region" >Regions</A> only work when used with <A
HREF="../basics/#option_simple" >Simple Image Processing Operators</A>.  Any
other operator including another "<A HREF="../option_link.cgi?region"
><CODE>-region</CODE></A>" operator will cancel the region processing, before
that operation is applied. </P>


<A NAME="region_internals"></A>
<H3>How Regions Work, and its Problems</H3>

In reality the way regions work is... <UL>

<LI>Extract from the image a smaller image according to the "<A
    HREF="../option_link.cgi?region" ><CODE>-region</CODE></A>" operator,
    using a simple crop with the region argument.
<LI>Apply any <A HREF="../basics/#option_simple"
    >Simple Image Processing Operators</A>, that follow, to the smaller image.
<LI>When a non-Simple Image Operator is seen, OR another "<A
    HREF="../option_link.cgi?region" ><CODE>-region</CODE></A>" operator is
    found, OR the region is turned off using "<A
    HREF="../option_link.cgi?region" ><CODE>+region</CODE></A>", then the
    extracted region is overlaid on the original image at its extracted
    location.
</UL></P>


Region works in a way that is similar to using <A
HREF="../basics/#option_sequence" >Image Stack Operators</A>, though it
existed in ImageMagick a long time before those operators.  It was for example
an integral part of IM version 5. </P>

For example, if you have this <A HREF="#region" >Region Operation</A>...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  ... -region WxH+X+Y  ...simple-operators... +region ...
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

the result is equivalent to this (for a single image)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  ... \( +clone -crop WxH+X+Y ...simple-operators... \
         \) -geometry +X+Y -composite   ...
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

Or this (for multiple images)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  ... \( -clone 0--1 -crop WxH+X+Y ...simple-operators... \
         null: +insert \) -geometry +X+Y -layer composite ...
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

How the 'region image' is actually overlaid onto the 'original image' is
a little tricky... </P>

If the original image has the no <A HREF="#alpha" >Transparency Channel</A>
enabled, the 'region image' is composed using <A HREF="../compose/#over" >Over
Composition</A>.  That means that transparent areas in the region image will
become see-thru, allowing you to see the original image behind it. </P>

For example here I purposefully turned off the transparency in the original
image, but then <A HREF="../warping/#rotate" >Rotate</A> the region so as to
produce some areas of transparency in the corners.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -alpha off -region 30x30+10+10 \
          -alpha on -background None  -rotate 30  koala_region_rotate_1.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_region_rotate_1.gif"
     ><IMG SRC="koala_region_rotate_1.gif"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the corners of the rotated area (which was transparent in the
'region image') shows the 'original image'.  Basically as the original image
cannot handle transparency, the region image is simply overlaid, with
see-thru corners. </P>

If the original image does contain active <A HREF="#alpha" >Transparency</A>
then the transparency in the modified region image can also be modified, so
transparency is just 'copied' as is.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif -alpha set  -region 30x30+10+10 \
          -background None  -rotate 30    koala_region_rotate_2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_region_rotate_2.gif"
     ><IMG SRC="koala_region_rotate_2.gif"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see IM uses a <A HREF="../compose/#copy" >Copy Composition</A>, so
that any transparency that exists in the region image, will also be copied to
the original image. </P>

If for some reason you want the original image to preserve its original
transparency, <A HREF="#alpha_off" >Turn off the Alpha</A> first, then after
the region image has been restored, <A HREF="#alpha_on" >Turn it on again</A>
so as to restore it. </P>

<BR>

Region Images which are enlarged or shrunk, may not 'fit' back into the
original.  For example here I resize (and color) the region image so it
becomes smaller...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -region 30x30+10+10 \
          -resize 75% -fill red -colorize 30%  koala_region_shrink.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_region_shrink.gif"
     ><IMG SRC="koala_region_shrink.gif"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the original region was not covered by the region image that
was restored.  As such those parts not covered were not replaced. </P>

In a similar way, if the region becomes larger, more of the original image may
become covered by the overlaid region image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert koala.gif  -region 30x30+10+10 \
          -resize 150% -fill red -colorize 30%  koala_region_enlarge.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="koala_region_enlarge.gif"
     ><IMG SRC="koala_region_enlarge.gif"   WIDTH=75  HEIGHT=75
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In both cases the top-left offset of the region, does not move.  You cannot
just shrink an region image and center it within the region area, nor can you
position the region image in another position. </P>

Caution should be exercised to prevent region images from changing size.
Though in some special circumstances you can still handle a resized region.
For an example of this look at the 'wave distortion' example above. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Like "<CODE><A HREF="../basics/#mogrify" >mogrify</A></CODE>" you cannot
  merge multiple sub-images as that requires the use of a non-simple image
  operation.  However you can use "<CODE><A HREF="../option_link.cgi?draw"
  >-draw</A></CODE>" as an alternative composition method. See <A
  HREF="../basics/#mogrify_compose" >Alpha Composition in Mogrify</A> for an
  example. </P>

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  At the time of writing, the 'region image' still contains the <A
  HREF="../crop/#crop" >Crop Virtual Canvas Offset</A> from its extraction
  from the original image.  This may, or may not be regarded as a bug,
  depending on if you find this information useful or not.  The offset is
  currently not used when a region image is restored. </P>

  If the offset is not wanted (as it interferes with an operator such as <A
  HREF="../distorts/#distort" >Distort</A>), follow the "<CODE><A
  HREF="../option_link.cgi?region" >-region</A></CODE>" option by a "<CODE><A
  HREF="../option_link.cgi?repage" >+repage</A></CODE>" operator to remove the
  offset, from the region images. Its removal or modification will not effect
  its restoration back onto the original image.  </P>

</I></FONT></TD></TR></TABLE></P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="bg_remove"></A>
<H2>Background Removal</H2>

One of the most common problems in image processing is mask generating from a
existing fully-opaque image.   Such images are commonly downloaded from the
World Wide Web, or generated by programs, or in image formats that don't
provide any form of transparency. </P>

It may also be that you have a photo of some object, and want to remove the
background. Remember photos do not have any understanding of transparency,
so you need to remove the unwanted parts yourself. </P>

Unfortunately there is no general solution to this problem, especially when
you also want to retain any semi-transparent edging to the image.
Consequentially their are hundreds of ways and variations on doing this task,
all dependant on the exact situation. </P>

Closely related to image masking is transparency adjustments to match a
background that an image is going to be overlaid on.  This is talked about in
detail as part of saving to the <A HREF="../formats/#gif" >GIF Image File
Format</A> which only allows Boolean transparency. </P>


<A NAME="floodfill"></A>
<H3>Masking Simple Backgrounds (floodfill)</H3>

When an images background is a simple single solid color, you can often
generate simple masks (and background removal) by just doing <A
HREF="../color_basics/#replace" >Replacing Colors in Images</A>. </P>

For example here is a direct floodfill masking of an image with a solid color
background.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert cyclops.png -alpha set -channel RGBA \
          -fuzz 1% -fill none -floodfill +0+0 white \
          cyclops_flood_1.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="cyclops_flood_1.png"
    ><IMG SRC="cyclops_flood_1.png"            WIDTH=100 HEIGHT=100
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

Well that did not work, as the floodfill 'seed' point in the top-right corner
does not actually reach all parts of the image!!! </P>

The solution to this is to enlarge the image slightly, so as to provide a path
for the floodfill to reach all the outside edges of the image.  However for
this you need to know the color of the background.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert cyclops.png -bordercolor white -border 1x1 \
          -alpha set -channel RGBA -fuzz 1% \
          -fill none -floodfill +0+0 white \
          -shave 1x1    cyclops_flood_2.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="cyclops_flood_2.png"
    ><IMG SRC="cyclops_flood_2.png"            WIDTH=100 HEIGHT=100
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

Of course we did not specify a very good <A HREF="../color_basics/#fuzz" >Fuzz
Factor</A>.  The problem with this is that you get a halo around the object
within the image.  This is because most images contain special pixels along
the edges which smooths the look of the image. </P>

However as this image has a good black border to it, relative to the
background, using a nice large fuzz setting can be used to nicely separate the
image from the background.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert cyclops.png -bordercolor white -border 1x1 \
          -alpha set -channel RGBA -fuzz 20% \
          -fill none -floodfill +0+0 white \
          -shave 1x1    cyclops_flood_3.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="cyclops_flood_3.png"
    ><IMG SRC="cyclops_flood_3.png"            WIDTH=100 HEIGHT=100
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

This technique has some problems with it.  First it is an all or nothing
masking of the image, producing edges that are aliased, staircase-like and
often horrible looking.  This is fine for the limited GIF image file format,
but not very good if you plan to overlay that image onto another background.
</P>

It is also very very difficult to get every anti-aliasing edge pixel.  As such
if I overlay the above image on a black background, you may see some pixels
that are much whiter that normal.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert cyclops_flood_3.png -background black -flatten \
          cyclops_flood_3_over.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
 <A HREF="cyclops_flood_3_over.png"
    ><IMG SRC="cyclops_flood_3_over.png"            WIDTH=100 HEIGHT=100
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Also if you do manage to use a high enough fuzz factor, you are likely to have
the problem of having very little edging pixels left, or 'leaking' into the
center of the image. </P>

Finally a direct flood fill like this does not work for a background that isn't
a simple single solid color. </P>


<A NAME="border_cut"></A>
<H3>Cutting Out Bordered Objects</H3>

Images with an existing single color border has a distinct advantage for these
methods of background removal, as the border provides a definite boundary
between what is 'inside' and what is 'outside' the image, and that in turn
allows use a better method of specifying the boundary of the background image.
</P>

That is rather than specifying what colors should be regarded as background,
we can instead specify what colors mark the border of the object being masked.
</P>

Further more, as the border color is known, only two specific colors will have
been mixed together around the edges of the image. That is both colors are
known, and so exactly how transparent the edges should be is also very well
known. </P>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50>
</B></FONT></DIV></P>

<!--
<I>Example: Floodfill using the negative of the border color and large fuzz
factor... </I> </P>

However as the border color is known, the <A HREF="../draw/#color" >Draw Color
primitives</A> do provide an even better way. That is by using the
'<CODE>filltoborder</CODE>' color replacement drawing method, we can specify
the limit of the flood fill instead. </P>

<PRE>
    convert color_test.png   -fill white  -bordercolor royalblue \
            -draw 'color 30,20 filltoborder'   color_filltoborder.png
</PRE>

You can also specify a <A HREF="../color_basics/#fuzz" >Fuzz Factor</A> so that
colors similar to the one you specified will be thought of as a border color.
Remember too small a fuzz factor and the border will leak,  too large and you
will start matching background colors as well. </P>

A similar technique is published by Dr Rick Mabry on his web site, <A
HREF="http://www.lsus.edu/sc/math/rmabry/imagemagick/multireplace/" >Gradient
Color Replacement</A>.  In this case he replaces colors that fall along
a linear gradient between two colors, with either another gradient, or a mix
of color and the texture image.  It is well worth a look at his results. </P>
-->

<A NAME="known_bgnd"></A>
<H3>Removing a Known Background</H3>

While removal of a simple background to a 'Boolean' mask, is relatively
straight forward, things get more complicated when the background is not so
simple.  However if the background itself is known. you can use that to help
in its removal from other images. </P>

As of IM v6.3.4 a special <A HREF="../compose/compose" >Alpha Composition</A>
method was added called '<CODE><A HREF="../compose/#changemask"
>ChangeMask</A></CODE>' which allows for the direct removal of a known
background from an image. </P>

For example here we have an unaltered background image, and one that has been
overlaid by a GIF image with a simple Boolean (straight on/off) transparency.
By using '<CODE><A HREF="../compose/#changemask" >ChangeMask</A></CODE>' we can
recover that original overlaid image (if it is very different to the
background).

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert overlay_figure.gif   overlay_bgnd.gif  \
            -compose ChangeMask  -composite  overlay_removed.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/overlay_figure.gif"
     ><IMG SRC="../images/overlay_figure.gif"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="../images/overlay_bgnd.gif"
     ><IMG SRC="../images/overlay_bgnd.gif"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="overlay_removed.png"
     ><IMG SRC="overlay_removed.png"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Basically what this does is determine how 'different' the pixels are from one
image to the other, and is the difference is less than the current <A
HREF="../color_basics/#fuzz" >Fuzz Factor</A>, then make that pixel
transparent. </P>

Only fully transparent pixels are added to the image, otherwise the original
image is left as is, transparency and all. </P>

We can simulate the operator by using the older '<CODE><A
HREF="../compose/#difference" >Difference</A></CODE>' composition method
to generate a <A HREf="../compare/#difference" >Comparison Difference
Image</A>...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite overlay_figure.gif   overlay_bgnd.gif  \
            -compose Difference     overlay_difference.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/overlay_figure.gif"
     ><IMG SRC="../images/overlay_figure.gif"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/bar.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="../images/overlay_bgnd.gif"
     ><IMG SRC="../images/overlay_bgnd.gif"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="overlay_difference.png"
     ><IMG SRC="overlay_difference.png"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the difference image is black for all the unchanged parts
and a mix of colors for the parts which has changed. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

By separating and adding the individual color channels together and
thresholding we get a mask of any difference in any channel between the two
images.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert overlay_difference.png -channel RGBA -separate +channel \
          -evaluate-sequence add  -threshold 0   overlay_mask.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="overlay_mask.png"
     ><IMG SRC="overlay_mask.png"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Using this mask we can set anything that has not changed to transparency.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert overlay_figure.gif overlay_mask.png \
          -alpha off -compose CopyOpacity -composite \
          overlay_removed.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="overlay_removed.png"
     ><IMG SRC="overlay_removed.png"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the '<CODE><A HREF="../compose/#changemask"
>ChangeMask</A></CODE>' composition method makes this process a lot easier.
</P>

However this only presents a 'on/off' style of background masking.  It does
not allow for fuzzy or anti-aliased edges, or transparent feathering of the
result. </P>


<A NAME="difference"></A>
<H3>Difference Image Masking and Feathering</H3>

The above can be taken further to images that have aliased edges.  as well as
non-simple backgrounds. </P>

For example,  Here we have a 'Cyclops' on a white background, which we want to
extract.  We then generate gray-scale image of the differences between this
image and the background color (as defined by top-left most pixel).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert cyclops.png \( +clone -fx 'p{0,0}' \) \
          -compose Difference  -composite  \
          -modulate 100,0  -alpha off  difference.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="cyclops.png"
    ><IMG SRC="cyclops.png"            WIDTH=100 HEIGHT=100
          ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <A HREF="difference.png"
    ><IMG SRC="difference.png"            WIDTH=100 HEIGHT=100
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

Of course this difference image is no good as a mask directly.  If you did use
it you will effectively make most of your image semi-transparent, instead of
just the surrounding background. </P>

However from this difference image, huge number of different transparency
masks can be created, depending on exactly what you are trying to achieve.
</P>

We can adjust the above difference image to produce a mask of all pixels that
are even the smallest amount different from the background color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert difference.png  -threshold 0  boolean_mask.png
  convert cyclops.png  boolean_mask.png \
          -alpha off -compose CopyOpacity -composite \
          cyclops_boolean.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
  <A HREF="boolean_mask.png"
     ><IMG SRC="boolean_mask.png"            WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="cyclops_boolean.png"
     ><IMG SRC="cyclops_boolean.png"            WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

As you can see a boolean 'any difference' resulted in a good amount of the
original background being included.  This is because the original image is
either 'anti-aliased' or blurred slightly with the background (in this case it
was caused by the original image being resized from a JPEG format image).  </P>

This would not be a problem if the original image was itself a Boolean overlay
(EG a GIF format image, overlaid on a background). In that case your result
will be perfect (see the 'ChangeMask' example above). </P>

By varying the "<CODE><A HREF="../option_link.cgi?threshold"
>-threshold</A></CODE>" you can add a 'fuzz factor' to the boolean (on/off
only) mask, so as to get the mask closer to the image proper.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert difference.png  -threshold 15%  threshold_mask.png
  convert cyclops.png  threshold_mask.png \
          -alpha Off -compose CopyOpacity -composite \
          cyclops_threshold.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
   <A HREF="threshold_mask.png"
      ><IMG SRC="threshold_mask.png"            WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="cyclops_threshold.png"
      ><IMG SRC="cyclops_threshold.png"            WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

Notice that the eye of the cyclops image is now also regarded as being a
transparent <B>hole</B>! </P>

This 'hole' highlights the biggest drawback with this whole technique.  Parts
of the image object which are close to the background color, or worse still,
exactly matches the background, will be thought of as being the same as the
background. </P>

Of course this may be desirable in images of 'holey' object, such as a donut,
but for our cyclops, a 'holey eye' is definitely a mistake. </P>

The original 'halo' effect can also be desirable for some things like text to
make it more readable when you want to overlay it again on some other 'noisy'
background.

You can enhance the halo effect by blurring the mask a little before applying
it, so that the resulting 'halo' becomes diminished by distance.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert difference.png -bordercolor black -border 5 \
          -threshold 10%  -blur 0x3  halo_mask.png
  convert cyclops.png -bordercolor white -border 5   halo_mask.png \
          -alpha Off -compose CopyOpacity -composite  cyclops_halo.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
  <A HREF="halo_mask.png"
     ><IMG SRC="halo_mask.png"            WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="cyclops_halo.png"
     ><IMG SRC="cyclops_halo.png"            WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

The resulting 'halo' effect can be further modified by using more <A
HREF="../color_mods/#histogram" >Histogram Adjustments</A> on the mask image,
giving you very precise control of the results for specific images.  With the
right parameters you can adjust the surrounding halo until it is practically
non-existent, though eliminating it completely in this way is difficult. See
next section for an improved technique. </P>

A small amount of blurring (say "<CODE>-blur 0x0.707</CODE>" or square rot of
2) is actually recommended when generating threshold masking, just to smooth
out the edging of the mask. Of course the result will not be boolean, so don't
try to save it to a GIF format image file. </P>

This is also an example of <A HREF="../blur/#feathering" >Blur Feathering</A>.
But be warned that it is not quite the same as true <A
HREF="../morphology/#distance_feather" >Feathering Shapes using Distance</A>.
However when dealing with 'bitmap' or 'threshold masks' such as we created
above, a small amount of blur feathering, followed by a larger amount of
distance feathering, will probably result in the best overall result. </P>


<A NAME="semi-trans"></A>
<H3>Recovering Semi-Transparent Edges</H3>

The <A HREF="#difference" >Difference Masking</A> technique that we used above
can be used with the previous <A HREF="#floodfill" >FloodFill Masking</A>
technique to solve most of the problems we have seen with simpler masking
techniques. </P>

Here we look at a multi-layered masking technique, but one that should produce
near ideal removal of the images background, while preserving the anti-alias
shading pixels along the edge. </P>

However this is limited to images on a known background, and having a good
contrasting 'edge' to the foreground pixels. </P>

For this example I decided to use something that was very hard to separate,
but which showed a LOT more shaded pixels around the edges than you would
typically have for anti-aliasing purposes.  A shape with a shadow effect.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 70x60 xc:none -font Candice -pointsize 50 -stroke black \
          -fill black          -annotate +12+42 'A' -channel RGBA  -blur 0x3 \
          -fill tile_disks.jpg -annotate +10+40 'A' \
          tile_water.jpg  -compose DstOver -composite letter.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="letter.png"
    ><IMG SRC="letter.png"
          ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

First we will need to generate a difference image, and lucky for us we do know
what the background image is.  Of course it will work just as well for a plain
colored background too, as long as their is a good contrast to let use
generate two masks.  </P>

Basically by using a difference image we can remove any influence of the
background image, and from that generate the masks we will be using.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert letter.png  tile_water.jpg \
          -compose Difference -composite \
          -modulate 100,0 -channel B -evaluate set 0 \
          -alpha Off  diff_mask.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="diff_mask.png"
    ><IMG SRC="diff_mask.png"
          ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

Note that this time I processed the grayscale difference image slightly,
limiting it to red and green channels, while clearing out the blue channel,
producing a black-yellow difference image.  This is tricky as it frees 'blue'
channel to allow the generation of a clean floodfill mask, separate to the
difference image itself. </P>

Technically I could clear the green channel as well so I can use it for the
second mask. But lets not get ahead of ourselves. </P>

Now we need two masks: an outside mask, defining of all areas that will
definitely be transparent; and a mask which defines the inside of the object in
the image, without generating any unwanted 'holes'. </P>

So lets flood fill the image from the outside inward, using a number of
different fuzz factors, so we can pick the two inside and outside masks we will use.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE>
  for fuzz in 01 03 06   28 32 34; do \
    convert diff_mask.png -fill blue -fuzz $fuzz% \
            -bordercolor black -border 1x1 -floodfill +0+0 black \
            -shave 1x1 diff_mask_$fuzz.png; \
  done
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0><TR>
<TD ALIGN=center>
  <A HREF="diff_mask_01.png"
      ><IMG SRC="diff_mask_01.png"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>-fuzz 1%
<TD ALIGN=center>
  <A HREF="diff_mask_03.png"
      ><IMG SRC="diff_mask_03.png"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>-fuzz 3%
<TD ALIGN=center>
  <A HREF="diff_mask_06.png"
      ><IMG SRC="diff_mask_06.png"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>-fuzz 6%
<TD><IMG SRC="../img_www/bar.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==">
<TD ALIGN=center>
  <A HREF="diff_mask_28.png"
      ><IMG SRC="diff_mask_28.png"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>-fuzz 28%
<TD ALIGN=center>
  <A HREF="diff_mask_32.png"
      ><IMG SRC="diff_mask_32.png"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>-fuzz 32%
<TD ALIGN=center>
  <A HREF="diff_mask_34.png"
      ><IMG SRC="diff_mask_34.png"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>-fuzz 34%
</TR></TABLE></DIV></P>

The blue areas in the above images is the area being masked. Remember we
cleared the blue channel for this purpose. </P>

The first mask should mask the areas of the image we definitely want to make
full-transparent.  That is the parts we definitely expect to be fully
transparent on the final image.  The area inside the mask should still contain
most of the black halo shadow of the image. </P>

In this case we have a lot of interaction between the image proper and the
rest of the background so I chose a <A HREF="../color_basics/#fuzz" >Fuzz
Factor</A> of '<CODE>1%</CODE>' which still contained a large area surrounding
the image.  In a more typical non-shadowed case this area can be even smaller,
down to a non-percentile value such as 5 or 10.  </P>

The second mask should have large enough 'fuzz' so as to eat up all the
semi-transparent pixels that is present.  That is right up to and preferably
actually into border of the image without completely removing the border, or
'leaking' into the image proper (see last image above).  The negative of this
mask will actually represent all the pixels that will be fully-opaque (and
thus represent the inside) in the final image. </P>

This selection can be difficult and may require a lot of trial and error to
figure out the best value to use.  For this image a very high fuzz
'<CODE>32%</CODE>' was able to be chosen without any major problems. </P>

Basically you want to try and get it high enough that the final image will not
contain any of the original 'background' pixels in it, but without the mask
eating away (or leaking into) the inside the image.  It may even require
a little hand editing to get the mask just right when you have a gap in the
surrounding 'edge' color. </P>

We can now use this mask to extract the 'core' or inside of our image. That is
the parts we are sure does not contain any semi-transparency through to the
background pattern we are removing.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert diff_mask_32.png -channel blue -separate +channel -negate \
          letter.png +swap -alpha Off -compose CopyOpacity -composite \
          letter_inside.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="letter_inside.png"
    ><IMG SRC="letter_inside.png"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

Note how I extracted the blue mask from the flood-filled masked images.
Also due to the all-or-nothing nature of flood-filling, the mask will show
heavy stair-casing or alias effects around the edges.  This is the problem the
second mask will allow us to fix. </P>

Remember this image is only of the pixels that we know does not interact with
the original background, and will be left as is, in the final image.  It does
not include any of the shadow effects, and anti-aliasing pixels that I am
specifically attempting to recover.  Recovering those pixels is where the real
work lies. </P>

By negating and subtracting (multiplying) the masks we can generate a new mask
which defines the area where we want to extract semi-transparent edging or
shadowing pixels...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert diff_mask_01.png -negate diff_mask_32.png \
          -channel blue -separate +channel -compose multiply -composite \
          mask_aliasing_area.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="mask_aliasing_area.png"
    ><IMG SRC="mask_aliasing_area.png"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

This area is then used to extract the anti-aliasing pixels from the difference
mask, which defines how transparent the pixels should be.  We normalize those
pixels to get a smooth transition from opaque to transparency.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert diff_mask.png -channel red -separate +channel \
          mask_aliasing_area.png -alpha Off -compose CopyOpacity -composite \
          -background gray30 -compose Over -flatten -normalize \
          mask_antialiased_pixels.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="mask_antialiased_pixels.png"
    ><IMG SRC="mask_antialiased_pixels.png"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

The lighter the color in the above mask, the more opaque the pixel will be.
Similarly the darker the color, the more transparency it will be. </P>

Note that I used a gray background here to ensure that the transparent colors
that is present in the image will not interfere with the <A
HREF="../color_mods/#normalize" >Normalization</A> of the image. Without this
this normalization will fail.  The flat gray color itself is not important as
they are outside the mask area, so will be ignored later. </P>

Now that we have the right transparency level, we need to know what color
should be used for these semi-transparent pixels.  This color will usually be
the same as the edge color of the image, in this case simply, black.  However
because of the interaction of the original background I decided to go for a
dark grey color for the shadow </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  You will need to somehow figure out what color the semi-transparent pixels
  should be, so you can set the correct color for the anti-aliasing pixels.
  </P>

  This could be <OL>
  <LI> A fixed edge color (EG: near-black, as in this example)
  <LI> Use the color of nearest fully-opaque edge pixels (using
       morphology.  See <A HREF="../canvas/#sparse_fill" >Sparse Color as
       a Fill Operator</A>
  <LI> Calculated: Once you know th alpha and the background color,
       you can subtract the background color to correct the pixel color.
       See <A HREF="#two_background" >Background Removal using Two
       Backgrounds</A> below.
  </OL>

  Basically it depends on your image.

</I></FONT></TD></TR></TABLE></P>

While we are at it lets also re-mask the image to leave just these special
edging pixels.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert mask_antialiased_pixels.png mask_aliasing_area.png \
          -compose multiply -composite -negate \
          -background '#444' -channel A  -combine letter_edging.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="letter_edging.png"
    ><IMG SRC="letter_edging.png"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

All that is needed is to now layer the inside 'core' of the image with the
semi-transparent edging pixels.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert letter_inside.png letter_edging.png \
          -background none  -flatten    letter_recovered.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="letter_recovered.png"
    ><IMG SRC="letter_recovered.png"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

And hey presto, we have an image with the background removed to produce a
perfect anti-aliased image, with correctly recovered semi-transparent edging
and shadowing </P>

You can even overlay it onto a completely different background.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert letter_recovered.png tile_aqua.jpg \
          -background none -compose DstOver -flatten    letter_on_aqua.png
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>
 <A HREF="letter_on_aqua.png"
    ><IMG SRC="letter_on_aqua.png"
          ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

The image I used for this example is very difficult with a large 'edge'
region.  Most images are not nearly so bad, but this method is probably the
best and most universal background removal technique. </P>

This has now been placed into a shell script called "<CODE><B><A
HREF="../scripts/bg_removal" >bg_removal</A></B></CODE>", which uses a single
command, no temporary files, and has a number of extra options on the methods
by which the masking is performed. </P>


<A NAME="two_background"></A>
<H3>Background Removal using Two Backgrounds</H3>

The major problem with the previous techniques is that you really do not have
enough information to completely recover all the information about the
foreground object. </P>

You really need to recover two pieces of information, how transparent each
pixel in the foreground object is, and what is its original color. And you can
not perfectly recover both pieces of information from just one image. </P>

Even when you know exactly what the background image looks like, you cannot
just subtract it from the foreground object, unless the two are very different
and known colors. </P>

The problem is you simply cannot be sure if the color that is visible is
really the color given (opaque), or it is some blending of some other color
and the background (semi-transparent).  You cannot separate the original color
from the alpha value needed, unless you have a source of some extra
information.  </P>

The one situation in which you can completely recover all the details of
a foreground object, is when you have two images containing two very different
but completely known background colors.  In that situation you do have
enough information to recover both the color and its transparency of the
foreground object, for a perfect background removal.  </P>

The important factor in selecting two images, is that the background colors
are as different as possible over the whole image.  That is the colors are not
only color complementary, but negative in intensity in all channels.  </P>

For example...
<DIV ALIGN=center>
  <A HREF="../images/match_navy.gif"
     ><IMG SRC="../images/match_navy.gif"   WIDTH=64 HEIGHT=67
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Input]"></A>
  <A HREF="../images/match_gold.gif"
     ><IMG SRC="../images/match_gold.gif"   WIDTH=64 HEIGHT=67
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Input]"></A>
</DIV></P>

While a different background color is used, both images contain exactly the
same object.  The object shown is not simple, but contains lots of
semi-transparent colors. You can see this in the way the dark blue background
is visible in the flames of the image, though this transparency is all but
invisible in the lighter yellow background. </P>

By using two colors, the semi-transparent pixels of the overlaid object will
become mixed with two very different colors, as a result be slightly different
colors in the two images.  By measuring how different each pixel is, you can
determine exactly what pixels are semi-transparent, and by how much.
Essentially there is enough information to allow you to perfectly recover the
transparency of the overlaid object. </P>

Recovery the transparency or 'mask' is of course the first step, and is
actually a very straight forward step. Generate a difference image, then merge
and maximize the differences found in each channel.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert match_navy.gif match_gold.gif \
          -compose difference -composite -separate \
          -evaluate-sequence max -auto-level -negate \
          match_alpha.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="match_alpha.png"
     ><IMG SRC="match_alpha.png"   WIDTH=64 HEIGHT=67
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This resulting image is a perfect map of how transparent each pixel is. It is
essentially the 'alpha mask' of the original object in the source images.
</P>

However it will only work if the overlay image contains both areas of
full-transparency, and full-opacity.  If that is not the case instead of the
normalization step ("<CODE>-evaluate-sequence max -auto-level</CODE>") in the
above , you will need to divide each channel by the difference of the two
background colors. That is divide by a value between 0.0 and 1.0, the larger
the difference the better.  If the two background colors is pure black and
pure white, then no normalization, is needed, just the difference of the two
images. </P>

The difference is then <A HREF="../color_mods/#negate" >Negated</A> so tha
a maximum difference produces zero alpha or full-transparency, and no
difference produces maximum alpha or full opacity.  </P>

The next task is harder, as the colors of each semi-transparent pixel is
modified by the background, you cannot just use the alpha mask to extract the
object from one of the source images. For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert match_navy.gif match_alpha.png \
          -alpha Off -compose Copy_Opacity -composite \
          match_bad_colors.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="match_bad_colors.png"
     ><IMG SRC="match_bad_colors.png"   WIDTH=64 HEIGHT=67
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Basically what we got was a horrible halo of the background color in the
semi-transparent 'flame' of the image. Not a nice result at all.  This is
known as 'color spill' (a term from <A
HREF="http://en.wikipedia.org/wiki/Chroma_key" >Chroma Key Masking</A>, also
known as the Blue or Green Screen technique) and this can be a major problem.
</P>

What we need to do is remove the background color from the semi-transparent
pixels.  However as we have already recovered the original images alpha
channel, we know exactly how much color needs to be removed from each pixel,
so as to restore the original color overlaid. </P>

To do this we not only need one of the source images, and the alpha channel we
just extracted, but we also need to know the exact color of the background,
in that source image.  A relative easy problem when using a solid color
background, as in these examples.  </P>

For example here I restore the original colors...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert match_navy.gif match_alpha.png -alpha Off \
          -fx "v==0 ? 0 : u/v - u.p{0,0}/v + u.p{0,0}" \
          match_alpha.png -compose Copy_Opacity -composite \
          match_recovered.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="match_recovered.png"
     ><IMG SRC="match_recovered.png"   WIDTH=64 HEIGHT=67
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

I used top-left corner pixel (FX formula '<CODE>u.p{0,0}</CODE>') in the
source image as the background color to remove from semi-transparent pixels.
Adjust this or directly substitute the color to remove if needed. </P>

The key to the color restoration, is the complex <A HREf="../transform/#fx"
>FX</A> blended subtraction operation in the above.  This will enhance the
original color ('<CODE>u</CODE>') of the source image according to the alpha
mask ('<CODE>v</CODE>'), then subtract the background color
(<CODE>u.p{0,0}</CODE> or the top-left corner pixel) from the final result.
</P>

The formula is not straight forward, and major thanks does to <A
HREF="../forum_link.cgi?u=14154" >HugoRune</A>, in the IM Forum discussion <A
HREF="../forum_link.cgi?t=18235" >Undo a Composite -dissolve</A> for
determining the mathematics needed. The discussion also goes on to exactly how
all the steps work, were derived, and even how you can also extract the
overlay from any two known but different background patterns. </P>

Here is the whole sequence all in one command.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert match_gold.gif match_navy.gif -alpha off \
          \( -clone 0,1 -compose difference -composite \
             -separate -evaluate-sequence max -auto-level -negate \) \
          \( -clone 0,2 -fx "v==0?0:u/v-u.p{0,0}/v+u.p{0,0}" \) \
          -delete 0,1 +swap -compose Copy_Opacity -composite \
          match_recovered_2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="match_recovered_2.png"
     ><IMG SRC="match_recovered_2.png"   WIDTH=64 HEIGHT=67
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  In IM v6.6.8-3, if FX references a transparent pixel using 'p{}' it gets
  zero values rather than the actual fully-transparent color values!
  This is a bug and was reported and fixed in IM v6.6.8-5.  It is not known
  when the bug was introduced. </P>

  This was only a problem, if you decide to merge the alpha image into the
  source image first, then try to fix semi-transparent or 'spill' colors,
  using the known background color.

</I></FONT></TD></TR></TABLE></P>

This time the 'gold' background image was used for the color extraction, and
was selected by the '<CODE>0</CODE>' in the second "<CODE><A
HREF="../option_link.cgi?clone" >-clone</A></CODE>" operation, but either
source image could have been used. </P>

Just one warning. The above assumes the top-left pixel is the unadulterated
background color. If it isn't you may have to modify the command to specify
a specific pixel color, or use a third image that does contain the correct
background color information. The latter method is vital if the background
color is not constant across the image, though even that complication can be
fixed. </P>

Here is the simpler sequence for images overlaid on a pure black and a pure
white background color. In this case the colors are always recovered from the
black background image, as it is just a simple division, and thus a faster <A
HREF="../compose/#divide" >Divide Composition</A> can be used instead of the
painfully slow <A HREF="../transform/#fx" >FX DIY Operator</A>.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert match_black.gif match_white.gif -alpha off \
          \( -clone 0,1 -compose difference -composite -negate \) \
          \( -clone 0,2 +swap -compose divide -composite \) \
          -delete 0,1 +swap -compose Copy_Opacity -composite \
          match_recovered_3.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/match_black.gif"
     ><IMG SRC="../images/match_black.gif"   WIDTH=64 HEIGHT=67
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Input]"></A>
  <A HREF="../images/match_white.gif"
     ><IMG SRC="../images/match_white.gif"   WIDTH=64 HEIGHT=67
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Input]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="match_recovered_3.png"
     ><IMG SRC="match_recovered_3.png"   WIDTH=64 HEIGHT=67
           ALIGN=middle VSPACE=0 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<BR>

<B>Studio photos for background recovery</B></P>

The ideal backgrounds are a matte (non-reflective) black, and simple pure
(non-reflective) white. The background should also be as smooth and unvarying
shade as possible.  For making photos specifically for background removal,
using two complementary colors may work better. Say taking photos with a green
and magenta backdrop.  </P>

Basically you will need to some how replace the background color screen before
taking the second photo.  Note that order of the two photos does not matter in
the background removal, but they should be a clean and uniform as possible,
and the primary object and camera must remain perfectly steady and fixed.
</P>

A better method may be to simply place a white screen well distanced behind
the object and uniformly light that screen using two different colored lamps
so as not produce any shadows from the object.  With this technique you can
switch to the other background color, without needing any physical change in
the studio to take two photos with two different backgrounds.  </P>

These two color background techniques should work well for transparent
objects, but reflections, and or background warping or 'lens' effects by the
object being photographed will not be recorded by the technique, only its
transparency. On the other hand reflections of a constant light source on the
object will be preserved! </P>

<I>If you try this please let us know, and give an example of your source
photos and results for inclusion here.  You will be named with a pointer to
your site for people to look at.</I> </P>

<BR>

<B>Video background recovery</B></P>

If you have a large enough series of images with many different but complex
backgrounds (such as a video), you can try taking a minimum and maximum value
of all the images to generate a near pure black and white background image for
use. The more images, the better this works.  </P>

With those two images any constant logo and its semi-transparency can be
extracted, and the same technique can then be used to remove it from all the
frames. </P>

However it will only work for a constant semi-transparent overlay, and may not
work for logos that use color or hue distortions, or even a solid color logo.
But it will will at least let you determine the exact logo shape. </P>

For logos that are fully opaque or more difficult, hole filling (see next) can
then be used to fill in missing detail from surrounding colors. </P>

See the <A HREF="../forum_link.cgi?t=18235" >IM Forum Discussion</A> for more
details. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="hole_filling"></A>
<H2>Hole Filling</H2>

While masking, adding transparency, and removing background provide one way of
dealing with unwanted elements, often a 'hole' is not what you actually want
as a result. Sure you can just overlay images with holes over other images to
fill them, but that may not provide a seamless result. </P>

To erase elements from an image, you don't just want to cut them out, but
replace them with colors, shades, and textures of parts that surround the
hole.  The following are various techniques for determining what to use
to fill-in that hole.  </P>


<A NAME="create_a_hole"></A>
<H3>Creating a hole to fill</H3>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Suppose we have an image with some ugly text...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert zelda_tn.gif -gravity Southwest -annotate +8+20 Zelda zelda_text.jpg
</CODE></PRE></TD></TR></TABLE></P>

Well what we really want to do is remove that text, and the simplest way is
to mask it, so as to leave a 'hole' where the text was.   This simplifies the
problem, as it no longer matters what was removed.  We just have a hole to be
filled.

</TD><TD>
  <A HREF="zelda_text.jpg"
     ><IMG SRC="zelda_text.jpg"      WIDTH=120   HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For this case however I'll create a mask using a drawn line that covers the
'ugly text', as if an user had quickly used an image editor.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 120x90 xc:black  -stroke white  -strokewidth 7 \
          -draw 'stroke-linecap round line 9,62 36,63' \
          -threshold 10%  zelda_text_mask.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="zelda_text_mask.gif"
     ><IMG SRC="zelda_text_mask.gif"      WIDTH=120   HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Just the creating of the 'hole' itself can be a tricky matter, and an
automated solution may depend on exactly what you are trying to remove, or
even involve comparing hundreds of images with the same 'text' or 'logo' to
locate it exactly. </P>

Note that a smaller the hole is the better the final result. The more
information that can be preserved from the original image, the better the
result will be.  A rough oddly shaped hole is also better than a very smoothly
outlined hole.  So taking your time to make the smallest hole that removes all
unwanted effects, can make a big difference. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Now lets use the mask to cut a hole out of the image, which will also check
that it covers all the unwanted parts.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert zelda_text.jpg \( zelda_text_mask.gif -negate \) \
          -compose CopyOpacity -composite   zelda_text_hole.png
</CODE></PRE></TD></TR></TABLE></P>

So here we have an image with a 'hole' in it that needs to be filled. </P>

</TD><TD>
  <A HREF="zelda_text_hole.png"
     ><IMG SRC="zelda_text_hole.png"      WIDTH=120   HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="blur_fill"></A>
<H3>Blurred Fill</H3>

So we have a hole, that needs to be fill with some color.  Something that will
not look like we have actually removed somethign from the image.</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

One of the simplest methods is to simply blur the image, allowing the colors
around the hole to 'spread' into the hole, and then remove the transparency.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert zelda_text_hole.png -blur 0x1 -alpha off zelda_text_fill.png
</CODE></PRE></TD></TR></TABLE></P>

The amount of blur you use depends on the size of the hole used.

</TD><TD>
  <A HREF="zelda_text_fill.png"
     ><IMG SRC="zelda_text_fill.png"      WIDTH=120   HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now how we can <A HREF="../compose/#dstover" >underlay</A> this blurred image
to 'fill the hole' that we previously made...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert zelda_text_hole.png zelda_text_fill.png \
          -compose Dst_Over  -composite   zelda_text_removed.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="zelda_text.jpg"
     ><IMG SRC="zelda_text.jpg"              WIDTH=120 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="zelda_text_hole.png"
     ><IMG SRC="zelda_text_hole.png"       WIDTH=120 HEIGHT=90
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="zelda_text_fill.png"
     ><IMG SRC="zelda_text_fill.png"        WIDTH=120 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="zelda_text_removed.png"
     ><IMG SRC="zelda_text_removed.png"       WIDTH=120 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

And the text has been removed. </P>

This isn't perfect, as the blurring of colors in that area makes it obvious
that something was removed.  For example if you closely look at the window
frame next to Zelda's head, you can see the effects of the blur.  Also the
area looks 'smoother' than the rest of the image, which is particularly
noticeable on photos. </P>

But it is a wide spread and fast technique, and you will often see this in
videos, where they have attempted to remove the logos some TV broadcaster had
added as a copyright prevention method. </P>

An alternative to trying to hide the removal is to make the actual removal
noticeable.  For example if you want to <A HREF="../photos/#anonymity" >Protect
Someone's Anonymity</A>. </P>


<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50>
</B></FONT></DIV></P>

Links to other methods. </P>

Resize blurring hole filling method... <A
HREF="../canvas/#sparse_blur" >Sparse Color, Shepard's Method (fast)</A>.
See also  <A
HREF="http://im.snibgo.com/fillholes.htm" >snibgo, Filling holes</A> </P>

Blurring Edge Pixels only...<A HREF="../canvas/#sparse_fill" >Sparse Color as
a Fill Operator</A>. See also <A HREF="http://im.snibgo.com/fillholespri.htm"
>snibgo, Filling holes in priority order</A> </P>

I would like to use a morphology operator that sets color in the color
channels while working out distance in a hidden background channel.  This
should generate a very fast no-leak Shepard's like fill known as, '<B>Color
Diffusion</B>'.  See the paper <A
HREF="http://artis.imag.fr/Publications/2008/OBWBTS08/">Diffusion Curves</A>
which makes heavy use of this technique. </P>

A large and old discussion on hole filling (text removal) is on the IM Users
Forums <A HREF="../forum_link.cgi?p=41498" >Text Removal Discussion</A>.
A newer discussion is <A HREF="../forum_link.cgi?p=138971" >Fill area with
nearest colour from boundary</A>, which is more about filling without
blurring. </P>

Some other non-IM methods of 'hole filling' to erase parts of images is shown
on <A
HREF="https://stackoverflow.com/questions/52461350/remove-text-from-jpeg"
>Stack Overflow, Remove text from jpeg</A>.  For example Using <A
HREF="http://scikit-image.org/docs/dev/api/skimage.restoration.html#inpaint-biharmonic"
>Python Skimage</A>.  Or using <A
HREF="https://docs.opencv.org/3.0-beta/modules/photo/doc/inpainting.html
https://docs.opencv.org/3.4.0/df/d3d/tutorial_py_inpainting.html" >Python
OpenCV inpainting</A>


</DIV></P>
<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 10 December 2003 (originally 'channels') <BR>
Updated: 2 October 2018 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/masking/</CODE>
</ADDRESS></BODY></HTML>

