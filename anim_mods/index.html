<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Animation Modifications -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/anim_mods/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Animation Modifications</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#mods"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Simple Modifications of Animations</A>
    <UL>
    <LI><A HREF="#annotating"
        >Annotating</A>          - add a copyright notice over ALL frames
    <LI><A HREF="#draw"
        >Drawing</A>             - modify a coalesced animation
    <LI><A HREF="#frame_mod"
        >Frame By Frame</A>      - modify animations one frame at a time
    <LI><A HREF="#crop"
        >Cropping_Smaller</A>    - limit the area of the animation
    <LI><A HREF="#crop_viewport"
        >Crop the Canvas Too</A> - viewport cropping an animation
    <LI><A HREF="#trim"
        >Bounds Trimming</A>     - automatic canvas size reduction
    <LI><A HREF="#repage_relative"
        >Repositioning Frames</A>  - moving sub-frames around
    <LI><A HREF="#reverse"
        >Reversing Animations</A> - making animations run backward
    <LI><A HREF="#patrol"
        >Patrol Cycles</A>       - cycle back and forth between two ends
    <LI><A HREF="#morph"
        >Color Morphing</A>      - animated change between two images
    <LI><A HREF="#morph_resize"
        >Resize Morphing</A>     - animated change in size
    <LI><A HREF="#wipe"
        >Wipe</A>                - creating a wipe from one image to another
    <LI><A HREF="#distort"
        >Animated Distorts</A>   - animated distortion of images
    <LI><A HREF="#label"
        >Append a Label</A>      - add a label to an animation
    <LI><A HREF="#remove_trans"
        >Remove Transparency (Flatten)</A> - add colored background
    </UL>
<DD><A HREF="#compose"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Animation Alpha Composition</A>
    <UL>
    <LI><A HREF="#compose_draw"
        >Draw Images</A>          - overlay an image onto animation
    <LI><A HREF="#composite"
        >Layer Composition</A>    - alpha composition for image lists
    <LI><A HREF="#composite_single"
        >Single Image Composition</A> - compose layer with single image
    <LI><A HREF="#background"
        >Static Background</A>    - compose over a larger background
    </UL>
<DD><A HREF="#glitter"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > All that Glitters...</A>
    <UL>
    <LI><A HREF="#glitter"
        >Glitter Animations</A>   - Animate a masked area of an animation
    <LI><A HREF="#glitter_tiles"
        >Glitter Tiles</A>        - 'hole in the image' underlaying
    <LI><A HREF="#sparkle"
        >Sparkles</A>             - overlaying transparent glitter
    <LI><A HREF="#flares"
        >Flares and Stars</A>     - Seeding Flares and Stars onto images
    </UL>
<DD><A HREF="#resize"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Resizing Animations</A>
    <UL>
    <LI><A HREF="#resize_problems"
        >Problems Resizing Animations</A> <I>(under construction)</I>
    <LI><A HREF="#resize_methods"
        >Resizing Animation Techniques</A> <I>(under construction)</I>
    <LI><A HREF="#resize_flatten"
        >Resize With Flatten</A>  - A general solution
    <LI><A HREF="#resize_colors"
        >Color Table Blowout</A>
    <LI><A HREF="#resize_thumbnail"
        >Animation as Padded Thumbnails</A>
    </UL>
<DD><A HREF="#merging"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    >Merging Multiple Animations</A>
    <UL>
    <LI><A HREF="#serial"
        > Serial or Time-wise Append</A>
    <LI><A HREF="#append"
        >Side by Side Appending (time synced)</A>
    <LI><A HREF="#append_fonts"
        >Appending Animated Fonts</A>
    <LI><A HREF="#split"
        >Splitting up an Animation</A>
    <LI><A HREF="#merge"
        >Merging Time Disjoint Animations</A> <I>(under construction)</I>
    </UL>
</DL>

This page contains practical examples of working with GIF animations.  It is
highly recommended that you read and understand the <A HREF="../anim_basics/"
>Basics of Animations</A> and at least the overall handling of <A
HREF="../anim_opt/" >Optimizing GIF Animations</A>, before trying to
understand these examples. </P>

<HR><!-- ------------------------------------------------------------------ -->

<A NAME="mods"></A>
<H2>Simple Modifications of Animations</H2>

<H3>First an Important point</H3>

DO NOT save the intermediate, animations which you are not finished
processing, directly to GIF, especially images that you have yet to perform
any sort of <A HREF="../anim_opt/#semitrans_opt" >Semi-Transparency
Handling</A> or <A HREF="../anim_opt/#color_opt" >Color Optimization</A>. </P>

If you made the big mistake of saving to GIF you would have just made the
resulting animation worse, as IM would have now performed an automatic <A
HREF="../quantize/#colors" >Color Quantization</A>, to reduce the number of
colors present to fit the images into the limited GIF format.  Not only that
but it did each frame completely separately to every other frame, producing
different color selections and dither patterns. That is turn makes any further
processing, particularly any <A HREF="../anim_opt/#frame_opt" >Frame
Optimization</A> just that much harder.  </P>

This is especially important for resized GIF animations, or ones you have
added a multi-color overlay or underlay, as this can add a lot of extra
colors. </P>

You can use the IM internal format MIFF, as a temporary file format if you
want to work on an animation in steps or use individual PNG format images for
each of the frames being edited.  Just do not do the final save to GIF unless
you are now sure you will not have color problems. </P>

I repeat...<DIV ALIGN=center><B>
   Do not use GIF as an intermediate file format, use MIFF, or PNG images.
</B></DIV></P>

<BR>

<A NAME="annotating"></A>
<H3>Annotating
<FONT SIZE=-1>- add a copyright notice over ALL frames </FONT></H3>

As of IM version 6.2.6, you can "<CODE><A HREF="../option_link.cgi?annotate"
>-annotate</A></CODE>" an animation, in similar way to that detailed in <A
HREF="../annotating/#anno_on" >Annotating on top of Images</A>,
simply by doing so. </P>

For example here we annotate the <A HREF="../anim_basics/#previous" >previous
dispose animation</A> created in <A HREF="../anim_basics/" >Animation
Basics</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert canvas_prev.gif -gravity center \
          -fill black     -annotate +1+1 "Copyright" \
          -fill white     -annotate +0+0 "Copyright" \
          annotate.gif
  gif_anim_montage annotate.gif annotate_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="annotate.gif"
     ><IMG SRC="annotate.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE><DIV ALIGN=center>
  <A HREF="annotate_frames.gif"
     ><IMG SRC="annotate_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The reason this works, is that "<CODE><A HREF="../option_link.cgi?annotate"
>-annotate</A></CODE>" will position text relative to the virtual canvas of an
image, and not relative to the actual image data.  As such the position of the
text on each frame is correct for an animated image. </P>

Before version 6.2.6 however  "<CODE><A HREF="../option_link.cgi?annotate"
>-annotate</A></CODE>", like many other image operators, positioned
information, and overlays, relative to the actual image, and ignored any page
or virtual canvas offset a sub-frame may have. </P>

One word of warning, drawing on an animation like this, without first <A
HREF="../anim_basics/#coalesce" >Coalescing</A> the animation, can cause some
unusual effects, due to an animations existing optimization scheme (see next
set of examples).  As such (and as you will see) removing any existing frame
and transparency optimizations by  <A HREF="../anim_basics/#coalesce"
>Coalescing</A> it first is recommended.

<A NAME="draw"></A>
<H3>Drawing
<FONT SIZE=-1>- modify a coalesced animation</FONT></H3>

Now while "<CODE><A HREF="../option_link.cgi?annotate" >-annotate</A></CODE>"
places text relative to the virtual canvas of each frame, many other images
operations do not.  This includes all "<CODE><A HREF="../option_link.cgi?draw"
>-draw</A></CODE>" operations, which only draw things relative to the actual
image, and completely ignore any offset it may have on a larger canvas.  </P>

For example, here we draw a fancy green circle near the top left corner of the
<A HREF="../anim_basics/#previous" >previous dispose animation</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert canvas_prev.gif -fill LimeGreen -stroke SeaGreen \
          -draw 'circle 35,35 20,30'  draw_circle_fail.gif
  gif_anim_montage draw_circle_fail.gif draw_circle_fail_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="draw_circle_fail.gif"
     ><IMG SRC="draw_circle_fail.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE><DIV ALIGN=center>
  <A HREF="draw_circle_fail_frames.gif"
     ><IMG SRC="draw_circle_fail_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Well as you can see "<CODE><A HREF="../option_link.cgi?draw"
>-draw</A></CODE>" drew the circle relative to the 'actual image', rather than
the larger virtual (page) canvas the image is part of. The result is, as is
typical in this sort of situation... a mess. </P>

The simple solution to this is to first <A HREF="../anim_basics/#coalesce"
>Coalesce</A> the animation, before drawing, then re-optimise the GIF
animation afterwards. See <A HREF="../anim_opt/" >Optimizing Animations</A>
for details.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert canvas_prev.gif -coalesce \
          -fill LimeGreen -stroke SeaGreen -draw 'circle 35,35 20,30' \
          -layers Optimize  draw_circle.gif
  gif_anim_montage draw_circle.gif draw_circle_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="draw_circle.gif"
     ><IMG SRC="draw_circle.gif"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE><DIV ALIGN=center>
  <A HREF="draw_circle_frames.gif"
     ><IMG SRC="draw_circle_frames.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note how the IM animation optimizer actually decided to just not overwrite the
part that was drawn on.  This is actually more optimal than if it had drawn on
the actual sub-frame images themselves. </P>

This method will let you overlay any sort of annotation, copyright notice, or
watermark you like. Of course you may need to use the special <A
HREF="#composite" >Layers Composition</A> technique to actually overlay
an image onto every frame in an animation. </P>

If you get really good you can even do so far as doing <A HREF="#merging"
>Animation Merging</A> to overlay an animated copyright notice on your
animation. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  While this 'coalesce-optimize' technique will work with most operations
  involving animations, especially with IM's optimizer, there are some
  operations that do such drastic changes to images, such as major color
  changes, and shadings, and with semi-transparency, that the resulting
  animation failing to optimize very well. </P>

  For example just about any "<CODE><A HREF="../option_link.cgi?resize"
  >-resize</A></CODE>" operation is likely to produce an animation that will
  optimize very badly afterward due major color changes. See <A HREF="#resize"
  >Resizing Animations</A> below for solutions to this.  </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="frame_mod"></A>
<H3>Frame by Frame
<FONT SIZE=-1>- modifying one frame at a time</FONT></H3>

By using the IM <A HREF="../basics/#image_seq" >Image List or Sequence
Operators</A> you can modify each frame of the animation separately. The trick
is to extract each frame in parenthesis, modify it, then replace the original
image with the modified version. </P>

For example here we add text as a copyright watermark into the animation, as
an animation itself, making it even harder to remove. So as not to completely
destroy the animation, I also used semi-transparent colors.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert canvas_prev.gif -coalesce -gravity center \
          -font Ravie -pointsize 24 -fill '#FFF8' -stroke '#0008' \
          \( -clone 0 -annotate 0 'This'        \) -swap 0 +delete \
          \( -clone 1 -annotate 0 'This'        \) -swap 1 +delete \
          \( -clone 2 -annotate 0 'image'       \) -swap 2 +delete \
          \( -clone 3 -annotate 0 'is'          \) -swap 3 +delete \
          \( -clone 4 -annotate 0 'Copy\nright' \) -swap 4 +delete \
          -layers OptimizeFrame   frame_mod.gif
  gif_anim_montage frame_mod.gif frame_mod_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="frame_mod.gif"
      ><IMG SRC="frame_mod.gif"          WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE><DIV ALIGN=center>
   <A HREF="frame_mod_frames.gif"
      ><IMG SRC="frame_mod_frames.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note the use of <A HREF="../basics/#parenthesis" >Parenthesis</A>, to limit
the effect of the "<CODE><A HREF="../option_link.cgi?annotate"
>-annotate</A></CODE>" operation to just a simple 'clone' of one frame of the
animation.  The modified image is then returned to its proper position in the
image sequence using the <A HREF="../basics#swap" >Swap</A> and <A
HREF="../basics#delete" >Delete</A> operators. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The single number usage in the "<CODE><A HREF="../option_link.cgi?swap"
  >-swap</A></CODE>" operator was added in IM v6.3.4-3.  before this you would
  need to specify "<CODE>-swap 3</CODE>" as  "<CODE>-swap -1,3</CODE>", for it
  to work properly.
</I></FONT></TD></TR></TABLE></P>


This technique of modifying individual frames will probably be one of the most
important techniques in manipulating image animations you will encounter. </P>

You will also notice that I actually added the same text to both the first and
second image.  The first image in the above animation is a <A
HREF="../anim_basics/#zero" >Zero Delay Intermediate Frame</A>, which is used
to define the background for the rest of this animation.  That is it flashes
by so fast, it is not usually visible to the users, nor is it meant to be
visible. </P>

Thus the first two actual frames in the above animation should be regarded as
a single visible frame, rather than two separate frames..  The frame with a
non-zero time delay is the last frame of a 'display' frame sequence. </P>

Similarly for other fast running animations, you may need to modify a number
of frames to make your change visible for any appreciable length of time.  This
is not a problem for a static annotation that was drawn over all the
frames (see previous <a HREF="#annotating" >Annotating</A> example above). </P>

This brings us to an important point about GIF animations.
<DIV ALIGN=center><B>
        Study an animation before attempting to modifying it.
<BR>      It can make a BIG difference to the final result.
</B></DIV></P>

<A NAME="crop"></A>
<H3>Cropping
<FONT SIZE=-1>- limit the area of animation</FONT></H3>

IM has endeavored to make the "<CODE><A HREF="../option_link.cgi?crop"
>-crop</A></CODE>" image operation work correctly relative to an images
virtual canvas rather than to the actual image (IM version 6.1.1 onward).
This in turn allows you to do things previously not directly possible. </P>

For example crop the images of a GIF animation and still have it work as
expected for all animations.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=cropped_error.txt>
  convert  canvas_prev.gif -crop 50x50+3+30  cropped.gif
  gif_anim_montage cropped.gif cropped_frames.gif
</CODE></PRE></TD></TR></TABLE>
<DIV ALIGN=center>
   <A HREF="cropped_frames.gif"
      ><IMG SRC="cropped_frames.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></TD><TD>
   <A HREF="cropped.gif"
      ><IMG SRC="cropped.gif"            WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the crop worked, just like it would for a <A HREF="../crop/"
>cropping a single image</A>, preserving the appropriate offset and page size,
so the image data is still positioned correctly, even though the area involved
has been reduced. </P>

As you can see this did not change the overall virtual canvas size! </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
    Do <B>not</B> use "<CODE><A HREF="../option_link.cgi?repage"
    >+repage</A></CODE>" to remove the crop offsets from a frame optimized GIF
    animation.  Doing do will also remove the needed frame offsets that the
    position the sub-frames on the virtual canvas, and which later frames
    may rely on to animate correctly.
</I></FONT></TD></TR></TABLE></P>

The above "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>"
operation did however produce a warning message...

<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
   <A HREF="cropped_error.txt"
      ><IMG SRC="cropped_error.txt.gif"
            ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

As the crop of one of the frames in the animation missed the sub-frame overlay
image used for that frame.  that is one frame did not update the area that was
cropped from teh animation. As a result that frame now does not contain any
real image!  </P>

To compensate, IM not only produces a warning message, but generates a special
'<A HREF="../crop/#crop_missed" >Missed Image</A>' as a placeholder in the
animation to keep everything in order, and preserve any 'delay' or 'disposal'
methods attached to that frame. You can leave that placeholder, or fix it as
you like. </P>

In this case the '<A HREF="../crop/#crop_missed" >Missed Image</A>' is needed
for the animation to run as expected.  However if multiple consecutive missed
images are generated, you can probably merge them together into a single
missed image using the  "<CODE><A HREF="../option_link.cgi?layers"
>-layers</A></CODE>" method '<CODE><A HREF="../anim_opt/#removedups"
>RemoveDups</A></CODE>'. </P>

Caution and study of the animation is however still recommended. (See <A
HREF="#split" >Splitting up an Animation</A> below, for a more detailed
example of this. </P>


<A NAME="crop_viewport"></A>
<H3>Crop the Canvas Too
<FONT SIZE=-1>- viewport crop of the animation</FONT></H3>

Just as a normal crop, preserved the virtual canvas of the original images, so
did a crop of an animation.  This is probably not the intent in this case.
</P>

Because of this, in IM version 6.2.4-5, a special flag '<CODE>!</CODE>' was
added to the "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>"
argument.  This flag will cause crop to not only crop the individual image
frames, but also adjust the page or canvas information about the image to that
same area. </P>

This is known as a 'viewport crop', as the result will be as if you are
looking at the image though a 'window' or 'viewport' of the size and position
of the crop argument. </P>

Not only is the size of the virtual canvas set to the size of the crop area,
but the offset of each frame in the animation is adjusted to keep things
correct.  (See <A HREF="../crop/#crop_viewport" >Viewport Crop with
Canvas/Page Adjustments</A>).  </P>

For example lets repeat the previous crop, but also crop the canvas
information using the '<CODE>!</CODE>' flag...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  canvas_prev.gif -quiet -crop 50x50+3+30\!  crop_viewport.gif
  gif_anim_montage crop_viewport.gif crop_viewport_frames.gif
</CODE></PRE></TD></TR></TABLE>
<DIV ALIGN=center>
   <A HREF="crop_viewport_frames.gif"
      ><IMG SRC="crop_viewport_frames.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></TD><TD>
   <A HREF="crop_viewport.gif"
      ><IMG SRC="crop_viewport.gif"            WIDTH=50 HEIGHT=50
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
    The '<CODE>!</CODE>' character has special significance to some UNIX
    shells, like "<CODE>csh</CODE>", and must be escaped with a backslash,
    even when placed inside quotes.  IM will ignore backslashes, in geometry
    arguments so it does not hurt to always backslash it.
</I></FONT></TD></TR></TABLE></P>

As you can see the result is more like what you probably really wanted to
achieve when cropping an animated image. </P>

Note that I included a "<CODE><A HREF="../option_link.cgi?quiet"
>-quiet</A></CODE>" setting to ask IM not to give the warning message about
the <A HREF="../crop/#crop_missed" >Missed Image</A>, that we generated in the
previous crop attempt.  This is recommended whenever cropping animations, as
the warning does not really apply. </P>

Note that a <A HREF="../crop/#crop_viewport" >Viewport Crop</A> will also
allow you to increase the canvas area or even re-position everything within
the canvas.  However it is dangerous as any images which fall partially or
completely outside the crop area will be cut down to only show the part of the
image that appears within that area. </P>

Just one final word of warning.  When using a 'viewport crop' the frame images
are moved in the negative direction to the offset given for the 'viewport'.
This can appear illogical, unless you remember that the offset in the crop
operator is the position of the viewport, and not a direct re-position of the
images themselves. </P>

<A NAME="trim"></A>
<H3>Bounds Trimming
<FONT SIZE=-1>- automatic canvas size correction</FONT></H3>

As with the previous operations trimming an animation can be tricky.  If the
animation consists of a simple <A HREF="../anim_basics/#cleared" >Cleared
Frame Animation</A>, then you can trim an animation simply by working out the
maximum bounds of all the individual frames within the animation. </P>

As of IM v6.3.4-8  you can do this very easily using a
'<CODE>TrimBounds</CODE>' layer method.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  anim_bgnd.gif -layers TrimBounds anim_trim_bounds.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../anim_basics/anim_bgnd.gif"
     ><IMG SRC="../anim_basics/anim_bgnd.gif"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="anim_trim_bounds.gif"
     ><IMG SRC="anim_trim_bounds.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

For users before this version of IM you can still do the same thing, but only
in a two step process (which also performs other unwanted processing).
To do this you would use a <A HREF="../layers/#merge" >Layers Merge</A> to
merge all the frames of an animation down to a single layer, and then have IM
report the size and offset of that layer...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=anim_trim_bounds.txt>
  convert  anim_bgnd.gif -layers merge -format '%wx%h%X%Y' info:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="anim_trim_bounds.txt"
     ><IMG SRC="anim_trim_bounds.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Now that you know the bounds of all the frames, you can just <A
HREF="#crop_viewport" >Viewport Crop</A> the whole animation to this size.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  anim_bgnd.gif -crop 89x77+5+10! anim_trim_crop.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../anim_basics/anim_bgnd.gif"
     ><IMG SRC="../anim_basics/anim_bgnd.gif"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="anim_trim_crop.gif"
     ><IMG SRC="anim_trim_crop.gif"    WIDTH=89 HEIGHT=77
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

If you also want to trim a static background from an animation then
your best bet is to delete the first frame from a <A
HREF="../anim_opt/#frame_opt" >Frame Optimized</A> animation, before using the
<A HREF="../layers/#merge" >Layers Merge</A> step. You can then use the
returned bounds for the <A HREF="#crop_viewport" >Viewport Crop</A> on the
original animation. </P>


<A NAME="repage_relative"></A>
<H3>Repositioning Frames</H3>

A similar and related operation is the 'relative repage' operator.  This will
add the given offset to all the individual sub-frame layers of the animation,
allowing you to adjust their positions relative to the whole canvas.  To make
a "<CODE><A HREF="../option_link.cgi?repage" >-repage</A></CODE>" operation
relative, you also add a '<CODE>!</CODE>' flag to its argument. </P>

For example here we displace the second an later frames of an animation 30
pixels down and right, returning the first 'background' frame in its normal
'<CODE>+0+0</CODE> position.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  canvas_prev.gif -repage 0x0+30+30\! \
           \( -clone 0 -repage +0+0 \) -swap 0,-1 +delete \
           repage_offset.gif
</CODE><CODE EXECUTE NOWARN OUT=repage_offset.txt>
  identify repage_offset.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="repage_offset.gif"
      ><IMG SRC="repage_offset.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
   <A HREF="repage_offset.txt"
      ><IMG SRC="repage_offset.txt.gif"
            ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The above animation will fail (show only the first two frames) for Windows
  Internet Explorer version 8.  This happens any time a frame attempts to draw
  an image beyond the bounds of the animation canvas.
</I></FONT></TD></TR></TABLE></P>

Notice that none of the images have been 'cropped' or cut down.  Only their
positions have been changed, relative to the original background image, even
if the image was moved 'off canvas'. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

If you like, you may also like to expand the canvas to match these new bounds,
either by adjusting the canvas size directly...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  repage_offset.gif -repage 130x130  repage_canvas.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="repage_canvas.gif"
      ><IMG SRC="repage_canvas.gif"            WIDTH=130 HEIGHT=130
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

By using the <A HREF="#trim" >Bounds Trim Layers Method</A> you can
automatically expand the animations bounds just enough to include the images
which were now being placed 'out-of-bounds'...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  repage_offset.gif -layers TrimBounds repage_bounds.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="repage_bounds.gif"
      ><IMG SRC="repage_bounds.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
    Using "<CODE><A HREF="../option_link.cgi?repage" >-repage</A></CODE>" to
    move images left or up, especially with a small canvas, is likely to fail
    for GIF animations. This format basically cannot use a negative image
    offset. </P>

    For that you may be better off also applying a 'viewport crop', or using
    the 'trim bounds' to shift all the offsets into a larger positive canvas.
    Either method will guarantee a positive offset to all the image frames.
    </P>

    The PNG and MNG formats can handle negative offsets, but many web browsers
    and other programs may not understand such offsets, producing weird
    effects. One version of the "<CODE>Firefox</CODE>" web browser for example
    produces extremely large images, when attempting to display a PNG with
    a negative offset.

</I></FONT></TD></TR></TABLE></P>



<A NAME="reverse"></A>
<H3>Reversing Animations
<FONT SIZE=-1>- making animations run backward, or cycle</FONT></H3>

As of IM v6.3.3, the "<CODE><A HREF="../option_link.cgi?reverse"
>-reverse</A></CODE>" image sequence operator was added (see <A
HREF="../basics/#reverse" >Reverse Operator</A> for more details).  This
allows you very simply reverse the order of a coalesced animation sequence.
</P>

For example here I make a 'hand draw k' animation become undrawn!

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce -reverse \
          -quiet -layers OptimizePlus  -loop 0 reversed.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="reversed.gif"
      ><IMG SRC="reversed.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

I had to re-add the "<CODE><A HREF="../option_link.cgi?loop" >-loop</A></CODE>"
option to the above as this needs to be attached to the first image, which is
now the last image! The result could also use some timing adjustments, but as
you can see it now 'undraws' the letter! </P>

Be sure to "<CODE><A HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>"
the image sequence before reversing it, as any <A
HREF="../anim_opt/#frame_opt" >Frame Optimizations</A> present are dependant
on the image order.  Better to remove those optimizations first.  </P>


<A NAME="patrol"></A>
<H3>Patrol Cycles
<FONT SIZE=-1>- cycle back and forth between two ends</FONT></H3>

A similar technique is to add a reversed order of frames to the end of the
animation, so the resulting animation cycles between the first and last frames
of the original animation. It's a bit like a guard walking a patrol between
two points, and is called a 'Patrol Cycle'. </P>

Here I use the image <A HREF="../basics/#duplicate" >Duplicate Operator</A>
(added to IM v6.6.8-7) to generate the extra frames (reversed).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce   -duplicate 1,-2-1 \
          -quiet -layers OptimizePlus  -loop 0 patrol_cycle.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="patrol_cycle.gif"
      ><IMG SRC="patrol_cycle.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Notice that I didn't just copy all the images of the animation, but skipped
copying the very first and last image of the original sequence.  If I had
copied all the images, the first and last images would appear for twice the
expected period of time, and make the animation file larger than is needed.
</P>

Even so, you should again watch out for <A HREF="../anim_basics/#zero" >Zero
Delay Intermediate Frames</A> at the start and end of the animation, as these
can result in unexpected problems.  Basically do not do this without studying
the animation first, or you are asking for trouble. </P>

Also to allow better optimization of the result, you may even need to add some
extra <A HREF="../anim_basics/#zero" >Zero Delay Intermediate Frames</A>,
between the forward and reverse cycles, to improve optimization.  These extra
frames were probably not provided in the original animation optimization as
the whole animation normally resets when it loops.  See <A
HREF="../anim_opt/#splitting" >Splitting Frame Updates</A> for more details of
how these extra frames help optimize and improve the animation. </P>

Here is an older method using the <A HREF="../basics/#clone" >Clone
Operator</A> to generate duplicate frames.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce \( -clone -2-1 \) \
          -quiet -layers OptimizePlus  -loop 0 patrol_cycle_2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="patrol_cycle_2.gif"
      ><IMG SRC="patrol_cycle_2.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="morph"></A>
<H3>Color Morphing
<FONT SIZE=-1>- animated change between two images</FONT></H3>

The "<CODE><A HREF="../option_link.cgi?morph" >-morph</A></CODE>" operator
is an especially interesting operator.  It will take a list of images, and
insert extra frames between them, so as to do a soft color change from one
image to the next. </P>

This operator is not however a true 'morph' as it only modifies the pixels
color creating a sequence of <A HREF="../compose/#blend" >Blended Images</A>.
A true movie like 'morph' also involves image <A HREF="../distorts"
>Distortion</A> to transform the outline of the object in the image to the
objects in the other image. </P>

For example here I create a <A HREF="#patrol" >Patrol Cycle</A> using a color
morph to generate the extra frames between the rose image and its flipped form.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -delay 20 rose: \( +clone -flip \)  -morph 5 \
          -duplicate 1,-2-1  rose_flip.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="rose_flip.gif"
      ><IMG SRC="rose_flip.gif"    WIDTH=70  HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is not particularly good as all the images have the same delay. The
result is that the animation never seems to 'rest' or pause between the two
end points of the cycle. </P>

A better solution would be to have a pause on the original and its 'flipped'
form. That however requires you adjust the delays of the original images
to be different to the morphing images.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: \( +clone -flip \)  -morph 5 -set delay 10 \
          \( -clone 0 -set delay 240 \) -swap 0 +delete \
          \( +clone   -set delay 240 \) +swap   +delete \
          -duplicate 1,-2-1 rose_flip_pause.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="rose_flip_pause.gif"
      ><IMG SRC="rose_flip_pause.gif"    WIDTH=70  HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the timing delays can become very important for generating
a good animations, allowing the animation to 'rest' at just the right points.
</P>

As of IM v6.6.9  you can set the delay using a <A
HREF="../transform/#fx_escapes" >FX Percent Escapes</A> calculating based on
the index of the image.  Here the FX expression says use a delay of 10 if the
image ingex is not the first (t=0) or the last (t=n-1), otherwise use larger
value.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: \( +clone -flip \)  -morph 5 \
          -set delay '%[fx:(t&gt;0&amp;&amp;t&lt;n-1)?10:240]' \
          -duplicate 1,-2-1    rose_flip_anim.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="rose_flip_anim.gif"
      ><IMG SRC="rose_flip_anim.gif"    WIDTH=70  HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For a whole range of different methods of 'morphing' or doing a 'transition'
from one image to another see Fred Weinhaus's "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/transitions/"
>transitions</A></CODE>" and "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/fxtransitions/"
>fxtransitions</A></CODE>" ImageMagick shell scripts. The Example page
includes the basic algorithm that the script uses to generate the animation.
</P>

<A NAME="morph_resize"></A>
<H3>Resize Morphing
<FONT SIZE=-1>- animated change in size</FONT></H3>

The <A HREF="#morph" >Color Morph Operator</A> actually will not only do color
blending between two images, but also does image resizing at the same time.

For example here I use "<CODE><A HREF="../option_link.cgi?morph"
>-morph</A></CODE>" on two images that are different sizes, and even different
aspect ratios.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: medical.gif -morph 10 \
          -layers TrimBounds -set dispose previous -coalesce \
          -background black -alpha remove \
          -set delay '%[fx:(t&gt;0&amp;&amp;t&lt;n-1)?10:60]' \
          -duplicate 1,-2-1  -loop 0  morph_resize.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="morph_resize.gif"
      ><IMG SRC="morph_resize.gif"    WIDTH=70  HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Only the first line does the resize morph. If you were to look at the actual
images each frame will have a different size!  The next two lines 'fills out'
the images to be the same size, and filling the unused parts with black.
Specifically the operations is designed so the order of the image does not
matter.  The rest is to just setup a <A HREF="#patrol" >Patrol Cycle</A> and
associated timing delays. </P>

The 'resize' is only performed from the top-left corner. At the time of
writing the <A HREF="#morph" >Color Morph Operator</A> does not understand
layer offsets, or any other spatial morphing (distorted morphing). As such if
you want the resize to be centered, you may need to use much more complex
techniques shown in later sections. </P>

Here is a similar example, this time resizing the image with a smaller version
of the same image (aspect ratio preserved)...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: \( +clone -resize 10 \) -morph 10 \
          -layers TrimBounds -set dispose previous -coalesce \
          -background black -alpha remove \
          -set delay '%[fx:(t&gt;0&amp;&amp;t&lt;n-1)?10:60]' \
          -duplicate 1,-2-1  -loop 0  morph_resize_self.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="morph_resize_self.gif"
      ><IMG SRC="morph_resize_self.gif"    WIDTH=70  HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the 'between' images are more blurry than they probably should be.
This is because the larger image is not only being resized smaller, but it is
also being color blended with the smaller image which was resized larger. </P>

<A NAME="wipe"></A>
<H3>Wipe
<FONT SIZE=-1>- creating a wipe from one image to another</FONT></H3>

This is actually very easy to do.  Just overlay 'slivers' of the new image.
These are directly generated using a simple <A HREF="../crop/#crop_tile" >Tile
Crop</A>. </P>

For example here we 'wipe' from one image to its flipped version, and just for
fun, wipe back again.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: \( -clone 0 -flip -crop 3x0 \) \
                \( -clone 0 -crop 3x0 \) \
                -set delay 10 -loop 0  wipe.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="wipe.gif"
      ><IMG SRC="wipe.gif"    WIDTH=70  HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here is a version from GeeMack on the IM Forums, that implements wipes from
all four directions...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x60 -delay 100 \
      gradient:green-yellow gradient:blue-purple \
      gradient:orange-white gradient:red-black \
      -write mpr:stack -delete 0--1 \
      \
      mpr:stack'[0]' \( mpr:stack'[1]' -set delay 5 -crop 4x0 \) \
      mpr:stack'[1]' \( mpr:stack'[2]' -set delay 5 -crop 0x4 \) \
      mpr:stack'[2]' \( mpr:stack'[3]' -set delay 5 -crop 4x0 -reverse \) \
      mpr:stack'[3]' \( mpr:stack'[0]' -set delay 5 -crop 0x4 -reverse \) \
      -loop 0 wipe_all.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="wipe_all.gif"
      ><IMG SRC="wipe_all.gif"    WIDTH=100  HEIGHT=60
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="distort"></A>
<H3>Animated Distorts
<FONT SIZE=-1>- distorting multiple image based on image index</FONT></H3>

Many operators can use <A HREF="../basics/#arg_percent" >Percent Escapes</A>
in their arguments.  This means you can actually modify the operator so that
it performs slightly differently for each image that is being processed.
</P>

The method involves first <A HREF="../basics/#duplicate" >Duplicating
Images</A> to create 30 (or however many you like) identical copies of the
rose image.  You then modify each image differently using <A
HREF="../transfom/#fx_escapes" >FX Percent Escapes</A> to calculate distortion
values, based of the images index '<CODE>%[fx:t]</CODE>' and the number of
images in the list '<CODE>%[fx:n]</CODE>'. </P>

For example here I translate the image by a calculated amount.
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -duplicate 29  -virtual-pixel tile \
          -distort SRT '0,0 1, 0, %[fx:w*t/n],%[fx:h*t/n]' \
          -set delay 10 -loop 0     rose_diagonal_roll.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="rose_diagonal_roll.gif"
      ><IMG SRC="rose_diagonal_roll.gif"    WIDTH=70  HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And here I rotate the image, depending on the index, but generate a longer pause
if the image index is 0 (the first image).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -duplicate 29  -virtual-pixel Gray \
          -distort SRT '%[fx:360*t/n]' \
          -set delay '%[fx:t==0?240:10]' -loop 0     rose_rotate.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="rose_rotate.gif"
      ><IMG SRC="rose_rotate.gif"    WIDTH=70  HEIGHT=46
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the image index ('<CODE>t</CODE>') has a value from '<CODE>0</CODE>'
to '<CODE>n-1</CODE>', as such the formula '<CODE>%[fx:t/n]</CODE>' will have
a value from '<CODE>0.0</CODE>' to a value just short of '<CODE>1.0</CODE>'.
</P>

This is perfect for a repeating or cyclic animation such as above, but may not
be very good for generating transitions from one image to a new image.  In
that case you want the final frame to have a multiplier of '<CODE>1.0</CODE>'
for the final frame, use the formula '<CODE>%[fx:t/(n-1)]</CODE>'. </P>

This is only a sample of what can now be done easily using image indexes in
'<CODE>%[fx:...]</CODE>' calculations.  Imagine what is possible with a more
complex distortions. </P>

Without the use of image index calculations, the above would have required
an external shell loop, to generate each frame individually, and a separate
step to collect the frames to form the final animation. Examples of such
looped shell scripts are given in <A HREF="../warping/#animations" >Simple
Warped Image Animations</A> as these operators do not allow the use of <A
HREF="../basics/#arg_percent" >Percent Escapes</A> in their arguments. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.6.9-0 <A HREF="../basics/#arg_percent" >Percent Escapes</A> and
  <A HREF="../transform/#fx_escapes">FX Percent Escapes</A> involving image
  indexes, such as '<CODE>%p</CODE>', '<CODE>%n</CODE>',
  '<CODE>%[fx:t]</CODE>' and '<CODE>%[fx:n]</CODE>' were broken.  Typically
  they would only return unhelpful values of either '<CODE>0</CODE>' or
  '<CODE>1</CODE>', and not the actual index and number of images in the
  current image sequence.
</I></FONT></TD></TR></TABLE></P>


<A NAME="label"></A>
<H3>Append a Label
<FONT SIZE=-1>- add a label to whole animation</FONT></H3>

As always there are a number of ways to actually append a label to an image.
</P>

For example, for animations that has an initial background canvas, or one that
only overlays new color to previous frames, then you can just append the label
to the first frame of the image.  The other frames will not remove it.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Here we just add some extra space with "<CODE><A
HREF="../option_link.cgi?splice" >-splice</A></CODE>", and "<CODE><A
HREF="../option_link.cgi?annotate" >-annotate</A></CODE>" some text in it.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert canvas_prev.gif \
          \( -clone 0 -coalesce -gravity South -background white \
             -splice 0x18 -annotate 0 'Label First' \) \
          -swap -1,0 +delete   label_first.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="label_first.gif"
      ><IMG SRC="label_first.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

However this only works for some animations, It would not work for a common <A
HREF="../anim_basics/#cleared" >Cleared Frame Animation</A> which clears or
replaces all the pixels after each frame has been displayed. </P>

For a more general method that works for all animations, we need to first
"<CODE><A HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>" the
animation to the un-optimized <A HREF="#coalesced" >Coalesced Animation</A>.
Then we can add the label to each and every coalesced frame of the animation,
before re-optimizing it.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert canvas_prev.gif -coalesce \
          -gravity South -background white -splice 0x18 \
          -annotate 0 'A Better Label' \
          -layers Optimize labeled_anim.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="labeled_anim.gif"
      ><IMG SRC="labeled_anim.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

Rather than using "<CODE><A HREF="../option_link.cgi?annotate"
>-annotate</A></CODE>" to draw text into the added extra space, you can use a
composition method (see next sections) to compose an image into the added
space.  That way you can prepare a much fancier label to add to the animation.
</P>

Of course doing this can cause some animations not to optimize very well
afterward, especially <A HREF="../anim_basics/#cleared" >Cleared Frame
Animations</A>, but that is the price you pay for adding labels. One solution
for that type of animation is to prepend a 'initial background canvas' that
contains the label, as shon in the section explainging <A
HREF="../anim_basics/#cleared" >Cleared Frame Animations</A>. </P>

Also note that adding a label to an animation can result in many extra colors
being added. This could overflow the GIF color limits, as such you may have to
be prepared to color optimize your animation as well. A very difficult task
that is best to avoid if possible (see <A HREF="../anim_opt/#color_opt" >Color
Optimization</A>).  This can be a problem for any general modification to any
animation.  </P>

<A NAME="flatten"></A>
<A NAME="remove_trans"></A>
<H3>Remove Transparency
<FONT SIZE=-1>- add a solid color background</FONT></H3>

A large number of animations you find on the web have a transparent
background.  These are very useful as you can place them on web pages without
needing to worry about any background pattern that may be present.  </P>

However when processing animations, especially when applying other image
operators such as "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>" and "<CODE><A HREF="../option_link.cgi?blur"
>-blur</A></CODE>", such an animation has problems.  The general solution is
<A HREF="../masking/#remove" >Remove Transparency</A> from the image,
generally by somehow overlaying them onto a specific color, such as the
specific color that us used as the background to a web page. <?P>

<A HREF="../images/script_k.gif"
    ><IMG SRC="../images/script_k.gif"     WIDTH=53  HEIGHT=54
          ALIGN=right VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</P>

For example here I have a simple transparent overlay animation of a letter 'K'
being drawn as if by an invisible hand.  </P>

As this GIF animation is drawn with transparency, and only overlays images
onto the previous frames (adding pixels, never removing them), a simple way of
setting a background color (or image) is to add it to just the first frame of
the animation.  All the other frames contain a transparent color for the
background, so will not effect the result. </P>

Here we use the <A HREF="../layers/#flatten" >Flatten Operator</A> to overlay
the first frame of the animation onto a '<CODE>LimeGreen</CODE>' background
color.  We can use "<CODE><A HREF="../option_link.cgi?flatten"
>-flatten</A></CODE>" for this as we are only applying it to a single image,
and NOT the whole animation. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif \( -clone 0 -background LimeGreen -flatten \) \
          -swap 0,-1 +delete      script_k_flatten_0.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="script_k_flatten_0.gif"
      ><IMG SRC="script_k_flatten_0.gif"     WIDTH=53  HEIGHT=54
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

It is also important to not that the original first frame was only a single
pixel in size. The <A HREF="../layers/#flatten" >Flatten Operator</A> not only
colored the background, but also expanded that frame to its full size.  that
is it 'filled out' the frame as well. </P>

Note however that as only the first frame of the animation has been colored.
This method is preferred, as any optimization (such as the heavy optimization
that this animation contains) is preserved. </P>

Coloring the first frame will not work for all GIF animations. It only works
for simple <A HREF="../anim_basics/#overlay" >Overlay Animations</A>. </P>

For a general method of removing the transparency from an animation, you need
to first "<CODE><A HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>"
the animation, and then actually <A HREF="../masking/#remove" >Remove
Transparency</A> from all the frames, using the <A
HREF="../masking/#alpha_remove" >Alpha Remove Operator</A>. This time lets
do this using a '<CODE>Tomato</CODE>' background color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce   -background Tomato -alpha remove \
          -layers Optimize   script_k_alpha_rm.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="script_k_alpha_rm.gif"
      ><IMG SRC="script_k_alpha_rm.gif"     WIDTH=53  HEIGHT=54
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course the resulting optimization may not be the as optimal as the
original, but the animation no longer has any transparency in it.  As an
additional side-effect, any '<CODE><A HREF="../anim_basics/#background"
>Background</A></CODE>' dispose settings in the animation will have been
converted to either '<CODE><A HREF="../anim_basics/#none" >None</A></CODE>' or
'<CODE><A HREF="../anim_basics/#previous" >Previous</A></CODE>', by the <A
HREF="../anim_opt/#frame_opt" >Frame Optimization</A> process, as transparency
is no longer an issue. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  <A HREF="../masking/#alpha_remove" >Alpha Remove</A> was added to IM v6.7.5.
  If your IM version is older you will need to use an alternative method such
  as using a side effect of the <A HREF="../crop/#border" >Border
  Operator</A>.  See <A HREF="../masking/#remove" >Remove Transparency</A> for
  details of this and other methods.
</I></FONT></TD></TR></TABLE></P>

A more complex background handling such as underlaying a background image or
pattern, requires a much more complex handling of animations, than the simple
modifications we have looked at so far.  This is what we will look at next. </P>

<HR><!-- ------------------------------------------------------------------ -->

<A NAME="compose"></A>
<H2>Multi-Image Alpha Composition</H2>

The next level of animation handling requires you to be able to compose single
static images either over, or under an existing animation.  That is general <A
HREF="../compose/#compose" >Alpha Composition</A>.  This gets even trickier
when two separate sets of images are being merged. </P>

Before IM v6.3.3-7 multi-list composition was only possible using specially
designed API scripts, or shell scripts that saved and merged individual frames
of the animation.  Neither was very nice techniques, but that was all that was
possible. That is now changed. </P>

<A NAME="compose_draw"></A>
<H3>Draw Images
<FONT SIZE=-1>- draw an image onto a list of images</FONT></H3>

The "<CODE><A HREF="../option_link.cgi?draw" >-draw</A></CODE>" operator has the
ability to compose a <I>source</I> image on top of a list of images. It is
also the only multi-image alpha composition method that you could use in
the "<CODE><A HREF="../basics/#mogrify" >mogrify</A></CODE>" command, or
against multiple images, before IM v6.3.3-7. </P>

The reason this Alpha Composition technique was so important was because it
allowed you to specify an image as a separate argument to the current image
list.  That is within the quoted <A HREF="../draw/#mvg" >Magick Vector
Graphic</A> language of "<CODE><A HREF="../option_link.cgi?draw"
>-draw</A></CODE>". </P>

Because of its historical importance, I will show its use in detail,
especially for users which still have older versions of IM. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example here I overlay rose image over the whole animation.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert canvas_prev.gif -coalesce \
          -gravity NorthEast  -draw 'image over 5,5 0,0 "rose:"' \
          -layers Optimize   draw_over.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="draw_over.gif"
      ><IMG SRC="draw_over.gif"            WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This allows you to <A HREF="../compose/#compose" >Compose</A> an external
<I>source</I> image over every image in the current image sequence.  </I>
</P>

This is good enough for most purposes.  For example by using the '<CODE><A
HREF="../compose/#dstover" >Dst_Over</A></CODE>' composition method you could
also place an image 'under' the animation as a static background. </P>

For example here we 'underlay' a "<CODE>netscape:</CODE>" built-in image,
though it could have been any external image file...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce \
              -draw 'image DstOver 0,0 0,0 "netscape:"' \
          -layers Optimize   script_k_netscape.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="script_k_netscape.gif"
      ><IMG SRC="script_k_netscape.gif"     WIDTH=53  HEIGHT=54
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the size of the animation has not changed, as it is the
<I>destination</I> images define the final size of the alpha composition. </P>

If you did want to create a larger canvas, you had to adjust the size and
offsets of the animation appropriately to accomidate the background.  For
example using a <A HREF="#repage_relative" >Relative Repage</A> of the
animation before coalescing.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif  -repage 100x100+20+20\!   -coalesce \
              -draw 'image DstOver 0,0 0,0 "granite:"' \
          -layers Optimize   script_k_granite.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="script_k_granite.gif"
      ><IMG SRC="script_k_granite.gif"     WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Also if you wanted to use an image that had already been read-in, created, or
modified, then you need to use a  "<A HREF="../files/#mpr" >MPR: Memory
Program Register</A> to provide you with a 'read source' for that image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 53x54 xc:SkyBlue -fill DodgerBlue \
          -draw 'circle 26,27 24,8' -write mpr:bgnd +delete \
          \
          script_k.gif -coalesce \
          -draw 'image DstOver 0,0 0,0 "mpr:bgnd"' \
          -layers Optimize   script_k_mpr_bg.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="script_k_mpr_bg.gif"
      ><IMG SRC="script_k_mpr_bg.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

That is about the limit of Draw Alpha Composition methods.  No overlaying the
animation images 'over' a <I>destination</I> image of unknown size, and no way
to merge two separate multi-image sequences together. </P>

That was until... </P>


<A NAME="composite"></A>
<A NAME="shadow"></A>
<H3>Layers Composition
<FONT SIZE=-1>- alpha composition for image lists</FONT></H3>

With IM v6.3.3-7 the "<CODE><A HREF="../option_link.cgi?layers"
>-layers</A></CODE>" method, '<CODE><B>Composite</B></CODE>' was added
allowing you compose two completely separate sets of images together.
(For a short summary see <A HREF="../layers/#layer_composite" >Layering Images,
Layer Composite</A>)</P>

To do this on the command line, a special  '<CODE><A HREF="../files/#null"
>null:</A></CODE>' marker image is needed to define where the first
<I>destination</I> list of images ends and the overlaid <I>source</I> image
list begins. But that is the only real complication of this method. </P>

So lets try it out by creating a set of shadows from set of images, then
overlaying the original image over those shadow images...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce  coalesced_k.gif

  convert coalesced_k.gif  -background black -shadow 100x3+2+5 \
          -background SkyBlue -alpha remove    shadows_k.gif

  convert shadows_k.gif  null:  coalesced_k.gif \
          -layers Composite          compose_shadow.gif

  gif_anim_montage compose_shadow.gif compose_shadow_frames.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="coalesced_k.gif"
      ><IMG SRC="coalesced_k.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
   <A HREF="shadows_k.gif"
      ><IMG SRC="shadows_k.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
   <A HREF="compose_shadow.gif"
      ><IMG SRC="compose_shadow.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE><DIV ALIGN=center>
   <A HREF="compose_shadow_frames.gif"
      ><IMG SRC="compose_shadow_frames.gif"
            ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The above example is very important, so I will explain it in detail. </P>

First we generate a <A HREF="../anim_basics/#coalesce" >Coalesced</A> version
of our animation so as to remove any <A HREF="../anim_opt/" >Optimizations</A>
that may be present to make the animation ready for some serious processing,
without any GIF optimizations interfering with the processing.
</P>

Next we created an animated shadow image from our coalesced animation, and <A
HREF="#remove_trans" >Remove Transparency</A>, as GIF cannot handle
semi-transparent shadows. This is the animation that want to add 'under' our
original animation.  It has the same number of frames, and even the same
timings as the original animation.   This correspondence is important, so
don't forget it.  </P>

Now we read in the two animation or layer sequences, but we add a special
'<CODE><A HREF="../files/#null" >null:</A></CODE>' image separator between
them, so that ImageMagick knows when one sequence ends and the next sequence
begins.  This image separator is automatically removed by the next all
important "<CODE>-layer composite</CODE>" operation.  Other API's should be
able to use separate 'Wands' of images, rather than a single sequence with
a special separator. </P>

The layers composition is then performed just as if these two animations or
image sequences were just a simple single image, rather than a sequence of
multiple images.  Each pair of images, one destination, and one source, are
composited together, to generating a merged (composited) sequence on images.
</P>

The final result is that we have added shadows to our original animation
sequence, which is ready for GIF optimizations, or just direct use. </P>

<BR>

Now you can do all the above steps in a single command.  However you can't
just use "<CODE><A HREF="../option_link.cgi?clone" >-clone</A></CODE>" to
create a copy of the original sequence, since we don't really know (or want to
know) how many images are in the sequence.  Instead you can use a  "<A
HREF="../files/#mpr" >MPR: Memory Program Register</A> to save a whole list of
images.  It's sort of like taking a snapshot of the whole image sequence
currently in memory, and then reading it in again later. </P>

The result is a command like this,  though I used a different colored
background.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce -write mpr:images \
          -background black  -shadow 100x3+2+5 \
          -bordercolor Wheat -border 0 \
          null:    mpr:images    -layers Composite \
          composite_shadow.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="composite_shadow.gif"
      ><IMG SRC="composite_shadow.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This version actually works better as we did not loose the offset information
that the <A HREF="../blur/#shadow" >Shadow Operator</A> generates (GIF's
cannot save a negative offset, so resets it to zero).  We could fix that in
the above by using a MIFF file format for the intermediate images rather than
GIF, or, as you will see in the next example, by using a "<CODE><A
HREF="../option_link.cgi?geomtry" >-geometry</A></CODE>" composition
offset. </P>

Basically these examples shows that the <A HREF="#composite" >Layers Composite
Operator</A> actually understands the individual Virtual Canvas Offset
("<CODE><A HREF="../option_link.cgi?page" >-page</A></CODE>") settings and
will handle them, just like a <A HREF="../layers/#flatten" >Layers Flatten</A>
or better still <A HREF="../layers/#merge" >Layers Merge</A> operators would
handle them. </P>

But the <A HREF="#composite" >Layers Composite Operator</A> also understands
the use of a Composite Geometry ("<CODE><A HREF="../option_link.cgi?geometry"
>-geometry</A></CODE>") offset (zero by default), to control the overall
placement of the whole overlay image sequence.  It even understands the
effects of "<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>"
on that global offset. </P>

For example.. let's overlay our original 'K' animation 'South' of the generated
shadow animation...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert shadows_k.gif  null:  coalesced_k.gif  \
          -geometry +0-10 -gravity South  -layers Composite \
          composite_south.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="composite_south.gif"
      ><IMG SRC="composite_south.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The above also shows that just like normal two image <A
HREF="../compose/#compose" >Alpha Composition</A>, it is the destination image
sequence that controls the final output image size, and any composition overlay
will be clipped to the destination canvas image.  As such you should ensure
all the destination images is large enough to contain your final results.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The resize capability of "<CODE><A HREF="../option_link.cgi?geometry"
  >-geometry</A></CODE>" is not strictly part of the composite operation, it
  only resizes the last image of the current image sequence. As such it will
  not do what you expect if used with multi-image <A HREF="../#composite"
  >Layers Composition</A>.  See <A HREF="../resize/#geometry" >Resize
  Geometry</A> for details.
</I></FONT></TD></TR></TABLE></P>

Basically Layers Composition is very much like normal composition. <BR>
Quite simple really.  <I>Did I say simple?</I> </P>

<BR>

<B>Layers Composition details...</B>...</P>

As you saw above the command line version of "<CODE><A
HREF="../option_link.cgi?layers" >-layers</A> Composite</CODE>" uses the first
'<CODE><A HREF="../files/#null" >null:</A></CODE>' image found in the current
image list as a marker to separate the two lists.  The two image lists are
separated and the '<CODE>null:</CODE>' junked before the two lists are <A
HREF="../compose/#compose" >Alpha Composited</A> together, two images at a
time. </P>

Only an image generated from the special  '<CODE><A HREF="../files/#null"
>null:</A></CODE>' image source can be used for the marker, and if not found
an error will be reported. You currently cannot read this '<CODE><A
HREF="../files/#null" >null:</A></CODE>' marker image from a pipeline (at
least not at this point), only generate it when needed. </P>

Layer composition is also rather more complex than a simple, two image <A
HREF="../compose/#compose" >Alpha Composition</A>, as the images virtual
canvas of the image list also accounted for.  Normally alpha composition
ignores any virtual canvas size and offset for positioning purposes, using
only the images actual size.  This special layers method uses the virtual
canvas information, for geometry positioning, so as to align the two image
sequences. </P>

To this end any virtual canvas offset a sub-frame has is also added to the
normal "<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>"
adjusted, "<CODE><A HREF="../option_link.cgi?geometry" >-geometry</A></CODE>"
composition offset, to work out the position of the image overlay. </P>

Only the virtual "<CODE><A HREF="../option_link.cgi?page" >-page</A></CODE>"
canvas size of the first image of each list is used to work out the "<CODE><A
HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" adjustment to the
"<CODE><A HREF="../option_link.cgi?geometry" >-geometry</A></CODE>"
composition offset.  The canvas size of later images is ignored, with only the
individual virtual "<CODE><A HREF="../option_link.cgi?page" >-page</A></CODE>"
offset being added to the calculated "<CODE><A
HREF="../option_link.cgi?geometry" >-geometry</A></CODE>" offset. </P>

In other words "<CODE><A HREF="../option_link.cgi?layers" >-layers</A>
Composite</CODE>" is designed for alpha composition of 'layers' or
'animations', and the special requirements of such image lists. </P>

<B>Caveats</B>...</P>

You do however still need to be careful with image lists you are overlaying.
</P>

If for example if the <I>destination</I> list images are not large enough, or
positioned incorrectly to contain the overlaid <I>source</I> image, the
overlaid image will be clipped, or miss the destination image completely.  For
this reason it is a good idea to <A HREF="../anim_basics/#coalesce"
>Coalesce</A> the <I>destination</I> images to the full canvas size, before
overlaying smaller <I>source</I> images.  For example see <A HREF="#append"
>Side-by-Size Animation Append</A> examples below where canvas size needed to
be expanded to provide space for the appended images. </P>

Also if the <I>source</I> image list is an GIF animation, then you may need to
be sure that the sub-frames are clean of things like: <A
HREF="../anim_opt/#compress_opt" >Compression Optimizations</A>, and fancy <A
<A HREF="../anim_opt/#frame_opt" >Frame Optimizations</A>; or you may have
problems.  On the other hand a <A HREF="../anim_basics/#cleared" >Cleared
Frame Animation</A> or <A HREF="../anim_basics/#coalesced" >Coalesced
Animation</A> can be directly '<CODE><A HREF="#composite"
>Composite</A></CODE>' without any problems. </P>

Just remember that <A HREF="#composite" >Layers Composition</A> does not
understand any existing <A HREF="../anim_basics/#dispose" >GIF Disposal
Methods</A> that may be present in the images, though it preserves the
<I>destination</I> GIF animation meta-data, such as: <A
HREF="../anim_basics/#dispose" >Dispose Method</A>, <A
HREF="../anim_basics/#delay" >Frame Delay</A>, and <A
HREF="../anim_basics/#loop" >Iteration Loop Limits</A>. </P>

The one exception to this is given in a special case below. </P>


<A NAME="composite_single"></A>
<H3>Single Image Composition
<FONT SIZE=-1>- compose images with a single image</FONT></H3>

Normally two lists of images of equal length are composed together, one image
pair at a time until either of the image lists runs out. Neither list of
images will be repeated. The composition will just stop.  You are left with
just the original <I>destination</I> image list with the added compositions.
The '<CODE><A HREF="../files/#null" >null:</A></CODE>' separator image, and
all the <I>source</I> images are deleted from the current image list. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  An API interface to this layers method, should allow you produce two separate
  image lists, and it will be left up to you to delete both input image lists
  that was used to generate the resulting list of images. The '<CODE><A
  HREF="../files/#null" >null:</A></CODE>' separator should not be needed.
</I></FONT></TD></TR></TABLE></P>

However if one of the lists only contains a single image, that image will be
composed against all the images in the other list.  It does not matter if that
single image is a <I>source</I> image or a <I>destination</I> image.  The
method will do the composition against the other image list, and preserve the
GIF meta-data of the <I>image list</I>, rather than the single image, even if
that image is the <I>destination</I> image. </P>

This 'compose against a single image' is a special case for <A
HREF="#composite" >Layers Composition</A>, and is very useful for adding a
background to an animation (see next), or inserting a static object into an
animation.  </P>


<A NAME="background"></A>
<H3>Static Background
<FONT SIZE=-1>- compose over a larger background</FONT></H3>

For example using this special <A HREF="#composite_single" >Single Image
Layer Composition</A> method we can compose an animation over a
a static background...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<r>  convert -size 100x100 plasma:fractal null: \( script_k.gif -coalesce \) \
              -gravity Center   -layers Composite \
          -layers Optimize   composite_background.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="composite_background.gif"
      ><IMG SRC="composite_background.gif"            WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As the background image is the <I>destination</I>, it defines the final size
of the animation, but all the meta-data (delays, labels, comments, etc) will
come from the source image list.  Normally that information comes from the
destination image list.  This is only time the source image provides the
meta-data information during an image composition. </P>

Also note that as  <A HREF="#composite" >Layers Composition</A> understands
"<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>", the image
is properly centered, without you needing to do the calculations yourself.
However if the source frames contained offsets, these will also be added to
the gravity defined position, so that the relative position of all the
sub-frames remains correct. </P>

Note that as the animation "<CODE><A HREF="../images/script_k.gif"
>script_k.gif</A></CODE>" is actually a type of <A
HREF="../anim_basics/#overlay" >Overlay Animation</A> their are alturnative
methods of adding a static background to the animation. See the section above
on <A HREF="../anim_basics/#remove_transparency" >Remove Transparency</A> for
an example (onto a solid color, but can be any image).  </P>

The same is true for the even simpler  <A HREF="../anim_basics/#cleared"
>Cleared Frame Animation</A>. In that case you don't even need to <A
HREF="../anim_basics/#coalesce" >Coalesce</A> the animation first, but can
directly compose it onto a background image.  However you may need to
"<CODE><A HREF="../option_link.cgi?set" >-set</A></CODE>" the
'<CODE>dispose</CODE>' method being used afterward or better still <A
HREF="../anim_opt/#optimize" >Optimize</A> the <A
HREF="../anim_basics/#coalesced" >Fully Coalesced Animation</A>. </P>

However any other type of optimized animation, will require that "<CODE><A
HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>" operation, and full
composition with all the animation frames.  As such it is probably better to
to use the above method, just to be sure all GIF animations are handled
correctly.  </P>

<HR><!-- ------------------------------------------------------------------ -->

<A NAME="glitter"></A>
<H2>All that Glitters...</H2>

<H3>Glitter Animations</H3>

The above <A HREF="#composite" >Layers Composition</A> methods makes it
a lot easier to generate simple animations, such as glitter. </P>

First we need some glitter that is large enough to cover the image being
processed.  Here I will generate a three image glitter animation from some <A
HREF="../canvas/#random_specks" >Random Specks Images</A>. </P>

First this is a raw black and white glitter on pure transparency, generating 3
frames of glitter by separating the three color channels into black and white
<A HREF="../color_basics/#channels" >Channel Images</A>.  It is basically a raw
starting point for generating any other type of glitter.  The
'<CODE>30%</CODE>' threshold controls how many 'dots' there are per frame.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<r>  convert -size 100x100 xc: +noise Random -separate \
          null: \( xc: +noise Random -separate -threshold 30% -negate \) \
              -compose CopyOpacity -layers composite \
          -set dispose background -set delay 20 -loop 0   glitter_overlay.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="glitter_overlay.gif"
     ><IMG SRC="glitter_overlay.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

From this 'raw' glitter you can overlay it using a '<CODE><A
HREF="../compose/#screen" >Screen</A></CODE>' alpha composition to only
brighten some color, to generate a glitter of a specific color. I use the <A
HREF="#flatten" >Border Flatten Method</A> (above).

Just a plain color...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert glitter_overlay.gif \
          -compose Screen -bordercolor GoldenRod -border 0x0  glitter_gold.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="glitter_gold.gif"
     ><IMG SRC="glitter_gold.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Using the <A HREF="#composite" >Layer Composition</A>, you can also use a
single image, or even multiple images to provide a variable colored
background.  For example here I generate three <A
HREF="../canvas/#plasma_fractal" >Fractal Plasma</A> images, to provide a
slightly randomised coloring to the glitter pattern.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<r>  convert glitter_overlay.gif null: -size 100x100 \
          plasma:red-firebrick plasma:red-firebrick  plasma:red-firebrick \
          -compose Screen -layers composite    glitter_plasma.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="glitter_plasma.gif"
     ><IMG SRC="glitter_plasma.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course there are lots of other glitter styles and movement patterns.
You can find and download many such glitter tiles from the WWW. </P>

To apply a glitter like this to an image, there are a number of different
methods.  Typically you mask the glitter to a specific shape and or
background. </P>

For this can either use a transparent shape (composited using <A
HREF="../compose/#dstin" >DstIn</A>)

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 -fill white -background none -font Candice \
          -gravity center -pointsize 90 label:A   glitter_mask_trans.gif
  convert glitter_plasma.gif null: glitter_mask_trans.gif -matte \
          -compose DstIn -layers composite        glitter_masked_trans.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="glitter_mask_trans.gif"
     ><IMG SRC="glitter_mask_trans.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="glitter_masked_trans.gif"
     ><IMG SRC="glitter_masked_trans.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Or a black and white mask image (composited using <A
HREF="../compose/#copyopacity" >CopyOpacity</A>)

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 -fill white -background black -font Candice \
          -gravity center -pointsize 90 label:A    glitter_mask.gif
  convert glitter_plasma.gif null: glitter_mask.gif +matte \
          -compose CopyOpacity -layers composite   glitter_masked.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="glitter_mask.gif"
     ><IMG SRC="glitter_mask.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="glitter_masked.gif"
      ><IMG SRC="glitter_masked.gif"      WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Ok we have an area that has been masked, you can complete the image,
generally by overlaying the masked glitter on the original image. </P>

However in our case I'll underlay a background, and overlay an border.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert glitter_masked.gif -size 100x100 \
          null: gradient:gold1-gold4 -compose DstOver -layers composite \
          null: \( -fill none -background none -stroke white -strokewidth 2 \
                   -font Candice -gravity center -pointsize 90 label:A \) \
              -compose over -layers composite      glittered_letter.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="glittered_letter.gif"
     ><IMG SRC="glittered_letter.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This last example also cleaned up any GIF transparency problems
by the removal of all transparency from the final image and the overlay
of a smooth border around the glittered region. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
    While I may have used GIF format images in the above to allow me to
    display individual steps of the process, in practice you would either
    combine all the steps into a single command, or use a better intermediate
    image file format such as MIFF. That is done to avoid the inherent
    problems of the GIF format, until we have finished.
</I></FONT></TD></TR></TABLE></P>

<A NAME="glitter_tiles"></A>
<H3>Glitter Tiles
<FONT SIZE=-1>- 'hole in the image' underlays</FONT></H3>

As mentioned there are a lot of pre-prepared animated glitter tile images
available on the WWW (do a search for "glitter tiles"). One source is a <A
HREF="https://legacy.imagemagick.org/MagickStudio/scripts/MagickStudio.cgi" >IM
Studio</A> user, <I><A HREF="forum_link.cgi?u=143" >scri8e</A></I> and his web
site <A HREF="http://www.scri8e.com/stars" >Moons Stars</A>. Be warned however
that I find most glitter tiles to be rather horrible looking, or too fast.</P>

<A HREF="../images/glitter_blue.gif"
   ><IMG SRC="../images/glitter_blue.gif" ALIGN=right HEIGHT=48 WIDTH=48></A>
For this example I found and modified a blue glitter tile with some small star
patterns in it.  I thought it would be useful for giving the IM wizard
a glittering clothing, making him look really magical. </P>

Probably the easiest ways to glitter an existing image is to cut holes in the
image rather than trying to mask out the glitter pattern.  This however only
works for images that do not contain transparency to start with.
Alternatively, you could remove the transparency from an image, and when
finished, re-add the original transparency. </P>

So lets take the IM Examples logo, and use <A HREF="../color_basics/#replace"
>Color Replacement</A> to cut out all the blue parts of the image.  Sort of
giving our wizard a cloak of invisibility ;-)

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert logo.gif -matte -fuzz 33% -transparent blue logo_holed.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/logo.gif"
     ><IMG SRC="../images/logo.gif"      WIDTH=180 HEIGHT=180
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="logo_holed.gif"
     ><IMG SRC="logo_holed.gif"      WIDTH=180 HEIGHT=180
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note the use of the <A HREF="../color_basics/#fuzz" >Fuzz Factor</A> to adjust
just how much of the blue color should be removed. Be warned however that this
is not a nice way to cut out an area of an image as it produces <A
HREF="../antialiasing/#floodfill" >Aliased Edges</A>. But no simple feathered
cut-out feature is currently available as yet. </P>

Okay we have an image with a hole (or lots of holes). The next step is to
underlay glitter tile image.  The problem is the above tile is too small, it
will not cover the whole image! </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The following uses a tricky technique to tile the multi-image glitter tile.
However you still need to give a size that is larger than the original image
to ensure that you can cover it completely.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert glitter_blue.gif -virtual-pixel tile \
          -set option:distort:viewport 180x180 -distort SRT 0 \
          glitter_blue_tiled.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="glitter_blue_tiled.gif"
     ><IMG SRC="glitter_blue_tiled.gif"      WIDTH=180 HEIGHT=180
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Now lets dress our wizard in his new cloths, by placing the above tiled
glitter under the 'holey' image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert logo_holed.gif null: glitter_blue_tiled.gif \
          -compose DstOver -layers composite \
          -loop 0 -layers Optimize logo_glittered.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="logo_glittered.gif"
     ><IMG SRC="logo_glittered.gif"      WIDTH=180 HEIGHT=180
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

You can of course do all these steps all in the one command. Here I limit the
hole generation to just the wizards cloak, which has two separate specific
parts.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert logo.gif -matte -fuzz 10% -fill none \
          -draw 'matte 120,150 floodfill  matte 150,120 floodfill' \
          null: \( glitter_blue.gif -virtual-pixel tile \
            -set option:distort:viewport 300x300 -distort SRT 0 \) \
          -compose DstOver -layers composite \
          -loop 0 -layers Optimize logo_glitter_cloak.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="logo_glitter_cloak.gif"
     ><IMG SRC="logo_glitter_cloak.gif"      WIDTH=180 HEIGHT=180
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The holes in the above were created using <A HREF="../draw/#matte" >Matte Fill
Draw primitives</A> to select an actual point and color from the image for the
color replacement.  This means I don't need to use such a high  <A
HREF="../color_basics/#fuzz" >Fuzz Factor</A> as I did originally, as my
comparison color came from the specific areas selected. </P>

Also I used a larger tiling 'viewport' so as to ensure I completely cover the
image being tiled, without needing to know its exact dimensions. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center> <TR
       VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The use of the <A HREF="../distorts/#distort" >General Distortion
  Operator</A> and its special "<CODE>viewport</CODE>' option (added to IM
  6.3.6-0), also gives you the opportunity to modify the distortion pattern
  in other special ways.  Such as give it a 'perspective' look or rotate the
  pattern into a non-rectangular angles.  Doing this can enhance the tiling
  so it does not have such an uniform look about it. </P>

  For some example see <A HREF="../distorts/#affine_tile" >Affine
  Tiling</A>.

</I></FONT></TD></TR></TABLE></P>


<A NAME="sparkle"></A>
<H3>Sparkles
<FONT SIZE=-1>- overlay mostly transparent glitter</FONT></H3>

The major problem with the two previous glitter animation techniques is that
it is an all or nothing type of replacement.  You cannot use the original
shading or background of the image. </P>

Also the glitter is completely restricted to the area that was masked.  It can
not extend beyond the bounds of the area involved.  As such some small areas,
such as the wizards 'hat' in the previous example, does not handle glitter
very well. </P>

Sparkles are different, in that the animation added is mostly transparent.
as a consequence the original image, can still show through.  Such animations
are usually added to an image one of two ways. Either the animation overlay
itself is transparent, or it is of the form of black background with white
'sparks' where the image should be brightened. </P>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

Here is an example of a mostly transparent 'sparkles' overlay. </P>

<I>Example Here</I> </P>

As you can see you can have colorful sparkle overlays when this form is used.
</P>

The major problem with this is that a GIF animation was used to save it,
(which is typically the case), so the overlay is heavily aliased.  That is, it can
not contain any semi-transparent pixels to smooth out the look of the overlaid
image.  If it did, you would have get horrible black halos around the 'sparkles'
in the final result. </P>

Lets mask out and overlay this onto the wizard.

<I>Example Here</I> </P>


The other form of sparkles is white sparkles on a black background (a
gray-scale image).  These are masked and overlaid so as to brighten the
image to add the sparkle. </P>

For example...

<I>Example Here</I> </P>

One of the best things about sparkles is you can generate a sequence of
frames where sparkles slowly appear and then disappear.  This can get quite
complex, but is no very hard to do.

<I>Example Here</I> </P>


<A NAME="flares"></A>
<H3>Adding Flares and Stars Animations</H3>

Where glitter consists of single points of brightness, and sparkles can
overlay some areas of an image, flares are usually added individually. </P>

A 'flare' is basically a point that flashes to cover a large area for just a
moment.  A 'star' is similar except the coverage is more in the form of 'rays'
of brightness. </P>

These usually are 'seeded' from specific points, but the result often extends,
at least momentarily well beyond the seeding area.  For example a flare that
is mask limited to a specific area looks very very stupid and unnatural. </P>

The more difficult aspects of flares is locating good 'seed' points
and timing of multiple flares appropriately. </P>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<PRE>Final example I want to create...  A 'sparkle' the travels up the wizards
wand, then flares, and dissolves into a number of small sparkle flares over an
area.  Then the sequence repeats.</PRE>

<HR><!-- ------------------------------------------------------------------ -->

<A NAME="resize"></A>
<H2>Resizing Animations</H2>

<A NAME="resize_problems"></A>
<H3>Problems with Resizing Animations</H3>

The biggest problem with resizing GIF animations is that the "<CODE><A
HREF="../option_link.cgi?resize" >-resize</A></CODE>" operator is designed
specifically to make the resulting images as close to ideal (after the resize)
as possible.  It does this by merging and generating lots of additional colors
in the image to make it look better. </P>

The resulting images are far from ideal for saving to the limited GIF file
format. With GIF's limited color table, this results in heavy <A
HREF="../quantize/#intro" >Color Reductions</A> in the resized images. For a
single  GIF image that is not so bad, but for a GIF animations, the default <A
HREF="../quantize/#dither_error" >Error Correction Dithering</A> of the
reduced color set produces problems, in 'dither noise' between frames, and in
turn a bad frame optimization for final file size. </P>

It is even worse when transparent colors are also being used, which is a
common practice for typical GIF animations used for web pages.  Transparency
is also commonly used for <A HREF="../anim_opt/#compress_opt" >Compression
Optimization</A> techniques, for animations that would otherwise not need it.
</P>

What happens is that "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>" produces semi-transparent pixels in the overlay images.
Then when the images are saved back to a GIF file format, these pixels are
then converted to either fully-transparent or fully-opaque, both producing
major color distortions in the resulting animation. </P>

If any form of optimization is used... frame, transparency or LZW... then the
transparency effects will basically result in a <B>disastrously resized GIF
animation</B>.  That is the facts, Jack! So you will need to live with it. </P>

Even if you avoid using "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>", by using "<CODE><A HREF="../option_link.cgi?sample"
>-sample</A></CODE>", you will still have major problems unless you "<CODE><A
HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>" the animation
first.</P>


<A NAME="resize_methods"></A>
<H3>Resizing Animation Techniques</H3>

As shown above, there are are serious problems in resizing GIF animations,
none of which are easily resolved.  The solution also generally depends on
just what type of image was resized in the first place, be it cartoon like, or
a real-world video image. </P>

Here are the methods I know about, or have been contributed... </P>

<H3>Avoid resizing</H3>

If it is at all possible, DO NOT RESIZE. </P>

You can for example <A HREF="#crop_viewport" >Canvas or Viewport Crop</A> your
animation to just trim it down to fit in the space you need it for. </P>

Or you can generate the GIF animation at the right size in the first place.
</P>

Neither technique is typically the best option, but if you can, consider it,
as it will save you a lot of problems and hair pulling. </P>

<A NAME="resize_direct"></A>
<H3>Direct resizing</H3>

As mentioned about directly using "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>" will have problems, either with number of colors for each
frame, or with semi-transparent colors. </P>

For example this goes really bad...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -resize 20x20 script_k_direct.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="../images/script_k.gif"
      ><IMG SRC="../images/script_k.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR><IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="script_k_direct.gif"
      ><IMG SRC="script_k_direct.gif"      WIDTH=20 HEIGHT=20
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now that did not work very well, and that is because the original image has
some heavy frame optimizations.  Each 'frame' of the animation is not the same
size, and the "<CODE><A HREF="../option_link.cgi?resize" >-resize</A></CODE>"
will resize each and every frame image completely separately from the other
images. </P>

That is the above resized the actual frame images, and not the virtual canvas
of the animation to the size given.  Actually I am surprised the resulting
animation wasn't more 'crazy' than just the blank area shown. </P>

That brings us to the first point about resizing animations. First ensure that
all the frames are fully defined, and ALL optimization has been removed. In
other words <A HREF="../anim_basics/#coalesce" >Coalesce</A> the animation
before attempting to resize it.  For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce  -resize 20x20  script_k_direct2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="../images/script_k.gif"
      ><IMG SRC="../images/script_k.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR><IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="script_k_direct2.gif"
      ><IMG SRC="script_k_direct2.gif"      WIDTH=20 HEIGHT=20
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The next problem is one of transparency colors.   If you look at the result
above you will see that the edges of the smaller animation are horribly aliased
('staircased').  That is because GIF cannot save the semi-transparent colors
the "<CODE><A HREF="../option_link.cgi?resize" >-resize</A></CODE>" operator
generated. </P>

The colors within the animated object will also have had the colors merged
together to produce new colors, but that is usually not nearly so bad as the
edge aliases. </P>


<A NAME="resize_flatten"></A>
<H3>Resize with Flatten, A General Solution.</H3>

The best idea when generating a GIF thumbnail is to avoid the problems of
transparency entirely.  That is <A HREF="#flatten" >Flatten the Animation</A>,
either before or after resizing the animation.  That way you do not loose the
'anti-aliasing' of edges in resized images.  </P>

In fact I have found most good GIF animation websites do exactly that when
generating their GIF animation thumbnails.  Of course the thumbnail will then
be limited to use on a specific colored background, usually 'white', but
sometimes 'black', or 'silver' (web page grey) though that last is less common
these days. </P>

For example, here I create a smaller thumbnail on a background color
appropriate for this web page.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce \
          -bordercolor LightSteelBlue -border 0 \
          -resize 20x20  -layers Optimize   script_k_thumbnail.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="../images/script_k.gif"
      ><IMG SRC="../images/script_k.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR><IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="script_k_thumbnail.gif"
      ><IMG SRC="script_k_thumbnail.gif"      WIDTH=20 HEIGHT=20
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is the recommended solution for general GIF thumbnail handling. Any other
method requires either human control, or a very sophisticated GIF thumbnail
handling logic. </P>

<A NAME="resize_colors"></A>
<H3>Color Table Blowout</H3>

The biggest problem (as I mentioned at the start of this section) is that huge
number extra colors are generated in the image, especially near lines, and the
edges of adjoining color areas. You also get resize-halo of semi-transparent
colors around the edges of images. </P>

This in turn enlarges the size color table needed for a simple minimal colored
animation, which in turn means a larger file size when a resize simple
animation is saved.  Worse still each and every frame in the resizes
animation, probably generates a different set of colors, further enlarging the
file size for your 'thumbnailed' animation. </P>

There is also the problem that after <A HREF="../quantize/#colors" >Color
Quantization</A>, you may no longer have the same specific colors as the
original animation (see <A HREF="../quantize/#quantize_not_exact"
>Quantization does NOT Preserve Colors</A>).  That is instead of having a
simple area of pure white, you may now have an off white area. </P>


<A NAME="resize_sample"></A>
<H3>Resize using Sample</H3>

To avoid generating extra colors when resizing the simplest way is to
"<CODE><A HREF="../option_link.cgi?sample" >-sample</A></CODE>", the animation,
rather than resizing it.  This will preserve the current colors in the
animation and allow you to easily re-optimize the animation at the new size.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert script_k.gif -coalesce  -sample 20x20  script_k_sample.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="../images/script_k.gif"
      ><IMG SRC="../images/script_k.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR><IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="script_k_sample.gif"
      ><IMG SRC="script_k_sample.gif"      WIDTH=20 HEIGHT=20
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However while this works, you are basically removing rows and columns of
pixels from the image, loosing image data and hence quality in the process.
With cartoon-like images, that often leaves 'dotty' borders, and missing or
distorted details. </P>

If your resize is more than 50% of the animations original size, as is the
case above, the result is often quite horrible, especially when texture or a
other color pattern is used in the animation. </P>

It is not surprising then that many GIF animation libraries are filled with
such horrible sample-resized animations that they have copied from all over
the net.  I often wish they would clean out this sort of crap, but that means
a reducing the number of GIFs on offer, and that in turn reduces the marketing
statistics of the number of GIFs available, which the advertising department
does not like. As a consequence, crappy GIF animations are common. </P>

<A NAME="resize_lqr"></A>
<H3>Resize using Liquid Resize</H3>

A similar method to using the <A HREF="#resize_sample" >Sample</A> method
above is to use <A HREF="../resize/#liquid-rescale" >Liquid Rescale</A>, which
is also known as <A HREF="../resize/#liquid-rescale" >Seam Carving</A>. </P>

This also removes or added whole pixels from the images involved, but tries to
do so in a way that preserves as much of the image complexity as possible.
Look at the above links to see how you can use it to generate nicer resized
images. </P>

Unfortunately at this time there is no way to use this on a general animated
image, as it does not have an understanding of an images complexity, and we
cannot currently extract the rescaling method to apply it to each frame of an
animation in a consistent way. </P>

Hopefully this will change at some point in the future. </P>


<A NAME="resize_restore"></A>
<H3>Resize and Restore Colors</H3>

Sampling an animation just results in removing rows and columns of pixels,
and the possible removal of thin lines and other important details.  But
merging pixels together using "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>", produces far too many new colors for the GIF format.
</P>

So the obvious solution is to do the  "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>" but then use the original animations colors to restore
the resized animations colors, by using a colormap. </P>

<PRE>FUTURE: example with original color table restored</PRE>

This has the added advantage of not generating local color tables. </P>

Results however may be better with dither turned off, so as to avoid any
'dither noise'.  This is especially true for cartoon like images that has
large smoothly colored areas. </P>

<PRE>FUTURE: non dithered color table restored example</PRE>


<H3>Full Color Optimize</H3>

If a horrible sampled thumbnail is not to your liking, then you are faced with
the prospect of going through a full <A HREF="../anim_opt/#color_opt" >Color
Optimization</A> of the resized GIF Animation. To sort out just what 'new'
colors you want the animation to keep. </P>

However this is often not so bad, for most animations, but it can be a major
effort for more complex animations like when converting a <A
HREF="../video/#gif" >Video to GIF Animation</A>. </P>

That is, if you dealing with a cartoon like animation, you will now have heavily
anti-aliased lines and edges. </P>

For animations that involve a transparent background, you will also have to
properly deal with semi-transparent pixels around the edge of your animation,
also caused by the anti-aliasing features of resize.  See the section on <A
HREF="../formats/#boolean_trans" >GIF Boolean Transparency</A> for the many
methods you can use to handling this. </P>


<H3>Large Resize Reductions</H3>

When you plan to resize a large animation to a much smaller animation, you
face the problem of important parts of the animation disappearing.  This is
actually a problem for static images as well as animations. </P>

See <A HREF="../resize/#thin_lines" >Resizing Line Drawings</A> for any known
solutions for this. </P>

<BR>

Any further suggestions, ideas, or techniques are most welcome. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="merging"></A>
<H2>Merging Multiple Animations</H2>

I said it before, but it becomes especially important when merging
animations...
<DIV ALIGN=center><B>
   Know as much as you can about the animation you are working with!
</B></DIV>

The  "<CODE><A HREF="../scripts/gif2anim" >gif2anim</A></CODE>" script is
ideal for this purpose. Its sister script "<CODE><A HREF="../scripts/anim2gif"
>anim2gif</A></CODE>", is also commonly used here to re-create an animation
using its original settings.  (See basic usage of the script in <A
HREF="../anim_basics/#list_info" >Animation List Information</A>.) </P>

Without knowledge of how an animation works it is next to impossible to merge
them in various ways. Programs can be developed (the ultimate goal of these
examples) to do this. But, such programs are often very complex and can
produce unexpected results.  </P>

Because of this you should still follow these examples, as they will give you
a major insight into how animations should be handled and merged. </P>


<A NAME="serial"></A>
<H3>Serial or Time-wise Append</H3>

Appending two GIF animations together so that one sequence follows another
time-wise is simple with IM.  You basically just list them on the command line
and they will follow each other.  But it may not be quite as easy as it looks.
</P>

For example, after some searching of the web, I found (well stole and heavily
modified for this example) a couple of animations of some letters being drawn.
Now I'd like to join these images so when one animation completes the next one
starts, as if someone is writing the word '<CODE>OK</CODE>'. </P>

Here are the letters, the 'animation sequence' and the details of the internals
of these two animations.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=10% ROWSPAN=3></TD><TD WIDTH=80% ALIGN=justify COLSPAN=3>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  gif2anim -n script_o.gif
  gif2anim -n script_k.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>&nbsp;</TD></TR>
<TR><TD WIDTH=* ROWSPAN=2 VALIGN=top BGCOLOR="#CCCCCC">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=50% BGCOLOR="#CCCCCC">
<TR><TD>
    <A HREF="script_o.anim"
       ><IMG SRC="script_o.anim.gif"
             ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD><TD ROWSPAN=2></TD>
<TD WIDTH=* ROWSPAN=2 VALIGN=top BGCOLOR="#CCCCCC">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
    <A HREF="script_k.anim"
       ><IMG SRC="script_k.anim.gif"
             ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD><TD ALIGN=center>
    <A HREF="../images/script_o.gif"
       ><IMG SRC="../images/script_o.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR><TR><TD ALIGN=center>
    <A HREF="../images/script_k.gif"
       ><IMG SRC="../images/script_k.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

These sequences start with an empty canvas then just slowly add and modify
pixels to this canvas.  They never remove, clear or make transparent any
pixels added by previous frames. For our purposes however it does not matter
if they do or not as it will have little bearing on the results. </P>

Nor will the number of the frames in the animation have a bearing on this
operation. </P>

What is important to know is the timings of the frame, as this could produce
problems.  In particular note the timed delay on the first, or in this case
the final frame.  This technique is very common, giving the viewer time to see
the final result before the animation clears and re-starts.  It is these
delays and frames that will cause use problems when doing time-wise appends.
</P>

Also notice that the '<CODE>k</CODE>' animation has a slight delay in the
middle of the animation sequence. This delay represents the end of the first
brush stroke in this animation and the second brush stroke.  This delay will
also need to be preserved, meaning we can't just change all the time
sequences in the animation to a constant value. </P>

Something that is not shown in the above, is that the first frame of both
animations is actually blank canvas. We will probably want to junk that canvas
on the second animation as an useless waste of time, though it should be kept
on the first animation as a starting delay. </P>

Now that we have examined the two animations, lets try to join them together
so one follows the other in time. </P>

Time appending animations is actually a very simple operation, just append the
two animated images on the command line.  So lets just try that...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
    convert script_o.gif script_k.gif   script_ok_try1.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="script_ok_try1.gif"
      ><IMG SRC="script_ok_try1.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Well the result was far from perfect.  The letters get drawn in the right
sequence, but on top of each other! </P>

Not only that but as the first '<CODE>o</CODE>' animation is thinner (40
pixels) than the second '<CODE>k</CODE>' animation (53 pixels), so the very
last bit of the final '<CODE>k</CODE>' letter gets clipped by that smaller
framing canvas size. </P>

The position of the second animation can be moved by using a <A
HREF="#repage_relative" >relative repage</A>, as shown above.  This method of
re-positioning will preserve any existing offsets that may be present in that
animation, just move them all as a single related group. In this case almost
all the frames have and existing offset, as this is a highly optimised
animation. </P>

To accommodate this shifted position and avoid 'clipping' the second animation
we also need to enlarge the canvas size for the whole animation. Changing the
the canvas size before reading the first animation or frame will enlarge the
canvas area in which the animation runs, and prevent the 'K' from being
clipped.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
    convert -page 90x54 script_o.gif \
            \( script_k.gif -repage +37+0\! \)   script_ok_try2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="script_ok_try2.gif"
      ><IMG SRC="script_ok_try2.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The result is a vast improvement. Though now the delays between the drawing of
the letters, is definitely noticeable. </P>

What we want is a much smaller delay for the last frame of the first
'<CODE>O</CODE>' animation. Just large enough to look like the invisible
artist is re-positioning the pen. </P>

To do this we make a copy of that last frame of the first animation, then
change the delay of just that frame using the "<CODE><A
HREF="../option_link.cgi?set" >-set</A></CODE>" operator.  We then re-add that
frame back into the image sequence by deleting the original un-modified image.
</P>

Also as we have now set a good delay between the drawing of the letters, the
initial blank canvas (just representing an initial start delay) in the second
animation is now redundant, so we can just delete that frame, without
problems.  If this frame actually contained part of the image, then we may
need to adjust its delay, instead of removing. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
    convert -page 90x54 script_o.gif \( +clone -set delay 20 \) -delete -2 \
            \( script_k.gif -delete 0 -repage +37+0\! \)     script_ok.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="script_ok.gif"
      ><IMG SRC="script_ok.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And our serial or time-wise appending of two animations is complete and all
the little problems associated with these two particular animations are fixed.
</P>

Notice that at no time did I try to globally change ALL of the individual
frames, or their timing delays.   That is I preserved as much of the original
animations as I could while achieving my goal.  This is important as not all
animations use a constant timing delay between frames and changing this can
make an animation look very bad. </P>


<A NAME="append"></A>
<H3>Side by Side Appending (time synced)</H3>

Suppose you want both animations to be appended side-by-side, but have both
parts of the animation animating at the same time.  This is not so easy, as
you need to append (or composite together) each pair frames in the the two
animations together, so the animation also works together.. </P>

The real problem to doing this is the IM command line only works with a single
sequence of images.  It does not have the luxury of an API where you can keep
two separate image sequences, to loop through and append them together into
a third.

I can think of three basic techniques in which to do this appending.

Before be start however you should first study the two animations, to check on
the time sequences, and other details of the animation.  The "<CODE><A
HREF="../scripts/gif2anim" >gif2anim</A></CODE>" script is good for this, and
the generated "<CODE>.anim</CODE>' file can be useful later. </P>

<!-- <CODE EXECUTE>
  gif2anim -l bag_left.gif  > bag_left_orig.anim
  gif2anim -l bag_right.gif > bag_right_orig.anim
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=10% ROWSPAN=3></TD><TD WIDTH=80% ALIGN=justify COLSPAN=3>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  gif2anim -n bag_left.gif
  gif2anim -n bag_right.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>&nbsp;</TD></TR>
<TR><TD WIDTH=* ROWSPAN=2 VALIGN=top BGCOLOR="#CCCCCC">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=50% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="bag_left_orig.anim"
     ><IMG SRC="bag_left_orig.anim.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD><TD ROWSPAN=2 BGCOLOR="#B0C4DE">&nbsp;</TD>
<TD WIDTH=* ROWSPAN=2 VALIGN=top BGCOLOR="#CCCCCC">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="bag_right_orig.anim"
     ><IMG SRC="bag_right_orig.anim.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD><TD ALIGN=center>
  <A HREF="../images/bag_left.gif"
     ><IMG SRC="../images/bag_left.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[left]"></A>
</TD></TR><TR><TD ALIGN=center>
  <A HREF="../images/bag_right.gif"
     ><IMG SRC="../images/bag_right.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[right]"></A>
</TD></TR></TABLE></P>

If you look at the information summaries you will see that the two animations
have the exact same number of frames, and almost exactly the same time
sequence.  It is the similarity of the timing that is important here, and you
can say the animations are already 'time synchronised'. </P>

However while the timings may be correct, the animations are frame optimized,
rather than fully-coalesced. But the canvas area height are the same, making
appending the two frames side-by-side practical. </P>

Actually this animation was badly 'split' (see <A HREF="#split" >splitting
animation</A> in the next example set) so that the 'cat' animation was cut in
two, and the original lost. Other modifications resulted in a very slight
timing difference, which only made the division more obvious.  This was
a problem that was presented to me by <I><A HREF="../forum_link.cgi?u=8005"
>gmabrys</A></I> in a discussion on <A HREF="../forum_link.cgi?f=7&t=8068" >IM
Forums</A>, though the actual problem he gave was far, far, worse. </P>

<IMG SRC="../images/bag_right.gif"
     ALIGN=right VSPACE=0 HSPACE=0 BORDER=0 ALT="[left]"
><IMG SRC="../images/bag_left.gif"
     ALIGN=right VSPACE=0 HSPACE=0 BORDER=0 ALT="[right]"
>

Now browsers usually animate each of the separate GIF images, without any
synchronization. As such the two animations may become out-of-sync with each
other, producing a 'cat' that appears to have been part of a chainsaw
massacre.   You may be able to see this effect to the right where I placed two
animations side-by-side on the browser's page, especially if you are on a
distant server via slow links. </P>

Now lets attempt to append them together into one, properly synchronized
animated image. </P>

<H4>Appending separate files</H4>

The simplest way is to just coalesce the two animations and separate them into
separate image files, one frame per image.  The separate images can then be
append together (or otherwise modify the frames) as appropriate. When done the
new frames can then be used to re-build the animation. </P>

This however requires you to save a lot of extra information about the
animation that could very easily be lost during this processing.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE SCRIPT IMAGE=bag_append_anim.gif>
  # Separate animations into coalesced frames (plus a ".anim" file)
  gif2anim -c bag_left.gif
  gif2anim -c bag_right.gif

  # Append the separated frames them together
  for i in `seq -f '%03g' 1 11`; do \
    convert bag_left_$i.gif bag_right_$i.gif +append bag_append_$i.gif; \
  done

  # Rebuild the animation (using one of the ".anim" files)
  anim2gif -c -b bag_append  bag_left.anim

  # Cleanup
  rm -f bag_left.anim bag_right.anim
  rm -f bag_{left,right,append}_???.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bag_append_anim.gif"
     ><IMG SRC="bag_append_anim.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see this is quite an involved process, generating many individual
temporary images, and thus requiring quite a bit of clean up when finished.
Of course if you are debugging the above, the individual temporary files make
it easier to figure out what is going wrong with your processing.  </P>

It also shows the power of the "<CODE><A HREF="../scripts/gif2anim"
>gif2anim</A></CODE>" script and is inverse the "<CODE><A
HREF="../scripts/anim2gif" >anim2gif</A></CODE>" script in separating, and
saving the animation meta-data, and then later re-building GIF animations.
Basically it lets you preserve the original timings of the animations, without
needing to code them into your script directly. </P>

The final image also still needs to be re-optimized, though in this case you
will get very little optimization as a lot of things are happening
simultaneously throughout the animation between each and every frame </P>

<H4>Layered Composition</H4>

A better technique is to overlay animations using a multi-image list
<A HREF="#composite" >Layer Composition</A>.  This involves just enlarging
one set of images, and overlaying the other set to join them together.
In fact this is what the normal  "<CODE><A HREF="../option_link.cgi?append"
>-append</A></CODE>" operator does internally, so it isn't that different.
</P>

Here I just tell IM how big to make the canvas, and the fill it out using
"<CODE><A HREF="../option_link.cgi?coalesce" >-coalesce</A></CODE>".
I then overlay other coalesced animation with an appropriate offset.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
  convert bag_left.gif -repage 97x92 -coalesce \
          null: \( bag_right.gif -coalesce \) \
          -geometry +50+0 -layers Composite    bag_append.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bag_append.gif"
     ><IMG SRC="bag_append.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course the above technique means I needed to know just how big
the final animation will be, as well as the offset needed for the overlaid
animation. But the process is fast, works very well, and a scripted command
can pre-read the images to determine that information. </P>

To make a more universal animation appending method, we need to do some fancy
image handling to automatically determine the final size and offset of the
append. To do this without pre-reading the animation, requires some jumping
though some hoops, but a single command general animation append is possible.
</P>

First we need to append the first coalesced frame of each animation to
create a canvas that is the right size and this is then cleared.  The first
animation is coalesced and overlaid into left half of this canvas, then the
second animation is then coalesced and overlaid with a "<CODE>-gravity
East</CODE>" to place it in the right-most half of the pre-prepared canvas, to
avoid the need for an offset.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
  convert bag_left.gif'[0]' -coalesce \( bag_right.gif'[0]' -coalesce \) \
          +append -channel A -evaluate set 0 +channel \
          bag_left.gif -coalesce -delete 0 \
          null: \( bag_right.gif -coalesce \) \
          -gravity East  -layers Composite    bag.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bag.gif"
     ><IMG SRC="bag.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And there you have a general technique to append two time synchronized
animations together. </P>


<A NAME="append_fonts"></A>
<H3>Double Append, Appending - or Appending Animated Fonts</H3>

Before finishing with appending animations, there is one other technique I
would like to show you.   This technique can append multiple animations at the
same time, but at the cost of loosing all the timing information that was
present.  Often (but not always) those timings is not a big loss. </P>

Basically we append all the frames of each animation together vertically into
a single image, and then append or overlay the whole animation as two simple
images.  This is sort of like taping the two film strips together side-by-side
to produce a wider film strip.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
  convert \( bag_left.gif  -coalesce -append \) \
          \( bag_right.gif -coalesce -append \) \
          +append  -crop x92 +repage \
          -set delay 30     bag_dbl_append.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="bag_dbl_append.gif"
     ><IMG SRC="bag_dbl_append.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This did not require any temporary files, but as I mentioned at the start, all
the original time delays have been lost.   For this example I just set all the
animation delays to a constant value, producing a reasonable, though different
result.  Also to re-build the animation we needed to know the frame height of
the original animation, to correctly divide (<A HREF="../crop/#crop_tile"
>Tile Crop</A>) the widened 'film strip'. </P>

Though it is possible to recover those timings using the "<CODE><A
HREF="../scripts/gif2anim" >gif2anim</A></CODE>" scripts, doing so sort of
defeats the purpose of using this method, and you may as well just used the
first animation append technique, by appending the individual frames as
temporary files.  </P>

As you are appending the animations as simple images, you can append
together a whole series of animations all at the same time, (producing an even
wider 'filmstrip') and that is what makes this technique such an useful one.
</P>

For example you can use it with animated fonts that all use the same timings.
Though I have found that while a lot of animated fonts have the same number of
frames, they usually have slightly different timings for each letter so as to
de-synchronize the animated letters (see <A HREF="#split" >Splitting up an
Animation</A> for reasons why that is desirable). </P>

A neon sign on the other hand should have synchronized animation timings,
so I'll use it as an example... </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
  convert \( neon_h.gif -coalesce -append \) \
          \( neon_e.gif -coalesce -append \) \
          \( neon_l.gif -coalesce -append \) \
          \( neon_l.gif -coalesce -append \) \
          \( neon_o.gif -coalesce -append \) \
          +append  -crop x60 +repage  -set delay 100  neon_hello.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="../images/neon_h.gif"
     ><IMG SRC="../images/neon_h.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="../images/neon_e.gif"
     ><IMG SRC="../images/neon_e.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="../images/neon_l.gif"
     ><IMG SRC="../images/neon_l.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="../images/neon_l.gif"
     ><IMG SRC="../images/neon_l.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="../images/neon_o.gif"
     ><IMG SRC="../images/neon_o.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="neon_hello.gif"
     ><IMG SRC="neon_hello.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</NOBR></DIV></P>

You could also do something a little fancier, by adjusting timings and
the number of loops in the resulting animation.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
  convert neon_h.gif'[0]' neon_e.gif'[0]' neon_l.gif'[0]' neon_l.gif'[0]' \
          +append \( +clone \) -append \
          \( neon_o.gif -coalesce -append \)    +append \
          \( +clone \) -append \( +clone \) -append \( +clone \) -append \
          -crop x60 +repage   -set delay 3 \
          \( -clone 0  -set delay 300 \) -swap 0,-1 +delete \
          \( -clone 1  -set delay  10 \) -swap 1,-1 +delete \
          \( +clone    -set delay 200 \) +swap      +delete \
          -quiet -layers OptimizeFrame   neon_hell.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="neon_hell.gif"
     ><IMG SRC="neon_hell.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</NOBR></DIV></P>

The first two lines makes the 'always lit' part of the sign (first frame of
each of the previously animated letters). After this the last 'broken' letter
is added and the whole animation is doubled up a couple of times to produce
about 16 frames.  The timings are set to complete the desired effect with the
first and last frame being displayed for a long period, while the rest of the
frames flash by past really fast ( "<CODE>-delay 10</CODE>" ). </P>

Actually this GIF animation optimizes a lot smaller than you would probably
think for the number of frames involved.  Basically the IM GIF optimizer found
that it only needed to re-overlay the 'O' animation every second frame, and
used a '<A HREF="../anim_basics/#previous" >Previous</A>' disposal to just
restore the previous lit 'O'.  The animation is thus only about 50% larger
than the basic flashing un-optimized 'hello' image.  Check it out yourself.
</P>

<I>Can you improve the neon animation? Make it more realistic? It is a shame
GIF animations don't have sound. </I> </P>


<A NAME="split"></A>
<H3>Splitting up an Animation</H3>

Now that we have the animation rejoined together, lets attempt to split it up
correctly for use on a web servers, so that the individual parts can animate
separately, without interfering with each other. </P>

This is actually reasonably hard, and I will not attempt to completely
automate the process.  There are however tools on the WWW that can do this.
</P>

First of all we need to study the animation to find what parts of the
animation changes over the whole period.  For that we need to find the
differences from one frame to the next, add them all together into a map
showing the areas that are being animated, verses though that remain
completely static. </P>

This is tricky.  Basically a <A HREF="#composite" >Multi-Image Alpha
Composition</A> is used to find a '<CODE><A HREF="../compose/#difference"
>Difference</A></CODE>' image between each frame of the animation.  These
greyscale difference images, are added together, then the channels are
separated and also added together.  A final threshold then makes any non-zero
change between any frame of the animation, pure white. </P>

The result is a black image with white anywhere the image changed,
highlighting the areas of change.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
  convert    bag.gif   -coalesce  -set delay 0 \
          -bordercolor red -border 0 +matte    null: \
          -duplicate 1,1--2 -compose difference -layers composite \
          +delete -compose plus -background black -flatten \
          -separate -flatten -threshold 0 bag_areas.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="bag.gif"
     ><IMG SRC="bag.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
   <A HREF="bag_areas.gif"
      ><IMG SRC="bag_areas.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Now we can see that this animation could be divided into at least three areas:
a 'cat' area at the top, a small 'bear' to the left, and a flapping 'wing'
to the right. All with simple orthogonal (vertical or horizontal) cuts. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

So lets just do this, with some simple <A HREF="#crop_viewport" >Viewport
Crops of the Animation</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
  convert bag.gif -coalesce  -crop 97x39+0+0\!   bag_cat.gif
  convert bag.gif -coalesce  -crop 50x54+0+39\!  bag_bear.gif
  convert bag.gif -coalesce  -crop 47x54+50+39\! bag_wing.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <TABLE><TR><TD COLSPAN=2 ALIGN=center>
      <A HREF="bag_cat.gif"
         ><IMG SRC="bag_cat.gif"
               ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <TR><TD>
      <A HREF="bag_bear.gif"
         ><IMG SRC="bag_bear.gif"
               ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <TD><A HREF="bag_wing.gif"
         ><IMG SRC="bag_wing.gif"
               ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  </TABLE>
</TD></TR></TABLE></P>

These three images can be displayed by the browser together and not have the
'Texas Chainsaw Massacre' look about it, as at no point does a sub-animation
cross the boundaries of another. </P>

Now technically, you can make a couple more cuts so as to separate the areas
that are not animated from the animated areas, splitting this animation into
about six or more areas, though you will not gain much from optimization doing
this. All it would really do is complicate your web page, and create more
files for the user to download. </P>

Now unlike the larger animation, these smaller areas will animate quite
independently from each other.  We can even also change the timings of these
simple sub-animations without adversely affecting the result so as to
completely de-synchronize them from the other sub-animations.  The result is
a nicer less repetitive animated image (see below).  </P>

If you study the 'bouncing bear' and the 'flapping wing', you will find they
form a simple two frame cycle that simply repeats a number of times, to match
the timing of the waving cat. We can thus junk the extra repeats to simplify
these animations. </P>

Also the first two frames of the 'cat' are also exactly the same.  However
unlike the 'bear' and 'wing' you can't just remove one of them, as each frame
contains time delays to allow the 'bear' and 'wing' to animate without the cat
being present. </P>

To correctly remove these duplicate frames, you need to use the "<CODE><A
HREF="../option_link.cgi?layers" >-layer</A></CODE>" method '<CODE><A
HREF="../anim_opt/#removeDups" >RemoveDups</A></CODE>' to locate and merge the
timings of such duplicate frames in a coalesced animation. </P>

And here are the final optimizations, of all three separated animations with
the timing changes to improve the overall de-synchronization of the
sub-animations.  I have also displayed all three animations side-by-side on
the page, just as they should be displayed.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=top><TD><PRE><CODE EXECUTE>
  convert bag_cat.gif -layers RemoveDups \
                           -quiet  -layers Optimize  bag_cat_opt.gif
  convert bag_bear.gif -delete 2--1 -set delay 47 \
                                   -layers Optimize  bag_bear_opt.gif
  convert bag_wing.gif -delete 2--1 -set delay 33 \
                                   -layers Optimize  bag_wing_opt.gif
</CODE></PRE></TD></TR></TABLE></TD><TD> &nbsp;
  <TABLE CELLSPACING=0 CELLPADDING=0><TR><TD COLSPAN=2 ALIGN=center>
      <A HREF="bag_cat_opt.gif"
         ><IMG SRC="bag_cat_opt.gif"
               ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <TR><TD>
      <A HREF="bag_bear_opt.gif"
         ><IMG SRC="bag_bear_opt.gif"
               ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <TD><A HREF="bag_wing_opt.gif"
         ><IMG SRC="bag_wing_opt.gif"
               ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  </TABLE> &nbsp;
</TD></TR></TABLE></P>

<!-- <CODE EXECUTE NOIMAGE OUT=bag_orig_size.txt>
    ls -lH bag_left.gif bag_right.gif | awk '{ a += $5 } END { print a }'
</CODE> -->
<!-- <CODE EXECUTE NOIMAGE OUT=bag_opt_size.txt>
    ls -l bag_*_opt.gif | awk '{ a += $5 } END { print a }'
</CODE> -->
As a final summary: The two original (badly split) images totalled
  <A HREF="bag_orig_size.txt"
     ><IMG SRC="bag_orig_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes, which is about the same as the appended version. After correctly
splitting the animation, which allows good optimization of the sub-animations,
we get a total of
  <A HREF="bag_opt_size.txt"
     ><IMG SRC="bag_opt_size.txt.gif"
           ALIGN=absmiddle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
bytes over three image. Quite a good saving. </P>


<A NAME="frame_split"></A>
<H3>Distant Change Frame Splitting</H3>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

Example of splitting up frame updates of 'two changing objects that are far
apart', without involving transparency (fixed background), but preserving the
timing syncronization between the parts. </P>

Then repeat with a transparency background, (needing 'OptimizePlus' to
generate the 'cleared' pixels. </P>

See <A HREF="../anim_opt/#splitting" >Splitting Frame Actions</A> for
the general example. </P>


<A NAME="merge"></A>
<H3>Merging Time Disjoint Animations</H3>

Before any two animations can be merged together to run synchronously, you
need to make all animations use the same number of frames, and use the same
set of time delays. </P>

How difficult the merger is really depends on how disjoint the timings
of the animation is.  If the time delays are basically constant, you can
simply ignore them and fix the timings latter.  An example where time could be
ignored in merging a 2 frame animation with a 6 frame animation was given in a
<A HREF="../forum_link.cgi?t=12573" >IM Forum Discussion</A>. </P>

Also if the total cycle time is very different, you may need to adjust things
so that one animation loops 2 or 3 times so as to fill the cycle time of the
other animation. Basically timing is what matters. </P>

<UL>Probably something like...
<LI> + Figure out and adjust animations to a common total loop cycle time
<LI> + Coalesce both animations to remove any frame optimizations.
<LI> * Convert frame time delays into, time-since-start of animation.
<LI> * Double up frames as appropriate to time-synchronize.
<LI> * Convert time-since-start back into frame time delays.
<LI> + Overlay the coalesced time-synchronized frames as desired.
<LI> + Optimally merge and remove any 'zero delay' frames.
<LI> + Re-optimize the new animation.
</UL></P>

The '*' parts could be turned into a single new "<CODE><A
HREF="../option_link.cgi?layers" >-layer</A></CODE>" method to time
synchronize the two animations with similar total cycle time durations. </P>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<PRE>

Example, time disjoint, but same cycle time...

For example suppose you have two animations of three frame with time delays of
    10  10  10
    5    5  20

Both animations are 30 time units long already so that is not a problem.

Now convert the above to the time index when each frame should appear...
and show the overall time line at which frames appear...
   0        10    20   |__ NOTE that both animations
   0   5    10         |   end or loop at 30

From this you can see that you need to insert some extra frames to make them
match.  The first frame of the first animation needs to be repeated at time
index 5

0->5  10  20
0  5  10

And the last frame of the second animation also needs to be duplicated at
time index 20

0->5  10  20
0  5  10->20

The arrow '->' in the above means the same frame is just repeated (duplicated)
into the next time index. They are actually the same image.

Now that the timings of the frames in both animations are the same, you can
simply merge (composite) the frames together, to get final animation that is
4 frames long.

The four frame will thus have time delays of
5  5  10  10
which still add up to 30 time units (overall time per loop cycle)

Current state of development....

While IM can help gather time delay information (try the '-t' option for
"gif2anim") and build the animation. IM can't perform the time synchronization
needed for two separate coalesced animations.  This may become a special
built-in option.

That is, you will need figure out and double up appropriate coalesced
animation frames so as to change two time-disjoint animations into two
time-synchronized animations.

Once you have the animations time synchronized, you can then simply use the
new "-layers Composite" method, to overlay or merge the two time-synchronized
animations  together very easily.

All the above however assumes the total loop time of the two animations
are at least roughly equal, or not a major concern.


<B>Simplified Solution</B>

A simplified limited solution has been <A HREF="../forum_link.cgi?p=50325"
>Discussed on IM Forums</A>, for use with fast changing animations (similes).

The solution takes each animation and expand it so that the animation has
a fixed frame rate.  That is all frames are duplicated so that each frame is
shown for a conatant 6 centi-seconds each.  As such one frame with a 22cs
delay may be replaced by 4 x 6cs frames (24cs total).

After this the animations are further modified so that short animations are
looped multiple times so that the two animations are finally of equal length.
That is the two animations are made the same overall length in terms of both
time, and number of frames.

Once both animations has the same frame-rate and the same length, <A
HREF="#composite" >Layer Composition</A> can be used to merge/overlay the two
animations, in the right position.

The result can then be optimized using <A HREF="../anim_opt/#removedups"
>Remove Duplicate Frames</A> to remove any extra unwanted frames (with
appropriate timing adjustments and other <A HREF="../anim_opt/#intro"
>Optimizations</A> applied before saving.

This method of having all your component animations in a fixed frame length
form is especially well suited to animation libraries.


-----
Other example to create....
  * Overlay two moving equal time animations into a single animation
    (dancing butterflies, circling atoms, or birds?)
    This should be a straight layers composition.

  * Overlaying a moving animation on a fix background.
    (displace animation linearly with time)

  * Overlay two animations with different numbers of frames but constant time
    delays (see <A HREF="../forum_link.cgi?t=12573" >IM Forum Discussion</A>).

  * Oveylay two time disjoint animations (as outlined above)

  * Overlay a simple animated figure, on an animated background.
    (full animation merge)

</PRE>

</DIV>
<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 24 July 2004 (sub-division of "animation") <BR>
Updated: 3 April 2012 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/anim_mods/</CODE>
</ADDRESS></BODY></HTML>
