<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../assets/usage.css">
  <title>Convolution of Images -- ImageMagick Examples</title>
  <link rel="icon" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="shortcut" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="canonical" href="https://imagemagick.org/Usage/convolve/">
</head>
<body>
  <main class="container">
    <div class="magick-template">
      <div class="magick-header">
        <h1>ImageMagick Examples --<br>
        <img src="../img_www/space.gif" width="50" height="1"> Convolution of Images</h1>
        <div>
          <dl>
            <dt><b>Index</b></dt>
            <dt>
              <a href="../"><img src="../img_www/granitesm_left.gif" border="0" width="15" height="15"> ImageMagick Examples Preface and Index</a>
            </dt>
            <dd>
              <a href="#intro"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Introduction to Convolution</a>
              <ul>
                <li>
                  <a href="#convolve">Convolve</a>
                </li>
                <li>
                  <a href="#kernel_scaling">Convolve Kernel Scaling</a>
                </li>
                <li>
                  <a href="#normalize">Kernel Normalization (Automatic Scaling)</a>
                </li>
                <li>
                  <a href="#zero-summing_normalization">Zero-Summing Normalization</a>
                </li>
                <li>
                  <a href="#identity_addition">Blending Kernel with the Identity Kernel</a>
                </li>
                <li>
                  <a href="#bias">Output result Bias Control</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#blurring_images"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Blurring Images</a> (Low-Pass Filtering)
              <ul>
                <li>
                  <a href="#blurring_kernels">Blurring Kernels</a>
                  <ul>
                    <li>
                      <a href="#unity"><code>Unity</code> or Identity Kernel</a>
                    </li>
                    <li>
                      <a href="#mean">Shaped Mean or Average Kernel</a>
                    </li>
                    <li>
                      <a href="#gaussian"><code>Gaussian</code> Blurring Kernel</a>
                    </li>
                    <li>
                      <a href="#blur">Linear 1D Gaussian (<code>Blur</code>)</a>
                    </li>
                    <li>
                      <a href="#comet">Half Gaussian (<code>Comet</code>)</a>
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#gaussian_vs_blur">Gaussian vs Blur Kernels</a>
                </li>
                <li>
                  <a href="#soft_blur">Softened Blurring</a> (blending with original image)
                </li>
                <li>
                  <a href="#unsharpen">'Un-sharpen' Images using Blurs</a> (subtracting from the original image)
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#edgedet"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Edge Detection Convolutions</a> (High-Pass Filtering)
              <ul>
                <li>
                  <a href="#edgedet_kernels">Edge Detection Kernels</a>
                  <ul>
                    <li>
                      <a href="#log">Laplacian Of Gaussians (<code>LoG</code>)</a>
                    </li>
                    <li>
                      <a href="#dog">Difference Of Gaussians (<code>DoG</code>)</a>
                    </li>
                    <li>
                      <a href="#laplacian">Discrete <code>Laplacian</code> Kernels</a>
                    </li>
                  </ul>
                </li>
                <li>
                  <a href="#sharpening">Sharpening Images with Edge Detection</a> (enhancing the edges of the original image)
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#directional"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Directional Convolutions</a> (Slopes, Compass Filtering)
              <ul>
                <li>
                  <a href="#directional_kernels">Directional Kernels</a>
                  <ul>
                    <li>
                      <a href="#sobel"><code>Sobel</code></a>,&nbsp; <a href="#roberts"><code>Roberts</code></a>,&nbsp; <a href="#prewitt"><code>Prewitt</code></a>,&nbsp; <a href="#compass"><code>Compass</code></a>,&nbsp; <a href="#kirsch"><code>Kirsch</code></a>,&nbsp; <a href="#freichen"><code>FreiChen</code></a>
                    </li>
                  </ul>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#correlate"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Correlate</a>
              <ul>
                <li>
                  <a href="#convolve_vs_correlate">Convolve vs Correlate</a> (asymmetrical kernel effects)
                </li>
                <li>
                  <a href="#correlate_search">Correlation and Shape Searching</a>
                </li>
                <li>
                  <a href="#correlate_vs_hitandmiss">Correlate vs HitAndMiss</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#neighbours"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Neighbour Counting</a>
              <ul>
                <li>
                  <a href="#counting">Counting Neighbours</a>
                </li>
                <li>
                  <a href="#life">The Game of Life</a>
                </li>
              </ul>
            </dd>
          </dl>Convolution uses the local 'neighbourhood' of pixels to modify images. It does this by merging and averaging all the color values around each pixel to blur images, to highlight edges and boundaries, and sharpen images. The convolution variation, 'Correlation' is also used for scanning and searching for specific patterns, producing an image denoting how closely images matches.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="intro" id="intro"></a>
          <h2>Introduction to Convolution</h2>The '<code>Convolve</code>' and the closely related '<code>Correlate</code>' methods, are is many ways very similar to <a href="../morphology/#intro">Morphology</a>. In fact they work in almost the exactly the same way, matching up a neighbourhood 'kernel' at each location, making them a just another special 'method' of morphology. In fact, they also use much of the same code and even the same kernel definitions that was defined in <a href="../morphology/#kernels">Basic Kernels</a> and <a href="../morphology/#user">User Defined Kernels</a>. For more specific kernels designed for use by this operator, (and there are many), I refer you to <a href="#blurring_kernels">Blurring Kernels</a>, and <a href="edgedet_kernels">Edge Detection Kernels</a>. The most important kernel being the '<code><a href="gaussian">Gaussian</a></code>' kernel. However, convolution is much older than morphology, and it generates more grey-scale gradient effects, rather than the binary shape studying effects that morphology typically generates. This is why it is often regarded as a very different or separate operation to morphology and one that is more central to image processing. Basically a convolution or correlation performs a 'weighted average' of all the pixels in the neighbourhood specified. That is, it multiplies the value of each nearby pixel by the amount given in the kernel, then adds all those values together to produce the final result. As such, each pixel in the final image will generally contain at least a small part of all the other pixels locally surrounding it in the source image. Looking at it another way, the color of each pixel in the image will be either added to (blurred) or subtracted from (sharpen/edge detection) the colors of all its near by neighbours, as defined by then kernel used. Both 'convolve' and 'correlate' are the same operation, except in a very minor but important way, and for the examples and controls that we will now look, you can treat them as being basically the same thing. Later (See <a href="#convolve_vs_correlate">Convolution vs Correlation</a>) we will examine exactly how the two operators really differ and why they differ in such a minor way. But in most circumstances they are the same method.<br>
          <a name="convolve" id="convolve"></a>
          <h3>Convolve &nbsp; <font size="5">( <img src="../img_www/mph_convolve.gif" align="absmiddle"> )</font></h3>As was mentioned above the '<code>Convolve</code>' method works by weighting each of the pixels in the local neighbourhood, according to the floating point values in the kernel. The weighted values are then simply added together to produce the new replacement pixel in the resulting image. For example lets convolve a single pixel, using a very small <a href="../morphology/#user">User Defined</a> convolution kernel. I also set the special <a href="../morphology/#showKernel">Show Kernel Setting</a>, so you can see the details of the kernel being defined and used (displayed images have been enlarged).
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="pixel_spread.gif" err="spread_kernel.txt">
  magick xc: -bordercolor black -border 5x5 pixel.gif
  magick pixel.gif -define morphology:showKernel=1 \
         -morphology Convolve '3x3: 0.0, 0.5, 0.0
                                    0.5, 1.0, 0.5
                                    0.0, 0.5, 0.0' pixel_spread.gif
</code></pre>
                </td>
              </tr>
            </table><!--<CODE EXECUTE>
  kernel2image -10.1 -n -mn -g 1 -ml '' \
               '3: 0,1,0  1,2,1  0,1,0'  kernel_spread.gif
  magick pixel.gif -scale 800% pixel_mag.gif
  magick pixel_spread.gif -scale 800% pixel_spread_mag.gif
</CODE>-->
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="spread_kernel.txt"><img src="spread_kernel.txt.gif" align="middle" vspace="5" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table><a href="pixel.gif"><img src="pixel_mag.gif" width="88" height="88" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_spread.gif"><img src="kernel_spread.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="pixel_spread.gif"><img src="pixel_spread_mag.gif" width="88" height="88" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As you can see the single pixel in the image has now expanded to produce 50% gray pixels around it. That is, when the kernel's 'origin' (it's center in this case) is positioned next to the single pixel in the original image, only that single pixel has a non-zero value. This pixel value is then weighted by the '<code>0.5</code>' value of the kernel, and the resulting 'half-bright' pixel is added to the resulting image. Simularly when the kernel's origin is position exactly over the original pixel, it will get a value of '<code>1.0</code>' reproducing the original pixel with no other values (black) in the neighbourhood around it adding any component to the result. Note that any kernel value of '<code>0.0</code>' will take no part in the final calculation. Zero values are effectively not part of the 'neighbourhood', just as any '<code>Nan</code>' value in morphology kernels take no part. As such this kernel consists of a 5 element neighbourhood. In many ways a '<code><a href="#convolve">Convolve</a></code>' method is very similar to a morphological '<code><a href="../morphology/#dilate">Dilate</a></code>' method, however '<code><a href="../morphology/#dilate">Dilate</a></code>' only treats the kernel as a type of bitmap mask, locating the largest value within the neighbourhood. On the other hand '<code><a href="#convolve">Convolve</a></code>' is a weighted sum of all the values in the neighbourhood, as such the value of each kernel element plays a part in the overall result. The syntax of a convolution operation is...
          <div align="center">
            <pre class="bg-light text-dark mx-4"><samp><b>
  -morphology Convolve {<i>convolution_kernel</i>}
</b></samp></pre>
          </div>But you can also use an older, more direct operator...
          <div align="center">
            <pre class="bg-light text-dark mx-4"><samp><b>
  -convolve {<i>convolution_kernel</i>}
</b></samp></pre>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Before IM v6.5.9 the older "<code><a href="../option_link.cgi?convolve">-convolve</a></code>" did not understand morphology kernel definitions. It would only accept the 'old style' of user defined kernels, consisting of just a string of comma separated values to produce to some odd-sized square kernel. It will now accept the 'new' style' convolution kernels defintions.<br>
              <br>
              However it is still restricted to 'odd sized' square kernels. And will remain that way until it starts to make use of the new 'morphology' convolution method.<br>
              <br></i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%">
                <font size="-1"><i>The older "<code><a href="../option_link.cgi?convolve">-convolve</a></code>" operator is not exactly the same as the newer morphology '<code><a href="#convolve">Convolve</a></code>' method. The following is a list of how the two operations differ...<br>
                <br></i></font>
                <ul>
                  <li><font size="-1"><i>The old operator is implemented as a <a href="#correlation">Correlation</a> rather than a true convolve. This means the kernel is not overlaid on the source image in its reflected form. See <a href="#convolve_vs_correlate">Convolve vs Correlate</a> for the effects this has on results.<br>
                  <br></i></font></li>
                  <li><font size="-1"><i>It only accepts odd sized square kernels. The morphology one allows any rectangular array, with any point within the array being declared as the origin.<br>
                  <br></i></font></li>
                  <li><font size="-1"><i>The old operator will always <a href="#kernel_normalization">Normalize Kernels</a> without any user control over kernel <a href="#kernel_scaling">Kernel Scaling</a> of the kernel. The new one does not automatically normalize, you need to request it. However most generated kernels are pre-normalized for you.<br>
                  <br></i></font></li>
                  <li><font size="-1"><i>You cannot use any form of <a href="#identity_addition">Blending with the Identity Kernel</a>, though output <a href="#bias">Output Bias</a> is performed as normal.</i></font></li>
                  <li><font size="-1"><i>It will however make use of fast 'GPU' code, if the host computer has such facilities. Morphology does not have this enabled yet.<br>
                  <br></i></font></li>
                  <li><font size="-1"><i>Currently other convolution related operators, such as "<code><a href="../option_link.cgi?gaussian_blur">-gaussian_blur</a></code>", "<code><a href="../option_link.cgi?blur">-blur</a></code>", "<code><a href="../option_link.cgi?sharpen">-sharpen</a></code>", "<code><a href="../option_link.cgi?unsharpen">-unsharp</a></code>", use the old version of the operator.<br>
                  <br></i></font></li>
                  <li><font size="-1"><i>By default the old command will only convolve against the color channels (as defined by the "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting. If you convolve with a "<code><a href="../option_link.cgi?channel">-channel</a> RGBA</code>" setting it will also weigh the kernel values by the alpha channel to ensure correct blurring with regards to transparency.<br>
                  <br>
                  The Morphology '<code>convolve</code>' method will automatically handle transparency weighting of the color channels by default. That is image blurring using it will treat transparent colors as transparent, and thus avoid the <a href="../bugs/blur_trans/">Blur Transparency Bug</a>, by default.<br>
                  <br>
                  However if the user modifies the default "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting (by not including the special '<code>Sync</code>' flag), then it will handle the convolution as a pure channel based greyscale operator.<br>
                  <br>
                  See the "<code><a href="../option_link.cgi?channel">-channel</a></code>" setting documentation, or look at <a href="../compose/#image_math">Image Channel Mathematics</a> which uses the same flag in the same way, for more information.<br>
                  <br></i></font></li>
                </ul><font size="-1"><i><br>
                <br>
                Eventually most of the above differences will change as it things merge with the newer morphology '<code><a href="#convolve">Convolve</a></code>' method.<br>
                <br></i></font>
              </td>
            </tr>
          </table>If you like to see some great examples of how '<code><a href="#convolve">Convolve</a></code>' actually does works, I recommend you also have a look at <a href="http://www.archive.org/details/Lectures_on_Image_Processing/EECE253_07_Convolution.pdf">EECE \ CS 253 Image Processing, Lecture 7, Spatial Convolution</a>. The <a href="http://en.wikipedia.org/wiki/Convolve">Wikipedia, Convolve</a> artical has some nice 1-D animations of the convolution process. <a name="kernel_scaling" id="kernel_scaling"></a>
          <h3>Convolve Kernel Scaling</h3>The above example works well for a mostly black image such as a single pixel, but if you were to apply this to a real image, you will have a problem...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
<br>  magick logo: -resize 50% -crop 80x80+150+60 +repage  face.png
<br>  magick face.png \
         -morphology Convolve '3x3: 0.0,0.5,0.0  0.5,1.0,0.5   0.0,0.5,0.0' \
         face_spread.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/face.png"><img src="../images/face.png" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_spread.gif"><img src="kernel_spread.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="../images/face.png"><img src="face_spread.png" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As you can see the resulting image is very bright (3 times brighter in fact) as the original image. What happened is that each pixel is being shared 3 times. 4 Ã— '<code>0.5</code>' on the sides, plus a full copy of the original pixel. That is the addition of all the values in the kernel is 3, making the resulting image three times as bright! If you go back and look at the 'showKernel' output above, you will see that it listed this kernel as having a "convolution output range from 0 to 3". Which shows that this kernel will in general brighten an image 3 times. To fix this you would want to divide all the values in the kernel by 3. That is a value of '<code>0.5</code>' should really have been about '<code>0.1667</code>' while the central value of '<code>1.0</code>' should have been '<code>0.3333</code>'. This is a process known as '<b>Kernel Normalization</b>'. For example, here is manually 'normalized' result, and the kernel definition... <!--<CODE EXECUTE>
  kernel2image -10.1 -s '!' -mn -g 1 -ml '' \
               '3: 0,1,0  1,2,1  0,1,0'  kernel_spread_norm.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" image="face_spread_norm.png" err="kernel_spread_norm.txt">
magick face.png -define morphology:showKernel=1 \
       -morphology Convolve \
       '3x3: 0.0,.1667,0.0  .1667,.3333,.1667  0.0,.1667,0.0' \
       face_spread_norm.png
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="kernel_spread_norm.txt"><img src="kernel_spread_norm.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table><a href="../images/face.png"><img src="../images/face.png" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_spread_norm.gif"><img src="kernel_spread_norm.gif" align="middle" vspace="5" hspace="15" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="face_spread_norm.png"><img src="face_spread_norm.png" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As you can see you get a very slightly blurred version of the face image, as each pixel was spread out to each of its immediate neighbours.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The 'kernel image' that is shown in the above (generated using a special <a href="../morphology/#kernel2image">Kernel 2 Image Script</a>) also shows the resulting normalized kernel. As you can see the kernel itself is now very dark, as all its values are also dark, though they all add up to a value of '<code>1.0</code>'.<br>
              <br>
              From this point on all convolution kernel images shown will always be adjusted so the maximum value is set to white, otherwise all you will generally see is a dark, and basically useless, 'Kernel Image'.<br>
              <br></i></font></td>
            </tr>
          </table>Normalizing the kernel yourself is not pleasant, and as you saw it makes the resulting kernel definition a lot harder to understand. As such, alternative ways are provided. As of IM v6.5.9-2 the special expert option "<code><a href="../option_link.cgi?define">-define</a> convolve:scale={<i>kernel_scale</i>}</code>' allows you to specify a global scaling factor for the kernel, and thus adjust the brightness of the overall result.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
magick face.png -define convolve:scale=0.33333 \
       -morphology Convolve '3x3: 0.0,0.5,0.0  0.5,1.0,0.5  0.0,0.5,0.0' \
       face_spread_scale.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_spread_scale.png"><img src="face_spread_scale.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Actually what this does is adjusts the overall intensity of the kernel results. As you will see in later examples, you will probably want to make the convolution result more or less powerful. This '<i>kernel_scale</i>' factor lets you do that. <a name="normalize" id="normalize"></a>
          <h3>Kernel Normalization (automatic scaling)</h3>Rather then working out the scaling factor (as above), you can simply ask the IM to work out this 'normalize scaling factor' internally by giving it the special '<code>!</code>' normalization flag.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
magick face.png -define convolve:scale=\! \
       -morphology Convolve  '3x3: 0,1,0  1,2,1  0,1,0' \
       face_spread_normalize.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_spread_normalize.png"><img src="face_spread_normalize.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The '<code>!</code>' character is also sometimes used for special purposes by various UNIX command line shells. So you may have to escape the character using a backslash, even in quotes. Caution is advised.</i></font></td>
            </tr>
          </table>Note that as the kernel is now normalized, I can define it in a simplier fashion using whole numbers. The normalized kernel will still be the same as previous 'scaled' kernel. Typically you will always want to normalize the kernel, and because of this the simplier "<code><a href="../option_link.cgi?convolve">-convolve</a></code>" variant will automatically do this normalization. You can have IM normalize the kernel, then scale it further again by a given amount to adjust its output range. To make this even easier you can specify the scaling factor as a percentage. For example, here I normalize the kernel but then re-scale the values to 50% the calculated size, so as to produce a darker result.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale=50%\! \
         -morphology Convolve  '3x3: 0,1,0  1,2,1  0,1,0' \
         face_spread_norm_half.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_spread_norm_half.png"><img src="face_spread_norm_half.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that using a value of '<code>!</code>' is actually equivelent to using '<code>1!</code>' or even '<code>100%!</code>'. You can even use a negative scaling factor if you want to flip the positive and negative values within the kernel. For an example of this see <a href="#unsharpen">'Un-Sharpening' Images using Blurs</a>. If the kernel has been normalized in this way the <a href="../morphology/#showKernel">Show Kernel</a> output will tell you that it is normalized.
          <h4>How Normalization Works</h4>The actual way '<i>Kernel Normalization</i>' works is that all the kernel values are added together (including any negative values which is also posible). If the result is non-zero, then scale all the values so that their combined value adds up to a value of one ('<code>1.0</code>'). Note that, if you have negative values, this could actually create a kernel with a value larger than one, typically at the origin. It specifically happens with <a href="#unsharpen">Un-Sharp</a> kernels. The important point, however, is that the kernel as a whole adds to '<code>1.0</code>', so that the final image is not made darker or lighter by the <a href="#convolve">Convolution</a> operation. If the result of the addition is Zero ('<code>0.0</code>'), then the kernel is assumed to be a special <a href="#zero-summing">Zero-Summing Kernel</a>. In that case the kernel is scaled to make all positive values equal to '<code>1.0</code>', and by the same token, all negative values will then add up to '<code>-1.0</code>'. These kernels are especially prevelent with <a href="#edgedet">Edge Detection</a> techniques. The <a href="../morphology/#showKernel">Show Kernel</a> output will also specify that it is zero-summing, if the kernel is in this form, even if not actually a normalized zero-summing kernel, though that will also be easilly seen by the other numbers displayed. Most mathematically determined kernels are pre-normalized. This includes the mathematically derived kernels: '<code><a href="#unity">Unity</a></code>', '<code><a href="#gaussian">Gaussian</a></code>', '<code><a href="#log">LoG</a></code>', '<code><a href="#dog">DoG</a></code>', '<code><a href="#blur">Blur</a></code>', '<code><a href="#comet">Comet</a></code>'. Discrete Constant Kernels, however are are not pre-normalized, so you will have to do this using the <a href="#normalize">Kernel Normalization Setting</a> (above). This includes the kernels: '<code><a href="#laplacian">Laplacian</a></code>', '<code><a href="#sobel">Sobel</a></code>', '<code><a href="#roberts">Roberts</a></code>', '<code><a href="#prewitt">Prewitt</a></code>', '<code><a href="#compass">Compass</a></code>', '<code><a href="#kirsch">Kirsch</a></code>', '<code><a href="#freichen">FreiChen</a></code>'. Note that the '<code><a href="#freichen">FreiChen</a></code>' kernel has sub-types that are specially pre-weighted for more specific purposes. The FreiChen kernels should not be normalized, but used as is. <a name="zero-summing_normalization" id="zero-summing_normalization"></a>
          <h3>Zero-Summing Normalization</h3>Not all convolution kernels use only positive values. You can also get kernels that use a mix of positive and negative values and often the values of these kernels are meant to add up to zero to produce a <a href="#zero-summing">Zero-Summing Kernels</a>. Such kernels are very important to more advanced Image Convolutions, as they provide techniques of <a href="#edgedet">Edge Detection</a> and <a href="#sharpening">Sharpening Images</a>. As I mentioned in the last section, the usual normalization flag '<code>!</code>' will work with such kernels. But sometimes due to special situations you want to ensure that the kernel does remain 'zero-summing'. The special '<code>^</code>' normalization method just provides a way to ensure the kernel is 'zero-summing' in situations such as...
          <ol>
            <li>If the user's kernel definition is not precise enough to ensure zero-summing. For example you cannot specify '<code>1/3</code>' or any other fractional factor of 3 as an exact floating point decimal number.</li>
            <li>The mathematical curve gets 'clipped' by the kernels size (radius) so it may no longer be zero summing. For example, this occurs in a '<code><a href="#log">LoG</a></code>' or '<code><a href="#dog&quot;">DoG</a></code>' kernels, which are based on infinite response curves. IM actually uses this special normalization internally on these kernels for this very reason.</li>
            <li>Ensure that a <a href="#correlate">Correlation</a> 'shape mask' is zero summing, so that in the search, IM can look for both positive and negative matches, equally. See <a href="#correlate">Correlation Shape Searching</a> below.
            </li>
          </ol>What happens is that it will normalize the all the positive and negative values of the kernel as separate enities. That is, all the negative values will be scaled to add up to '<code>-1.0</code>' and all the positive values to scaled add to '<code>+1.0</code>'. The result is that the kernel will be guranteeed as a whole, to add up to zero. Note that if you use this normalization method for an all-positive kernel such as 'Gaussian' you will still get a properly normalized kernel. As such this form of normalization can still be used with <a href="blurring_kernels">Blurring Kernels</a>. However it should not be used to normalize directly defined <a href="#sharpening">Sharpening</a> or even <a href="#unsharpen">Un-Sharpening</a> kernels, as this can contain negative values, but are required to sum to a value of one (using the normal normalization method). <a name="identity_addition" id="identity_addition"></a>
          <h3>Blending Kernel with the Identity Kernel</h3>The full syntax of the Kernel Scaling Setting is either...
          <div align="center">
            <code><b>-define convolve:scale='{<i>kernel_scale</i>}[!^] [,{<i>origin_addition</i>}] [%]'<br>
            -set option:convolve:scale '{<i>kernel_scale</i>}[!^] [,{<i>origin_addition</i>}] [%%]'</b></code>
          </div>Note the doubling of the percent character when using "<code><a href="../option_link.cgi?set">-set</a></code>". The optional normalization flags '<code>!</code>' or '<code>^</code>" will be applied to the user defined or built in kernel first (if requested). After that, the kernel will scaled by the '<i>kernel_scale</i>' factor either increasing or decreasing the effective 'power' of the convolution on the results. Default scaling factor is '<code>1.0</code>'. Lastly the 'origin' value of the kernel will have the number after a comma added to it. Default '<i>origin_addition</i>' is '<code>0.0</code>'. This last step effectively 'adds' a <a href="#unity">Unity Kernel</a> of the given 'scaling' to the previously generated normalized and scaled kernel. This generates kernels that can...
          <ul>
            <li>Soften the effects of a <a href="#blurring_kernels">Blurring Kernel</a>.
            </li>
            <li>Convert a <a href="#blurring_kernels">Blurring Kernel</a> into one that can be used to directly to <a href="#unsharpening">Un-Sharpen an Image</a>.
            </li>
            <li>It can also allow you to magick <a href="#edgedet_kernels">Edge Detection Kernel</a> into a <a href="#sharpening">Image Sharpening Kernel</a>.
            </li>
          </ul>Note that if you give a percent ('<code>%</code>') flag, that percentage will be applied to BOTH the '<i>kernel_scale</i>' factor and the '<i>origin_addition</i>'. This can make makes the scale easier to read and understand when fractions are involved. Example use of kernel scaling define...
          <div align="left" style="margin-left:50">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  -define convolve:scale='!50%,100%'  -morphology Convolve Laplacian:2  
</samp></pre>
                </td>
              </tr>
            </table>
          </div>Will generate the requested '<code><a href="#laplacian_2">Laplacian:2</a></code>' kernel...
          <div align="center" style="margin-left:20%;margin-right:50%">
            <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8" style="border-width:1">
              <tr>
                <th>0</th>
                <th>-1</th>
                <th>0</th>
              </tr>
              <tr>
                <th>-1</th>
                <th>4</th>
                <th>-1</th>
              </tr>
              <tr>
                <th>0</th>
                <th>-1</th>
                <th>0</th>
              </tr>
            </table>
          </div>Normalizes it ('!' flag)
          <div align="center" style="margin-left:20%;margin-right:50%">
            <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8" style="border-width:1">
              <tr>
                <th>0</th>
                <th>-0.25</th>
                <th>0</th>
              </tr>
              <tr>
                <th>-0.25</th>
                <th>1</th>
                <th>-0.25</th>
              </tr>
              <tr>
                <th>0</th>
                <th>-0.25</th>
                <th>0</th>
              </tr>
            </table>
          </div>Scale by 50%
          <div align="center" style="margin-left:20%;margin-right:50%">
            <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8" style="border-width:1">
              <tr>
                <th>0</th>
                <th>-0.125</th>
                <th>0</th>
              </tr>
              <tr>
                <th>-0.125</th>
                <th>0.5</th>
                <th>-0.125</th>
              </tr>
              <tr>
                <th>0</th>
                <th>-0.125</th>
                <th>0</th>
              </tr>
            </table>
          </div>Add an Unity kernel (add 100% to origin value)
          <div align="center" style="margin-left:20%;margin-right:50%">
            <table border="0" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8" style="border-width:1">
              <tr>
                <th>0</th>
                <th>-0.125</th>
                <th>0</th>
              </tr>
              <tr>
                <th>-0.125</th>
                <th>1.5</th>
                <th>-0.125</th>
              </tr>
              <tr>
                <th>0</th>
                <th>-0.125</th>
                <th>0</th>
              </tr>
            </table>
          </div>And you can now convolve using '<code><a href="#laplacian_2">Laplacian:2</a></code>' as a sharpening kernel, but with only a '<code>50%</code> sharpening power. Remember any '<code>%</code>' flag given anywhere in the scale setting, will make both values percentages. If not present both values are just simple direct multipliers. For example all these scaling options are equivalent
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
     50,100%     50%,100    %50,100      .5,1      0.5,1.0   
</samp></pre>
                </td>
              </tr>
            </table>
          </blockquote>The same goes for the two normalization flags. They can appear anywhere in the convolve scaling setting, but they will always be applied first before any other scaling takes place. <a name="bias" id="bias"></a>
          <h3>Output result Bias Control</h3>When you are dealing with a kernel that contains negative values, some pixels in the resulting image should be assigned a negative value. This is especially the case with <a href="#zero-summing">Zero-Summing Kernels</a> (see below). Unfortunately, unless you have a specially built <a href="../basics/#hdri">HDRI Version of ImageMagick</a>, to preserve the negative values that were generated, any negative result will be clipped to zero (black). You will only get thge positive results from the convolution. It just can not be stored in a normal image format, leaving you with half the result. You could build <a href="../basics/#hdri">HDRI Version of ImageMagick</a> to preserve the negative values that were generated, and then extract the information you want. Alternately, you can negate the kernel by using a negative scaling factor. For example using...
          <div align="center">
            <code>-define convolve:scale='-1'</code>
          </div>However then you only get the negative results with the positive results becoming clipped. However by using the IM setting "<code><a href="../option_link.cgi?bias">-bias</a></code>" you can still preserve both positive and negative results. The settings to use for non-HDRI version of IM is...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
     -define convolve:scale=50%\!  -bias 50%
</samp></pre>
                </td>
              </tr>
            </table>
          </div>The first setting scales the output to half the size you would normally get (after it is normalized), so as to make room for both positive and negative results. Then it will add a 50% gray to the pixel output before saving the result back into an image. With these settings, any 'zero' result will become pure gray with negative results darker than this and positive result lighter than this. Black will represent '<code>-1.0</code>' and white will mean '<code>+1.0</code>'. One example of doing this is shown in the <a href="#correlate_search">Correlate Shape Search</a> examples below.<br>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="blurring_images" id="blurring_images"></a>
          <h2>Blurring Images <font size="-1">(low-pass filtering)</font></h2>Another section of IM examples, specifically <a href="../blur/">Blurring, and Sharpening Images</a>, actually deals with practical aspects of this subject. Here we look at more specific details. First however, we will describe the basic kernels and how you can use them directly without modification. Later we will look at ways of modifying the bluring to generate other effects. <a name="blurring_kernels" id="blurring_kernels"></a>
          <h3>Blurring Kernels</h3><!--<CODE EXECUTE>
   kernel2image -35.2 -m "Unity"    kernel_unity.gif
</CODE>-->
          <a href="kernel_unity.gif"><img src="kernel_unity.gif" align="right" border="0" alt="[IM Output]"></a> <a name="unity" id="unity"></a>
          <h4>Unity</h4>This is a special kernel that actually does nothing. Only one kernel element is specified, and as a result each pixel is replace by itself without change. For example, here is a no-op <a href="#convolve">Convolution</a>...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Unity face_unity.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/face.png"><img src="../images/face.png" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_unity.gif"><img src="kernel_unity.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="face_unity.png"><img src="face_unity.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
          </div>As of IM v 6.6.9-4, the kernel can take a single argument, as a kernel specific scale argument. This allows you to use it to multiply the values of an image, such as make an image brighter or darker.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Unity:0.5 face_dimmed.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_dimmed.png"><img src="face_dimmed.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This may not seem very useful, but it can be used for generating <a href="#soft_blur">Soft Blurs</a>, and <a href="#unsharpen">Unsharpen</a> effects, or in multi-kernel sequences where you may not be able to use <a href="#kernel_scaling">Kernel Scaling</a> or <a href="#identity_addition">Kernel Identity Blending</a>. The same single element kernel can also be generated using '<code><a href="../morphology/#disk">Disk:0.5</a></code>', which also allows you to specify an extra scaling argument as part of the kernels generation. (EG: '<code>Disk:0.5,0.5</code>' for the last example). A similar kernel (for <a href="#convolve">Convolution</a>) can also be generated by the a '<code><a href="#gaussian">Gaussian</a></code>' kernel generator with a '<i>sigma</i>' of '<code>0.0</code>'. However that can only produce a small 3x3 kernel, consisting of a central '<code>1.0</code>' value surrounding by 8 '<code>0.0</code>' values. <!--<CODE EXECUTE>
  kernel2image -10.1 -m -n "Octagon:2"   kernel_shape.gif
</CODE>-->
          <a href="kernel_shape.gif"><img src="kernel_shape.gif" align="right" vspace="0" hspace="10" border="0" alt="[IM Output]"></a> <a name="mean" id="mean"></a>
          <h4>Mean or Average Filtering using Shape Kernels</h4>While most convolution kernels defined below generally involve the use of a Gaussian Curve in some way, you can still use one of the previous <a href="../morphology/#shape_kernels">Morphology Shape Kernels</a> to simply average the pixels over a given (large) area. Of course you will need to <a href="#normalize">Normalize</a> the kernel so as to actually generate an average, rather than just a sum of the neighbourhood. For example, here I use a smaller '<code><a href="../morphology/#octagon">Octagon</a></code>' shaped kernel, to average all the pixel values found within a circlular areas surrounding each pixel.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale=! \
         -morphology Convolve Octagon:2 face_mean.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/face.png"><img src="../images/face.png" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_shape.gif"><img src="kernel_shape.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="face_mean.png"><img src="face_mean.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
          </div>The result is that the value of each pixel is spread out equally over all 25 pixels in the defined neighbourhood. That is, it is equivelent to a 'mean' or 'averaging' filter over the given shape. If you want to exclude the original pixel from that average, only using the surrounding pixels, then you can use a '<code><a href="../morphology/#ring">Ring</a></code>' kernel (supplying only one radii). The other <a href="#shape_kernels">Shape Kernels</a> can also be used in the same way to, say, average the pixel values over a '<code><a href="../morphology/#diamond">Diamond</a></code>', '<code><a href="../morphology/#square">Square</a></code>' or large '<code><a href="../morphology/#disk">Disk</a></code>' shape and to whatever size you want. However while a constant averaging over an shaped area does blur images, it has a tendency to produce unusual effects (specifically <a href="../filter/#aliasing">Aliasing Artefacts</a>) in the resulting image. More specifically, by using a 'flat' averaging kernel tends to convert sharp edges into a thicker linear slope with sudden change in the slope at the thickened edges The thickness of the result is kernel '<code>radius*2-1</code>'. How different edge angles effect the slope thickness and linearity of the slope depends on the shape of the 'flat' or averaging kernel.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc: -draw 'polygon 15,15 15,65 60,15' shape.png
  magick shape.png \
         -define convolve:scale=! -morphology Convolve Square:5 \
         shape_mean_square.png
  magick shape.png \
         -define convolve:scale=! -morphology Convolve Disk:5 \
         shape_mean_disk.png
</samp></pre>
                </td>
              </tr>
            </table><a href="shape.png"><img src="shape.png" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="shape_mean_square.png"><img src="shape_mean_square.png" width="80" height="80" align="middle" vspace="0" hspace="0" border="1" alt="[IM Output]"></a> <a href="shape_mean_disk.png"><img src="shape_mean_disk.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Note that the diagonal blur in the above is different for a square kernel, than it is for a disk kernel. Another way of generating square 'linear slope' blurring is to use a very large sigma with a specific radius. The above square kernel convolution can for example also be achieved using <code>-blur 5x65535</code>. This was commonly used by Fred Wienhaus in his scripts before morphology was available. <!--<CODE EXECUTE>
  kernel2image -8.1 -mn -n -ml "Gaussian:0x2" \
               "Gaussian:5x2"    kernel_gaussian.gif
</CODE>-->
          <a href="kernel_gaussian.gif"><img src="kernel_gaussian.gif" align="right" vspace="0" hspace="0" border="0" alt="[IM Output]"></a> <a name="gaussian" id="gaussian"></a>
          <h4>Gaussian Kernel <font size="-1">(2d gaussian blur)</font></h4>As you may have gathered, the '<code>Gaussian</code>' kernel is the most commonly used kernel to <a href="#convolve">Convolve</a> an image. This is the mathematical ideal kernel for blurring effects. Here for example is the <a href="../morphology/#showKernel">Show Kernel</a> of a small '<code>Gaussian</code>' kernel (they can get very large very quickly)...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" err="kernel_gaussian.txt">
  magick xc: -define morphology:showKernel=1 \
         -morphology Convolve:0 Gaussian:0x0.8 null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="kernel_gaussian.txt"><img src="kernel_gaussian.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>I did not actually want to apply a convolution to the above, as I only wanted to show the kernel that it was going to use. As such I used a '<code>:0</code>' <a href="../morphology/#iterate">Iteration Count</a>, so it does nothing. Similarly I junk the resulting image output using the special '<code><a href="../files/#null">null:</a></code>' file format. As you can see by the convolution output range, a '<code>Gaussian</code>' kernel has already been normalized (scaled) for you. However you will also notice that it is still quite a large kernel, filled with small fractional values. If you look closer you will find the largest value (2.48678, which is also listed on the first line) is in the center, with the smallest values toward the edges and the corners (a value of about .000000194). Here is typical Gaussian blur using a convolution...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Gaussian:0x2 face_gaussian.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/face.png"><img src="../images/face.png" width="80" height="80" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_gaussian.gif"><img src="kernel_gaussian.gif" align="middle" vspace="5" hspace="0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="face_gaussian.png"><img src="face_gaussian.png" width="80" height="80" align="middle" vspace="0" hspace="10" border="1" alt="[IM Output]"></a>
          </div>The kernels syntax is straight forward...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   Gaussian:[{<i>radius</i>}]x{<i>sigma</i>}
</samp></pre>
                </td>
              </tr>
            </table>
          </div>These arguments are in fact exactly the same as that used by the "<code><a href="../option_link.cgi?gaussian-blur">-gaussian-blur</a></code>" operator, which actually performs a <a href="#convolve">Convolution</a> using this kernel. The first number, like most <a href="../morphology/#kernel">Morphology Kernels</a>, is the '<i>radius</i>' or size of the kernel. This is just an integer, with a minimum value of 1, making the smallest posible kernel 3x3 elements in size. The best idea is to always specify zero, which allows ImageMagick to calculate an appropriate radius for the '<i>sigma</i>' value provided. The second more important argument is '<i>sigma</i>' which defines how blurred or 'spread out' each pixel should become. The larger the value the more blurry an image will become. It is a floating-point value. <b>The <i>sigma</i> value MUST be provided</b>. If a sigma value of '<code>0.0</code>' is given you will end up with a fairly useless '<code><a href="#unity">Unity</a></code>' kernel (of the given radius, or a radius of 1, so producing a 3x3 kernel of a single '<code>1.0</code>' value surrounded by '<code>0.0</code>' values.). As you saw above, convolving with any type of '<code><a href="#unity">Unity</a></code>' kernel does <i>nothing</i> to the image! If you do specify a '<i>radius</i>' it is generally a good idea to make it at lest twice as big as the '<i>sigma</i>', IM usually calculates a radius that is approximately 3 times as big (actually the largest radius that will provide meaningful results), though it depends on the <a href="../basics/#quality">Compile-time Quality</a> of your specific IM installation. For more information on the effect of the '<code>Gaussian</code>' kernel arguments, and on blurring images in general, see... <a href="../blur/#blur">Blurring Images</a>. <!--<CODE EXECUTE>
  kernel2image -10.1 -mn -n -ml "Blur:0x2"  "Blur:7x2"  kernel_blur.gif
</CODE>-->
          <a href="kernel_blur.gif"><img src="kernel_blur.gif" align="right" vspace="0" hspace="0" border="0" alt="[IM Output]"></a> <a name="blur" id="blur"></a>
          <h4>Blur Kernel <font size="-1">(1d gaussian blur)</font></h4>The '<code>Blur</code>' kernel is very similar to the <a href="#gaussian">Gaussian Kernel</a>, and even takes the same arguments (see below). But where gaussian is a 2-dimensional curve, the '<code>Blur</code>' kernel produces a 1-dimensional curve. That is, to say it generates a long thin single row of values. Here is a <a href="../morphology/#showKernel">Show Kernel</a> output of a small '<code>Blur</code>' kernel. <!--<CODE EXECUTE>
  kernel2image -g 1 "Blur" miff:- | im_profile -s - kernel_blur_profile.gif
</CODE>-->
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" noimage="" err="kernel_blur.txt">
  magick xc: -define morphology:showKernel=1 \
         -morphology Convolve:0 Blur:0x0.8 null:
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="kernel_blur_profile.gif"><img src="kernel_blur_profile.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_blur.txt"><img src="kernel_blur.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>The graph shown above is an actual profile of the default '<code>Blur</code>' kernel. It was created using the <a href="../morphology/#kernel2image">Kernel Image</a> script "<code><a href="../scripts/kernel2image">kernel2image</a></code>", and that image then graphed using the "<code><a href="../scripts/im_profile">im_profile</a></code>" script. It clearly shows the 'Gaussian Bell Curve' that this kernel represents.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Here is an example of using this kernel to horizontally blur an image.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Blur:0x4 face_blur.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_blur.png"><img src="face_blur.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The kernel's syntax is exactly like that of '<code><a href="#gaussian">Gaussian</a></code>' but with an extra optional rotation angle.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   Blur:[{<i>radius</i>}]x{<i>sigma</i>}[,{<i>angle</i>}]
</samp></pre>
                </td>
              </tr>
            </table>
          </div>As before the second value '<i>sigma</i>' is required, and if set to zero you will get the linear equivelent of a '<code><a href="#unity">Unity</a></code>' kernel.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                The '<i>angle</i>' allows you rotate the kernel by 90 degrees allowing you to blur an image vertically.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Blur:0x4,90 face_blur_vert.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_blur_vert.png"><img src="face_blur_vert.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>At this time only a 90 degree rotation is posible. This may change in a later version of ImageMagick. The purpose of this kernel is actually to create a faster form of 2-dimentional image blurring that the '<code><a href="#gaussian">Gaussian</a></code>' kernel produces. See <a href="#gaussian_vs_blur">Gaussian vs Blur Kernels</a> below for details of how this is done. <!--<CODE EXECUTE>
  kernel2image -10.1 -mn -n -ml "Comet:0x3"  "Comet:9x3"  kernel_comet.gif
</CODE>-->
          <a href="kernel_comet.gif"><img src="kernel_comet.gif" align="right" vspace="0" hspace="0" border="0" alt="[IM Output]"></a> <a name="comet" id="comet"></a>
          <h4>Comet Kernel <font size="-1">(half 1d gaussian blur)</font></h4>The '<code>Comet</code>' kernel is almost exactly the same as a '<code><a href="#blur">Blur</a></code>' kernel, but is actually only a half a blur kernel.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" err="kernel_comet.txt">
  magick xc: -define morphology:showKernel=1 \
         -morphology Convolve:0 Comet:0x1.0 null:
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="kernel_comet.txt"><img src="kernel_comet.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>Note how the defined location of the origin is on the left hand edge, and not in the center of the kernel. This is very unusual for a convolution kernel, and as as such produces a very unusual result. It blurs the image out in one direction like a finger had smeared the surface of a wet painting, leaving a trail of color. Its a bit like the tail of a comet, or the trail left by a meteor, or falling star.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Comet:0x5 face_comet.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_comet.png"><img src="face_comet.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that both the foreground and background colors were 'smeared'. If you only want to blur the foreground colors, make the background transparent, and add it after the foreground has been blurred. You can also give a third <i>angle</i> argument to rotate the kernel in any multiple of 90 degrees about its 'origin'.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve comet:0x5+90 face_comet_vert.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_comet_vert.png"><img src="face_comet_vert.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This kernel is actually the same kernel that is use by the specialized <a href="../blur/#motion_blur">Motion Blur</a> operator, though that operator also does some very fancy coordinate look-up handling to allow the blur to work at any angle. Though it does so poorly, producing 'clumps' of color at large angles, such as 45 degrees. Hopefully proper kernel rotation will be implemented to create better motion blur type effects at angles outside of 90 degree increments. <a href="kernel_blur_profile.gif"><img src="kernel_blur_profile.gif" align="right" vspace="0" hspace="5" border="1" alt="[IM Output]"></a> <a name="gaussian_vs_blur" id="gaussian_vs_blur"></a>
          <h3>Gaussian vs Blur Kernels</h3>As mentioned the '<code><a href="#gaussian">Gaussian</a></code>' and '<code><a href="#blur">Blur</a></code>' kernels are very closely related, and can in fact to the same job. Both are representations of the <a href="#gaussian_curve">Gaussian Curve</a>, the first being a 2-dimentional representation, while the other is a 1-dimentional representation. For example, here is repeat of the "<code>-gaussian-blur 0x2</code>" which is equivalent to "<code>-morphology Convolve Gaussian:0x2</code>" operation.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -gaussian-blur 0x2 face_gaussian-blur.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_gaussian-blur.png"><img src="face_gaussian-blur.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This can be replaced by using two separate Linear or 1 dimensional blurring operations rotated ninety degrees to each other (order does not really matter either)...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Blur:0x2 \
         -morphology Convolve Blur:0x2+90 face_blur_x2.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_blur_x2.png"><img src="face_blur_x2.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Rather than specifying two separate convolutions, you can give both kernels as a kernel list. For example
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code do_no_execute="">
  magick face.png -morphology Convolve 'Blur:0x2;Blur:0x2+90' face_blur_x2.png
</code></pre>
                </td>
              </tr>
            </table>
          </div>IM will by default 're-iterate' the result of the first convolve kernel with the second (and later) convolve kernel, as defined by <a href="../morphology/#kernel_compose">Multiple Kernel Composition</a> setting. You can even simplify the above even further by asking IM to expand one kernel into a <a href="../morphology/#rotated_kernels">Rotated Kernel List</a>, by using a '<code>&gt;</code>' to do a list of 90 degree rotations (two kernels in this case). For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve 'Blur:0x2&gt;' face_blur_x2.png
</samp></pre>
                </td>
              </tr>
            </table>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                All the above examples are equivalent to each other, and is how the "<code><a href="../option_link.cgi?blur">-blur</a></code>" operator works.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -blur 0x2 face_blurred.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_blurred.png"><img src="face_blurred.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This represents the real difference between "<code><a href="../option_link.cgi?blur">-blur</a></code>" and "<code><a href="../option_link.cgi?gaussian-blur">-gaussian-blur</a></code>" operators. In the latter one single large 2-dimensional kernel is used, while the former uses two small 1-dimensional kernels are used. In terms of speed however the "<code><a href="../option_link.cgi?blur">-blur</a></code>" operator is usually an order of magnitude faster, as it uses two much smaller kernels, rather than one very large one. The larger the blurring argument (the size of the <i>sigma</i> argument) the bigger kernels become, and the larger the difference in speed between the two operations. As such the "<code><a href="../option_link.cgi?blur">-blur</a></code>" operator is generally the recommended one to use. The only difference in results between the two operators are small quantum rounding effects (unless you are using HDRI) and edge effects (depending on <a href="../misc/#virtual">Virtual Pixel Setting</a>). Both of these being caused by a loss of information generated due to saving an intermediate image between the two separate passes of the 'blur' convolutions. This difference is typically so small as to be invisible and of no concern to any practical usage. <a name="soft_blur" id="soft_blur"></a>
          <h3>Softened Blurring <font size="-1">(blending with original image)</font></h3>You can soften the impact of any sort of blur by blending it with some of the original image. Especially when applying a very strong blur. For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Gaussian:0x3 face_strong_blur.png
  magick face.png face_strong_blur.png \
         -compose Blend -define compose:args=60,40% -composite \
         face_soft_blur.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/face.png"><img src="../images/face.png" width="80" height="80" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" align="middle" width="20" height="20&quot;" alt="+"> <a href="face_strong_blur.png"><img src="face_strong_blur.png" width="80" height="80" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="face_soft_blur.png"><img src="face_soft_blur.png" width="80" height="80" align="middle" vspace="0" hspace="10" border="1" alt="[IM Output]"></a>
          </div>This used the '<code><a href="../compose/#blend">Blend</a></code>' composition method, to mix '<code>60%</code>' of the blurred image (composition source image) with '<code>40%</code>' of the original image (composition destination image) to give a 'soft blur' effect on the final image. However you can do the same thing directly by <a href="#identity_addition">Blending the Kernel with the Identity Kernel</a>, using the same ratio.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale=60,40% \
         -morphology Convolve 'Gaussian:0x3' face_soft_blur2.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_soft_blur2.png"><img src="face_soft_blur2.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that the order of the scaling numbers is the same. The first number ('<code>60%</code>') scales the given kernel so as to reduce its effect on the output, while the second number ('<code>40%</code>') adds enough of the '<code><a href="#unity">Unity</a></code>' (or 'Identity') kernel to prevent the result from becoming darker. The important point is that for <a href="#blurring_kernels">Blurring Kernels</a>, the two numbers add up to '<code>100%</code>', just as you would for <a href="../compose/#blend_use">Composite Blending</a>. You can also use the faster 2-pass blurring, but in this case we can not incorperate a 'Blend' into the kernel directly, as the two separate convolutions will not 'separate' cleanly. As such we will need to again do the <a href="../compose/#blend">Blend Composition</a> afterwards.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png \( +clone -blur 0x3 \) \
         -compose Blend -define compose:args=60 -composite \
         face_soft_blur3.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_soft_blur3.png"><img src="face_soft_blur3.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that you only need to give the amount of the blurred (source) image you want to be blended with the original image. As such values of '<code>100</code>' will give the blurred image, while '<code>0</code>' will give the original image.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Remember the "<code><a href="../option_link.cgi?blur">-blur</a></code>" operator is exactly equivelent to using the faster 2-pass <a href="#blur">Bluring Kernels</a>.</i></font></td>
            </tr>
          </table><br>
          <a name="unsharpen" id="unsharpen"></a>
          <h3>'Un-sharpen' Images using Blurs <font size="-1">(subtracting from the original image)</font></h3>By taking this blending of kernels further, so that you start to use a negative scaling, you can subtract the blurring effects from the original image. The result is a technique called 'unsharp'. See <a href="http://en.wikipedia.org/wiki/Unsharp_mask">Unsharp, Wikipedia</a> for how it came to get such an unfortunate name.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale=-100,200% \
         -morphology Convolve 'Gaussian:0x2' face_unsharp.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_unsharp.png"><img src="face_unsharp.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that even though a negative kernel scaling factor is used, the two numbers still adds up to '<code>100%</code>', exactly as it did above. You can also do this with <a href="../compose/#blend_use">Composite Blending</a> as well. The above example is actually exactly how the mis-named "<code><a href="../option_link.cgi?sharpen">-sharpen</a></code>" operator works but with only the '<i>sigma</i>' blurring control. However no other control of the operation is provided. The blending is exactly as given above. You can use faster 2-pass, 1-dimensional <a href="#blur">Blurring Kernels</a>, but again you will need to do the blending operation as a separate step.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png \( +clone -blur 0x2 \) \
         -compose Blend -define compose:args=-100,200 -composite \
         face_unsharp_fast.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_unsharp_fast.png"><img src="face_unsharp_fast.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This you may have gathered is almost identical to that of <a href="#soft_blur">Softened Blurring</a> but with the blurred image being subtracted from the original image instead of being added. A blending method known as <a href="#compose/#blend_use">Extrapolated Blending</a>, or blending beyond the normal 0 to 100 percent range. Again like you can simply specify how much of the blurred image you want to subtract from the original image. For example lets over do the unsharpening of the image, causing some aliasing and color distortions.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png \( +clone -blur 0x2 \) \
         -compose Blend -define compose:args=-200 -composite \
         face_unsharp_200.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_unsharp_200.png"><img src="face_unsharp_200.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The full "<code><a href="../option_link.cgi?unsharp">-unsharp</a></code>" operator provides another type of control. Specifically, a difference threshold, so that the sharpening only applied when the given difference is larger, such as near an actual edge within the image. That threshold can be use to prevent the 'sharpening' small small defects, like wrinkles, or camera noise. Unsharpening an image is typically used with very small blurs (on the order of sigma=0.75) after resizing or distorting image, to improve the final result. See <a href="../resize/#resize_unsharp">Sharpen Resized Images</a> for some examples of this. The alternative to using an 'unsharp' technique for image sharpening is to actually locate image edges and use them to sharpen images. See <a href="#sharpening">Sharpening Images with Edge Detection</a> below for details. However it is generally regarded as being slower, though not really by very much.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="edgedet" id="edgedet"></a>
          <h2>Edge Detection Convolutions <font size="-1">(high-pass filtering)</font></h2>Edge Detection is another area in which convolutions are heavilly used. The task here is to highlight or enhance the edges of an image in various ways. This can be to either locate an edge as accuratelly as posible or to determine the angle or direction of slope of each of the edges. However the job can be made a lot more difficult by the presence of noise in the image, such as that produced by scanners, digital cameras, or even just caused by the lossy compression of the JPEG image file format. In general, however, larger kernels handle noise better, but at a loss of localizing the edge properly, while smaller kernels produce sharp edge locating results but with more spurious results caused by noise in the image. There are a lot of small, well-known kernels, that have been developed and studied for edge detection. Most of these are 'named' after the mathematician which studied the mathematics or the developed that specific kernel type. As such, you have kernels such as '<code><a href="#laplacian">Laplacian</a></code>', '<code><a href="#sobel">Sobel</a></code>' and '<code><a href="#prewitt">Prewitt</a></code>'. These 'named' kernels are generally very small and are defined using whole numbers, so they can be built into specifically designed optimized software and hardware for speed. That is, they are said to be 'discrete' kernels. Because of that, you will need to either <a href="#kernel_scale">Scale</a> or <a href="#normalize">Normalize</a> the kernel as part of their use. Edge detection also has the side effect of providing ways of sharpening the edges of an image. <a name="zero-summing_kernels" id="zero-summing_kernels"></a>
          <h3>Zero-Summing Kernels</h3>All the edge detection kernels have one feature in common. They are all zero-summing. That means they contain negative values, but with all the values in the kernel adding up to zero. For a smooth flat color image, a <a href="#convolve">Convolution</a> using such a kernel will produce a 'zero' or black image. However for any other image, you will have results that contain both negatative and positive values. For example, here I apply a discrete '<code><a href="#sobel">Sobel</a></code>' edge detector on an image containing some basic shapes...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc:black \
         -fill white -draw 'rectangle 15,15 65,65' \
         -fill black -draw 'circle 40,40 40,20' shapes.gif
  magick shapes.gif -define convolve:scale='!' \
         -morphology Convolve Sobel shapes_sobel.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="shapes.gif"><img src="shapes.gif" width="80" height="80" align="middle" vspace="5" hspace="25" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="shapes_sobel.gif"><img src="shapes_sobel.gif" width="80" height="80" align="middle" vspace="0" hspace="25" border="1" alt="[IM Output]"></a>
          </div>If you look at the results you will see that the kernel is directional in that only the vertical edges are found (as defined by the '<code><a href="#sobel">Sobel</a></code>' kernel with a zero angle. However it only found one set of edges, the 'positive' left-to-right black-to-white slopes. To get the 'negative' slopes you will need to negate the kernel, by using the <a href="#kernel_scaling">Kernel Scaling Setting</a>. For example...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick shapes.gif -define convolve:scale='-1!' \
         -morphology Convolve Sobel shapes_sobel_neg.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="shapes_sobel_neg.gif"><img src="shapes_sobel_neg.gif" width="80" height="80" align="middle" vspace="0" hspace="25" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>With a '<code><a href="#sobel">Sobel</a></code>' kernel, you can also rotate it 180 degrees to get the same result as the 'scale negation', but not all kernels are symmetrical in this way. The other solution is to add an <a href="#bias">Output Bias</a> to the result. That is, add 50% grey to the resulting image so that negative values are lighter than this and positive values are brighter. However, you will also need to <a href="#kernel_scale">Scale the Kernel</a> to ensure the results remain 'unclipped' by the 'black' and 'white' limits of the image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick shapes.gif -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Sobel shapes_sobel_bias.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="shapes_sobel_bias.gif"><img src="shapes_sobel_bias.gif" width="80" height="80" align="middle" vspace="0" hspace="25" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>If you don't care about the polarity you can get an absolute value of the results with a little trickiness..
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick shapes.gif -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Sobel -solarize 50% -level 50,0% \
         shapes_sobel_abs.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="shapes_sobel_abs.gif"><img src="shapes_sobel_abs.gif" width="80" height="80" align="middle" vspace="0" hspace="25" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>See the '<code><a href="#sobel">Sobel</a></code>' kernel, for more result handling techniques, especially techniques involving direction determination. The other alternative to using an <a href="#bias">Output Bias</a> is to build a special <a href="../basics/#hdri">HDRI</a> version of Imagemagick. This stores images in memory using floating point vaules and means that the image values will not be 'clipped' or 'rounded' by the use of integers. However, even if you do use this special version of IM you will still need to post-process the results before saving to a normal image file format or you will need to use a special floating point enabled image file format. However you will not need to worry about clipping or rounding effects in the intermediate image results, making things easier to handle. <a name="edgedet_kernels" id="edgedet_kernels"></a>
          <h3>Edge detection Kernels</h3><!--<CODE EXECUTE>
  kernel2image -8.1 -mn -n -ml "LoG:0x2"  "Log:5x2"  kernel_log.gif
</CODE>-->
          <a href="kernel_log.gif"><img src="kernel_log.gif" align="right" vspace="0" hspace="0" border="0" alt="[IM Output]"></a> <a name="log" id="log"></a>
          <h4>LoG: Laplacian Of Gaussians</h4>
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   LoG:{<i>radius</i>},{<i>sigma</i>}
</samp></pre>
                </td>
              </tr>
            </table>
          </div>The '<code>LoG</code>' or "Laplacian of a Gaussian" is one of the best edge detection kernels you can get. It is also known as a "Mexican Hat" kernel. Basically is it a '<code><a href="#laplacian">Laplacian</a></code>' differential (slope) operator, that has been smoothed by the addition of gaussian blurring. This in turn removes most of the impact of noise in an image, which can be adjusted by the '<i>sigma</i>' setting. The Kernel contains negative values that form a ring around a strong central peak. In the 'Kernel Image' shown above, the negatives are shown as the dark (near black) colors with the edges decaying to zero (dark grey) toward the edges. And here is its effect.. showing how it highlights the edges of the image.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -bias 50% -morphology Convolve LoG:0x2 face_log.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/face.png"><img src="../images/face.png" width="80" height="80" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_log.gif"><img src="kernel_log.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="face_log.png"><img src="face_log.png" width="80" height="80" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>A laplacian kernel is direction-less, but produces both a positive and negative ridge of values on either size of an edge. To locate the edge you would look for the points of zero-crossing, between the positive and negative ridges, a technique known as <a href="http://en.wikipedia.org/wiki/Marr-Hildreth_algorithm">Marr and Hildreth Edge Detection</a>. This kernel is also ideal for <a href="#sharpen">Sharpening Images</a>.<br>
          <!--<CODE EXECUTE>
  kernel2image -8.1 -mn -n -ml "DoG:0,1.8,2.4" "DoG:5,1.8,2.4" kernel_dog.gif
</CODE>-->
           <a href="kernel_dog.gif"><img src="kernel_dog.gif" align="right" vspace="0" hspace="0" border="0" alt="[IM Output]"></a> <a name="dog" id="dog"></a>
          <h4>DoG: Difference of Gaussians</h4>
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   DoG:{<i>radius</i>},{<i>sigma1</i>}[,{<i>sigma2</i>}]
</samp></pre>
                </td>
              </tr>
            </table>
          </div>This will generate a '<code>DoG</code>' or "Difference of Gaussians" kernel in which the gaussian generated by '<i>sigma1</i>' will have the gaussian generated by '<i>sigma2</i>' subtracted from it. Normally '<i>sigma2</i>' is the larger so that the 'central peak' of the kernel is positive. Reversing the two numbers will effectivally negate the resulting kernel. One of the major criticisms of a <a href="#log">Laplacian of a Gaussian</a> is that it is difficult to implement as it is such an unusual mathematical curve. It is also not a very well documented curve. The other aspect is that it can not be 'separated' into a faster 2-pass solution as you can with a Gaussian, (see <a href="#gaussian_vs_blur">Gaussian vs Blur Kernels</a>). However by generating two '<code><a href="#gaussian">Gaussian</a></code>' kernels of slightly different <i>sigma</i> values (in a ratio of approximatally 1.6), and subtracting them from each other you can actually generate a close approximation of a <a href="#log">Laplacian of a Gaussian</a>. The result is that a '<code><a href="#dog">DoG</a></code>' is much more easilly generated in hardware, than a '<code><a href="#log">LoG</a></code>' kernel. For example, here I have placed the <a href="../morphology/#kernel2image">Kernel Images</a> of a '<code><a href="#log">LoG</a></code>', and a '<code><a href="#dog">DoG</a></code>' kernel side-by-side for comparison.
          <div align="center">
            <a href="kernel_dog.gif"><img src="kernel_dog.gif" align="middle" vspace="0" hspace="10" border="0" alt="[IM Output]"></a> <a href="kernel_log.gif"><img src="kernel_log.gif" align="middle" vspace="0" hspace="10" border="0" alt="[IM Output]"></a>
          </div>If you look on the <a href="http://en.wikipedia.org/wiki/Difference_of_Gaussians">Difference of Gaussian, Wikipedia</a> web page you will see some graphs where they also compare the profile of a '<code><a href="#log">LoG</a></code>' (or "Maxican Hat"), with a '<code><a href="#dog">DoG</a></code>', showing the verly very slight difference between matching curves. <i>More information wanted on how to map a sigma of a LoG to generate a near equivelent 'DoG'. If you know please Mail Me at the address in the footer.</i>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                The applied results are also the very similar.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr valign="bottom">
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -bias 50% -morphology Convolve DoG:0,1.8,2.4 face_dog.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_dog.png"><img src="face_dog.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Note that both '<i>sigma</i>' values should be defined and at least one should be non-zero. A zero value for either sigma component will be the equivalent of a '<code><a href="#unity">Unity</a></code>' kernel, meaning that it keeps the image unchanged. If both values are zero, the two Gaussians would be a '<code><a href="#unity">Unity</a></code>' kernels, which when substracted would produce a perfectly zero or black result (plus any bias value). When the arguments are '<code>Dog:0,0,<i>non-zero</i></code>, the DoG, becomes a simple high pass filter, which is defined as the 'Unity' kernel (producing the original image) minus a low pass filter kernel (blurred image). In this case sigma1=0 is just the 'Unity' kernel and sigma2=<i>non-zero</i> is a Gaussian low pass (blur) filter kernel. The following, therefore, produces a high pass filtered image with filter value of sigma2=2
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr valign="bottom">
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -bias 50% -morphology Convolve DoG:0,0,2 face_dog_unity.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_dog_unity.png"><img src="face_dog_unity.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>A Photoshop high pass filter with filter value of radius=2 produces the same result. Note that using '<code>DoG:0,2,0</code>' will return an image that is basically the negated version (around the Output Bias) of the previous image. This technique can also be used to generate a 3x3 'Isotropic Laplacian' kernel, meaning a '<code><a href="#laplacian">Laplacian</a></code>' kernel which produce equal results in all directions, rather than having unequal diagonal bias. For example radius=1 (for a 3x3 kernel) and a sigma of 1 will generate...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" err="kernel_laplacian_isotropic.txt">
  magick face.png -define morphology:showKernel=1 -bias 50% \
          -morphology Convolve DoG:1,0,1 face_laplacian_isotropic.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="face_laplacian_isotropic.png"><img src="face_laplacian_isotropic.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_laplacian_isotropic.txt"><img src="kernel_laplacian_isotropic.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>The other point about using a "Difference of Gaussians" is that you can use the much faster "<code><a href="../option_link.cgi?blur">-blur</a></code>" operator (which internally uses the '<code><a href="#blur">Blur</a></code>' kernels), to generate the same results. However to do this you will need to generate each of the two 'blurred' images separately, and then subtract the results, with the addition of an appropriate scaling and bias. For example...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png \
         \( -clone 0 -blur 0x1.8 \) \( -clone 0 -blur 0x2.4 \) -delete 0 \
         -compose Mathematics -define compose:args=0,-4,4,0.5 -composite \
         face_diff_of_blurs.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_diff_blurs.png"><img src="face_diff_of_blurs.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The above uses the special <a href="../compose/#mathematics">Mathematics Composition Method</a> to avoid problems with 'clipping' during the subtraction of the images in a non-<a href="../basics/#hdri">HDRI</a> version of IM. For more details see <a href="../transform/#math_addition">Adding Biased Gradients</a>. The only other factor is the use of a larger scaling factor during the subtraction (the two '<code>4</code>'s in the <a href="../compose/#mathematics">Mathematics Compose</a> argument). This is because subtracting two normalized blurs, does not produce the same (increased) magnitude of results that you from normalizing the two subtracted gaussian curves together in a '<code><a href="#dog">DoG</a></code>' kernel. However other than the magnitude, the above example image is equivelent to the first '<code><a href="#dog">DoG</a></code>' kernel result, just faster to generate, especially for larger sigma values. And that is the point, even though it is more work, that complex method is faster than using a '<code><a href="#dog">DoG</a></code>' or '<code><a href="#log">LoG</a></code>' kernel directly.<br>
          <a name="laplacian" id="laplacian"></a>
          <h4>Discrete Laplacian Kernels</h4>
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   Laplacian:{<i>type</i>}
</samp></pre>
                </td>
              </tr>
            </table>
          </div>There have been many forms of small "Laplacian Kernel" that have been published in many scientific research papers. Here I provide built in versions of the more common ones I have been able to find in the academic literature. These kernel are basically calculated using a '<code><a href="#log">LoG</a></code>' kernel but scaled so as to use discrete integer values in a small kernel array. This allows you to use generated dedicated fast image filters that only use integer maths to process the image data. However ImageMagick is a more generalized image processor and as such does not provide such an ultra fast dedicated filter. But people like to use these as they are simpler to understand, so many of them have been built into IM. None of the kernels provided here are rotatable, and most are 'anisotropic', meaning they are not perfectly circular, especially in diagonal directions. However see the previous section ('<code><a href="#dog">DoG</a></code>' kernels) for a way to generate a true "Isotropic 3x3 Laplacian Kernel". The first two '<code>Laplacian:0</code>' and '<code>Laplacian:1</code>' kernels are the most common form of "Discrete Laplacian Kernel" in use. They are very small, meaning they will locate edges very accurately, but are also prone to enhancing image noise. Note that not all '<i>type</i>' numbers have been defined, leaving spaces for more discrete kernels to be defined in the future. The numbers used were selected to better match the kernel defined by that number. <a name="laplacian_0" id="laplacian_0"></a>
          <h4><code>Laplacian:0</code> (default)</h4>The 8 neighbour Laplacian. Probably the most common discrete Laplacian edge detection kernel. Here I use <a href="../morphology/#showKernel">Show Kernel</a> to extract the 'discrete' and 'unnormalized' kernel, before showing you thw result of the normalized kernel with a <a href="#kernel_bias">Output Bias</a>.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" err="kernel_laplacian_0.txt">
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Laplacian:0 null:
  magick face.png -define convolve:scale='!' -bias 50% \
         -morphology Convolve Laplacian:0 face_laplacian_0.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="face_laplacian_0.png"><img src="face_laplacian_0.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_laplacian_0.txt"><img src="kernel_laplacian_0.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>Sometimes a Laplacian, whether it is a discrete Laplacian, as in the last example, or a generated '<code><a href="#log">LoG</a></code>' or '<code><a href="#dog">DoG</a></code>' produces a result that is more complex than is desired. In such cases, generating an unbiased image, (without any <a href="#kernel_bias">Output Bias</a>) will work better. So lets repeat the above without a bias, so as to only keep the brigher 'positive' edges.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='!' \
         -morphology Convolve Laplacian:0 \
         -auto-level face_laplacian_positives.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_laplacian_positives.png"><img src="face_laplacian_positives.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>In this case we have dark (black) lines on a lighter (white) colors. This in turn causes the filter to 'double' the edges, which can be seen in the results shown. For this image using a negative scaling factor (to keep negative edges, rather than positive edges), and seemd to work better on our test image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='-1!' \
         -morphology Convolve Laplacian:0 \
         -auto-level face_laplacian_negatives.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_laplacian_negatives.png"><img src="face_laplacian_negatives.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see, for this image using the negative size produces stronger edges without the 'twinning' effects the positive results produced. This is because of the use of 'black' edging lines on a white background, in the image being used. ASIDE: The reason you get a blue edge around the yellow star is that the difference between the 'yellow' star, and the 'white' background is a subtraction of blue color. If the background was black, you would get a yellow edge color. <!-- This does NOT work well
Another alternative is to merge an absolute value of the results. This can be
done using a <A HREF="../color_mods/#solarize" >Solarize Operation</A> on the
biased results and rescaling the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover table-striped" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='!' -bias 50% \
         -morphology Convolve Laplacian:0 -solarize 50% -negate \
         -auto-level face_laplacian_solarize.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_laplacian_solarize.png"
     ><IMG SRC="face_laplacian_solarize.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
-->
          <a name="laplacian_1" id="laplacian_1"></a>
          <h4><code>Laplacian:1</code></h4>The 4 neighbour Laplacian. Also very commonly used.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" err="kernel_laplacian_1.txt">
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Laplacian:1 null:
  magick face.png -define convolve:scale='!' -bias 50% \
         -morphology Convolve Laplacian:1 face_laplacian_1.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="face_laplacian_1.png"><img src="face_laplacian_1.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_laplacian_1.txt"><img src="kernel_laplacian_1.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>The results are not a strong, but are often clearer than the 8-neighbour laplacian. <a name="laplacian_2" id="laplacian_2"></a>
          <h4><code>Laplacian:2</code></h4>3x3 Laplacian, with center:4 edge:1 corner:-2
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" err="kernel_laplacian_2.txt">
  magick xc: -define morphology:showKernel=1 -precision 2 \
        -morphology Convolve:0 Laplacian:2 null:
  magick face.png -define convolve:scale='!' -bias 50% \
         -morphology Convolve Laplacian:2 face_laplacian_2.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="face_laplacian_2.png"><img src="face_laplacian_2.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_laplacian_2.txt"><img src="kernel_laplacian_2.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table><a name="laplacian_3" id="laplacian_3"></a>
          <h4><code>Laplacian:3</code></h4>3x3 Laplacian, with center:4 edge:-2 corner:1
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" err="kernel_laplacian_3.txt">
  magick xc: -define morphology:showKernel=1 -precision 2 \
             -morphology Convolve:0 Laplacian:3 null:
  magick face.png -define convolve:scale='400%!' -bias 50% \
         -morphology Convolve Laplacian:3  face_laplacian_3.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="face_laplacian_3.png"><img src="face_laplacian_3.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_laplacian_3.txt"><img src="kernel_laplacian_3.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>This kernel highlights diagonal edges, and tends to make vertical and horizontal edges vanish. However you may need to scale the results (as I did above) to see make any result visible. <a name="laplacian_5" id="laplacian_5"></a>
          <h4><code>Laplacian:5</code></h4>5x5 Laplacian
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" err="kernel_laplacian_5.txt">
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Laplacian:5 null:
  magick face.png -define convolve:scale='!' -bias 50% \
         -morphology Convolve Laplacian:5 face_laplacian_5.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="face_laplacian_5.png"><img src="face_laplacian_5.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_laplacian_5.txt"><img src="kernel_laplacian_5.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>The rule-of-thumb with laplacian kernels is the larger they are the cleaner the result, especially when errors are involved. However you also get less detail. <a name="laplacian_7" id="laplacian_7"></a>
          <h4><code>Laplacian:7</code></h4>7x7 Laplacian
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" err="kernel_laplacian_7.txt">
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Laplacian:7 null:
  magick face.png -define convolve:scale='!' -bias 50% \
         -morphology Convolve Laplacian:7 face_laplacian_7.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="face_laplacian_7.png"><img src="face_laplacian_7.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_laplacian_7.txt"><img src="kernel_laplacian_7.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table><a name="laplacian_15" id="laplacian_15"></a>
          <h4><code>Laplacian:15</code></h4>A Discrete 5x5 LoG (Sigma approximatally 1.4)
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" err="kernel_laplacian_15.txt">
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Laplacian:15 null:
  magick face.png -define convolve:scale='!' -bias 50% \
         -morphology Convolve Laplacian:15 face_laplacian_15.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="face_laplacian_15.png"><img src="face_laplacian_15.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_laplacian_15.txt"><img src="kernel_laplacian_15.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table><a name="laplacian_19" id="laplacian_19"></a>
          <h4><code>Laplacian:19</code></h4>A Discrete 9x9 LoG (Sigma approximatally 1.4)
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="10%" align="justify" rowspan="2"></td>
              <td width="90%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre><code execute="" err="kernel_laplacian_19.txt">
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Laplacian:19 null:
  magick face.png -define convolve:scale='!' -bias 50% \
         -morphology Convolve Laplacian:19 face_laplacian_19.png
</code></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td align="center" rowspan="2">
                <a href="face_laplacian_19.png"><img src="face_laplacian_19.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Text]"></a>
              </td>
            </tr>
            <tr>
              <td>
                <table border="0" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <a href="kernel_laplacian_19.txt"><img src="kernel_laplacian_19.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                    </td>
                  </tr>
                </table>
              </td>
            </tr>
          </table><a name="sharpening" id="sharpening"></a>
          <h3>Sharpening Images with Edge Detection <font size="-1">(enhancing the edges of the original image)</font></h3>The '<code><a href="#log">LoG</a></code>' and '<code><a href="#dog">DoG</a></code>' kernels can also be used to sharpen images, as opposed to <a href="#unsharpen">Un-sharpening Images using Blurs</a>. Basically all you need to do is add the kernel results (including negative results) to the original image. To do this is easy, simply add 100% weighted '<code><a href="#unity">Unity</a></code>' or "Identity" kernel to the scaling factors. This is why it was provided.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                For example...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='100,100%' \
         -morphology Convolve 'Log:0x2' face_sharpen.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_sharpen.png"><img src="face_sharpen.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                This is a much broader smoother sharpening of the image than what the <a href="#unsharpen">Unsharpen Technique</a> generated (result shown to right). That is, because it is an actual true sharpening of the image, and not one faked by the subtraction of a blur.
              </td>
              <td>
                <a href="face_unsharp.png"><img src="face_unsharp.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As before, when only a single pass convolution is being performed, you can make direct use of a <a href="#identity_addition">Blended Kernel</a>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                For example less sharp...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50,100%' \
         -morphology Convolve 'Log:0x2' face_sharpen_50.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_sharpen_50.png"><img src="face_sharpen_50.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                Or more sharp...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='150,100%' \
         -morphology Convolve 'Log:0x2' face_sharpen_150.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_sharpen_150.png"><img src="face_sharpen_150.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can use 2-pass methods of the <a href="#dog">Difference of Gaussians</a> to produce a faster multi-step sharpen operation, but as it was shown above, such a scheme requires, 4 convolutions and a separate blending operation to achieve the same result. <i>FUTURE: add example of this</i>It is this complexity that is the reason that using <a href="#unsharp">Unsharpen</a> is more often the preferred method of sharpening images. But as you can see for a heavy sharpening process, using a proper sharpening kernel is preferred over an <a href="#unsharpen">Unsharp Sharpening</a>. However for minor sharpening, such as <a href="../resize/#resize_unsharp">Sharpening Resized Images</a> their is no problem with using unsharp.<br>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="directional" id="directional"></a>
          <h2>Directional Convolutions <font size="-1">(Slopes, and Compass)</font></h2>Like the above, these kernels look for slopes in the color intensity of the image, but rather than any slope, these look for slopes in a specific direction. Mathematically this is known as a 'derivative' which is really just fancy way of saying 'slope'. But knowing slope information for different directions can also be useful as a means from which you can determine the angle or 'compass' direction of the a slope or image edge. That is, the 2-dimensional direction of the slope in an image at some particular point. Slopes are also used in image processing techniques known as 'embossing' and 'shading' of images. At this time no 'generated' kernels are available, only 'named' pre-defined kernels, such as <a href="#sobel">Sobel</a> and <a href="#roberts">Roberts</a>. However I am certain that the embossing and shading kernel generation functions will be moved into the morphology/convolution kernel set, at some point in the future. So lets have a look at some of the 'named' directional kernels. <a name="directional_kernels" id="directional_kernels"></a>
          <h3>Directional Kernels</h3><a name="sobel" id="sobel"></a>
          <h4>Sobel</h4><!--<CODE EXECUTE NOIMAGE ERR=kernel_sobel.txt>
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Sobel null:
</CODE>-->
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   Sobel:{<i>angle</i>}  
</samp></pre>
                </td>
              </tr>
              <tr>
                <td>
                  <a href="kernel_sobel.txt"><img src="kernel_sobel.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </blockquote>We already saw the '<i>Sobel</i>' kernel above in the discussion of <a href="zero-summing_kernels">Zero-Summing Kernels</a>. This kernel is a raw directional (first derivative) kernel designed to return the slope of an edge in some specific orthogonal direction. By default it is designed for left to right slope detection, using a '<code>convolve</code>' operation. The result is essentually a X-derivative (slope) of the image. <!--<CODE EXECUTE>
  kernel2image -15.1 -n -mn -g 1 -ml 'Sobel' Sobel kernel_sobel.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="pixel_spread.gif" err="spread_kernel.txt">
  magick -size 60x60 xc:black xc:white +append slope_positive.gif
  magick slope_positive.gif -morphology Convolve Sobel slope_sobel.gif
</code></pre>
                </td>
              </tr>
            </table><a href="slope_positive.gif"><img src="slope_positive.gif" width="120" height="60" align="middle" vspace="5" hspace="0" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_sobel.gif"><img src="kernel_sobel.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="slope_sobel.gif"><img src="slope_sobel.gif" width="120" height="60" align="middle" vspace="5" hspace="20" border="1" alt="[IM Output]"></a>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>If you look at the kernel you may think that it is declared backwards. In one sense you are actually correct. However this is due to the way '<a href="#convolve">Convolve</a>' actually works.<br>
              <br>
              You can find out more about this 'reversal' in more detail in <a href="#convolve_vs_correlate">Convolve vs Correlate</a> below.<br>
              <br></i></font></td>
            </tr>
          </table>Note that this kernel can produce a 'negative slope' indication too, but this cannot be seen unless a <a href="#bias">Bias</a> of '<code>50%</code>' is also used with this convolve operation. Though there is no negative slope in the previous example, this next example does have one, so I also added a <a href="#bias">Bias Setting</a> so you can see it.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="pixel_spread.gif" err="spread_kernel.txt">
  magick -size 40x60 xc:black xc:white xc:black +append slope_both.gif
  magick slope_both.gif -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Sobel slope_sobel_bias.gif
</code></pre>
                </td>
              </tr>
            </table><a href="slope_both.gif"><img src="slope_both.gif" width="120" height="60" align="middle" vspace="5" hspace="0" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_sobel.gif"><img src="kernel_sobel.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="slope_sobel_bias.gif"><img src="slope_sobel_bias.gif" width="120" height="60" align="middle" vspace="5" hspace="20" border="1" alt="[IM Output]"></a>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>If you use this kernel with '<code>Correlate</code>', you will find slopes that 'match' the way the kernel is defined. In that case you would get a positive results for a slope going from high (white value) on left and a low (black value) on right. In the able example the two lines would then be swapped.<br>
              <br>
              However the above is '<a href="#convolve">Convolution</a>', and not a '<a href="#correlate">Correlation</a>' (meaning match the kernel) . Again see <a href="#convolve_vs_correlate">Convolve vs Correlate</a> for more detail of the difference.</i></font></td>
            </tr>
          </table>As you can see we now get a white line (positive slope) as we go up the slope from black to white, and a black line (negative slope) as we go back down from white to black. Here is the result of using default '<code>Sobel</code>' kernel, on the face image.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Sobel face_sobel.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/face.png"><img src="../images/face.png" width="80" height="80" align="middle" vspace="5" hspace="10" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_sobel.gif"><img src="kernel_sobel.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="face_sobel.png"><img src="face_sobel.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Note that sobel, and most other edge detection kernals tend to produce a 2 pixel thick response along very strong edge, and a 3 pixel response over a single pixel wide line. This is much stronger than a laplacian edge detector. You can rotate this kernel using the '<i>angle</i>' argument, generally in multiples of 90 degrees. However you can also rotate it 45 degree multiples, even though it was not designed for this. This is useful for getting 45 degree quantized directional derivatives or the gradient magnitude from the maximum of all 45 degree rotated derivative results.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                Here it is again, but rotated 90 degrees (top to bottom).
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Sobel:90 face_sobel_90.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_sobel_90.png"><img src="face_sobel_90.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><br>
          One way to collect all the edges of an image using a '<code><a href="#sobel">Sobel</a></code>' kernel, is to apply the kernel 4 times in all directions, and collect the maximum value seen (using a <a href="../compose/#lighten">Lighten Mathematical Composition</a>. This is an approximation to the gradient magnitude.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
   magick face.png -define convolve:scale='!' \
          \( -clone 0 -morphology Convolve Sobel:0 \) \
          \( -clone 0 -morphology Convolve Sobel:90 \) \
          \( -clone 0 -morphology Convolve Sobel:180 \) \
          \( -clone 0 -morphology Convolve Sobel:270 \) \
          -delete 0 -background Black -compose Lighten -flatten \
          face_sobel_maximum.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_sobel_maximum.png"><img src="face_sobel_maximum.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can simplify the above by making use of the <a href="../morphology/#multi-kernel">Multiple Kernel Handling</a> features of IM morphology. That is, you can create a rotated list of all 90 degree rotations of the '<code><a href="#sobel">Sobel</a></code>' kernel.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
   magick face.png -define convolve:scale='!' \
          -define morphology:compose=Lighten \
          -morphology Convolve 'Sobel:&gt;' face_sobel_maximum_2.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_sobel_maximum_2.png"><img src="face_sobel_maximum_2.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>If you want to see exactly what the above is doing add the <a href="../morphology/#showKernel">Show Kernel</a> setting, and the <a href="../morphology/#verbose">Verbose</a> setting. A more efficient technique for generating a gradient magnitude would be to use the fact that a 180 degree rotation, simply produces the same result as a negating the kernel, and thus negating the results. As such the X and Y derivative (90 degree rotated convolutions), with some trickiness to get the absolute values of the convolution, can achieve such a result with less processing.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
   magick face.png -define convolve:scale='50%!' -bias 50% \
          \( -clone 0 -morphology Convolve Sobel:0 \) \
          \( -clone 0 -morphology Convolve Sobel:90 \) \
          -delete 0 -solarize 50% -level 50,0% \
          -compose Lighten -composite face_sobel_maximum_3.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_sobel_maximum_3.png"><img src="face_sobel_maximum_3.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>This is typically good enough for most purposes. A more exact magnitude of all the slopes can be extracted by doing a vector addition of the two X and Y derivatives (as per <a href="http://en.wikipedia.org/wiki/Pythagorean_theorem">Pythagorean Theorem</a>).
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
   magick face.png -define convolve:scale='50%!' -bias 50% \
          \( -clone 0 -morphology Convolve Sobel:0 \) \
          \( -clone 0 -morphology Convolve Sobel:90 \) \
          -delete 0 -solarize 50% -level 50,0% \
          +level 0,70% -gamma 0.5 -compose plus -composite -gamma 2 \
          -auto-level face_sobel_magnitude.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_sobel_magnitude.png"><img src="face_sobel_magnitude.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The "<code><a href="../option_link.cgi?gamma">-gamma</a></code>" function in the above use being used to perform a mathematical 'Square' and 'Square Root' of the values returned by the '<code><a href="#sobel">Sobel</a></code>' results. For more detail see <a href="../transform/#evaluate_pow">Power Of Maths Function</a>.<br>
              <br>
              The extra "<code><a href="../option_link.cgi?level">+level</a></code>" ensures the <a href="../compose/#plus">Plus Composition</a> does not overflow the image quantum range. See <a href="../basics/#quantum_effects">Quantum Effects, non-HDRI vs HDRI</a> for details.</i></font></td>
            </tr>
          </table>Instead of the magnitude you can extract the direction of the slope from the two edge detection results.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 30x600 xc:'#0F0' -colorspace HSB \
         gradient: -compose CopyRed -composite \
         -colorspace RGB -rotate 90  rainbow.jpg
  magick shapes.gif -define convolve:scale='50%!' -bias 50% \
         \( -clone 0 -morphology Convolve Sobel:0 \) \
         \( -clone 0 -morphology Convolve Sobel:90 \) \
         -delete 0 \
         \( -clone 0,1 -fx '0.5+atan2(v-0.5,0.5-u)/pi/2' rainbow.jpg -clut \) \
         \( -clone 0,1 -fx 'u&gt;0.48&amp;&amp;u&lt;0.52&amp;&amp;v&gt;0.48&amp;&amp;v&lt;0.52 ? 0.0 : 1.0' \) \
         -delete 0,1 -alpha off -compose CopyOpacity -composite \
         face_sobel_direction.png
</samp></pre>
                </td>
              </tr>
            </table><a href="shapes.gif"><img src="shapes.gif" width="80" height="80" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="face_sobel_direction.png"><img src="face_sobel_direction.png" width="80" height="80" align="middle" vspace="5" hspace="15" border="0" alt="[IM Output]"></a>
          </div>The first "<code><a href="../option_link.cgi?fx">-fx</a></code>" expression is the one that uses a 'atan()' function to magick a X,Y vector into an angle. This is then colored with the an external <a href="../canvas/#gradient_colorspace">Rainbow Gradient Image</a>, as a <a href="../color_mods/#clut">Color Lookup Table</a>. The second "<code><a href="../option_link.cgi?fx">-fx</a></code>" expression create a thresholded transparency mask to make any areas without a slope transparent. However the above technique tends to produce huge mess of information for real images as it does not take into account the magnitude of the slope. Here is another more complex version. This does almost all the calculations in the green 'G' channel, so as to reduce the amount of image processing needed by a factor of three. It then uses HSB colorspace to create direction (hue) and magnitude (brightness).
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -colorspace Gray    -channel G \
         -define convolve:scale='50%!' -bias 50% \
         \( -clone 0 -morphology Convolve Sobel:0 \) \
         \( -clone 0 -morphology Convolve Sobel:90 \) \
         -delete 0 \
         \( -clone 0,1 -fx '0.5 + atan2(v-0.5,0.5-u)/pi/2' \) \
         \( -clone 0   -fill white -colorize 100% \) \
         \( -clone 0,1 -fx 'hypot(u-0.5,v-0.5)*2' \) \
         -delete 0,1 -separate +channel \
         -set colorspace HSB -combine -colorspace RGB \
         face_sobel_magnitude_n_direction.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_sobel_magnitude_n_direction.png"><img src="face_sobel_magnitude_n_direction.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><br>
          <a name="roberts" id="roberts"></a>
          <h4>Roberts</h4><!--<CODE EXECUTE NOIMAGE ERR=kernel_roberts.txt>
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Roberts null:
</CODE>-->
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   Roberts:{<i>angle</i>}  
</samp></pre>
                </td>
              </tr>
              <tr>
                <td>
                  <a href="kernel_roberts.txt"><img src="kernel_roberts.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </blockquote>The '<code>Roberts</code>' kernel is far simplier that the previous '<code><a href="#sobel">Sobel</a></code>' kernel, and will produce an even tighter edge location (down to 2 pixels). Of course that also makes it more prone to noise effects. Normally this kernel is represented by a much smaller 2x1 or even a 2x2 kernel, however by implementing it as a 3x3 kernel I can 'cyclically' rotate the kernel in 45 degree increments.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                For example, here is a 45 degree result, more commonly known as a 'Roberts-Cross' kernel.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Roberts:45 face_roberts.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_roberts.png"><img src="face_roberts.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As with '<code><a href="#sobel">Sobel</a></code>' you can also use <a href="../morphology/#multi-kernel">Multi-Kernel Handling</a> to generate a maximum slope from all directions. But this time we will get 8 x 45 degree directions, rather than just 4.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
   magick face.png -define morphology:compose=Lighten \
          -morphology Convolve 'Roberts:@' face_roberts_maximum.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_roberts_maximum.png"><img src="face_roberts_maximum.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that as rotating this kernel by 180 degrees does not generate a negated result (due to an offset). As such you cannot simply merge half the number of convolutions, as you can with '<code><a href="#sobel">Sobel</a></code>'. Basically the slope generated by just one '<code><a href="#roberts">Roberts</a></code>' convolution, is offset by half a pixel from aligning with the actual image. That is, the slope calculated is located for a point between the '<code>+1</code>' and '<code>-1</code>' values, between the pixels, but stored in the center '<code>-1</code>' pixel. However this also means that by saving all the slopes around a pixel and adding them together, you get a much smaller sharper edge detection with only 2 pixels (rather than 4 pixels) highlighting sharp edge boundaries. <a name="prewitt" id="prewitt"></a>
          <h4>Prewitt</h4><!--<CODE EXECUTE NOIMAGE ERR=kernel_prewitt.txt>
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Prewitt null:
</CODE>-->
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   Prewitt:{<i>angle</i>}  
</samp></pre>
                </td>
              </tr>
              <tr>
                <td>
                  <a href="kernel_prewitt.txt"><img src="kernel_prewitt.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </blockquote>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                The '<code>Prewitt</code>' kernel is very similar to a '<code><a href="#sobel">Sobel</a></code>', though much looser on the exact direction of the specific edge detection. The result is thus a little more fuzzy.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Prewitt face_prewitt.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_prewitt.png"><img src="face_prewitt.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="compass" id="compass"></a>
          <h4>Compass</h4><!--<CODE EXECUTE NOIMAGE ERR=kernel_compass.txt>
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Compass null:
</CODE>-->
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   Compass:{<i>angle</i>}  
</samp></pre>
                </td>
              </tr>
              <tr>
                <td>
                  <a href="kernel_compass.txt"><img src="kernel_compass.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </blockquote>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                This is the 'Prewitt Compass' kernel which supposedly a stronger directional sense than '<code><a href="#sobel">Sobel</a></code>'.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Compass face_compass.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_compass.png"><img src="face_compass.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="kirsch" id="kirsch"></a>
          <h4>Kirsch</h4><!--<CODE EXECUTE NOIMAGE ERR=kernel_kirsch.txt>
  magick xc: -define morphology:showKernel=1 -precision 2 \
         -morphology Convolve:0 Kirsch null:
</CODE>-->
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   Kirsch:{<i>angle</i>}  
</samp></pre>
                </td>
              </tr>
              <tr>
                <td>
                  <a href="kernel_kirsch.txt"><img src="kernel_kirsch.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </blockquote>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                This is another strong direction sensing edge detector.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Kirsch face_kirsch.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_kirsch.png"><img src="face_kirsch.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="freichen" id="freichen"></a>
          <h4>Frei-Chen</h4>Three sets of kernels are provided by this built-in. The first is a 'Isotropic' (uniform direction) variant of '<code><a href="#sobel">Sobel</a></code>', where the '<code>2</code>' values have been replaced by a Square Root of 2. <!--<CODE EXECUTE NOIMAGE ERR=kernel_freichen.txt>
  magick xc: -define morphology:showKernel=1 \
         -morphology Convolve:0 Frei-Chen null:
</CODE>-->
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
   Frei-Chen:[{<i>type</i>},][{<i>angle</i>}]  
</samp></pre>
                </td>
              </tr>
              <tr>
                <td>
                  <a href="kernel_freichen.txt"><img src="kernel_freichen.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </blockquote>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="bottom">
              <td width="100%" align="justify">
                The kernel above is the default unweighted kernel that is the heart of the '<code>Frei-Chen</code>' kernel.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
         -morphology Convolve Frei-Chen face_freichen.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="face_freichen.png"><img src="face_freichen.png" width="80" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Like '<code><a href="#sobel">Sobel</a></code>', this kernel should be applied using an angle in multiples of 90 degrees. To make things easier two kernels (with the same weighting) have been provided, one like the above for orthogonal use, the other for diagonal use. <!--<CODE EXECUTE NOIMAGE ERR=kernel_freichen1.txt>
  magick xc: -define morphology:showKernel=1 \
         -morphology Convolve:0 Frei-Chen:1 null:
</CODE>-->
          <!--<CODE EXECUTE NOIMAGE ERR=kernel_freichen2.txt>
  magick xc: -define morphology:showKernel=1 \
         -morphology Convolve:0 Frei-Chen:2 null:
</CODE>-->
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td align="center">Frei-Chen:1</td>
              </tr>
              <tr>
                <td>
                  <a href="kernel_freichen1.txt"><img src="kernel_freichen1.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
              <tr>
                <td align="center">Frei-Chen:2</td>
              </tr>
              <tr>
                <td>
                  <a href="kernel_freichen2.txt"><img src="kernel_freichen2.txt.gif" align="middle" vspace="0" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </blockquote>The third set of types consists of 9 specially designed and weighted kernels that is used not only for edge detection in a specific direction, but also for determining the actual angle of a sharp edge. The '<i>type</i>' in this can is a number from '<code>11</code>' to '<code>19</code>', allowing you to extract any one of the 9 kernels in the set. However if you give a '<i>type</i>' value of '<code>10</code>' you will get a multi-kernel list of all 9, pre-weighted kernels.
          <pre>
The kernels are each applied to the original image, then the results are added
together to generate the edge detection result.

This is best done using a <a href="../basics/#hdri">HDRI</a> version of
ImageMagick.

</pre>
          <pre class="bg-light text-dark mx-4"><samp>
   magick image.png \
          \( -clone 0 -morphology Convolve FreiChen:11 \) \
          \( -clone 0 -morphology Convolve FreiChen:12 \) \
          \( -clone 0 -morphology Convolve FreiChen:13 \) \
          \( -clone 0 -morphology Convolve FreiChen:14 \) \
          \( -clone 0 -morphology Convolve FreiChen:15 \) \
          \( -clone 0 -morphology Convolve FreiChen:16 \) \
          \( -clone 0 -morphology Convolve FreiChen:17 \) \
          \( -clone 0 -morphology Convolve FreiChen:18 \) \
          \( -clone 0 -morphology Convolve FreiChen:19 \) \
          -delete 0 -background Black -compose Plus -flatten \
          result.pfm
</samp></pre>
          <pre>

If a type of 10 is given then a multi-kernel list of all the 9 weighted kernels
shown above is generated. This lets you use multi-kernel composition to do the
above, much more simply...

</pre>
          <pre class="bg-light text-dark mx-4"><samp>
    magick image.png -define morphology:compose=Plus \
           -morphology Convolve FreiChen:10 \
           result.pfm
</samp></pre>
          <pre>

I have not however found out what the supposed meaning of the results are.  If
anyone has any experience or knowledge about how this is actually used, please
let me know, so I can include it here for others to use.  </pre><br>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="correlate" id="correlate"></a>
          <h2>Correlate &nbsp; <font size="5">( <img src="../img_www/mph_correlate.gif" align="absmiddle"> )</font></h2>Where the '<code><a href="#convolve">Convolve</a></code>' method is basically used for image processing, the '<code>Correlate</code>' method is designed more for pattern matching. That is, it performs a 'Cross-Correlation' of an image with its kernel, looking for a match of the given shape within the image. In reality both '<code><a href="#convolve">Convolve</a></code>' and '<code>Correlate</code>' are the same operation. The only difference between them is actually very minor, namely, an x and y reflection (equivalent to a 180 degree rotation) of the kernel.The best guide I have found on the how correlation and convolution work and how they differ to each other is <a href="http://www.cs.umd.edu/~djacobs/CMSC426/Convolution.pdf">Class Notes for CMSC 426, Fall 2005, by David Jacobs</a>. <a name="convolve_vs_correlate" id="convolve_vs_correlate"></a>
          <h3>Convolution vs Correlation <font size="-1">(asymmetrical kernel effects)</font></h3>As I mentioned above the two operators '<code><a href="#convolve">Convolve</a></code>' and '<code><a href="#correlate">Correlate</a></code>' are essentially the same. In fact users often say convolution, when what they really mean is a correlation. Also correlation is actually the simpler method to understand. For kernels which are symmetrical around a central 'origin', which is very typically the case, the two methods are actually the same. The difference only becomes apparent when you are using an asymmetrical or uneven kernel. For example, here I use a 'L' shaped 'flat' kernel against our 'single pixel' image. <!--<CODE EXECUTE SCRIPT IMAGE=kernel_lshape.gif>
  kernel2image -15.2 -m -ml 'L-Shape' \
               '3: 1,0,0
                   1,0,0
                   1,1,0'    kernel_lshape.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="convolve_shape.gif">
  magick pixel.gif  \
         -morphology Convolve '3: 1,0,0
                                  1,0,0
                                  1,1,0' convolve_shape.gif
</code></pre>
                </td>
              </tr>
            </table><a href="pixel.gif"><img src="pixel.gif" width="88" height="88" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_convolve.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_lshape.gif"><img src="kernel_lshape.gif" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="convolve_shape.gif"><img src="convolve_shape.gif" width="88" height="88" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
          </div>As you can see a '<code><a href="#convolve">Convolve</a></code>' expanded the single pixel in the center to form the 'L' shape around it. Even when the origin itself was not part of the 'neighbourhood'. Now lets repeat this example but using '<code><a href="#correlate">Correlate</a></code>' instead.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="correlate_shape.gif">
  magick pixel.gif  \
         -morphology Correlate '3: 1,0,0
                                   1,0,0
                                   1,1,0' correlate_shape.gif
</code></pre>
                </td>
              </tr>
            </table><a href="pixel.gif"><img src="pixel.gif" width="88" height="88" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_correlate.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_lshape.gif"><img src="kernel_lshape.gif" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="correlate_shape.gif"><img src="correlate_shape.gif" width="88" height="88" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
          </div>As you can see '<code><a href="#correlate">Correlate</a></code>' also expanded the single pixel, to form a 'L' shape but it was a 'rotated' 'L' shape. This is essentially the only difference between these two methods. The '<code><a href="#correlate">Correlate</a></code>' method applies the kernel 'AS IS' which results in the single pixel expanding into a 'rotated' form. On the other hand '<code><a href="#convolve">Convolve</a></code>' actually uses an 180 degree 'rotated' form of the kernel so that each pixel gets expanded into the same non-rotated shape. If you like to see some great examples of how '<code><a href="#convolve">Convolve</a></code>' actually does work, I recommend you also have a look at <a href="http://www.archive.org/2/items/Lectures_on_Image_Processing/EECE253_07_Convolution.pdf">EECE \ CS 253 Image Processing, Lecture 7, Spatial Convolution</a>. The diagram on page 22, where it actually applies the 'reflected' kernel to a single pixel, just as I did above.<br>
          This rotation difference may not seem like much, but it means that in terms of the mathematics, a convolve operation (represented by an asterix ('<code>*</code>') symbol) is <a href="http://en.wikipedia.org/wiki/Commutativity">Commutative</a> in that if both kernel and image were treated as just an array of values (or two images), then <code>F * G == G * F</code>. It also means convolve is <a href="http://en.wikipedia.org/wiki/Associativity">Associtive</a> in that <code>( F * G ) * H == F * ( G * H )</code>. See <a href="http://en.wikipedia.org/wiki/Convolve#Properties">Convolution Properties, Wikipedia</a> for more information on this. The '<code><a href="#correlate">Correlate</a></code>' operation is neither <a href="http://en.wikipedia.org/wiki/Commutativity">Commutative</a> or <a href="http://en.wikipedia.org/wiki/Associativity">Associtive</a>. Even though it is closely related (by rotation of the kernel). Basically '<code><a href="#convolve">Convolve</a></code>' acts more like a mathematical 'multiply', while '<code><a href="#correlate">Correlate</a></code>' does not. The exception to all this fuss, is when the kernel being used is, identical when rotated 180 degrees. That is, the kernel is symetrical about the 'origin'. In that special case both operations generate equivelent results. What confuses people, is that most of the kernels that are use for convolution, such as Gaussian Blurs, Laplacian, and so on are symetrical, in which case it does not really matter whether you are in fact doing a convolution, or a correlation. So people get relaxed and fuzzy on the meanings. It is only when they are not symetrical, as in the case of <a href="#correlate_search">Shape Searching</a> (see next), or with directional kernels such as <a href="#sobel">Sobel</a>, that the difference really becomes important. <a name="correlate_search" id="correlate_search"></a>
          <h3>Correlation and Shape Searching</h3>The real use of the '<code>Correlate</code>' method, (applying the kernel neighbourhood 'as is' without rotation), is an old, but simple method of locating shaped objects that roughly match the shape found in the provided kernel. For example if we were to use '<code>Correlate</code>' with an 'L' shaped kernel and attempt to search the image that we created with the convolution method example above, we get...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="correlate.gif">
  magick convolve_shape.gif -define convolve:scale='1!' \
         -morphology Correlate '3: 1,0,0
                                   1,0,0
                                   1,1,0' correlate.gif
</code></pre>
                </td>
              </tr>
            </table><a href="convolve_shape.gif"><img src="convolve_shape_mag.gif" width="88" height="88" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_correlate.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_lshape.gif"><img src="kernel_lshape.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="correlate.gif"><img src="correlate_mag.gif" width="88" height="88" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            <table border="0" cellspacing="0" cellpadding="0" width="90%">
              <tr>
                <td align="justify"><font size="-1"><i>ASIDE: note that the 'black' areas in the above kernel image, represent a value of zero. Their are no negative values in this kernel, only positive values for the shape being matched.<br>
                <br></i></font></td>
              </tr>
            </table>
          </div><!--<CODE EXECUTE SCRIPT IMAGE=convolve_shape_mag.gif>
  magick convolve_shape.gif -scale 800% convolve_shape_mag.gif
  magick correlate.gif -scale 800% correlate_mag.gif
</CODE>-->
          Note that I used IM's <a href="#convolve_normalize">Kernel Normalization</a> to prevent the final results becoming too bright, and swamping the 'peak' in a sea of white points. As you can see the '<code><a href="#correlate">Correlate</a></code>' method produced a maximum brightness at the point where the kernel 'origin' exactly matches the same shape in the image. But it also produces less bright results where you only get a partial match of the shape. The more of the shape that matched, the brighter the pixel becomes. I would warn you however that while '<code><a href="#correlate">Correlate</a></code>' succeeded in this case, it is not really a great way of doing so. For example, it can generate a very large number of false matches in areas of very high brightness. This problem can be mitigated by using negative values for areas that should match the dark background of the image instead. That is, areas that do not match the background should make the resulting pixel less bright. <!--<CODE EXECUTE SCRIPT IMAGE=kernel_lpattern.gif>
  kernel2image -10.1 -m -ml 'L-Pattern' \
     '4x5+2+2:   - -1  -  -
                -1 +1 -1  -
                -1 +1 -1  -
                -1 +1 +1 -1
                 - -1 -1  - ' kernel_lpattern.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="correlate_pattern.gif">
  magick convolve_shape.gif -define convolve:scale='1^'  \
         -morphology Correlate '4x5+2+2:  0 -1  0  0
                                         -1 +1 -1  0
                                         -1 +1 -1  0
                                         -1 +1 +1 -1
                                          0 -1 -1  0 ' correlate_pattern.gif
</code></pre>
                </td>
              </tr>
            </table><a href="convolve_shape.gif"><img src="convolve_shape_mag.gif" width="88" height="88" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_correlate.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_lpattern.gif"><img src="kernel_lpattern.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="correlate_pattern.gif"><img src="correlate_pattern_mag.gif" width="88" height="88" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
            <table border="0" cellspacing="0" cellpadding="0" width="90%">
              <tr>
                <td align="justify"><font size="-1"><i>ASIDE: To make the kernel image clearer, I generated the kernel image so that positive (foreground) values are white, negative (background) values are black and the zero (don't care) values are transparent. However the kernel that is actually used, is completely defined, in terms of numbers, and its 'neighbourhood' is a full rectangle.<br>
                <br></i></font></td>
              </tr>
            </table>
          </div><!--<CODE EXECUTE>
  magick correlate_pattern.gif -scale 800% correlate_pattern_mag.gif
</CODE>-->
          As you can see, the matching peak is much more pronounced, as you are now not only matching forground pixels, but background pixels as well. Note the use of the special normalization flag '<code>^</code>' in the above. This is important as it will normalize the positive and negative values in the kernel separately. That is, you want to search for foreground pixels equally with the background pixels. This means that you can search for both positive and negative matches of the given shape by using an <a href="#../basics/#hdri">HDRI version of IM</a> or with the appropriate use of <a href="#bias">Output Bias</a> (see above). For example, here I apply the 'L' shape search to a test image containing both positive and negative 'L' shapes. (images shown have been magnified)
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="correlate_bias.gif">
  magick test_morphology.gif  -bias 50% -define convolve:scale='50%^' \
         -morphology Correlate '4x5+2+2:  0 -1  0  0
                                         -1  1 -1  0
                                         -1  1 -1  0
                                         -1  1  1 -1
                                          0 -1 -1  0 ' correlate_bias.gif
</code></pre>
                </td>
              </tr>
            </table><a href="test_mag.gif"><img src="test_mag.gif" width="208" height="136" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_correlate.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_lpattern.gif"><img src="kernel_lpattern.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="correlate_bias.gif"><img src="correlate_bias_mag.gif" width="208" height="136" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
          </div><!--<CODE EXECUTE>
  magick test_morphology.gif -scale 800% test_mag.gif
  magick correlate_bias.gif -scale 800% correlate_bias_mag.gif
</CODE>-->
          The <a href="#bias">Output Bias</a> made the normal output of the search a mid-tone grey, while the matching shapes are given brighter or darker colors, depending on the number of pixels that actually match the 'shape kernel'. If you examine the actual values of the output image only, one pure-white and one pure-black pixel are produced, indicating perfect matches. However there are also quite a number of near-matches as well. If I was not interested in the negative or 'black' matches, I could remove the <a href="#bias">Output Bias</a>, and the '<code>50%</code>' scaling factor, so that the no-match pixels are black, and perfect matches are white. Once you have a '<code><a href="#correlate">Correlate</a></code>' matching image, you need to try to find the matching 'peaks'. This can be done using another <a href="#correlate">Correlation</a>, but does not always work very well. The better method is to use the more exact pattern matching method, '<code><a href="../morphology/#hitmiss">HitAndMiss</a></code>' morphology, with the special '<code><a href="../morphology/#peaks">Peaks</a></code>' which was created for this purpose. This finds any single pixel that is only surrounded by darker colored pixels. Other '<code><a href="../morphology/#peaks">Peaks</a></code>' kernels can be used to find 'looser' matches. <!--<CODE EXECUTE>
  kernel2image -15.2 -m  Peaks:1.9  kernel_peaks.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick correlate_bias.gif  -morphology hitandmiss peaks:1.9 \
         -auto-level correlate_peaks.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="correlate_bias.gif"><img src="correlate_bias_mag.gif" width="208" height="136" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a> <img src="../img_www/mph_hitmiss.gif" align="middle" width="20" height="30&quot;"> <a href="kernel_peaks.gif"><img src="kernel_peaks.gif" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="correlate_peaks.gif"><img src="correlate_peaks_mag.gif" width="208" height="136" align="middle" vspace="5" hspace="15" border="1" alt="[IM Output]"></a>
          </div><!--<CODE EXECUTE>
  magick correlate_peaks.gif -scale 800% correlate_peaks_mag.gif
-->
          And here you can easilly find the location where the best match of the shape was found, though the degree of the match has been lost. You may like to look at the 'peak finding' section of <a href="../compare/#sub-image">Compare and Sub-Image Searching</a>. But also look at Fred Weinhaus's script "<code><a href="http://www.fmwconcepts.com/imagemagick/maxima/">maxima</a></code>". <i>FUTURE: Normalized Cross Correlation with the Fast Fourier Transform, for generating very fast image Correlations with very large images (both source image and sub-image).</i> <a name="correlate_vs_hitandmiss" id="correlate_vs_hitandmiss"></a>
          <h3>Correlation vs HitAnd Miss Morphology</h3>If you compare the kernel image as I represented it to kernels that are used by the <a href="../morphology/#hitmiss">Hit-And-Miss Morphology Method</a>, you will find they actually represent the same thing.
          <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5">
            <tr>
              <th></th>
              <th>'<code><a href="../morphology/#hitmiss">HitAndMiss</a></code>'</th>
              <th>'<code><a href="#correlate">Correlate</a></code>'</th>
            </tr>
            <tr valign="top">
              <td>Foreground</td>
              <td align="justify">A value of '<code>1.0</code>'</td>
              <td align="justify">A value of '<code>1.0</code>' (before normalization)</td>
            </tr>
            <tr valign="top">
              <td>Don't Care</td>
              <td align="justify">A value of '<code>Nan</code>' or '<code>0.5</code>'</td>
              <td align="justify">A value of '<code>Nan</code>' or '<code>0.0</code>'</td>
            </tr>
            <tr valign="top">
              <td>Background</td>
              <td align="justify">A value of '<code>0.0</code>'</td>
              <td align="justify">A value of '<code>-1.0</code>' (before normalization)</td>
            </tr>
            <tr valign="top">
              <td>Results</td>
              <td align="justify">Subtracts the minimum of the foreground from the maximum of background. Only exact matches will thus produce positive results and thresholding will produce a binary matching image.</td>
              <td align="justify">Generates a range of how closely the image matches a shape. It is possible for some background pixels to be larger in value than foreground pixels as long as the overall pattern is present. Can be difficult to locate specific 'matching' peaks. You can also find negative matches.</td>
            </tr>
          </table>As you can see they to correspond to each other. Thus a kernel for one could be transformed into a kernel for the other. However '<code><a href="../morphology/#hitmiss">Hit-And-Miss</a></code>' will only find perfect exact matches with a definite foreground to background difference. As such, it is much less forgiving of noise and near misses than '<code><a href="#correlate">Correlate</a></code>'. On the other hand '<code><a href="#correlate">Correlate</a></code>' can be performed using linear image processing and more specifically using a <a href="../fourier/">Fast Fourier Transform</a>. This can make pattern matching with larger patterns and kernels a lot faster, especially when multiple patterns are involved, saving you the cost of transforming images and patterns into the frequency domain. It also works with actual images, though some pre-processing and the use of <a href="../basics/#hdri">HDRI</a> may also be necessary. Which you use is really up to you, and what results you are after. Perfect matches only, or near matches with lots more errors, and the possible use of a faster algorithm. Note that for finding exact matches of small color images within larger images, the <a href="../compare/#sub-image">Sub-Image Locating Feature</a> of the "<code>magick compare</code>" program will provide a much better method than either '<code><a href="../morphology/#hmt">Hit-And-Miss</a></code>' or '<code><a href="#correlate">Correlate</a></code>' methods. This is because it uses a 'least squares of color vector differences' to do the sub-image matching, which can produce a better metric for match results. However it is just as slow, especially for large images.<br>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="neighbours" id="neighbours"></a>
          <h2>Neighbour Counting</h2>One of the more unusual things convolution can be put to is known as neighbour counting. That is, figuring out how many pixels exist in a particular area surrounding each pixel point in an image. <a name="counting" id="counting"></a>
          <h3>Counting Neighbours</h3>Basically by using a very simple convolution kernel you can create an image that contains a count of the number of neighbours surrounding a particular point in a binary image. By convolving with a <a href="../morphology/#ring">Ring Kernel</a> of the size '<code>1.5</code>' you get a neighbour count. Here is a count the neighbours of each pixel in a small area, and show the enlargement of individual pixels before and after (generated using the <a href="../scripts/enlarge_image">Enlarge Image Script</a>)...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick area.gif -define convolve:scale=\! \
         -morphology Convolve Ring:1.5 neighbour.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="area_enlarged.png"><img src="area_enlarged.png" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="neighbour_enlarged.png"><img src="neighbour_enlarged.png" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a>
          </div><!-- <CODE EXECUTE>
  enlarge_image -10.2 area.gif area_enlarged.png
  enlarge_image -10.2 neighbour.gif neighbour_enlarged.png
</CODE> -->
          As you can see all the pixels grey-level show how many neighbours they have, including any <a href="../misc/#virtual">Virtual Pixel</a> neighbours along the edges. If you want to include the current pixel in the count, you can use a <a href="../morphology/#square">Square Kernel</a> instead. With appropriate conversions (including level adjustments) and using the <a href="../formats/#pbmplus">PbmPlus File Format</a>, you can magick the above grey levels, into actual numbers if that is what you want.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" noimage="" out="neighbour.txt">
  magick neighbour.gif +depth +level 0,8 pgm: | pnmnoraw | tail -n +4
</code></pre>
                </td>
              </tr>
            </table>
            <table border="0" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <a href="neighbour.txt"><img src="neighbour.txt.gif" align="middle" vspace="5" hspace="0" border="0" alt="[IM Text]"></a>
                </td>
              </tr>
            </table>
          </div>If you want to exclude pixels that lie inside in the actual shape, you can use a kernel with a strong negative center pixel and then <a href="../basics/#clamp">Clamp</a> any negative results (if you are using <a href="../basics/#hdri">HDRI version of IM</a>). One simple method to generate just such a kernel of positive 1's surrounding a large negative center is to negatively scale a standard <a href="#laplacian">Descrete Laplacian Kernel</a>.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick area.gif -define convolve:scale=-1\! \
         -morphology Convolve Laplacian:0 -clamp neigh_edge.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="area_enlarged.png"><img src="area_enlarged.png" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="neigh_edge_enlarged.png"><img src="neigh_edge_enlarged.png" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a>
          </div><!-- <CODE EXECUTE>
  enlarge_image -10.2 neigh_edge.gif neigh_edge_enlarged.png
</CODE> -->
          Of course we could have used the original image as a mask to remove the uninteresting pixels too. <a name="life" id="life"></a>
          <h3>The Game of Life</h3>In 1970 a British mathematician, John Horton Conway, publish in Scientific American, a special simulation which became very popular. It is now known as <a href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life">Conway's Game of Life</a>. It was based on a grid of points where each point was either 'alive', or 'dead'. What 'cells' were then classed as being 'alive' or 'dead' in the next 'generation' depended of a set of very simple rules purely based on the number living neighbouring cells around them.
          <ul>
            <li>The neighbourhood is the 8 pixels surrounding each 'cell'.</li>
            <li>A 'live' cell continues to live if it has 2 or 3 neighbours.</li>
            <li>A 'dead' cell becomes 'live' (born) if it has exactly 3 neighbours.</li>
            <li>Otherwise the cell becomes or remains 'dead'.</li>
          </ul>The results of these rules on binary patterns was remarkable, in that you get clusters of 'cells' that seem to expand, and shrink, oscillate, or even move slowly across the grid. It became a major point of theoretical research, to see if you could even generate 'DNA' style replication of larger 'life patterns. ASIDE: It seems it was possible but it was so fragile as to be impractical, which makes current DNA life so much more remarkable. It also sparked major interest in the study and implementation of other forms of <a href="http://en.wikipedia.org/wiki/Cellular_automaton">Cellular Automation</a>, as a method of generating and studying large effects using very very simple rules at very small scales. Much like what happens in chemistry at the atomic and molecular level, but with greater complexity. So lets implement 'Life' using ImageMagick. First to make things easy we will make 'live' cells white, and 'dead' cells black. That way we are only counting 'white' pixels, surrounding each cell, in a 8 pixel neighbourhood. However we could also implemented with black and white swapped, though it would be harder to follow how it is done. However the rules has a strong dependency on if the central cell is alive or dead. So we need to separate the neighbourhood counts for a 'dead' cell from those of a 'live' cell. That can be simply done by giving the central cell a larger value than the sum of all its neighbours. A value of '10' is good for this. It is a nice round number that is larger than the maximum neighbourhood count of 8. That makes the 'Game of Life' Convolution kernel equivalent to..
          <blockquote>
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
    '3: 1,  1,  1     
        1, 10,  1
        1,  1,  1'
</samp></pre>
                </td>
              </tr>
            </table>
          </blockquote>The result of this will be a count of the 8 neighbours around each pixel (is 'white'), plus a value of 10 if the central pixel is 'live' or 'white'. As such the value of this kernel will be either '<code>0</code>' to '<code>8</code>' for dead pixels or '<code>10</code>' to '<code>18</code>' for live pixels. If we scale this kernel by a value of 20 (actually scaling by '<code>0.05</code>' to generate a gradient, see below), you will generate an image with 21 posible grey-levels. That is, you will get a 'black' for a value for the '<code>0</code>' grey-level and a white value for the '<code>21</code>' grey-level, not that the kernel can actually generate such a value. Now we can encode the '<i>Game of Life</i>' rules into an <a href="../color_mods/#clut">Color Lookup Table Image</a>, so as to magick the resulting neighbour count 'grey-level', generated by the above kernel, into the appropriate 'life and death' result according to the 'Life Rules'.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 21x1 xc:black -fill white \
          -draw 'point 3,0  point 12,0  point 13,0' \
          life_clut.gif
  enlarge_image -25.3 -ml 'Life Rules' life_clut.gif life_clut_enlarged.png
</samp></pre>
                </td>
              </tr>
            </table><a href="life_clut_enlarged.png"><img src="life_clut_enlarged.png" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a>
          </div>The image is very small, so I used a <a href="../scripts/enlarge_image">Enlarge Image Script</a> to generate a larger version to display above, with each pixel clearly separated. Basically the first 10 pixels are what to do for a 'dead cell', the next 10 pixels what to do for a 'live cell'. The first white pixel on the left side (neighbour count = 3 around a dead cell) is a 'birth', while the two white pixels on the right side (neighbour counts 2 and 3 next to a live cell) allows an existing 'live cell' to continue to live. Any other result leaves the result as black (dead). The <a href="../color_mods/#clut">Color Lookup Table</a> is 21 pixels long because I will be dividing by a scaling factor of 20, whice means we could generate a value in the range from 0 to 20, or 21 distinct gray-scale levels. We could actually use a different value than 10 for the center (cells previous state), and 20 for the scaling, but these values are easy numbers to work with. In summary, we divide the convolution kernel by 20, and use an CLUT that is 21 pixels long (with <a href="../misc/#integer">Integer Interpolation</a>) to match convolution results (grey-levels) to the right output color value. ASIDE: This 'Life Rules' CLUT, can be regarded as a general Cellular Automata Rules Table. The neighbourhood pattern used for neighbour counting is also part of the cellular automata. This technique is also outlined in <a href="http://psoup.math.wisc.edu/mcell/ca_rules.html">Cellular Automata Rules Lexicon</a>, in the <a href="http://psoup.math.wisc.edu/mcell/rullex_rtab.html">Rules Tables</a> section, as a way of defining general 'limit-free' forms of the cellular automata that it lists. Basically almost any automata can be defined using such a neighbourhood/table combination, though most are defined using more simplified forms. So lets apply this to an image containing a 'life' pattern, multiple times to see how the pattern changes from one generation to the next, and to check that it is working as expected.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 15x15 xc:black -fill white \
         -draw 'line  3,2 3,4  line 10,10 12,10  point 10,11  point 11,12' \
         life_gen_000.gif
  magick life_gen_000.gif -define convolve:scale=0.05 \
         -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
         life_clut.gif -interpolate integer -clut \
         life_gen_001.gif
  magick life_gen_001.gif -define convolve:scale=0.05 \
         -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
         life_clut.gif -interpolate integer -clut \
         life_gen_002.gif
  magick life_gen_002.gif -define convolve:scale=0.05 \
         -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
         life_clut.gif -interpolate integer -clut \
         life_gen_003.gif
  magick life_gen_003.gif -define convolve:scale=0.05 \
         -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
         life_clut.gif -interpolate integer -clut \
         life_gen_004.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="life_gen_000.gif"><img src="life_gen_000_mag.gif" width="90" height="90" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="life_gen_001.gif"><img src="life_gen_001_mag.gif" width="90" height="90" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="life_gen_002.gif"><img src="life_gen_002_mag.gif" width="90" height="90" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="life_gen_003.gif"><img src="life_gen_003_mag.gif" width="90" height="90" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="life_gen_004.gif"><img src="life_gen_004_mag.gif" width="90" height="90" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div><!-- <CODE EXECUTE NOIMAGE OUT=life_gen_000_mag.gif>
  magick life_gen_*.gif -scale 90x90 \
         -set filename:fname '%t_mag' +adjoin '%[filename:fname].gif'
</CODE> -->
          Remember the above images have been enlarged, to see the original 'tiny' image generated click the enlarged image. As you can see the 'Life' patterns behave as they should (if you are familar with the patterns). The 'blinker' in the top left corner flips back and forth, while the 'glider' in the bottom moved 1 diagonal step toward it, over the 4 'generations' we iterated the life rules. <a href="../images/glider_gun.gif"><img src="../images/glider_gun.gif" width="50" height="36" align="right" vspace="0" hspace="2" border="1" alt="[IM Output]"></a> And here is a larger example known as <a href="http://en.wikipedia.org/wiki/Gun_%28cellular_automaton%29">Gosper's Glider Gun</a>, where I generate an animation of 60 frames from a special life pattern. The actual size of the image being used is shown to the right, but I scale the resulting animation for better viewing.<br clear="all" height="1">
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" image="glider_gun_anim.gif">
  magick glider_gun.gif life_pattern.gif
  for i in `seq 59`; do
    magick life_pattern.gif -define convolve:scale=0.05 \
           -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
           life_clut.gif -interpolate integer -clut \
           -write life_pattern.gif miff:-
  done | magick - -scale 500% \
                -set delay 10 -layers Optimize -loop 0  glider_gun_anim.gif
  magick glider_gun.gif -scale 500% life_pattern.gif
</code></pre>
                </td>
              </tr>
            </table><a href="life_pattern.gif"><img src="life_pattern.gif" width="250" height="180" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" align="middle" width="20" height="20" alt="==&gt;"> <a href="glider_gun_anim.gif"><img src="glider_gun_anim.gif" width="250" height="180" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Note that the reason the glider 'explodes' on the bottom edge is because of the default '<a href="../misc/#virtual">Virtual Pixel</a>' handling that convolve uses, and the loss of the life information as it goes beyond the bounds of the image. More life pattern images can be found in the <a href="http://www.radicaleye.com/lifepage/patterns/contents.html">Life Pattern Catalog</a>, though you will need to recolor (negate) the images for use in the above life processor. I'll leave it as an exercise for someone to put the above into a script, that can generate a life sequence for some particular input image.<br>
          This is just one example of whole range of '<i>Cellular Automata</i>' that IM could process. Of course their are many faster dedicated programs for 'Life' and 'Cellular Automata', which generally do exactly the same thing, but I wanted to show that IM is flexiable enough to do it as well. As the results are simple binary images, you can also use IM's <a href="../morphology/#morphology">Morphology</a> methods such as <a href="../morphology/#hmt">Hit and Miss Pattern Searching</a> or <a href="#correlate_search">Cross-Correlation</a> to search for specific life patterns, making using IM for life reseach more practical, if slow.
          <hr>
          <!-- ---------------------------------------------------------------- -->
        </div>
      </div>
    </div>
  </main>
  <footer class="magick-footer">
    <div class="container-fluid">
      Created: 26 May 2010 (Separated from "morphology")<br>
      Updated: 26 March 2013<br>
      Author: <a href="https://antofthy.gitlab.io/anthony.html">Anthony Thyssen</a>, &lt;Anthony.Thyssen@gmail.com&gt;<br>
      Major Input: <a href="http://www.fmwconcepts.com/fmw/fmw.html">Fred Weinhaus</a>, &lt;fmw at alink dot net&gt;<br>
      Examples Generated with: <img src="version.gif" align="absmiddle" alt="[version image]"><br>
      URL: <code>https://imagemagick.org/Usage/convolve/</code>
    </div>
  </footer>
</body>
</html>
