<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Convolution of Images -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://imagemagick.org/Usage/convolve/">
</HEAD><body><main class="container"><div class="magick-template"><div class="magick-header">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Convolution of Images</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#intro"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Introduction to Convolution</A>
    <UL>
    <LI><A HREF="#convolve"
        >Convolve</A>
    <LI><A HREF="#kernel_scaling"
        >Convolve Kernel Scaling</A>
    <LI><A HREF="#normalize"
        >Kernel Normalization (Automatic Scaling)</A>
    <LI><A HREF="#zero-summing_normalization"
        >Zero-Summing Normalization</A>
    <LI><A HREF="#identity_addition"
        >Blending Kernel with the Identity Kernel</A>
    <LI><A HREF="#bias"
        >Output result Bias Control</A>
    </UL>
<DD><A HREF="#blurring_images"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Blurring Images</A> (Low-Pass Filtering)
    <UL>
    <LI><A HREF="#blurring_kernels"
        >Blurring Kernels</A>
        <UL>
        <LI><A HREF="#unity"    ><CODE>Unity</CODE> or Identity Kernel</A>
        <LI><A HREF="#mean"     >Shaped Mean or Average Kernel</A>
        <LI><A HREF="#gaussian" ><CODE>Gaussian</CODE> Blurring Kernel</A>
        <LI><A HREF="#blur"     >Linear 1D Gaussian (<CODE>Blur</CODE>)</A>
        <LI><A HREF="#comet"    >Half Gaussian (<CODE>Comet</CODE>)</A>
        </UL>
    <LI><A HREF="#gaussian_vs_blur"
        >Gaussian vs Blur Kernels</A>
    <LI><A HREF="#soft_blur"
        >Softened Blurring</A>
        (blending with original image)
    <LI><A HREF="#unsharpen"
        >'Un-sharpen' Images using Blurs</A>
        (subtracting from the original image)
    </UL>
<DD><A HREF="#edgedet"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Edge Detection Convolutions</A> (High-Pass Filtering)
    <UL>
    <LI><A HREF="#edgedet_kernels"
        >Edge Detection Kernels</A>
        <UL>
        <LI><A HREF="#log" >Laplacian Of Gaussians (<CODE>LoG</CODE>)</A>
        <LI><A HREF="#dog" >Difference Of Gaussians (<CODE>DoG</CODE>)</A>
        <LI><A HREF="#laplacian" >Discrete <CODE>Laplacian</CODE> Kernels</A>
        </UL>
    <LI><A HREF="#sharpening"
        >Sharpening Images with Edge Detection</A>
        (enhancing the edges of the original image)
    </UL>
<DD><A HREF="#directional"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Directional Convolutions</A> (Slopes, Compass Filtering)
    <UL>
    <LI><A HREF="#directional_kernels"
        >Directional Kernels</A>
        <UL>
        <LI><A HREF="#sobel"     ><CODE>Sobel</CODE></A>,&nbsp;
            <A HREF="#roberts"   ><CODE>Roberts</CODE></A>,&nbsp;
            <A HREF="#prewitt"   ><CODE>Prewitt</CODE></A>,&nbsp;
            <A HREF="#compass"   ><CODE>Compass</CODE></A>,&nbsp;
            <A HREF="#kirsch"     ><CODE>Kirsch</CODE></A>,&nbsp;
            <A HREF="#freichen"  ><CODE>FreiChen</CODE></A>
        </UL>
    </UL>
<DD><A HREF="#correlate"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Correlate</A>
    <UL>
    <LI><A HREF="#convolve_vs_correlate"
        >Convolve vs Correlate</A>
        (asymmetrical kernel effects)
    <LI><A HREF="#correlate_search"
        >Correlation and Shape Searching</A>
    <LI><A HREF="#correlate_vs_hitandmiss"
        >Correlate vs HitAndMiss</A>
    </UL>
<DD><A HREF="#neighbours"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Neighbour Counting</A>
    <UL>
    <LI><A HREF="#counting"
        >Counting Neighbours</A>
    <LI><A HREF="#life"
        >The Game of Life</A>
    </UL>
</DL></P>

Convolution uses the local 'neighbourhood' of pixels to modify images.  It
does this by merging and averaging all the color values around each pixel to
blur images, to highlight edges and boundaries, and sharpen images.  The
convolution variation, 'Correlation' is also used for scanning and searching
for specific patterns, producing an image denoting how closely images matches.
</P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="intro"></A>
<H2>Introduction to Convolution</H2>

The '<CODE>Convolve</CODE>' and the closely related '<CODE>Correlate</CODE>'
methods, are is many ways very similar to <A HREF="../morphology/#intro"
>Morphology</A>.  In fact they work in almost the exactly the same way,
matching up a neighbourhood 'kernel' at each location, making them a just
another special 'method' of morphology. </P>

In fact, they also use much of the same code and even the same kernel
definitions that was defined in <A HREF="../morphology/#kernels" >Basic
Kernels</A> and <A HREF="../morphology/#user" >User Defined Kernels</A>.  For
more specific kernels designed for use by this operator, (and there are many),
I refer you to <A HREF="#blurring_kernels" >Blurring Kernels</A>, and <A
HREF="edgedet_kernels" >Edge Detection Kernels</A>.  The most important
kernel being the '<CODE><A HREF="gaussian" >Gaussian</A></CODE>' kernel. </P>

However, convolution is much older than morphology, and it generates more
grey-scale gradient effects, rather than the binary shape studying effects
that morphology typically generates.  This is why it is often regarded as
a very different or separate operation to morphology and one that is more
central to image processing. </P>

Basically a convolution or correlation performs a 'weighted average' of all
the pixels in the neighbourhood specified.  That is, it multiplies the value of
each nearby pixel by the amount given in the kernel, then adds all those
values together to produce the final result. </P>

As such, each pixel in the final image will generally contain at least a small
part of all the other pixels locally surrounding it in the source image.
Looking at it another way, the color of each pixel in the image will be either
added to (blurred) or subtracted from (sharpen/edge detection) the colors of
all its near by neighbours, as defined by then kernel used. </P>

Both 'convolve' and 'correlate' are the same operation, except in a very minor
but important way, and for the examples and controls that we will now look,
you can treat them as being basically the same thing.  Later (See <A
HREF="#convolve_vs_correlate" >Convolution vs Correlation</A>) we will examine
exactly how the two operators really differ and why they differ in such
a minor way. But in most circumstances they are the same method.  </P>


<BR>

<A NAME="convolve"></A>
<H3>Convolve
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/mph_convolve.gif" ALIGN=absmiddle>
)</FONT></H3>

As was mentioned above the '<CODE>Convolve</CODE>' method works by weighting
each of the pixels in the local neighbourhood, according to the floating point
values in the kernel.  The weighted values are then simply added together to
produce the new replacement pixel in the resulting image. </P>

For example lets convolve a single pixel, using a very small <A
HREF="../morphology/#user" >User Defined</A> convolution kernel.  I also set
the special <A HREF="../morphology/#showkernel" >Show Kernel Setting</A>, so
you can see the details of the kernel being defined and used (displayed images
have been enlarged).

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=pixel_spread.gif ERR=spread_kernel.txt>
  magick xc: -bordercolor black -border 5x5 pixel.gif
  magick pixel.gif -define morphology:showkernel=1 \
          -morphology Convolve '3x3: 0.0, 0.5, 0.0
                                     0.5, 1.0, 0.5
                                     0.0, 0.5, 0.0'  pixel_spread.gif
</samp></pre></TD></TR></TABLE>
<!--<CODE EXECUTE>
  kernel2image -10.1 -n -mn -g 1 -ml '' \
               '3: 0,1,0  1,2,1  0,1,0'  kernel_spread.gif
  magick pixel.gif -scale 800% pixel_mag.gif
  magick pixel_spread.gif -scale 800% pixel_spread_mag.gif
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="spread_kernel.txt"
     ><IMG SRC="spread_kernel.txt.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
  <A HREF="pixel.gif"
     ><IMG SRC="pixel_mag.gif"  WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_spread.gif"
     ><IMG SRC="kernel_spread.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="pixel_spread.gif"
     ><IMG SRC="pixel_spread_mag.gif"  WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the single pixel in the image has now expanded to produce 50%
gray pixels around it.  </P>

That is, when the kernel's 'origin' (it's center in this case) is positioned
next to the single pixel in the original image, only that single pixel has
a non-zero value. This pixel value is then weighted by the '<CODE>0.5</CODE>'
value of the kernel, and the resulting 'half-bright' pixel is added to the
resulting image.  </P>

Simularly when the kernel's origin is position exactly over the original
pixel, it will get a value of '<CODE>1.0</CODE>' reproducing the original
pixel with no other values (black) in the neighbourhood around it adding any
component to the result. </P>

Note that any kernel value of '<CODE>0.0</CODE>' will take no part in the
final calculation. Zero values are effectively not part of the
'neighbourhood', just as any '<CODE>Nan</CODE>' value in morphology kernels
take no part.   As such this kernel consists of a 5 element neighbourhood.
</P>

In many ways a '<CODE><A HREF="#convolve" >Convolve</A></CODE>' method is very
similar to a morphological '<CODE><A HREF="../morphology/#dilate"
>Dilate</A></CODE>' method, however '<CODE><A HREF="../morphology/#dilate"
>Dilate</A></CODE>' only treats the kernel as a type of bitmap mask, locating
the largest value within the neighbourhood. On the other hand '<CODE><A
HREF="#convolve" >Convolve</A></CODE>' is a weighted sum of all the values in
the neighbourhood, as such the value of each kernel element plays a part in
the overall result. </P>

The syntax of a convolution operation is...

<DIV ALIGN=center>
<pre class="bg-light text-dark mx-4"><samp><B>
  -morphology Convolve {<I>convolution_kernel</I>}
</B></samp></pre>
</DIV></P>

But you can also use an older, more direct operator...

<DIV ALIGN=center>
<pre class="bg-light text-dark mx-4"><samp><B>
  -convolve {<I>convolution_kernel</I>}
</B></samp></pre>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Before IM v6.5.9 the older "<CODE><A HREF="../option_link.cgi?convolve"
  >-convolve</A></CODE>" did not understand morphology kernel definitions.
  It would only accept the 'old style' of user defined kernels, consisting of
  just a string of comma separated values to produce to some odd-sized square
  kernel.  It will now accept the 'new' style' convolution kernels defintions.
  </P>

  However it is still restricted to 'odd sized' square kernels. And will
  remain that way until it starts to make use of the new 'morphology'
  convolution method. </P>

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The older "<CODE><A HREF="../option_link.cgi?convolve"
  >-convolve</A></CODE>" operator is not exactly the same as the newer
  morphology '<CODE><A HREF="#convolve" >Convolve</A></CODE>' method.  The
  following is a list of how the two operations differ... </P>

  <UL>
  <LI>The old operator is implemented as a <A HREF="#correlation"
      >Correlation</A> rather than a true convolve.  This means the kernel is
      not overlaid on the source image in its reflected form.  See <A
      HREF="#convolve_vs_correlate" >Convolve vs Correlate</A> for the effects
      this has on results. </P>

  <LI>It only accepts odd sized square kernels. The morphology one allows any
      rectangular array, with any point within the array being declared as the
      origin. </P>

  <LI>The old operator will always <A HREF="#kernel_normalization" >Normalize
      Kernels</A> without any user control over kernel <A
      HREF="#kernel_scaling" >Kernel Scaling</A> of the kernel. The new one
      does not automatically normalize, you need to request it.  However most
      generated kernels are pre-normalized for you. </P>

  <LI>You cannot use any form of <A HREF="#identity_addition" >Blending with
      the Identity Kernel</A>, though output <A HREF="#bias" >Output Bias</A>
      is performed as normal.

  <LI>It will however make use of fast 'GPU' code, if the host computer has
      such facilities. Morphology does not have this enabled yet. </P>

  <LI>Currently other convolution related operators, such as "<CODE><A
      HREF="../option_link.cgi?gaussian_blur" >-gaussian_blur</A></CODE>",
      "<CODE><A HREF="../option_link.cgi?blur" >-blur</A></CODE>",
      "<CODE><A HREF="../option_link.cgi?sharpen" >-sharpen</A></CODE>",
      "<CODE><A HREF="../option_link.cgi?unsharpen" >-unsharp</A></CODE>", use
      the old version of the operator. </P>

  <LI>By default the old command will only convolve against the color channels
      (as defined by the "<CODE><A HREF="../option_link.cgi?channel"
      >-channel</A></CODE>" setting.  If you convolve with a "<CODE><A
      HREF="../option_link.cgi?channel" >-channel</A> RGBA</CODE>" setting it
      will also weigh the kernel values by the alpha channel to ensure
      correct blurring with regards to transparency. </P>

      The Morphology '<CODE>convolve</CODE>' method will automatically handle
      transparency weighting of the color channels by default. That is
      image blurring using it will treat transparent colors as transparent,
      and thus avoid the <A HREF="../bugs/blur_trans/" >Blur Transparency
      Bug</A>, by default. </P>

      However if the user modifies the default "<CODE><A
      HREF="../option_link.cgi?channel" >-channel</A></CODE>" setting (by not
      including the special '<CODE>Sync</CODE>' flag), then it will handle the
      convolution as a pure channel based greyscale operator. </P>

      See the "<CODE><A HREF="../option_link.cgi?channel"
      >-channel</A></CODE>" setting documentation, or look at <A
      HREF="../compose/#image_math" >Image Channel Mathematics</A> which uses
      the same flag in the same way, for more information. </P>

  </UL></P>

  Eventually most of the above differences will change as it things merge
  with the newer morphology '<CODE><A HREF="#convolve" >Convolve</A></CODE>'
  method. </P>

</I></FONT></TD></TR></TABLE></P>


If you like to see some great examples of how '<CODE><A HREF="#convolve"
>Convolve</A></CODE>' actually does works, I recommend you also have a look at
<A
HREF="http://www.archive.org/details/Lectures_on_Image_Processing/EECE253_07_Convolution.pdf"
>EECE \ CS 253 Image Processing, Lecture 7, Spatial Convolution</A>. </P>

The <A HREF="http://en.wikipedia.org/wiki/Convolve" >Wikipedia, Convolve</A>
artical has some nice 1-D animations of the convolution process. </P>


<A NAME="kernel_scaling"></A>
<H3>Convolve Kernel Scaling</H3>

The above example works well for a mostly black image such as a single pixel,
but if you were to apply this to a real image, you will have a problem...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
<c>  magick logo: -resize 50% -crop 80x80+150+60 +repage  face.png
<z>  magick face.png \
          -morphology Convolve '3x3: 0.0,0.5,0.0  0.5,1.0,0.5   0.0,0.5,0.0' \
          face_spread.png
</samp></pre></TD></TR></TABLE>
  <A HREF="../images/face.png"
     ><IMG SRC="../images/face.png"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_spread.gif"
     ><IMG SRC="kernel_spread.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="../images/face.png"
     ><IMG SRC="face_spread.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the resulting image is very bright (3 times brighter in fact)
as the original image. </P>

What happened is that each pixel is being shared 3 times. 4 &times;
'<CODE>0.5</CODE>' on the sides, plus a full copy of the original pixel.  That
is the addition of all the values in the kernel is 3, making the resulting
image three times as bright! </P>

If you go back and look at the 'showkernel' output above, you will see that it
listed this kernel as having a "convolution output range from 0 to 3". Which
shows that this kernel will in general brighten an image 3 times. </P>

To fix this you would want to divide all the values in the kernel by 3.  That
is a value of '<CODE>0.5</CODE>' should really have been about
'<CODE>0.1667</CODE>' while the central value of '<CODE>1.0</CODE>' should
have been '<CODE>0.3333</CODE>'.  This is a process known as '<B>Kernel
Normalization</B>'. </P>

For example here is manually 'normalized' result, and the kernel definition...

<!--<CODE EXECUTE>
  kernel2image -10.1 -s '!' -mn -g 1 -ml '' \
               '3: 0,1,0  1,2,1  0,1,0'  kernel_spread_norm.gif
</CODE>-->
<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE IMAGE=face_spread_norm.png
                                          ERR=kernel_spread_norm.txt>
magick face.png  -define morphology:showkernel=1 \
        -morphology Convolve \
                '3x3: 0.0,.1667,0.0  .1667,.3333,.1667   0.0,.1667,0.0' \
        face_spread_norm.png
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
<A HREF="kernel_spread_norm.txt"
    ><IMG SRC="kernel_spread_norm.txt.gif"
          ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
<A HREF="../images/face.png"
    ><IMG SRC="../images/face.png"               WIDTH=80 HEIGHT=80
          ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
<A HREF="kernel_spread_norm.gif"
    ><IMG SRC="kernel_spread_norm.gif"
          ALIGN=middle VSPACE=5 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
<A HREF="face_spread_norm.png"
    ><IMG SRC="face_spread_norm.png"      WIDTH=80 HEIGHT=80
          ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see you get a very slightly blurred version of the face image, as
each pixel was spread out to each of its immediate neighbours.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
  ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The 'kernel image' that is shown in the above (generated using a special <A
  HREF="../morphology/#kernel2image" >Kernel 2 Image Script</A>) also shows
  the resulting normalized kernel.  As you can see the kernel itself is now
  very dark, as all its values are also dark, though they all add up to
  a value of '<CODE>1.0</CODE>'.  </P>

  From this point on all convolution kernel images shown will always be
  adjusted so the maximum value is set to white, otherwise all you will
  generally see is a dark, and basically useless, 'Kernel Image'. </P>

</I></FONT></TD></TR></TABLE></P>

Normalizing the kernel yourself is not pleasant, and as you saw it makes the
resulting kernel definition a lot harder to understand.  As such, alternative
ways are provided. </P>

As of IM v6.5.9-2 the special expert option "<CODE><A
HREF="../option_link.cgi?define" >-define</A> convolve:scale={<I
>kernel_scale</I>}</CODE>' allows you to specify a global scaling factor for
the kernel, and thus adjust the brightness of the overall result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
magick face.png  -define convolve:scale=0.33333 \
        -morphology Convolve '3x3: 0.0,0.5,0.0  0.5,1.0,0.5  0.0,0.5,0.0' \
        face_spread_scale.png
</samp></pre></TD></TR></TABLE></TD><TD>
<A HREF="face_spread_scale.png"
    ><IMG SRC="face_spread_scale.png"      WIDTH=80 HEIGHT=80
          ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Actually what this does is adjusts the overall intensity of the kernel results.
As you will see in later examples, you will probably want to make the
convolution result more or less powerful.  This '<I>kernel_scale</I>' factor
lets you do that.  </P>


<A NAME="normalize"></A>
<H3>Kernel Normalization (automatic scaling)</H3>

Rather then working out the scaling factor (as above), you can simply ask the
IM to work out this 'normalize scaling factor' internally by giving it the
special '<CODE>!</CODE>' normalization flag. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
magick face.png  -define convolve:scale=\! \
        -morphology Convolve  '3x3: 0,1,0  1,2,1  0,1,0' \
        face_spread_normalize.png
</samp></pre></TD></TR></TABLE></TD><TD>
<A HREF="face_spread_normalize.png"
    ><IMG SRC="face_spread_normalize.png"      WIDTH=80 HEIGHT=80
          ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
  ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The '<CODE>!</CODE>' character is also sometimes used for special purposes
  by various UNIX command line shells.  So you may have to escape the
  character using a backslash, even in quotes.  Caution is advised.
</I></FONT></TD></TR></TABLE></P>

Note that as the kernel is now normalized, I can define it in a simplier
fashion using whole numbers.  The normalized kernel will still be the same
as previous 'scaled' kernel. </P>

Typically you will always want to normalize the kernel, and because of this
the simplier "<CODE><A HREF="../option_link.cgi?convolve"
>-convolve</A></CODE>" variant will automatically do this normalization. </P>

You can have IM normalize the kernel, then scale it further again by a given
amount to adjust its output range.  To make this even easier you can specify
the scaling factor as a percentage. </P>

For example here I normalize the kernel but then re-scale the values to 50%
the calculated size, so as to produce a darker result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png  -define convolve:scale=50%\! \
          -morphology Convolve  '3x3: 0,1,0  1,2,1  0,1,0' \
          face_spread_norm_half.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_spread_norm_half.png"
     ><IMG SRC="face_spread_norm_half.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that using a value of '<CODE>!</CODE>' is actually equivelent to using
'<CODE>1!</CODE>' or even '<CODE>100%!</CODE>'.  You can even use a negative
scaling factor if you want to flip the positive and negative values within the
kernel.  For an example of this see <A HREF="#unsharpen" >'Un-Sharpening'
Images using Blurs</A>. </P>

If the kernel has been normalized in this way the <A
HREF="../morphology/#showkernel" >Show Kernel</A> output will tell you that it
is normalized. </P>

<H4>How Normalization Works</H4>

The actual way '<I>Kernel Normalization</I>' works is that all the kernel
values are added together (including any negative values which is also
posible).  If the result is non-zero, then scale all the values so that their
combined value adds up to a value of one ('<CODE>1.0</CODE>'). </P>

Note that, if you have negative values, this could actually create a kernel
with a value larger than one, typically at the origin. It specifically happens
with <A HREF="#unsharpen" >Un-Sharp</A> kernels.  The important point,
however, is that the kernel as a whole adds to '<CODE>1.0</CODE>', so that the
final image is not made darker or lighter by the <A HREF="#convolve"
>Convolution</A> operation. </P>

If the result of the addition is Zero ('<CODE>0.0</CODE>'), then the kernel is
assumed to be a special <A HREF="#zero-summing" >Zero-Summing Kernel</A>.  In
that case the kernel is scaled to make all positive values equal to
'<CODE>1.0</CODE>', and by the same token, all negative values will then add
up to '<CODE>-1.0</CODE>'.  These kernels are especially prevelent with
<A HREF="#edgedet" >Edge Detection</A> techniques. </P>

The <A HREF="../morphology/#showkernel" >Show Kernel</A> output will also
specify that it is zero-summing, if the kernel is in this form, even if not
actually a normalized zero-summing kernel, though that will also be easilly
seen by the other numbers displayed. </P>

Most mathematically determined kernels are pre-normalized.  This includes
the mathematically derived kernels:
'<CODE><A HREF="#unity" >Unity</A></CODE>',
'<CODE><A HREF="#gaussian" >Gaussian</A></CODE>',
'<CODE><A HREF="#log" >LoG</A></CODE>',
'<CODE><A HREF="#dog" >DoG</A></CODE>',
'<CODE><A HREF="#blur" >Blur</A></CODE>',
'<CODE><A HREF="#comet" >Comet</A></CODE>'. </P>

Discrete Constant Kernels, however are are not pre-normalized, so you will
have to do this using the <A HREF="#normalize" >Kernel Normalization
Setting</A> (above).  This includes the kernels:
'<CODE><A HREF="#laplacian" >Laplacian</A></CODE>',
'<CODE><A HREF="#sobel" >Sobel</A></CODE>',
'<CODE><A HREF="#roberts" >Roberts</A></CODE>',
'<CODE><A HREF="#prewitt" >Prewitt</A></CODE>',
'<CODE><A HREF="#compass" >Compass</A></CODE>',
'<CODE><A HREF="#kirsch" >Kirsch</A></CODE>',
'<CODE><A HREF="#freichen" >FreiChen</A></CODE>'. </P>

Note that the '<CODE><A HREF="#freichen" >FreiChen</A></CODE>' kernel
has sub-types that are specially pre-weighted for more specific purposes.
The FreiChen kernels should not be normalized, but used as is. </P>


<A NAME="zero-summing_normalization"></A>
<H3>Zero-Summing Normalization</H3>

Not all convolution kernels use only positive values. You can also get kernels
that use a mix of positive and negative values and often the values of these
kernels are meant to add up to zero to produce a <A HREF="#zero-summing"
>Zero-Summing Kernels</A>.  Such kernels are very important to more advanced
Image Convolutions, as they provide techniques of <A HREF="#edgedet" >Edge
Detection</A> and <A HREF="#sharpening" >Sharpening Images</A>. </P>

As I mentioned in the last section, the usual normalization flag
'<CODE>!</CODE>' will work with such kernels.  But sometimes due to special
situations you want to ensure that the kernel does remain 'zero-summing'. </P>

The special '<CODE>^</CODE>' normalization method just provides a way to
ensure the kernel is 'zero-summing' in situations such as...

<OL>
<LI>If the user's kernel definition is not precise enough to ensure
    zero-summing.  For example you cannot specify '<CODE>1/3</CODE>' or any
    other fractional factor of 3 as an exact floating point decimal number.
    </P>

<LI>The mathematical curve gets 'clipped' by the kernels size (radius) so it
    may no longer be zero summing.  For example, this occurs in a '<CODE><A
    HREF="#log">LoG</A></CODE>' or '<CODE><A HREF=#dog" >DoG</A></CODE>'
    kernels, which are based on infinite response curves.  IM actually uses
    this special normalization internally on these kernels for this very
    reason. </P>

<LI>Ensure that a <A HREF="#correlate" >Correlation</A> 'shape mask'
    is zero summing, so that in the search, IM can look for both positive and
    negative matches, equally.  See <A HREF="#correlate" >Correlation Shape
    Searching</A> below.  </P>

</OL></P>

What happens is that it will normalize the all the positive and negative
values of the kernel as separate enities.  That is all the negative values
will be scaled to add up to '<CODE>-1.0</CODE>' and all the positive values to
scaled add to '<CODE>+1.0</CODE>'.  The result is that the kernel will be
guranteeed as a whole, to add up to zero. </P>

Note that if you use this normalization method for an all-positive kernel such
as 'Gaussian' you will still get a properly normalized kernel.  As such this
form of normalization can still be used with <A HREF="blurring_kernels"
>Blurring Kernels</A>. </P>

However it should not be used to normalize directly defined <A
HREF="#sharpening" >Sharpening</A> or even <A HREF="#unsharpen"
>Un-Sharpening</A> kernels, as this can contain negative values, but are
required to sum to a value of one (using the normal normalization method).
</P>


<A NAME="identity_addition"></A>
<H3>Blending Kernel with the Identity Kernel</H3>

The full syntax of the Kernel Scaling Setting is either... </P>

<DIV ALIGN=center><CODE><B>
 -define convolve:scale='{<I>kernel_scale</I>}[!^]
      [,{<I>origin_addition</I>}] [%]'
<BR>-set option:convolve:scale '{<I>kernel_scale</I>}[!^]
      [,{<I>origin_addition</I>}] [%%]'
</B></CODE></DIV></P>

Note the doubling of the percent character when using "<CODE><A
HREF="../option_link.cgi?set" >-set</A></CODE>". </P>

The optional normalization flags '<CODE>!</CODE>' or '<CODE>^</CODE>" will be
applied to the user defined or built in kernel first (if requested). </P>

After that, the kernel will scaled by the '<I>kernel_scale</I>' factor either
increasing or decreasing the effective 'power' of the convolution on the
results. Default scaling factor is '<CODE>1.0</CODE>'.  </P>

Lastly the 'origin' value of the kernel will have the number after a comma
added to it. Default '<I>origin_addition</I>' is '<CODE>0.0</CODE>'. </P>

This last step effectively 'adds' a <A HREF="#unity" >Unity Kernel</A> of the
given 'scaling' to the previously generated normalized and scaled kernel. </P>

This generates kernels that can...

<UL>
<LI>Soften the effects of a <A HREF="#blurring_kernels" >Blurring Kernel</A>.
    </P>

<LI>Convert a <A HREF="#blurring_kernels" >Blurring Kernel</A> into one that
    can be used to directly to <A HREF="#unsharpening" >Un-Sharpen an
    Image</A>.  </P>

<LI>It can also allow you to magick <A HREF="#edgedet_kernels" >Edge
    Detection Kernel</A> into a <A HREF="#sharpening" >Image Sharpening
    Kernel</A>. </P>

</UL></P>

Note that if you give a percent ('<CODE>%</CODE>') flag, that percentage will
be applied to BOTH the '<I>kernel_scale</I>' factor and the
'<I>origin_addition</I>'.  This can make makes the scale easier to read and
understand when fractions are involved. </P>

Example use of kernel scaling define...

<DIV ALIGN=left STYLE="margin-left:50">
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  -define convolve:scale='!50%,100%'  -morphology Convolve Laplacian:2 &nbsp;
</samp></pre></TD></TR></TABLE></DIV></P>

Will generate the requested '<CODE><A HREF="#laplacian_2"
>Laplacian:2</A></CODE>' kernel...

<DIV ALIGN=center STYLE="margin-left:20%;margin-right:50%">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8"
       STYLE="border-width:1">
<TR><TH>  0  <TH> -1  <TH>  0
<TR><TH> -1  <TH>  4  <TH> -1
<TR><TH>  0  <TH> -1  <TH>  0
</TABLE></DIV>

Normalizes it ('!' flag)

<DIV ALIGN=center STYLE="margin-left:20%;margin-right:50%">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8"
       STYLE="border-width:1">
<TR><TH>   0   <TH> -0.25 <TH>   0
<TR><TH> -0.25 <TH>   1   <TH> -0.25
<TR><TH>   0   <TH> -0.25 <TH>   0
</TABLE></DIV>

Scale by 50%
<DIV ALIGN=center STYLE="margin-left:20%;margin-right:50%">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8"
       STYLE="border-width:1">
<TR><TH>    0   <TH> -0.125 <TH>    0
<TR><TH> -0.125 <TH>   0.5  <TH> -0.125
<TR><TH>    0   <TH> -0.125 <TH>    0
</TABLE></DIV>

Add an Unity kernel (add 100% to origin value)
<DIV ALIGN=center STYLE="margin-left:20%;margin-right:50%">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8"
       STYLE="border-width:1">
<TR><TH>    0   <TH> -0.125 <TH>    0
<TR><TH> -0.125 <TH>   1.5  <TH> -0.125
<TR><TH>    0   <TH> -0.125 <TH>    0
</TABLE></DIV>

And you can now convolve using '<CODE><A HREF="#laplacian_2"
>Laplacian:2</A></CODE>' as a sharpening kernel, but with only
a '<CODE>50%</CODE> sharpening power. </P>

Remember any '<CODE>%</CODE>' flag given anywhere in the scale setting, will
make both values percentages.  If not present both values are just simple
direct multipliers.  For example all these scaling options are equivalent

<BLOCKQUOTE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
     50,100%     50%,100    %50,100      .5,1      0.5,1.0  &nbsp;
</samp></pre></TD></TR></TABLE>
</BLOCKQUOTE></P>

The same goes for the two normalization flags.  They can appear anywhere in
the convolve scaling setting, but they will always be applied first before any
other scaling takes place. </P>


<A NAME="bias"></A>
<H3>Output result Bias Control</H3>

When you are dealing with a kernel that contains negative values, some pixels
in the resulting image should be assigned a negative value.  This is
especially the case with <A HREF="#zero-summing" >Zero-Summing Kernels</A>
(see below). </P>

Unfortunately, unless you have a specially built <A HREF="../basics/#hdri"
>HDRI Version of ImageMagick</A>, to preserve the negative values that were
generated, any negative result will be clipped to zero (black).  You will only
get thge positive results from the convolution.  It just can not be stored in
a normal image format, leaving you with half the result. </P>

You could build <A HREF="../basics/#hdri" >HDRI Version of ImageMagick</A> to
preserve the negative values that were generated, and then extract the
information you want.  Alternately, you can negate the kernel by using
a negative scaling factor. For example using...

<DIV ALIGN=center><CODE>
 -define convolve:scale='-1'
</CODE></DIV>

However then you only get the negative results with the positive results
becoming clipped. </P>

However by using the IM setting "<CODE><A HREF="../option_link.cgi?bias"
>-bias</A></CODE>" you can still preserve both positive and negative results.
</P>

The settings to use for non-HDRI version of IM is...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
     -define convolve:scale=50%\!  -bias 50%
</samp></pre></TD></TR></TABLE>
</DIV></P>

The first setting scales the output to half the size you would normally get
(after it is normalized), so as to make room for both positive and negative
results. Then it will add a 50% gray to the pixel output before saving the
result back into an image. </P>

With these settings, any 'zero' result will become pure gray with negative
results darker than this and positive result lighter than this.  Black will
represent '<CODE>-1.0</CODE>' and white will mean '<CODE>+1.0</CODE>'.  </P>

One example of doing this is shown in the <A HREF="#correlate_search"
>Correlate Shape Search</A> examples below.  </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="blurring_images"></A>
<H2>Blurring Images
<FONT SIZE=-1>(low-pass filtering)</FONT></H2>

Another section of IM examples, specifically <A HREF="../blur/"
>Blurring, and Sharpening Images</A>, actually deals with practical aspects of
this subject.  Here we look at more specific details. </P>

First however, we will describe the basic kernels and how you can use them
directly without modification.  Later we will look at ways of modifying
the bluring to generate other effects. </P>

<A NAME="blurring_kernels"></A>
<H3>Blurring Kernels</H3>


<!--<CODE EXECUTE>
   kernel2image -35.2 -m "Unity"    kernel_unity.gif
</CODE>-->
  <A HREF="kernel_unity.gif"
      ><IMG SRC="kernel_unity.gif"
            ALIGN=right BORDER=0 ALT="[IM Output]"></A>

<A NAME="unity"></A>
<H4>Unity</H4>

This is a special kernel that actually does nothing.  Only one kernel element
is specified, and as a result each pixel is replace by itself without change.
</P>

For example here is a no-op <A HREF="#convolve" >Convolution</A>...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Unity  face_unity.png
</samp></pre></TD></TR></TABLE>
  <A HREF="../images/face.png"
     ><IMG SRC="../images/face.png"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_unity.gif"
     ><IMG SRC="kernel_unity.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="face_unity.png"
     ><IMG SRC="face_unity.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As of IM v 6.6.9-4, the kernel can take a single argument, as a kernel
specific scale argument. This allows you to use it to multiply the values of
an image, such as make an image brighter or darker.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Unity:0.5  face_dimmed.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_dimmed.png"
     ><IMG SRC="face_dimmed.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This may not seem very useful, but it can be used for generating <A
HREF="#soft_blur" >Soft Blurs</A>, and <A HREF="#unsharpen" >Unsharpen</A>
effects, or in multi-kernel sequences where you may not be able to use <A
HREF="#kernel_scaling" >Kernel Scaling</A> or <A HREF="#identity_addition"
>Kernel Identity Blending</A>. </P>

The same single element kernel can also be generated using '<CODE><A
HREF="../morphology/#disk" >Disk:0.5</A></CODE>', which also allows you to
specify an extra scaling argument as part of the kernels generation. (EG:
'<CODE>Disk:0.5,0.5</CODE>' for the last example). </P>

A similar kernel (for <A HREF="#convolve" >Convolution</A>) can also be
generated by the a '<CODE><A HREF="#gaussian" >Gaussian</A></CODE>' kernel
generator with a '<I>sigma</I>' of '<CODE>0.0</CODE>'.  However that can only
produce a small 3x3 kernel, consisting of a central '<CODE>1.0</CODE>' value
surrounding by 8 '<CODE>0.0</CODE>' values. </P>


<!--<CODE EXECUTE>
  kernel2image -10.1 -m -n "Octagon:2"   kernel_shape.gif
</CODE>-->
  <A HREF="kernel_shape.gif"
     ><IMG SRC="kernel_shape.gif"
           ALIGN=right VSPACE=0 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

<A NAME="mean"></A>
<H4>Mean or Average Filtering using Shape Kernels</H4>

While most convolution kernels defined below generally involve the use of
a Gaussian Curve in some way, you can still use one of the previous <A
HREF="../morphology/#shape_kernels" >Morphology Shape Kernels</A> to simply
average the pixels over a given (large) area.  Of course you will need to <A
HREF="#normalize" >Normalize</A> the kernel so as to actually generate an
average, rather than just a sum of the neighbourhood. </P>

For example, here I use a smaller '<CODE><A HREF="../morphology/#octagon"
>Octagon</A></CODE>' shaped kernel, to average all the pixel values found within
a circlular areas surrounding each pixel.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png  -define convolve:scale=! \
          -morphology Convolve Octagon:2  face_mean.png
</samp></pre></TD></TR></TABLE>
  <A HREF="../images/face.png"
     ><IMG SRC="../images/face.png"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_shape.gif"
     ><IMG SRC="kernel_shape.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="face_mean.png"
     ><IMG SRC="face_mean.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The result is that the value of each pixel is spread out equally over all 25
pixels in the defined neighbourhood.  That is, it is equivelent to a 'mean' or
'averaging' filter over the given shape. </P>

If you want to exclude the original pixel from that average, only using the
surrounding pixels, then you can use a '<CODE><A HREF="../morphology/#ring"
>Ring</A></CODE>' kernel (supplying only one radii). </P>

The other <A HREF="#shape_kernels" >Shape Kernels</A> can also be used in the
same way to, say, average the pixel values over a '<CODE><A
HREF="../morphology/#diamond" >Diamond</A></CODE>', '<CODE><A
HREF="../morphology/#square" >Square</A></CODE>' or large '<CODE><A
HREF="../morphology/#disk" >Disk</A></CODE>' shape and to whatever size you
want.  </P>


However while a constant averaging over an shaped area does blur images, it
has a tendency to produce unusual effects (specifically <A
HREF="../filter/#aliasing" >Aliasing Artefacts</A>) in the resulting image.
</P>

More specifically, by using a 'flat' averaging kernel tends to magick sharp
edges into a thicker linear slope with sudden change in the slope at the
thickened edges </P>

The thickness of the result is kernel '<CODE>radius*2-1</CODE>'.  How different
edge angles effect the slope thickness and linearity of the slope depends on
the shape of the 'flat' or averaging kernel.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc: -draw 'polygon 15,15 15,65 60,15' shape.png
  magick shape.png \
          -define convolve:scale=! -morphology Convolve Square:5 \
          shape_mean_square.png
  magick shape.png \
          -define convolve:scale=! -morphology Convolve Disk:5 \
          shape_mean_disk.png
</samp></pre></TD></TR></TABLE>
  <A HREF="shape.png"
     ><IMG SRC="shape.png"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="shape_mean_square.png"
     ><IMG SRC="shape_mean_square.png"   WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shape_mean_disk.png"
     ><IMG SRC="shape_mean_disk.png"   WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the diagonal blur in the above is different for a square kernel,
than it is for a disk kernel. </P>

Another way of generating square 'linear slope' blurring is to use a very
large sigma with a specific radius.  The above square kernel convolution can
for example also be achieved using  <CODE>-blur 5x65535</CODE>. This was
commonly used by Fred Wienhaus in his scripts before morphology was available.
</P>

<!--<CODE EXECUTE>
  kernel2image -8.1 -mn -n -ml "Gaussian:0x2" \
               "Gaussian:5x2"    kernel_gaussian.gif
</CODE>-->
  <A HREF="kernel_gaussian.gif"
     ><IMG SRC="kernel_gaussian.gif"
           ALIGN=right VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>

<A NAME="gaussian"></A>
<H4>Gaussian Kernel <FONT SIZE=-1>(2d gaussian blur)</FONT></H4>

As you may have gathered, the '<CODE>Gaussian</CODE>' kernel is the most
commonly used kernel to <A HREF="#convolve" >Convolve</A> an image.  This is
the mathematical ideal kernel for blurring effects. </P>

Here for example is the <A HREF="../morphology/#showkernel" >Show Kernel</A>
of a small '<CODE>Gaussian</CODE>' kernel (they can get very large very
quickly)...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=kernel_gaussian.txt>
  magick xc:  -define morphology:showkernel=1 \
               -morphology Convolve:0 Gaussian:0x0.8  null:
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_gaussian.txt"
     ><IMG SRC="kernel_gaussian.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

I did not actually want to apply a convolution to the above, as I only wanted
to show the kernel that it was going to use.  As such I used
a '<CODE>:0</CODE>' <A HREF="../morphology/#iterate" >Iteration Count</A>, so
it does nothing. Similarly I junk the resulting image output using the special
'<CODE><A HREF="../files/#null" >null:</A></CODE>' file format. </P>

As you can see by the convolution output range, a '<CODE>Gaussian</CODE>'
kernel has already been normalized (scaled) for you.  However you will also
notice that it is still quite a large kernel, filled with small fractional
values. If you look closer you will find the largest value (2.48678, which is
also listed on the first line) is in the center, with the smallest values
toward the edges and the corners (a value of about .000000194).  </P>

Here is typical Gaussian blur using a convolution...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png   -morphology Convolve Gaussian:0x2  face_gaussian.png
</samp></pre></TD></TR></TABLE>
  <A HREF="../images/face.png"
     ><IMG SRC="../images/face.png"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_gaussian.gif"
     ><IMG SRC="kernel_gaussian.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="face_gaussian.png"
     ><IMG SRC="face_gaussian.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The kernels syntax is straight forward...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   Gaussian:[{<I>radius</I>}]x{<I>sigma</I>}
</samp></pre></TD></TR></TABLE>
</DIV></P>

These arguments are in fact exactly the same as that used by the "<CODE><A
HREF="../option_link.cgi?gaussian-blur" >-gaussian-blur</A></CODE>" operator,
which actually performs a <A HREF="#convolve" >Convolution</A> using this
kernel.  </P>

The first number, like most <A HREF="../morphology/#kernel" >Morphology
Kernels</A>, is the '<I>radius</I>' or size of the kernel.  This is just an
integer, with a minimum value of 1, making the smallest posible kernel 3x3
elements in size.  The best idea is to always specify zero, which allows
ImageMagick to calculate an appropriate radius for the '<I>sigma</I>' value
provided. </P>

The second more important argument is '<I>sigma</I>' which defines how blurred
or 'spread out' each pixel should become.  The larger the value the more
blurry an image will become. It is a floating-point value.  <B>The <I>sigma</I>
value MUST be provided</B>.  </P>

If a sigma value of '<CODE>0.0</CODE>' is given you will end up with a fairly
useless '<CODE><A HREF="#unity" >Unity</A></CODE>' kernel (of the given
radius, or a radius of 1, so producing a 3x3 kernel of a single
'<CODE>1.0</CODE>' value surrounded by '<CODE>0.0</CODE>' values.). As you saw
above, convolving with any type of '<CODE><A HREF="#unity" >Unity</A></CODE>'
kernel does <I>nothing</I> to the image! </P>

If you do specify a '<I>radius</I>' it is generally a good idea to make it at
lest twice as big as the '<I>sigma</I>', IM usually calculates a radius that is
approximately 3 times as big (actually the largest radius that will provide
meaningful results), though it depends on the <A HREF="../basics/#quality"
>Compile-time Quality</A> of your specific IM installation. </P>

For more information on the effect of the '<CODE>Gaussian</CODE>' kernel
arguments, and on blurring images in general, see... <A HREF="../blur/#blur"
>Blurring Images</A>. </P>



<!--<CODE EXECUTE>
  kernel2image -10.1 -mn -n -ml "Blur:0x2"  "Blur:7x2"  kernel_blur.gif
</CODE>-->
  <A HREF="kernel_blur.gif"
    ><IMG SRC="kernel_blur.gif"
           ALIGN=right VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>

<A NAME="blur"></A>
<H4>Blur Kernel <FONT SIZE=-1>(1d gaussian blur)</FONT></H4>

The '<CODE>Blur</CODE>' kernel is very similar to the <A HREF="#gaussian"
>Gaussian Kernel</A>, and even takes the same arguments (see below). But where
gaussian is a 2-dimensional curve, the '<CODE>Blur</CODE>' kernel produces
a 1-dimensional curve.  That is to say it generates a long thin single row of
values. </P>

Here is a <A HREF="../morphology/#showkernel" >Show Kernel</A> output of
a small '<CODE>Blur</CODE>' kernel.

<!--<CODE EXECUTE>
  kernel2image -g 1 "Blur" miff:- | im_profile -s - kernel_blur_profile.gif
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=kernel_blur.txt>
  magick xc:  -define morphology:showkernel=1 \
               -morphology Convolve:0 Blur:0x0.8  null:
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="kernel_blur_profile.gif"
     ><IMG SRC="kernel_blur_profile.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_blur.txt"
     ><IMG SRC="kernel_blur.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

The graph shown above is an actual profile of the default '<CODE>Blur</CODE>'
kernel.  It was created using the <A HREF="../morphology/#kernel2image"
>Kernel Image</A> script "<CODE><A HREF="../scripts/kernel2image"
>kernel2image</A></CODE>", and that image then graphed using the "<CODE><A
HREF="../scripts/im_profile" >im_profile</A></CODE>" script.  It clearly shows
the 'Gaussian Bell Curve' that this kernel represents. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Here is an example of using this kernel to horizontally blur an image.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Blur:0x4  face_blur.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_blur.png"
     ><IMG SRC="face_blur.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The kernel's syntax is exactly like that of '<CODE><A HREF="#gaussian"
>Gaussian</A></CODE>' but with an extra optional rotation angle.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   Blur:[{<I>radius</I>}]x{<I>sigma</I>}[,{<I>angle</I>}]
</samp></pre></TD></TR></TABLE>
</DIV></P>

As before the second value '<I>sigma</I>' is required, and if set to zero you
will get the linear equivelent of a  '<CODE><A HREF="#unity"
>Unity</A></CODE>' kernel. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

The '<I>angle</I>' allows you rotate the kernel by 90 degrees allowing you to
blur an image vertically.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Blur:0x4,90  face_blur_vert.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_blur_vert.png"
     ><IMG SRC="face_blur_vert.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

At this time only a 90 degree rotation is posible.  This may change in
a later version of ImageMagick. </P>

The purpose of this kernel is actually to create a faster form of
2-dimentional image blurring that the '<CODE><A HREF="#gaussian"
>Gaussian</A></CODE>' kernel produces.  See <A HREF="#gaussian_vs_blur"
>Gaussian vs Blur Kernels</A> below for details of how this is done. </P>


<!--<CODE EXECUTE>
  kernel2image -10.1 -mn -n -ml "Comet:0x3"  "Comet:9x3"  kernel_comet.gif
</CODE>-->
  <A HREF="kernel_comet.gif"
     ><IMG SRC="kernel_comet.gif"
           ALIGN=right VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>

<A NAME="comet"></A>
<H4>Comet Kernel <FONT SIZE=-1>(half 1d gaussian blur)</FONT></H4>

The '<CODE>Comet</CODE>' kernel is almost exactly the same as a '<CODE><A
HREF="#blur" >Blur</A></CODE>' kernel, but is actually only a half a blur
kernel.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=kernel_comet.txt>
  magick xc:  -define morphology:showkernel=1 \
               -morphology Convolve:0 Comet:0x1.0  null:
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_comet.txt"
     ><IMG SRC="kernel_comet.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Note how the defined location of the origin is on the left hand edge, and not
in the center of the kernel.  This is very unusual for a convolution kernel,
and as as such produces a very unusual result. </P>

It blurs the image out in one direction like a finger had smeared the surface
of a wet painting, leaving a trail of color. Its a bit like the tail of
a comet, or the trail left by a meteor, or falling star.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Comet:0x5  face_comet.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_comet.png"
     ><IMG SRC="face_comet.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that both the foreground and background colors were 'smeared'.  If you
only want to blur the foreground colors, make the background transparent, and
add it after the foreground has been blurred. </P>

You can also give a third <I>angle</I> argument to rotate the kernel in any
multiple of 90 degrees about its 'origin'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve comet:0x5+90  face_comet_vert.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_comet_vert.png"
     ><IMG SRC="face_comet_vert.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This kernel is actually the same kernel that is use by the specialized <A
HREF="../blur/#motion_blur" >Motion Blur</A> operator, though that operator
also does some very fancy coordinate look-up handling to allow the blur to
work at any angle. Though it does so poorly, producing 'clumps' of color at
large angles, such as 45 degrees. </P>

Hopefully proper kernel rotation will be implemented to create better motion
blur type effects at angles outside of 90 degree increments. </P>


  <A HREF="kernel_blur_profile.gif"
     ><IMG SRC="kernel_blur_profile.gif"
           ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

<A NAME="gaussian_vs_blur"></A>
<H3>Gaussian vs Blur Kernels</H3>

As mentioned the '<CODE><A HREF="#gaussian" >Gaussian</A></CODE>' and
'<CODE><A HREF="#blur" >Blur</A></CODE>' kernels are very closely related, and
can in fact to the same job.  Both are representations of the <A
HREF="#gaussian_curve" >Gaussian Curve</A>, the first being a 2-dimentional
representation, while the other is a 1-dimentional representation. </P>

For example here is repeat of the "<CODE>-gaussian-blur 0x2</CODE>" which is
equivalent to "<CODE>-morphology Convolve Gaussian:0x2</CODE>" operation.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png    -gaussian-blur 0x2      face_gaussian-blur.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_gaussian-blur.png"
     ><IMG SRC="face_gaussian-blur.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This can be replaced by using two separate Linear or 1 dimensional blurring
operations rotated ninety degrees to each other (order does not really matter
either)...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve Blur:0x2 \
                   -morphology Convolve Blur:0x2+90  face_blur_x2.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_blur_x2.png"
     ><IMG SRC="face_blur_x2.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Rather than specifying two separate convolutions, you can give both kernels
as a kernel list.   For example

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE DO_NO_EXECUTE>
  magick face.png -morphology Convolve 'Blur:0x2;Blur:0x2+90' face_blur_x2.png
</samp></pre></TD></TR></TABLE>
</DIV></P>

IM will by default 're-iterate' the result of the first convolve kernel with
the second (and later) convolve kernel, as defined by <A
HREF="../morphology/#kernel_compose" >Multiple Kernel Composition</A> setting.
</P>

You can even simplify the above even further by asking IM to expand one kernel
into a <A HREF="../morphology/#rotated_kernels" >Rotated Kernel List</A>, by
using a '<CODE>&gt;</CODE>' to do a list of 90 degree rotations (two kernels
in this case).  For example...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -morphology Convolve 'Blur:0x2&gt;' face_blur_x2.png
</samp></pre></TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

All the above examples are equivalent to each other, and is how the "<CODE><A
HREF="../option_link.cgi?blur" >-blur</A></CODE>" operator works.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png    -blur 0x2      face_blurred.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_blurred.png"
     ><IMG SRC="face_blurred.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This represents the real difference between "<CODE><A
HREF="../option_link.cgi?blur" >-blur</A></CODE>" and "<CODE><A
HREF="../option_link.cgi?gaussian-blur" >-gaussian-blur</A></CODE>" operators.
In the latter one single large 2-dimensional kernel is used,  while the former
uses two small 1-dimensional kernels are used.  </P>

In terms of speed however the "<CODE><A HREF="../option_link.cgi?blur"
>-blur</A></CODE>" operator is usually an order of magnitude faster, as it
uses two much smaller kernels, rather than one very large one.  The larger the
blurring argument (the size of the <I>sigma</I> argument) the bigger kernels
become, and the larger the difference in speed between the two operations.  As
such the "<CODE><A HREF="../option_link.cgi?blur" >-blur</A></CODE>" operator
is generally the recommended one to use. </P>

The only difference in results between the two operators are small quantum
rounding effects (unless you are using HDRI) and edge effects (depending on <A
HREF="../misc/#virtual" >Virtual Pixel Setting</A>). Both of these being
caused by a loss of information generated due to saving an intermediate image
between the two separate passes of the 'blur' convolutions.  This difference
is typically so small as to be invisible and of no concern to any practical
usage. </P>

<A NAME="soft_blur"></A>
<H3>Softened Blurring
<FONT SIZE=-1>(blending with original image)</FONT></H3>

You can soften the impact of any sort of blur by blending it with some of the
original image.  Especially when applying a very strong blur.  For example...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png  -morphology Convolve Gaussian:0x3  face_strong_blur.png
  magick face.png  face_strong_blur.png \
          -compose Blend -define compose:args=60,40% -magick composite \
          face_soft_blur.png
</samp></pre></TD></TR></TABLE>
  <A HREF="../images/face.png"
     ><IMG SRC="../images/face.png"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20" ALT="+">
  <A HREF="face_strong_blur.png"
     ><IMG SRC="face_strong_blur.png"   WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="face_soft_blur.png"
     ><IMG SRC="face_soft_blur.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This used the '<CODE><A HREF="../compose/#blend" >Blend</A></CODE>'
composition method, to mix '<CODE>60%</CODE>' of the blurred image
(composition source image) with '<CODE>40%</CODE>' of the original image
(composition destination image) to give a 'soft blur' effect on the final
image. </P>

However you can do the same thing directly by <A HREF="#identity_addition"
>Blending the Kernel with the Identity Kernel</A>, using the same ratio.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale=60,40% \
          -morphology Convolve 'Gaussian:0x3' face_soft_blur2.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_soft_blur2.png"
     ><IMG SRC="face_soft_blur2.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the order of the scaling numbers is the same. The first number
('<CODE>60%</CODE>') scales the given kernel so as to reduce its effect on the
output, while the second number ('<CODE>40%</CODE>') adds enough of the
'<CODE><A HREF="#unity" >Unity</A></CODE>' (or 'Identity') kernel to prevent
the result from becoming darker. </P>

The important point is that for <A HREF="#blurring_kernels" >Blurring
Kernels</A>, the two numbers add up to '<CODE>100%</CODE>', just as you would
for <A HREF="../compose/#blend_use" >Composite Blending</A>. </P>

You can also use the faster 2-pass blurring, but in this case we can not
incorperate a 'Blend' into the kernel directly, as the two separate
convolutions will not 'separate' cleanly. As such we will need to again do
the <A HREF="../compose/#blend" >Blend Composition</A> afterwards. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png \( +clone -blur 0x3 \) \
          -compose Blend -define compose:args=60 -magick composite \
          face_soft_blur3.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_soft_blur3.png"
     ><IMG SRC="face_soft_blur3.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that you only need to give the amount of the blurred (source) image
you want to be blended with the original image.  As such values of
'<CODE>100</CODE>' will give the blurred image, while '<CODE>0</CODE>'
will give the original image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
  ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  Remember the "<CODE><A HREF="../option_link.cgi?blur" >-blur</A></CODE>"
  operator is exactly equivelent to using the faster 2-pass <A HREF="#blur">
  Bluring Kernels</A>.
</I></FONT></TD></TR></TABLE></P>

<BR>

<A NAME="unsharpen"></A>
<H3>'Un-sharpen' Images using Blurs
<FONT SIZE=-1>(subtracting from the original image)</FONT></H3>

By taking this blending of kernels further, so that you start to use
a negative scaling, you can subtract the blurring effects from the original
image.   The result is a technique called 'unsharp'.  See <A
HREF="http://en.wikipedia.org/wiki/Unsharp_mask" >Unsharp, Wikipedia</A> for
how it came to get such an unfortunate name.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale=-100,200% \
          -morphology Convolve 'Gaussian:0x2' face_unsharp.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_unsharp.png"
     ><IMG SRC="face_unsharp.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that even though a negative kernel scaling factor is used, the two
numbers still adds up to '<CODE>100%</CODE>', exactly as it did above.  You
can also do this with <A HREF="../compose/#blend_use" >Composite Blending</A>
as well. </P>

The above example is actually exactly how the mis-named "<CODE><A
HREF="../option_link.cgi?sharpen" >-sharpen</A></CODE>" operator works but
with only the '<I>sigma</I>' blurring control. However no other control of the
operation is provided.  The blending is exactly as given above. </P>

You can use faster 2-pass, 1-dimensional <A HREF="#blur" >Blurring
Kernels</A>, but again you will need to do the blending operation as
a separate step.


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png \( +clone -blur 0x2 \) \
          -compose Blend -define compose:args=-100,200 -magick composite \
          face_unsharp_fast.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_unsharp_fast.png"
     ><IMG SRC="face_unsharp_fast.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This you may have gathered is almost identical to that of <A HREF="#soft_blur"
>Softened Blurring</A> but with the blurred image being subtracted from the
original image instead of being added.  A blending method known as <A
HREF="#compose/#blend_use" >Extrapolated Blending</A>, or blending beyond the
normal 0 to 100 percent range.

Again like you can simply specify how much of the blurred image you want to
subtract from the original image. For example lets over do the unsharpening of
the image, causing some aliasing and color distortions.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png \( +clone -blur 0x2 \) \
          -compose Blend -define compose:args=-200 -magick composite \
          face_unsharp_200.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_unsharp_200.png"
     ><IMG SRC="face_unsharp_200.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The full "<CODE><A HREF="../option_link.cgi?unsharp" >-unsharp</A></CODE>"
operator provides provides another type of control.  Specifically,
a difference threshold, so that the sharpening only applied when the given
difference is larger, such as near an actual edge within the image.  That
threshold can be use to prevent the 'sharpening' small small defects, like
wrinkles, or camera noise. </P>

Unsharpening an image is typically used with very small blurs (on the order of
sigma=0.75) after resizing or distorting image, to improve the final result.
See <A HREF="../resize/#resize_unsharp" >Sharpen Resized Images</A> for some
examples of this. </P>

The alternative to using an 'unsharp' technique for image sharpening is to
actually locate image edges and use them to sharpen images.  See <A
HREF="#sharpening" >Sharpening Images with Edge Detection</A> below for
details. However it is generally regarded as being slower, though not really
by very much. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="edgedet"></A>
<H2>Edge Detection Convolutions
<FONT SIZE=-1>(high-pass filtering)</FONT></H2>

Edge Detection is another area in which convolutions are heavilly used. </P>

The task here is to highlight or enhance the edges of an image in various
ways.  This can be to either locate an edge as accuratelly as posible or to
determine the angle or direction of slope of each of the edges. </P>

However the job can be made a lot more difficult by the presence of noise in
the image, such as that produced by scanners, digital cameras, or even just
caused by the lossy compression of the JPEG image file format. </P>

In general, however, larger kernels handle noise better, but at a loss of
localizing the edge properly, while smaller kernels produce sharp edge
locating results but with more spurious results caused by noise in the image.
</P>

There are a lot of small, well-known kernels, that have been developed and
studied for edge detection.  Most of these are 'named' after the mathematician
which studied the mathematics or the developed that specific kernel type.  As
such, you have kernels such as '<CODE><A HREF="#laplacian"
>Laplacian</A></CODE>', '<CODE><A HREF="#sobel" >Sobel</A></CODE>' and
'<CODE><A HREF="#prewitt" >Prewitt</A></CODE>'.

These 'named' kernels are generally very small and are defined using whole
numbers, so they can be built into specifically designed optimized software
and hardware for speed.  That is, they are said to be 'discrete' kernels.
Because of that, you will need to either <A HREF="#kernel_scale" >Scale</A> or
<A HREF="#normalize" >Normalize</A> the kernel as part of their use.
</P>

Edge detection also has the side effect of providing ways of sharpening the
edges of an image. </P>


<A NAME="zero-summing_kernels"></A>
<H3>Zero-Summing Kernels</H3>

All the edge detection kernels have one feature in common. They are all
zero-summing.  That means they contain negative values, but with all the values
in the kernel adding up to zero. </P>

For a smooth flat color image, a <A HREF="#convolve" >Convolution</A> using such
a kernel will produce a 'zero' or black image.  However for any other image,
you will have results that contain both negatative and positive values. </P>

For example here I apply a discrete '<CODE><A HREF="#sobel" >Sobel</A></CODE>'
edge detector on an image containing some basic shapes...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 80x80 xc:black \
          -fill white -draw 'rectangle 15,15 65,65' \
          -fill black -draw 'circle 40,40 40,20'       shapes.gif
  magick shapes.gif  -define convolve:scale='!' \
          -morphology Convolve Sobel  shapes_sobel.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="shapes.gif"
     ><IMG SRC="shapes.gif"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="shapes_sobel.gif"
     ><IMG SRC="shapes_sobel.gif"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

If you look at the results you will see that the kernel is directional in that
only the vertical edges are found (as defined by the '<CODE><A HREF="#sobel"
>Sobel</A></CODE>' kernel with a zero angle.   However it only found one set of
edges, the 'positive' left-to-right black-to-white slopes. </P>

To get the 'negative' slopes you will need to negate the kernel, by using the
<A HREF="#kernel_scaling" >Kernel Scaling Setting</A>.  For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick shapes.gif  -define convolve:scale='-1!' \
          -morphology Convolve Sobel  shapes_sobel_neg.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="shapes_sobel_neg.gif"
     ><IMG SRC="shapes_sobel_neg.gif"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

With a '<CODE><A HREF="#sobel" >Sobel</A></CODE>' kernel, you can also rotate
it 180 degrees to get the same result as the 'scale negation', but not all
kernels are symmetrical in this way. </P>

The other solution is to add an <A HREF="#bias" >Output Bias</A> to the
result.  That is add 50% grey to the resulting image so that negative values
are lighter than this and positive values are brighter.  However, you will
also need to <A HREF="#kernel_scale" >Scale the Kernel</A> to ensure the
results remain 'unclipped' by the 'black' and 'white' limits of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick shapes.gif  -define convolve:scale='50%!' -bias 50% \
          -morphology Convolve Sobel  shapes_sobel_bias.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="shapes_sobel_bias.gif"
     ><IMG SRC="shapes_sobel_bias.gif"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you don't care about the polarity you can get an absolute
value of the results with a little trickiness..

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick shapes.gif  -define convolve:scale='50%!' -bias 50% \
          -morphology Convolve Sobel  -solarize 50% -level 50,0% \
          shapes_sobel_abs.gif
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="shapes_sobel_abs.gif"
     ><IMG SRC="shapes_sobel_abs.gif"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

See the '<CODE><A HREF="#sobel" >Sobel</A></CODE>' kernel, for more result
handling techniques, especially techniques involving direction determination.
</P>

The other alternative to using an <A HREF="#bias" >Output Bias</A> is to
build a special <A HREF="../basics/#hdri" >HDRI</A> version of Imagemagick.
This stores images in memory using floating point vaules and means that the
image values will not be 'clipped' or 'rounded' by the use of integers. </P>

However, even if you do use this special version of IM you will still need to
post-process the results before saving to a normal image file format or you
will need to use a special floating point enabled image file format. However
you will not need to worry about clipping or rounding effects in the
intermediate image results, making things easier to handle.  </P>


<A NAME="edgedet_kernels"></A>
<H3>Edge detection Kernels</H3>

<!--<CODE EXECUTE>
  kernel2image -8.1 -mn -n -ml "LoG:0x2"  "Log:5x2"  kernel_log.gif
</CODE>-->
  <A HREF="kernel_log.gif"
     ><IMG SRC="kernel_log.gif"
           ALIGN=right VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>

<A NAME="log"></A>
<H4>LoG: Laplacian Of Gaussians</H4>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   LoG:{<I>radius</I>},{<I>sigma</I>}
</samp></pre></TD></TR></TABLE>
</DIV></P>

The '<CODE>LoG</CODE>' or "Laplacian of a Gaussian" is one of the best edge
detection kernels you can get. It is also known as a "Mexican Hat" kernel.
</P>

Basically is it a '<CODE><A HREF="#laplacian" >Laplacian</A></CODE>'
differential (slope) operator, that has been smoothed by the addition of
gaussian blurring. This in turn removes most of the impact of noise in an
image, which can be adjusted by the '<I>sigma</I>' setting. </P>

The Kernel contains negative values that form a ring around a strong central
peak.  In the 'Kernel Image' shown above, the negatives are shown as the dark
(near black) colors with the edges decaying to zero (dark grey) toward the
edges. </P>

And here is its effect.. showing how it highlights the edges of the image.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -bias 50% -morphology Convolve LoG:0x2  face_log.png
</samp></pre></TD></TR></TABLE>
  <A HREF="../images/face.png"
     ><IMG SRC="../images/face.png"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_log.gif"
     ><IMG SRC="kernel_log.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="face_log.png"
     ><IMG SRC="face_log.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

A laplacian kernel is direction-less, but produces both a positive and
negative ridge of values on either size of an edge.  To locate the edge you
would look for the points of zero-crossing, between the positive and negative
ridges, a technique known as <A
HREf="http://en.wikipedia.org/wiki/Marr-Hildreth_algorithm" >Marr and Hildreth
Edge Detection</A>. </P>

This kernel is also ideal for <A HREF="#sharpen" >Sharpening Images</A>. </P>

<BR>

<!--<CODE EXECUTE>
  kernel2image -8.1 -mn -n -ml "DoG:0,1.8,2.4" "DoG:5,1.8,2.4" kernel_dog.gif
</CODE>-->
  <A HREF="kernel_dog.gif"
     ><IMG SRC="kernel_dog.gif"
           ALIGN=right VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>

<A NAME="dog"></A>
<H4>DoG: Difference of Gaussians</H4>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   DoG:{<I>radius</I>},{<I>sigma1</I>}[,{<I>sigma2</I>}]
</samp></pre></TD></TR></TABLE>
</DIV></P>

This will generate a '<CODE>DoG</CODE>' or "Difference of Gaussians" kernel in
which the gaussian generated by '<I>sigma1</I>' will have the gaussian
generated by '<I>sigma2</I>' subtracted from it.  Normally '<I>sigma2</I>' is
the larger so that the 'central peak' of the kernel is positive. Reversing the
two numbers will effectivally negate the resulting kernel. </P>

One of the major criticisms of a <A HREF="#log" >Laplacian of a Gaussian</A>
is that it is difficult to implement as it is such an unusual mathematical
curve. It is also not a very well documented curve.  The other aspect is that
it can not be 'separated' into a faster 2-pass solution as you can with
a Gaussian, (see <A HREF="#gaussian_vs_blur" >Gaussian vs Blur Kernels</A>).
</P>

However by generating two '<CODE><A HREF="#gaussian" >Gaussian</A></CODE>'
kernels of slightly different <I>sigma</I> values (in a ratio of
approximatally 1.6), and subtracting them from each other you can actually
generate a close approximation of a <A HREF="#log" >Laplacian of
a Gaussian</A>. </P>

The result is that a '<CODE><A HREF="#dog" >DoG</A></CODE>' is much more
easilly generated in hardware, than a '<CODE><A HREF="#log" >LoG</A></CODE>'
kernel.  </P>

For example here I have placed the <A HREF="../morphology/#kernel2image"
>Kernel Images</A> of a '<CODE><A HREF="#log" >LoG</A></CODE>', and a
'<CODE><A HREF="#dog" >DoG</A></CODE>' kernel side-by-side for comparison.

<DIV ALIGN=center>
  <A HREF="kernel_dog.gif"
     ><IMG SRC="kernel_dog.gif"
           ALIGN=middle VSPACE=0 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_log.gif"
     ><IMG SRC="kernel_log.gif"
           ALIGN=middle VSPACE=0 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
</DIV>

If you look on the <A
HREF="http://en.wikipedia.org/wiki/Difference_of_Gaussians" >Difference of
Gaussian, Wikipedia</A> web page you will see some graphs where they also
magick compare the profile of a '<CODE><A HREF="#log" >LoG</A></CODE>' (or "Maxican
Hat"), with a '<CODE><A HREF="#dog" >DoG</A></CODE>', showing the verly very
slight difference between matching curves. </P>

<I>More information wanted on how to map a sigma of a LoG to generate a near
equivelent 'DoG'.  If you know please Mail Me at the address in the footer.</I>
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>

The applied results are also the very similar.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR VALIGN=bottom><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -bias 50% -morphology Convolve DoG:0,1.8,2.4  face_dog.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_dog.png"
     ><IMG SRC="face_dog.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>

Note that both '<I>sigma</I>' values should be defined and at least one should
be non-zero. A zero value for either sigma component will be the equivalent of
a '<CODE><A HREF="#unity" >Unity</A></CODE>' kernel, meaning that it keeps the
image unchanged. If both values are zero, the two Gaussians would be a
'<CODE><A HREF="#unity" >Unity</A></CODE>' kernels, which when substracted
would produce a perfectly zero or black result (plus any bias value). </P>

When the arguments are '<CODE>Dog:0,0,<I>non-zero</I></CODE>, the DoG, becomes
a simple high pass filter, which is defined as the 'Unity'  kernel (producing
the original image) minus a low pass filter kernel (blurred image).  In this
case sigma1=0 is just the 'Unity' kernel and sigma2=<I>non-zero</I> is a
Gaussian low pass (blur) filter kernel. </P>

The following, therefore, produces a high pass filtered image with 
filter value of sigma2=2 </P>

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR VALIGN=bottom><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -bias 50% -morphology Convolve DoG:0,0,2  face_dog_unity.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_dog_unity.png"
     ><IMG SRC="face_dog_unity.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

A Photoshop high pass filter with filter value of radius=2 produces 
the same result. </P>

Note that using '<CODE>DoG:0,2,0</CODE>' will return an image that is basically
the negated version (around the Output Bias) of the previous image. </P>

This technique can also be used to generate a 3x3 'Isotropic Laplacian'
kernel, meaning a '<CODE><A HREF="#laplacian"
>Laplacian</A></CODE>' kernel which produce equal results in all directions,
rather than having unequal diagonal bias.  </P>

For example radius=1 (for a 3x3 kernel) and a sigma of 1 will generate...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=kernel_laplacian_isotropic.txt>
  magick face.png  -define morphology:showkernel=1 -bias 50% \
          -morphology Convolve DoG:1,0,1  face_laplacian_isotropic.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="face_laplacian_isotropic.png"
     ><IMG SRC="face_laplacian_isotropic.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_laplacian_isotropic.txt"
     ><IMG SRC="kernel_laplacian_isotropic.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

The other point about using a "Difference of Gaussians" is that you can use the
much faster "<CODE><A HREF="../option_link.cgi?blur" >-blur</A></CODE>"
operator (which internally uses the '<CODE><A HREF="#blur" >Blur</A></CODE>'
kernels), to generate the same results.  However to do this you will need to
generate each of the two 'blurred' images separately, and then subtract the
results, with the addition of an appropriate scaling and bias. </P>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png \
          \( -clone 0 -blur 0x1.8 \) \( -clone 0 -blur 0x2.4 \) -delete 0 \
          -compose Mathematics -define compose:args=0,-4,4,0.5 -magick composite \
          face_diff_of_blurs.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_diff_blurs.png"
     ><IMG SRC="face_diff_of_blurs.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The above uses the special <A HREF="../compose/#mathematics" >Mathematics
Composition Method</A> to avoid problems with 'clipping' during the
subtraction of the images in a non-<A HREF="../basics/#hdri" >HDRI</A> version
of IM.  For more details see <A HREF="../transform/#math_addition" >Adding
Biased Gradients</A>. </P>

The only other factor is the use of a larger scaling factor during the
subtraction (the two '<CODE>4</CODE>'s in the <A
HREF="../compose/#mathematics" >Mathematics Compose</A> argument).  This is
because subtracting two normalized blurs, does not produce the same
(increased) magnitude of results that you from normalizing the two subtracted
gaussian curves together in a '<CODE><A HREF="#dog" >DoG</A></CODE>' kernel.
</P>

However other than the magnitude, the above example image is equivelent to the
first '<CODE><A HREF="#dog" >DoG</A></CODE>' kernel result, just faster to
generate, especially for larger sigma values. And that is the point, even
though it is more work, that complex method is faster than using a '<CODE><A
HREF="#dog" >DoG</A></CODE>' or '<CODE><A HREF="#log" >LoG</A></CODE>' kernel
directly. </P>

<BR>


<A NAME="laplacian"></A>
<H4>Discrete Laplacian Kernels</H4>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   Laplacian:{<I>type</I>}
</samp></pre></TD></TR></TABLE>
</DIV></P>

There have been many forms of small "Laplacian Kernel" that have been
published in many scientific research papers. Here I provide built in versions
of the more common ones I have been able to find in the academic literature.
</P>

These kernel are basically calculated using a '<CODE><A HREF="#log"
>LoG</A></CODE>' kernel but scaled so as to use discrete integer values in
a small kernel array.  This allows you to use generated dedicated fast image
filters that only use integer maths to process the image data. However
ImageMagick is a more generalized image processor and as such does not provide
such an ultra fast dedicated filter. But people like to use these as they are
simpler to understand, so many of them have been built into IM. </P>

None of the kernels provided here are rotatable, and most are 'anisotropic',
meaning they are not perfectly circular, especially in diagonal directions.
However see the previous section ('<CODE><A HREF="#dog" >DoG</A></CODE>'
kernels) for a way to generate a true "Isotropic 3x3 Laplacian Kernel". </P>

The first two '<CODE>Laplacian:0</CODE>' and '<CODE>Laplacian:1</CODE>'
kernels are the most common form of "Discrete Laplacian Kernel" in use.  They
are very small, meaning they will locate edges very accurately, but are also
prone to enhancing image noise. </P>

Note that not all '<I>type</I>' numbers have been defined, leaving spaces for
more discrete kernels to be defined in the future. The numbers used were
selected to better match the kernel defined by that number. </P>


<A NAME="laplacian_0"></A>
<H4><CODE>Laplacian:0</CODE> (default)</H4>

The 8 neighbour Laplacian. Probably the most common discrete Laplacian
edge detection kernel. </P>

Here I use <A HREF="../morphology/#showkernel" >Show Kernel</A> to extract the
'discrete' and 'unnormalized' kernel, before showing you thw result of the
normalized kernel with a <A HREF="#kernel_bias" >Output Bias</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=kernel_laplacian_0.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
          -morphology Convolve:0 Laplacian:0 null:
  magick face.png -define convolve:scale='!' -bias 50% \
          -morphology Convolve Laplacian:0   face_laplacian_0.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="face_laplacian_0.png"
     ><IMG SRC="face_laplacian_0.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_laplacian_0.txt"
     ><IMG SRC="kernel_laplacian_0.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

Sometimes a Laplacian, whether it is a discrete Laplacian, as in the last
example, or a generated '<CODE><A HREF="#log" >LoG</A></CODE>' or '<CODE><A
HREF="#dog" >DoG</A></CODE>' produces a result that is more complex than is
desired.  In such cases, generating an unbiased image, (without any <A
HREF="#kernel_bias" >Output Bias</A>) will work better. </P>

So lets repeat the above without a bias, so as to only keep the brigher
'positive' edges.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='!' \
          -morphology Convolve Laplacian:0 \
          -auto-level face_laplacian_positives.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_laplacian_positives.png"
     ><IMG SRC="face_laplacian_positives.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In this case we have dark (black) lines on a lighter (white) colors.  This in
turn causes the filter to 'double' the edges, which can be seen in the results
shown. </P>

For this image using a negative scaling factor (to keep negative edges, rather
than positive edges), and seemd to work better on our test image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='-1!' \
          -morphology Convolve Laplacian:0 \
          -auto-level face_laplacian_negatives.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_laplacian_negatives.png"
     ><IMG SRC="face_laplacian_negatives.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see, for this image using the negative size produces stronger edges
without the 'twinning' effects the positive results produced. This is because
of the use of 'black' edging lines on a white background, in the image being
used. </P>

ASIDE: The reason you get a blue edge around the yellow star is that the
difference between the 'yellow' star, and the 'white' background is
a subtraction of blue color. If the background was black, you would get
a yellow edge color. </P>

<!-- This does NOT work well
Another alternative is to merge an absolute value of the results. This can be
done using a <A HREF="../color_mods/#solarize" >Solarize Operation</A> on the
biased results and rescaling the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='!' -bias 50% \
          -morphology Convolve Laplacian:0 -solarize 50% -negate \
          -auto-level face_laplacian_solarize.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_laplacian_solarize.png"
     ><IMG SRC="face_laplacian_solarize.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
-->


<A NAME="laplacian_1"></A>
<H4><CODE>Laplacian:1</CODE></H4>

The 4 neighbour Laplacian. Also very commonly used.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=kernel_laplacian_1.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
              -morphology Convolve:0 Laplacian:1 null:
  magick face.png -define convolve:scale='!' -bias 50% \
                   -morphology Convolve Laplacian:1   face_laplacian_1.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="face_laplacian_1.png"
     ><IMG SRC="face_laplacian_1.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_laplacian_1.txt"
     ><IMG SRC="kernel_laplacian_1.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

The results are not a strong, but are often clearer than the 8-neighbour
laplacian. </P>


<A NAME="laplacian_2"></A>
<H4><CODE>Laplacian:2</CODE></H4>

3x3 Laplacian, with center:4 edge:1 corner:-2

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=kernel_laplacian_2.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
              -morphology Convolve:0 Laplacian:2 null:
  magick face.png -define convolve:scale='!' -bias 50% \
                   -morphology Convolve Laplacian:2   face_laplacian_2.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="face_laplacian_2.png"
     ><IMG SRC="face_laplacian_2.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_laplacian_2.txt"
     ><IMG SRC="kernel_laplacian_2.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>


<A NAME="laplacian_3"></A>
<H4><CODE>Laplacian:3</CODE></H4>

3x3 Laplacian, with center:4 edge:-2 corner:1

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=kernel_laplacian_3.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
              -morphology Convolve:0 Laplacian:3 null:
  magick face.png -define convolve:scale='400%!' -bias 50% \
          -morphology Convolve Laplacian:3    face_laplacian_3.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="face_laplacian_3.png"
     ><IMG SRC="face_laplacian_3.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_laplacian_3.txt"
     ><IMG SRC="kernel_laplacian_3.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

This kernel highlights diagonal edges, and tends to make vertical and
horizontal edges vanish. However you may need to scale the results (as I did
above) to see make any result visible. </P>

<A NAME="laplacian_5"></A>
<H4><CODE>Laplacian:5</CODE></H4>

5x5 Laplacian

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=kernel_laplacian_5.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
              -morphology Convolve:0 Laplacian:5 null:
  magick face.png -define convolve:scale='!' -bias 50% \
                   -morphology Convolve Laplacian:5   face_laplacian_5.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="face_laplacian_5.png"
     ><IMG SRC="face_laplacian_5.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_laplacian_5.txt"
     ><IMG SRC="kernel_laplacian_5.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

The rule-of-thumb with laplacian kernels is the larger they are the cleaner
the result, especially when errors are involved.  However you also get less
detail. </P>


<A NAME="laplacian_7"></A>
<H4><CODE>Laplacian:7</CODE></H4>

7x7 Laplacian

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=kernel_laplacian_7.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
              -morphology Convolve:0 Laplacian:7 null:
  magick face.png -define convolve:scale='!' -bias 50% \
                   -morphology Convolve Laplacian:7   face_laplacian_7.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="face_laplacian_7.png"
     ><IMG SRC="face_laplacian_7.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_laplacian_7.txt"
     ><IMG SRC="kernel_laplacian_7.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>


<A NAME="laplacian_15"></A>
<H4><CODE>Laplacian:15</CODE></H4>

A Discrete 5x5 LoG (Sigma approximatally 1.4)

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=kernel_laplacian_15.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
              -morphology Convolve:0 Laplacian:15 null:
  magick face.png -define convolve:scale='!' -bias 50% \
                   -morphology Convolve Laplacian:15   face_laplacian_15.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="face_laplacian_15.png"
     ><IMG SRC="face_laplacian_15.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_laplacian_15.txt"
     ><IMG SRC="kernel_laplacian_15.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>


<A NAME="laplacian_19"></A>
<H4><CODE>Laplacian:19</CODE></H4>

A Discrete 9x9 LoG (Sigma approximatally 1.4)

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR valign="top"><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD width="90%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE ERR=kernel_laplacian_19.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
              -morphology Convolve:0 Laplacian:19 null:
  magick face.png -define convolve:scale='!' -bias 50% \
                   -morphology Convolve Laplacian:19   face_laplacian_19.png
</samp></pre></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="face_laplacian_19.png"
     ><IMG SRC="face_laplacian_19.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="kernel_laplacian_19.txt"
     ><IMG SRC="kernel_laplacian_19.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>


<A NAME="sharpening"></A>
<H3>Sharpening Images with Edge Detection
<FONT SIZE=-1>(enhancing the edges of the original image)</FONT></H3>

The '<CODE><A HREF="#log" >LoG</A></CODE>' and '<CODE><A HREF="#dog"
>DoG</A></CODE>' kernels can also be used to sharpen images, as opposed to
<A HREF="#unsharpen" >Un-sharpening Images using Blurs</A>. </P>

Basically all you need to do is add the kernel results (including negative
results) to the original image. </P>

To do this is easy,  simply add 100% weighted '<CODE><A HREF="#unity"
>Unity</A></CODE>' or "Identity" kernel to the scaling factors.  This is why
it was provided. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example...

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='100,100%' \
          -morphology Convolve 'Log:0x2' face_sharpen.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_sharpen.png"
     ><IMG SRC="face_sharpen.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

This is a much broader smoother sharpening of the image than what the <A
HREF="#unsharpen" >Unsharpen Technique</A> generated (result shown to right).
That is because it is an actual true sharpening of the image, and not one
faked by the subtraction of a blur. </P>

</TD><TD>
  <A HREF="face_unsharp.png"
     ><IMG SRC="face_unsharp.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As before, when only a single pass convolution is being performed, you can
make direct use of a <A HREF="#identity_addition" >Blended Kernel</A>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example less sharp...

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50,100%' \
          -morphology Convolve 'Log:0x2' face_sharpen_50.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_sharpen_50.png"
     ><IMG SRC="face_sharpen_50.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Or more sharp...

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='150,100%' \
          -morphology Convolve 'Log:0x2' face_sharpen_150.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_sharpen_150.png"
     ><IMG SRC="face_sharpen_150.png"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can use 2-pass methods of the <A HREF="#dog" >Difference of
Gaussians</A> to produce a faster multi-step sharpen operation,
but as it was shown above, such a scheme requires, 4 convolutions
and a separate blending operation to achieve the same result. </P>

<I>FUTURE: add example of this</I></P>

It is this complexity that is the reason that using <A HREF="#unsharp"
>Unsharpen</A> is more often the preferred method of sharpening images. </P>

But as you can see for a heavy sharpening process, using a proper sharpening
kernel is preferred over an <A HREF="#unsharpen" >Unsharp Sharpening</A>.
However for minor sharpening, such as <A HREF="../resize/#resize_unsharp"
>Sharpening Resized Images</A> their is no problem with using unsharp. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="directional"></A>
<H2 > Directional Convolutions
<FONT SIZE=-1>(Slopes, and Compass)</FONT></H2>

Like the above, these kernels look for slopes in the color intensity of the
image, but rather than any slope, these look for slopes in a specific
direction.  Mathematically this is known as a 'derivative' which is really
just fancy way of saying 'slope'. </P>

But knowing slope information for different directions can also be useful as
a means from which you can determine the angle or 'compass' direction of the
a slope or image edge.  That is the 2-dimensional direction of the slope in an
image at some particular point. </P>

Slopes are also used in image processing techniques known as 'embossing' and
'shading' of images. </P>

At this time no 'generated' kernels are available, only 'named' pre-defined
kernels, such as <A HREF="#sobel" >Sobel</A> and <A HREF="#roberts"
>Roberts</A>.  However I am certain that the embossing and shading kernel
generation functions will be moved into the morphology/convolution kernel set,
at some point in the future. </P>

So lets have a look at some of the 'named' directional kernels. </P>

<A NAME="directional_kernels"></A>
<H3>Directional Kernels</H3>


<A NAME="sobel"></A>
<H4>Sobel</H4>

<!--<CODE EXECUTE NOIMAGE ERR=kernel_sobel.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
          -morphology Convolve:0 Sobel null:
</CODE>-->
<BLOCKQUOTE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   Sobel:{<I>angle</I>} &nbsp;
</samp></pre></TD></TR>
<TR><TD>
  <A HREF="kernel_sobel.txt"
     ><IMG SRC="kernel_sobel.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</BLOCKQUOTE></P>

We already saw the '<I>Sobel</I>' kernel above in the discussion of <A
HREF="zero-summing_kernels" >Zero-Summing Kernels</A>. </P>

This kernel is a raw directional (first derivative) kernel designed to return
the slope of an edge in some specific orthogonal direction.  By default it is
designed for left to right slope detection, using a '<CODE>convolve</CODE>'
operation.  The result is essentually a X-derivative (slope) of the image.
</P>

<!--<CODE EXECUTE>
  kernel2image -15.1 -n -mn -g 1 -ml 'Sobel' Sobel kernel_sobel.gif
</CODE>-->
<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=pixel_spread.gif ERR=spread_kernel.txt>
  magick -size 60x60 xc:black xc:white +append slope_positive.gif
  magick slope_positive.gif -morphology Convolve Sobel slope_sobel.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="slope_positive.gif"
     ><IMG SRC="slope_positive.gif"  WIDTH=120 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_sobel.gif"
     ><IMG SRC="kernel_sobel.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="slope_sobel.gif"
     ><IMG SRC="slope_sobel.gif"  WIDTH=120 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  If you look at the kernel you may think that it is declared backwards.  In
  one sense you are actually correct. However this is due to the way '<A
  HREF="#convolve" >Convolve</A>' actually works. </P>

  You can find out more about this 'reversal' in more detail in <A
  HREF="#convolve_vs_correlate" >Convolve vs Correlate</A> below. </P>

</I></FONT></TD></TR></TABLE></P>

Note that this kernel can produce a 'negative slope' indication too, but this
cannot be seen unless a <A HREf="#bias" >Bias</A> of '<CODE>50%</CODE>' is
also used with this convolve operation.

Though there is no negative slope in the previous example, this next example
does have one, so I also added a <A HREf="#bias" >Bias Setting</A> so you can
see it. </P>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=pixel_spread.gif ERR=spread_kernel.txt>
  magick -size 40x60 xc:black xc:white xc:black +append slope_both.gif
  magick slope_both.gif -define convolve:scale='50%!' -bias 50% \
                         -morphology Convolve Sobel slope_sobel_bias.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="slope_both.gif"
     ><IMG SRC="slope_both.gif"  WIDTH=120 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_sobel.gif"
     ><IMG SRC="kernel_sobel.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="slope_sobel_bias.gif"
     ><IMG SRC="slope_sobel_bias.gif"  WIDTH=120 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
  ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  If you use this kernel with '<CODE>Correlate</CODE>', you will find slopes
  that 'match' the way the kernel is defined. In that case you would get
  a positive results for a slope going from high (white value) on left and
  a low (black value) on right.  In the able example the two lines would then
  be swapped. </P>

  However the above is '<A HREF="#convolve" >Convolution</A>', and not a '<A
  HREF="#correlate" >Correlation</A>' (meaning match the kernel) . Again see
  <A HREF="#convolve_vs_correlate" >Convolve vs Correlate</A> for more detail
  of the difference.

</I></FONT></TD></TR></TABLE></P>

As you can see we now get a white line (positive slope) as we go up the slope
from black to white, and a black line (negative slope) as we go back down from
white to black. </P>

Here is the result of using default '<CODE>Sobel</CODE>' kernel, on the face
image.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
                   -morphology Convolve Sobel  face_sobel.png
</samp></pre></TD></TR></TABLE>
  <A HREF="../images/face.png"
     ><IMG SRC="../images/face.png"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_sobel.gif"
     ><IMG SRC="kernel_sobel.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="face_sobel.png"
     ><IMG SRC="face_sobel.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that sobel, and most other edge detection kernals tend to produce
a 2 pixel thick response along very strong edge, and a 3 pixel response over
a single pixel wide line.  This is much stronger than a laplacian edge
detector.  </P>

You can rotate this kernel using the '<I>angle</I>' argument, generally in
multiples of 90 degrees.  However you can also rotate it 45 degree multiples,
even though it was not designed for this. This is useful for getting 45 degree
quantized directional derivatives or the gradient magnitude from the maximum
of all 45 degree rotated derivative results.</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>

Here it is again, but rotated 90 degrees (top to bottom).

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
          -morphology Convolve Sobel:90   face_sobel_90.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_sobel_90.png"
     ><IMG SRC="face_sobel_90.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<BR>

One way to collect all the edges of an image using a '<CODE><A HREF="#sobel"
>Sobel</A></CODE>' kernel, is to apply the kernel 4 times in all directions,
and collect the maximum value seen (using a <A HREF="../compose/#lighten"
>Lighten Mathematical Composition</A>. This is an approximation to the
gradient magnitude.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   magick face.png   -define convolve:scale='!' \
           \( -clone 0 -morphology Convolve Sobel:0 \) \
           \( -clone 0 -morphology Convolve Sobel:90 \) \
           \( -clone 0 -morphology Convolve Sobel:180 \) \
           \( -clone 0 -morphology Convolve Sobel:270 \) \
           -delete 0 -background Black -compose Lighten -flatten \
           face_sobel_maximum.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_sobel_maximum.png"
     ><IMG SRC="face_sobel_maximum.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can simplify the above by making use of the <A
HREF="../morphology/#multi-kernel" >Multiple Kernel Handling</A> features of
IM morphology.  That is you can create a rotated list of all 90 degree
rotations of the '<CODE><A HREF="#sobel" >Sobel</A></CODE>' kernel.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   magick face.png   -define convolve:scale='!' \
           -define morphology:compose=Lighten \
           -morphology Convolve  'Sobel:&gt;'   face_sobel_maximum_2.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_sobel_maximum_2.png"
     ><IMG SRC="face_sobel_maximum_2.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you want to see exactly what the above is doing add the <A
HREF="../morphology/#showkernel" >Show Kernel</A> setting, and the <A
HREF="../morphology/#verbose" >Verbose</A> setting. </P>

A more efficient technique for generating a gradient magnitude would be to use
the fact that a 180 degree rotation, simply produces the same result as
a negating the kernel, and thus negating the results. As such the X and
Y derivative (90 degree rotated convolutions), with some trickiness to get the
absolute values of the convolution, can achieve such a result with less
processing.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   magick face.png   -define convolve:scale='50%!' -bias 50% \
           \( -clone 0 -morphology Convolve Sobel:0 \) \
           \( -clone 0 -morphology Convolve Sobel:90 \) \
           -delete 0 -solarize 50% -level 50,0% \
           -compose Lighten -magick composite      face_sobel_maximum_3.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_sobel_maximum_3.png"
     ><IMG SRC="face_sobel_maximum_3.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is typically good enough for most purposes. </P>

A more exact magnitude of all the slopes can be extracted by doing a vector
addition of the two X and Y derivatives (as per <A
HREF="http://en.wikipedia.org/wiki/Pythagorean_theorem" >Pythagorean
Theorem</A>).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   magick face.png   -define convolve:scale='50%!' -bias 50% \
           \( -clone 0 -morphology Convolve Sobel:0 \) \
           \( -clone 0 -morphology Convolve Sobel:90 \) \
           -delete 0 -solarize 50% -level 50,0% \
           +level 0,70% -gamma 0.5 -compose plus -magick composite  -gamma 2 \
           -auto-level face_sobel_magnitude.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_sobel_magnitude.png"
     ><IMG SRC="face_sobel_magnitude.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR valign="top">
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify width="100%"><FONT SIZE=-1><I>
  The "<CODE><A HREF="../option_link.cgi?gamma" >-gamma</A></CODE>" function
  in the above use being used to perform a mathematical 'Square' and 'Square
  Root' of the values returned by the '<CODE><A HREF="#sobel"
  >Sobel</A></CODE>' results.  For more detail see <A
  HREF="../transform/#evaluate_pow" >Power Of Maths Function</A>. </P>

  The extra "<CODE><A HREF="../option_link.cgi?level" >+level</A></CODE>"
  ensures the <A HREF="../compose/#plus" >Plus Composition</A> does not
  overflow the image quantum range. See <A HREF="../basics/#quantum_effects"
  >Quantum Effects, non-HDRI vs HDRI</A> for details.

</I></FONT></TD></TR></TABLE></P>

Instead of the magnitude you can extract the direction of the slope from the
two edge detection results.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 30x600 xc:'#0F0' -colorspace HSB \
          gradient: -compose CopyRed -magick composite \
          -colorspace RGB -rotate 90  rainbow.jpg
  magick shapes.gif -define convolve:scale='50%!' -bias 50% \
      \( -clone 0 -morphology Convolve Sobel:0 \) \
      \( -clone 0 -morphology Convolve Sobel:90 \) \
      -delete 0 \
      \( -clone 0,1 -fx '0.5+atan2(v-0.5,0.5-u)/pi/2' rainbow.jpg -clut \) \
      \( -clone 0,1 -fx 'u&gt;0.48&amp;&amp;u&lt;0.52&amp;&amp;v&gt;0.48&amp;&amp;v&lt;0.52 ? 0.0 : 1.0' \) \
      -delete 0,1 -alpha off -compose CopyOpacity -magick composite \
      face_sobel_direction.png
</samp></pre></TD></TR></TABLE>
  <A HREF="shapes.gif"
     ><IMG SRC="shapes.gif"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="face_sobel_direction.png"
     ><IMG SRC="face_sobel_direction.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The first "<CODE><A HREF="../option_link.cgi?fx" >-fx</A></CODE>" expression
is the one that uses a 'atan()' function to magick a X,Y vector into an
angle.  This is then colored with the an external <A
HREF="../canvas/#gradient_colorspace" >Rainbow Gradient Image</A>, as a <A
HREF="../color_mods/#clut" >Color Lookup Table</A>.  The second "<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>" expression create a thresholded
transparency mask to make any areas without a slope transparent. </P>

However the above technique tends to produce huge mess of information for real
images as it does not take into account the magnitude of the slope.  </P>

Here is another more complex version.  This does almost all the calculations
in the green 'G' channel, so as to reduce the amount of image processing
needed by a factor of three.  It then uses HSB colorspace to create direction
(hue) and magnitude (brightness). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -colorspace Gray    -channel G \
          -define convolve:scale='50%!' -bias 50% \
          \( -clone 0 -morphology Convolve Sobel:0 \) \
          \( -clone 0 -morphology Convolve Sobel:90 \) \
          -delete 0 \
          \( -clone 0,1 -fx '0.5 + atan2(v-0.5,0.5-u)/pi/2' \) \
          \( -clone 0   -fill white -colorize 100% \) \
          \( -clone 0,1 -fx 'hypot(u-0.5,v-0.5)*2' \) \
          -delete 0,1 -separate +channel \
          -set colorspace HSB -combine -colorspace RGB \
          face_sobel_magnitude_n_direction.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_sobel_magnitude_n_direction.png"
     ><IMG SRC="face_sobel_magnitude_n_direction.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<BR>



<A NAME="roberts"></A>
<H4>Roberts</H4>

<!--<CODE EXECUTE NOIMAGE ERR=kernel_roberts.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
          -morphology Convolve:0 Roberts null:
</CODE>-->
<BLOCKQUOTE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   Roberts:{<I>angle</I>} &nbsp;
</samp></pre></TD></TR>
<TR><TD>
  <A HREF="kernel_roberts.txt"
     ><IMG SRC="kernel_roberts.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</BLOCKQUOTE></P>

The '<CODE>Roberts</CODE>' kernel is far simplier that the previous '<CODE><A
HREF="#sobel" >Sobel</A></CODE>' kernel, and will produce an even tighter edge
location (down to 2 pixels).  Of course that also makes it more prone to noise
effects. </P>

Normally this kernel is represented by a much smaller 2x1 or even a 2x2
kernel, however by implementing it as a 3x3 kernel I can 'cyclically' rotate
the kernel in 45 degree increments. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example here is a 45 degree result, more commonly known as
a 'Roberts-Cross' kernel.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
                   -morphology Convolve Roberts:45  face_roberts.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_roberts.png"
     ><IMG SRC="face_roberts.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As with '<CODE><A HREF="#sobel" >Sobel</A></CODE>' you can also use <A
HREF="../morphology/#multi-kernel" >Multi-Kernel Handling</A> to generate
a maximum slope from all directions.  But this time we will get 8 x 45 degree
directions, rather than just 4.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR><TD width="100%" ALIGN=justify>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   magick face.png -define morphology:compose=Lighten \
           -morphology Convolve  'Roberts:@'   face_roberts_maximum.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_roberts_maximum.png"
     ><IMG SRC="face_roberts_maximum.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that as rotating this kernel by 180 degrees does not generate a negated
result (due to an offset). As such you cannot simply merge half the number of
convolutions, as you can with '<CODE><A HREF="#sobel" >Sobel</A></CODE>'. </P>

Basically the slope generated by just one '<CODE><A HREF="#roberts"
>Roberts</A></CODE>' convolution, is offset by half a pixel from aligning with
the actual image.  That is the slope calculated is located for a point between
the '<CODE>+1</CODE>' and '<CODE>-1</CODE>' values, between the pixels, but
stored in the center '<CODE>-1</CODE>' pixel. </P>

However this also means that by saving all the slopes around a pixel and
adding them together, you get a much smaller sharper edge detection with only
2 pixels (rather than 4 pixels) highlighting sharp edge boundaries. </P>


<A NAME="prewitt"></A>
<H4>Prewitt</H4>

<!--<CODE EXECUTE NOIMAGE ERR=kernel_prewitt.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
          -morphology Convolve:0 Prewitt null:
</CODE>-->
<BLOCKQUOTE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   Prewitt:{<I>angle</I>} &nbsp;
</samp></pre></TD></TR>
<TR><TD>
  <A HREF="kernel_prewitt.txt"
     ><IMG SRC="kernel_prewitt.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</BLOCKQUOTE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

The '<CODE>Prewitt</CODE>' kernel is very similar to a '<CODE><A HREF="#sobel"
>Sobel</A></CODE>', though much looser on the exact direction of the
specific edge detection.  The result is thus a little more fuzzy.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
                   -morphology Convolve Prewitt  face_prewitt.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_prewitt.png"
     ><IMG SRC="face_prewitt.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="compass"></A>
<H4>Compass</H4>

<!--<CODE EXECUTE NOIMAGE ERR=kernel_compass.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
          -morphology Convolve:0 Compass null:
</CODE>-->
<BLOCKQUOTE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   Compass:{<I>angle</I>} &nbsp;
</samp></pre></TD></TR>
<TR><TD>
  <A HREF="kernel_compass.txt"
     ><IMG SRC="kernel_compass.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</BLOCKQUOTE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

This is the 'Prewitt Compass' kernel which supposedly a stronger directional
sense than '<CODE><A HREF="#sobel" >Sobel</A></CODE>'.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
                   -morphology Convolve Compass  face_compass.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_compass.png"
     ><IMG SRC="face_compass.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="kirsch"></A>
<H4>Kirsch</H4>

<!--<CODE EXECUTE NOIMAGE ERR=kernel_kirsch.txt>
  magick xc: -define morphology:showkernel=1 -precision 2 \
          -morphology Convolve:0 Kirsch null:
</CODE>-->
<BLOCKQUOTE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   Kirsch:{<I>angle</I>} &nbsp;
</samp></pre></TD></TR>
<TR><TD>
  <A HREF="kernel_kirsch.txt"
     ><IMG SRC="kernel_kirsch.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</BLOCKQUOTE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

This is another strong direction sensing edge detector.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
                   -morphology Convolve Kirsch  face_kirsch.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_kirsch.png"
     ><IMG SRC="face_kirsch.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="freichen"></A>
<H4>Frei-Chen</H4>

Three sets of kernels are provided by this built-in. </P>

The first is a 'Isotropic' (uniform direction) variant of '<CODE><A
HREF="#sobel" >Sobel</A></CODE>', where the '<CODE>2</CODE>' values have been
replaced by a Square Root of 2.

<!--<CODE EXECUTE NOIMAGE ERR=kernel_freichen.txt>
  magick xc: -define morphology:showkernel=1 \
          -morphology Convolve:0 Frei-Chen null:
</CODE>-->
<BLOCKQUOTE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
   Frei-Chen:[{<I>type</I>},][{<I>angle</I>}] &nbsp;
</samp></pre></TD></TR>
<TR><TD>
  <A HREF="kernel_freichen.txt"
     ><IMG SRC="kernel_freichen.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</BLOCKQUOTE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

The kernel above is the default unweighted kernel that is the heart of the
'<CODE>Frei-Chen</CODE>' kernel.

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick face.png -define convolve:scale='50%!' -bias 50% \
                   -morphology Convolve Frei-Chen  face_freichen.png
</samp></pre></TD></TR></TABLE></TD><TD>
  <A HREF="face_freichen.png"
     ><IMG SRC="face_freichen.png"         WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Like '<CODE><A HREF="#sobel" >Sobel</A></CODE>', this kernel should be applied
using an angle in multiples of 90 degrees. </P>


To make things easier two kernels (with the same weighting) have been
provided, one like the above for orthogonal use, the other for diagonal use.

<!--<CODE EXECUTE NOIMAGE ERR=kernel_freichen1.txt>
  magick xc: -define morphology:showkernel=1 \
          -morphology Convolve:0 Frei-Chen:1 null:
</CODE>-->
<!--<CODE EXECUTE NOIMAGE ERR=kernel_freichen2.txt>
  magick xc: -define morphology:showkernel=1 \
          -morphology Convolve:0 Frei-Chen:2 null:
</CODE>-->
<BLOCKQUOTE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD ALIGN=center>Frei-Chen:1</TD></TR>
<TR><TD>
  <A HREF="kernel_freichen1.txt"
     ><IMG SRC="kernel_freichen1.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR>
<TR><TD ALIGN=center>Frei-Chen:2</TD></TR>
<TR><TD>
  <A HREF="kernel_freichen2.txt"
     ><IMG SRC="kernel_freichen2.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</BLOCKQUOTE></P>


The third set of types consists of 9 specially designed and weighted kernels
that is used not only for edge detection in a specific direction, but also for
determining the actual angle of a sharp edge. </P>

The '<I>type</I>' in this can is a number from '<CODE>11</CODE>' to
'<CODE>19</CODE>', allowing you to extract any one of the 9 kernels in the set.
</P>

However if you give a '<I>type</I>' value of '<CODE>10</CODE>' you will get
a multi-kernel list of all 9, pre-weighted kernels. </P>

<PRE>
The kernels are each applied to the original image, then the results are added
together to generate the edge detection result.

This is best done using a <A HREF="../basics/#hdri" >HDRI</A> version of
ImageMagick.

   magick image.png \
           \( -clone 0 -morphology Convolve FreiChen:11 \) \
           \( -clone 0 -morphology Convolve FreiChen:12 \) \
           \( -clone 0 -morphology Convolve FreiChen:13 \) \
           \( -clone 0 -morphology Convolve FreiChen:14 \) \
           \( -clone 0 -morphology Convolve FreiChen:15 \) \
           \( -clone 0 -morphology Convolve FreiChen:16 \) \
           \( -clone 0 -morphology Convolve FreiChen:17 \) \
           \( -clone 0 -morphology Convolve FreiChen:18 \) \
           \( -clone 0 -morphology Convolve FreiChen:19 \) \
           -delete 0 -background Black -compose Plus -flatten \
           result.pfm

If a type of 10 is given then a multi-kernel list of all the 9 weighted kernels
shown above is generated. This lets you use multi-kernel composition to do the
above, much more simply...

    magick image.png  -define morphology:compose=Plus \
          -morphology Convolve FreiChen:10 \
          result.pfm

I have not however found out what the supposed meaning of the results are.  If
anyone has any experience or knowledge about how this is actually used, please
let me know, so I can include it here for others to use.  </PRE>

</P><BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="correlate"></A>
<H2>Correlate
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/mph_correlate.gif" ALIGN=absmiddle>
)</FONT></H2>

Where the '<CODE><A HREF="#convolve" >Convolve</A></CODE>' method is basically
used for image processing, the '<CODE>Correlate</CODE>' method is designed
more for pattern matching.  That is, it performs a 'Cross-Correlation' of an
image with its kernel, looking for a match of the given shape within the
image.  </P>

In reality both '<CODE><A HREF="#convolve" >Convolve</A></CODE>' and
'<CODE>Correlate</CODE>' are the same operation.  The only difference between
them is actually very minor, namely, an x and y reflection (equivalent to
a 180 degree rotation) of the kernel.</P>

The best guide I have found on the how correlation and convolution work and
how they differ to each other is <A
HREF="http://www.cs.umd.edu/~djacobs/CMSC426/Convolution.pdf" >Class Notes for
CMSC 426, Fall 2005, by David Jacobs</A>.

<A NAME="convolve_vs_correlate"></A>
<H3>Convolution vs Correlation
<FONT SIZE=-1>(asymmetrical kernel effects)</FONT></H3>

As I mentioned above the two operators '<CODE><A HREF="#convolve"
>Convolve</A></CODE>' and '<CODE><A HREF="#correlate" >Correlate</A></CODE>'
are essentially the same.  In fact users often say convolution, when what they
really mean is a correlation.  Also correlation is actually the simpler method
to understand.  </P>

For kernels which are symmetrical around a central 'origin', which is very
typically the case, the two methods are actually the same.  The difference
only becomes apparent when you are using an asymmetrical or uneven kernel.
</P>

For example, here I use a 'L' shaped 'flat' kernel against our 'single pixel'
image.

<!--<CODE EXECUTE SCRIPT IMAGE=kernel_lshape.gif>
  kernel2image -15.2 -m -ml 'L-Shape' \
               '3: 1,0,0
                   1,0,0
                   1,1,0'    kernel_lshape.gif
</CODE>-->
<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE  SCRIPT IMAGE=convolve_shape.gif>
  magick pixel.gif  \
          -morphology Convolve '3: 1,0,0
                                   1,0,0
                                   1,1,0'   convolve_shape.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="pixel.gif"
     ><IMG SRC="pixel.gif"  WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_lshape.gif"
     ><IMG SRC="kernel_lshape.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="convolve_shape.gif"
     ><IMG SRC="convolve_shape.gif"  WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see a '<CODE><A HREF="#convolve" >Convolve</A></CODE>' expanded the
single pixel in the center to form the 'L' shape around it. Even when the
origin itself was not part of the 'neighbourhood'.  </P>

Now lets repeat this example but using '<CODE><A HREF="#correlate"
>Correlate</A></CODE>' instead.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE  SCRIPT IMAGE=correlate_shape.gif>
  magick pixel.gif  \
          -morphology Correlate '3: 1,0,0
                                    1,0,0
                                    1,1,0'  correlate_shape.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="pixel.gif"
     ><IMG SRC="pixel.gif"  WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_correlate.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_lshape.gif"
     ><IMG SRC="kernel_lshape.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="correlate_shape.gif"
     ><IMG SRC="correlate_shape.gif"  WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see '<CODE><A HREF="#correlate" >Correlate</A></CODE>' also
expanded the single pixel, to form a 'L' shape but it was a 'rotated' 'L'
shape. </P>

This is essentially the only difference between these two methods.  The
'<CODE><A HREF="#correlate" >Correlate</A></CODE>'  method applies the kernel
'AS IS' which results in the single pixel expanding into a 'rotated' form.
On the other hand '<CODE><A HREF="#convolve" >Convolve</A></CODE>' actually
uses an 180 degree 'rotated' form of the kernel so that each pixel gets
expanded into the same non-rotated shape. </P>

If you like to see some great examples of how '<CODE><A HREF="#convolve"
>Convolve</A></CODE>' actually does work, I recommend you also have a look at
<A
HREF="http://www.archive.org/2/items/Lectures_on_Image_Processing/EECE253_07_Convolution.pdf"
>EECE \ CS 253 Image Processing, Lecture 7, Spatial Convolution</A>.  The
diagram on page 22, where it actually applies the 'reflected' kernel to
a single pixel, just as I did above. </P>

<BR>

This rotation difference may not seem like much, but it means that in terms of
the mathematics, a convolve operation (represented by an asterix
('<CODE>*</CODE>') symbol) is <A
HREF="http://en.wikipedia.org/wiki/Commutativity" >Commutative</A> in that if
both kernel and image were treated as just an array of values (or two images),
then <CODE>F * G  == G * F</CODE>.  It also means convolve is <A
HREF="http://en.wikipedia.org/wiki/Associativity" >Associtive</A> in that
<CODE>( F * G ) * H  == F * ( G * H )</CODE>.  See <A
HREF="http://en.wikipedia.org/wiki/Convolve#Properties" >Convolution
Properties, Wikipedia</A> for more information on this. </P>

The '<CODE><A HREF="#correlate" >Correlate</A></CODE>' operation is neither
<A HREF="http://en.wikipedia.org/wiki/Commutativity" >Commutative</A> or <A
HREF="http://en.wikipedia.org/wiki/Associativity" >Associtive</A>. Even though
it is closely related (by rotation of the kernel).  Basically '<CODE><A
HREF="#convolve" >Convolve</A></CODE>' acts more like a mathematical
'multiply', while '<CODE><A HREF="#correlate" >Correlate</A></CODE>' does not.
</P>

The exception to all this fuss, is when the kernel being used is, identical
when rotated 180 degrees. That is the kernel is symetrical about the 'origin'.
In that special case both operations generate equivelent results. </P>

What confuses people, is that most of the kernels that are use for
convolution, such as Gaussian Blurs, Laplacian, and so on are symetrical,
in which case it does not really matter whether you are in fact doing a
convolution, or a correlation.  So people get relaxed and fuzzy on the
meanings. </P>

It is only when they are not symetrical, as in the case of <A
HREF="#correlate_search" >Shape Searching</A> (see next), or with directional
kernels such as <A HREF="#sobel" >Sobel</A>, that the difference really
becomes important. </P>


<A NAME="correlate_search"></A>
<H3>Correlation and Shape Searching</H3>

The real use of the '<CODE>Correlate</CODE>' method, (applying the kernel
neighbourhood 'as is' without rotation), is an old, but simple method of
locating shaped objects that roughly match the shape found in the provided
kernel. </P>

For example if we were to use '<CODE>Correlate</CODE>' with an 'L' shaped
kernel and attempt to search the image that we created with the convolution
method example above, we get...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=correlate.gif>
  magick convolve_shape.gif  -define convolve:scale='1!' \
          -morphology Correlate '3: 1,0,0
                                    1,0,0
                                    1,1,0' correlate.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="convolve_shape.gif"
     ><IMG SRC="convolve_shape_mag.gif"    WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_correlate.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_lshape.gif"
     ><IMG SRC="kernel_lshape.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="correlate.gif"
     ><IMG SRC="correlate_mag.gif"      WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="90%">
<TR><TD ALIGN=Justify><FONT SIZE=-1><I>
   ASIDE: note that the 'black' areas in the above kernel image, represent
   a value of zero.  Their are no negative values in this kernel, only
   positive values for the shape being matched. </P>
</I></FONT></TD></TR></TABLE>
</DIV></P>
<!--<CODE EXECUTE SCRIPT IMAGE=convolve_shape_mag.gif>
  magick convolve_shape.gif -scale 800% convolve_shape_mag.gif
  magick correlate.gif -scale 800% correlate_mag.gif
</CODE>-->

Note that I used IM's <A HREF="#convolve_normalize" >Kernel Normalization</A>
to prevent the final results becoming too bright, and swamping the 'peak' in
a sea of white points. </P>

As you can see the '<CODE><A HREF="#correlate" >Correlate</A></CODE>' method
produced a maximum brightness at the point where the kernel 'origin' exactly
matches the same shape in the image.  But it also produces less bright results
where you only get a partial match of the shape. The more of the shape that
matched, the brighter the pixel becomes.  </P>

I would warn you however that while '<CODE><A HREF="#correlate"
>Correlate</A></CODE>' succeeded in this case, it is not really a great way of
doing so.  For example, it can generate a very large number of false matches in
areas of very high brightness. </P>

This problem can be mitigated by using negative values for areas that should
match the dark background of the image instead.  That is, areas that do not
match the background should make the resulting pixel less bright.

<!--<CODE EXECUTE SCRIPT IMAGE=kernel_lpattern.gif>
  kernel2image -10.1 -m -ml 'L-Pattern' \
     '4x5+2+2:   - -1  -  -
                -1 +1 -1  -
                -1 +1 -1  -
                -1 +1 +1 -1
                 - -1 -1  - ' kernel_lpattern.gif
</CODE>-->
</CODE>
<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=correlate_pattern.gif>
  magick convolve_shape.gif -define convolve:scale='1^'  \
          -morphology Correlate '4x5+2+2:  0 -1  0  0
                                          -1 +1 -1  0
                                          -1 +1 -1  0
                                          -1 +1 +1 -1
                                           0 -1 -1  0 '  correlate_pattern.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="convolve_shape.gif"
     ><IMG SRC="convolve_shape_mag.gif"    WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_correlate.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_lpattern.gif"
     ><IMG SRC="kernel_lpattern.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="correlate_pattern.gif"
     ><IMG SRC="correlate_pattern_mag.gif"       WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="90%">
<TR><TD ALIGN=Justify><FONT SIZE=-1><I>
   ASIDE: To make the kernel image clearer, I generated the kernel image so
   that positive (foreground) values are white, negative (background) values
   are black and the zero (don't care) values are transparent. However the
   kernel that is actually used, is completely defined, in terms of numbers,
   and its 'neighbourhood' is a full rectangle. </P>
</I></FONT></TD></TR></TABLE>
</DIV></P>
<!--<CODE EXECUTE>
  magick correlate_pattern.gif -scale 800% correlate_pattern_mag.gif
</CODE>-->

As you can see, the matching peak is much more pronounced, as you are now not
only matching forground pixels, but background pixels as well. </P>

Note the use of the special normalization flag '<CODE>^</CODE>' in the above.
This is important as it will normalize the positive and negative values in the
kernel separately.  That is you want to search for foreground pixels equally
with the background pixels. </P>

This means that you can search for both positive and negative matches of the
given shape by using an <A HREF="#../basics/#hdri" >HDRI version of
IM</A> or with the appropriate use of <A HREF="#bias" >Output Bias</A> (see
above).  </P>

For example, here I apply the 'L' shape search to a test image containing
both positive and negative 'L' shapes. (images shown have been magnified)

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=correlate_bias.gif>
  magick test_morphology.gif  -bias 50% -define convolve:scale='50%^' \
          -morphology Correlate '4x5+2+2:  0 -1  0  0
                                          -1  1 -1  0
                                          -1  1 -1  0
                                          -1  1  1 -1
                                           0 -1 -1  0 '  correlate_bias.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="test_mag.gif"
     ><IMG SRC="test_mag.gif"            WIDTH=208  HEIGHT=136
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_correlate.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_lpattern.gif"
     ><IMG SRC="kernel_lpattern.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="correlate_bias.gif"
     ><IMG SRC="correlate_bias_mag.gif"    WIDTH=208 HEIGHT=136
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!--<CODE EXECUTE>
  magick test_morphology.gif -scale 800% test_mag.gif
  magick correlate_bias.gif -scale 800% correlate_bias_mag.gif
</CODE>-->

The <A HREF="#bias" >Output Bias</A> made the normal output of the search
a mid-tone grey, while the matching shapes are given brighter or darker
colors, depending on the number of pixels that actually match the 'shape
kernel'.  If you examine the actual values of the output image only,
one pure-white and one pure-black pixel are produced, indicating perfect
matches.  However there are also quite a number of near-matches as well. </P>

If I was not interested in the negative or 'black' matches, I could remove the
<A HREF="#bias" >Output Bias</A>, and the '<CODE>50%</CODE>' scaling factor,
so that the no-match pixels are black, and perfect matches are white. </P>

Once you have a '<CODE><A HREF="#correlate" >Correlate</A></CODE>' matching
image, you need to try to find the matching 'peaks'.  This can be done using
another <A HREF="#correlate" >Correlation</A>, but does not always work very
well. </P>

The better method is to use the more exact pattern matching method, '<CODE><A
HREF="../morphology/#hitmiss" >HitAndMiss</A></CODE>' morphology, with the
special '<CODE><A HREF="../morphology/#peaks" >Peaks</A></CODE>' which was
created for this purpose.  This finds any single pixel that is only surrounded
by darker colored pixels.  Other '<CODE><A HREF="../morphology/#peaks"
>Peaks</A></CODE>' kernels can be used to find 'looser' matches.

<!--<CODE EXECUTE>
  kernel2image -15.2 -m  Peaks:1.9  kernel_peaks.gif
</CODE>-->
<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick correlate_bias.gif  -morphology hitandmiss peaks:1.9 \
          -auto-level  correlate_peaks.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="correlate_bias.gif"
     ><IMG SRC="correlate_bias_mag.gif"              WIDTH=208  HEIGHT=136
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_hitmiss.gif" ALIGN=middle WIDTH=20 HEIGHT=30">
  <A HREF="kernel_peaks.gif"
     ><IMG SRC="kernel_peaks.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="correlate_peaks.gif"
     ><IMG SRC="correlate_peaks_mag.gif"    WIDTH=208 HEIGHT=136
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!--<CODE EXECUTE>
  magick correlate_peaks.gif -scale 800% correlate_peaks_mag.gif
-->


And here you can easilly find the location where the best match of the shape
was found, though the degree of the match has been lost. </P>


You may like to look at the 'peak finding' section of <A
HREF="../compare/#sub-image" >Compare and Sub-Image Searching</A>. But also
look at Fred Weinhaus's script "<CODE><A
HREF="http://www.fmwconcepts.com/imagemagick/maxima/" >maxima</A></CODE>". </P>

<I>FUTURE: Normalized Cross Correlation with the Fast Fourier Transform, for
generating very fast image Correlations with very large images (both source
image and sub-image). </I></P>


<A NAME="correlate_vs_hitandmiss"></A>
<H3>Correlation vs HitAnd Miss Morphology</H3>

If you magick compare the kernel image as I represented it to kernels that are used
by the <A HREF="../morphology/#hitmiss" >Hit-And-Miss Morphology
Method</A>, you will find they actually represent the same thing. </P>

<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5>
<TR><TH>
    <TH>'<CODE><A HREF="../morphology/#hitmiss" >HitAndMiss</A></CODE>'
    <TH>'<CODE><A HREF="#correlate" >Correlate</A></CODE>'

<TR valign="top">
<TD>Foreground
    <TD ALIGN=Justify>
        A value of '<CODE>1.0</CODE>'
    <TD ALIGN=Justify>
        A value of '<CODE>1.0</CODE>' (before normalization)

<TR valign="top">
<TD>Don't Care
    <TD ALIGN=Justify>
        A value of '<CODE>Nan</CODE>' or '<CODE>0.5</CODE>'
    <TD ALIGN=Justify>
        A value of '<CODE>Nan</CODE>' or '<CODE>0.0</CODE>'

<TR valign="top">
<TD>Background
    <TD ALIGN=Justify>
        A value of '<CODE>0.0</CODE>'
    <TD ALIGN=Justify>
        A value of '<CODE>-1.0</CODE>' (before normalization)

<TR valign="top">
<TD>Results
    <TD ALIGN=Justify>
        Subtracts the  minimum of the foreground from the maximum of
        background.  Only exact matches will thus produce positive results
        and thresholding will produce a binary matching image.
    <TD ALIGN=Justify>
        Generates a range of how closely the image matches a shape.  It is
        possible for some background pixels to be larger in value than
        foreground pixels as long as the overall pattern is present.  Can be
        difficult to locate specific 'matching' peaks.  You can also find
        negative matches.
</TABLE></P>

As you can see they to correspond to each other. Thus a kernel for one could
be transformed into a kernel for the other. </P>

However  '<CODE><A HREF="../morphology/#hitmiss" >Hit-And-Miss</A></CODE>'
will only find perfect exact matches with a definite foreground to background
difference. As such, it is much less forgiving of noise and near misses than
'<CODE><A HREF="#correlate" >Correlate</A></CODE>'. </P>

On the other hand '<CODE><A HREF="#correlate" >Correlate</A></CODE>' can be
performed using linear image processing and more specifically using a <A
HREF="../fourier/" >Fast Fourier Transform</A>.  This can make pattern
matching with larger patterns and kernels a lot faster, especially when
multiple patterns are involved, saving you the cost of transforming images and
patterns into the frequency domain. It also works with actual images, though
some pre-processing and the use of <A HREF="../basics/#hdri" >HDRI</A> may
also be necessary. </P>

Which you use is really up to you, and what results you are after. Perfect
matches only, or near matches with lots more errors, and the possible use of
a faster algorithm. </P>

Note that for finding exact matches of small color images within larger
images, the <A HREF="../compare/#sub-image" >Sub-Image Locating Feature</A> of
the "<CODE>compare</CODE>" program will provide a much better method than
either  '<CODE><A HREF="../morphology/#hmt" >Hit-And-Miss</A></CODE>' or
'<CODE><A HREF="#correlate" >Correlate</A></CODE>' methods. This is because it
uses a 'least squares of color vector differences' to do the sub-image
matching, which can produce a better metric for match results.  However it is
just as slow, especially for large images. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="neighbours"></A>
<H2>Neighbour Counting</H2>

One of the more unusual things convolution can be put to is known as neighbour
counting.  That is figuring out how many pixels exist in a particular area
surrounding each pixel point in an image. </P>

<A NAME="counting"></A>
<H3>Counting Neighbours</H3>

Basically by using a very simple convolution kernel you can create an image
that contains a count of the number of neighbours surrounding a particular
point in a binary image. </P>

By convolving with a <A HREF="../morphology/#ring" >Ring Kernel</A> of the
size '<CODE>1.5</CODE>' you get a neighbour count. </P>

Here is a count the neighbours of each pixel in a small area, and show the
enlargement of individual pixels before and after (generated using the <A
HREF="../scripts/enlarge_image" >Enlarge Image Script</A>)...

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick area.gif  -define convolve:scale=\! \
          -morphology Convolve Ring:1.5     neighbour.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="area_enlarged.png"
     ><IMG SRC="area_enlarged.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="neighbour_enlarged.png"
     ><IMG SRC="neighbour_enlarged.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>
<!-- <CODE EXECUTE>
  enlarge_image -10.2 area.gif area_enlarged.png
  enlarge_image -10.2 neighbour.gif neighbour_enlarged.png
</CODE> -->

As you can see all the pixels grey-level show how many neighbours they have,
including any <A HREF="../misc/#virtual" >Virtual Pixel</A> neighbours along
the edges.  </P>

If you want to include the current pixel in the count, you can use a <A
HREF="../morphology/#square" >Square Kernel</A> instead. </P>

With appropriate conversions (including level adjustments) and using the <A
HREf="../formats/#pbmplus" >PbmPlus File Format</A>, you can magick the above
grey levels, into actual numbers if that is what you want.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=neighbour.txt>
  magick neighbour.gif +depth +level 0,8 pgm: | pnmnoraw | tail -n +4
</samp></pre></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD>
  <A HREF="neighbour.txt"
     ><IMG SRC="neighbour.txt.gif"
           ALIGN=middle VSPACE=5 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>

</DIV></P>

If you want to exclude pixels that lie inside in the actual shape, you can use
a kernel with a strong negative center pixel and then <A
HREF="../basics/#clamp" >Clamp</A> any negative results (if you are using <A
HREF="../basics/#hdri" >HDRI version of IM</A>). </P>

One simple method to generate just such a kernel of positive 1's surrounding
a large negative center is to negatively scale a standard <A HREF="#laplacian"
>Descrete Laplacian Kernel</A>.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick area.gif  -define convolve:scale=-1\! \
          -morphology Convolve Laplacian:0 -clamp  neigh_edge.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="area_enlarged.png"
     ><IMG SRC="area_enlarged.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="neigh_edge_enlarged.png"
     ><IMG SRC="neigh_edge_enlarged.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>
<!-- <CODE EXECUTE>
  enlarge_image -10.2 neigh_edge.gif neigh_edge_enlarged.png
</CODE> -->

Of course we could have used the original image as a mask to remove the
uninteresting pixels too. </P>


<A NAME="life"></A>
<H3>The Game of Life</H3>

In 1970 a British mathematician, John Horton Conway, publish in Scientific
American, a special simulation which became very popular. It is now known as
<A HREF="http://en.wikipedia.org/wiki/Conway's_Game_of_Life" >Conway's Game of
Life</A>. </P>

It was based on a grid of points where each point was either 'alive', or
'dead'. What 'cells' were then classed as being 'alive' or 'dead' in the next
'generation' depended of a set of very simple rules purely based on the number
living neighbouring cells around them. </P>

<UL>
<LI>The neighbourhood is the 8 pixels surrounding each 'cell'.
<LI>A 'live' cell continues to live if it has 2 or 3 neighbours.
<LI>A 'dead' cell becomes 'live' (born) if it has exactly 3 neighbours.
<LI>Otherwise the cell becomes or remains 'dead'.
</UL>

The results of these rules on binary patterns was remarkable, in that you get
clusters of 'cells' that seem to expand, and shrink, oscillate, or even move
slowly across the grid.  It became a major point of theoretical research, to
see if you could even generate 'DNA' style replication of larger 'life
patterns. ASIDE: It seems it was possible but it was so fragile as to be
impractical, which makes current DNA life so much more remarkable. </P>

It also sparked major interest in the study and implementation of other forms
of <A HREF="http://en.wikipedia.org/wiki/Cellular_automaton" >Cellular
Automation</A>, as a method of generating and studying large effects using
very very simple rules at very small scales. Much like what happens in
chemistry at the atomic and molecular level, but with greater complexity. </P>

So lets implement 'Life' using ImageMagick. </P>

First to make things easy we will make 'live' cells white, and 'dead' cells
black.  That way we are only counting 'white' pixels, surrounding each cell,
in a 8 pixel neighbourhood.  However we could also implemented with black and
white swapped, though it would be harder to follow how it is done. </P>

However the rules has a strong dependency on if the central cell is alive or
dead. So we need to separate the neighbourhood counts for a 'dead' cell from
those of a 'live' cell.  That can be simply done by giving the central cell
a larger value than the sum of all its neighbours.  A value of '10' is good
for this. It is a nice round number that is larger than the maximum
neighbourhood count of 8.  </P>

That makes the 'Game of Life' Convolution kernel equivalent to..

<BLOCKQUOTE>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
    '3: 1,  1,  1    &nbsp;
        1, 10,  1
        1,  1,  1'
</samp></pre></TD></TR></TABLE>
</BLOCKQUOTE></P>

The result of this will be a count of the 8 neighbours around each pixel (is
'white'), plus a value of 10 if the central pixel is 'live' or 'white'.  As
such the value of this kernel will be either '<CODE>0</CODE>' to
'<CODE>8</CODE>' for dead pixels or '<CODE>10</CODE>' to '<CODE>18</CODE>' for
live pixels. </P>

If we scale this kernel by a value of 20 (actually scaling by
'<CODE>0.05</CODE>' to generate a gradient, see below), you will generate an
image with 21 posible grey-levels. That is you will get a 'black' for a value
for the '<CODE>0</CODE>'  grey-level and a white value for the
'<CODE>21</CODE>' grey-level, not that the kernel can actually generate such
a value. </P>

Now we can encode the '<I>Game of Life</I>' rules into an <A
HREF="../color_mods/#clut" >Color Lookup Table Image</A>, so as to magick the
resulting neighbour count 'grey-level', generated by the above kernel, into
the appropriate 'life and death' result according to the 'Life Rules'.</P>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 21x1 xc:black -fill white \
          -draw 'point 3,0  point 12,0  point 13,0' \
          life_clut.gif
  enlarge_image -25.3 -ml 'Life Rules'  life_clut.gif  life_clut_enlarged.png
</samp></pre></TD></TR></TABLE>
  <A HREF="life_clut_enlarged.png"
     ><IMG SRC="life_clut_enlarged.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The image is very small, so I used a <A HREF="../scripts/enlarge_image"
>Enlarge Image Script</A> to generate a larger version to magick display above, with
each pixel clearly separated.  </P>

Basically the first 10 pixels are what to do for a 'dead cell', the next 10
pixels what to do for a 'live cell'. </P>

The first white pixel on the left side (neighbour count = 3 around a dead
cell) is a 'birth', while the two white pixels on the right side (neighbour
counts 2 and 3 next to a live cell) allows an existing 'live cell' to continue
to live.  Any other result leaves the result as black (dead). </P>

The <A HREF="../color_mods/#clut" >Color Lookup Table</A> is 21 pixels long
because I will be dividing by a scaling factor of 20, whice means we could
generate a value in the range from 0 to 20, or 21 distinct gray-scale levels.
We could actually use a different value than 10 for the center (cells previous
state), and 20 for the scaling, but these values are easy numbers to work
with. </P>

In summary, we divide the convolution kernel by 20, and use an CLUT that is
21 pixels long (with <A HREF="../misc/#integer" >Integer Interpolation</A>) to
match convolution results (grey-levels) to the right output color value.  </P>

ASIDE: This 'Life Rules' CLUT, can be regarded as a general Cellular Automata
Rules Table.  The neighbourhood pattern used for neighbour counting is also
part of the cellular automata.  This technique is also outlined in <A
HREF="http://psoup.math.wisc.edu/mcell/ca_rules.html" >Cellular Automata Rules
Lexicon</A>, in the <A
HREF="http://psoup.math.wisc.edu/mcell/rullex_rtab.html" >Rules Tables</A>
section, as a way of defining general 'limit-free' forms of the cellular
automata that it lists. Basically almost any automata can be defined using
such a neighbourhood/table combination, though most are defined using more
simplified forms. </P>

So lets apply this to an image containing a 'life' pattern, multiple times to
see how the pattern changes from one generation to the next, and to check that
it is working as expected.

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><pre class="bg-light text-dark mx-4"><samp>
  magick -size 15x15 xc:black -fill white \
          -draw 'line  3,2 3,4  line 10,10 12,10  point 10,11  point 11,12' \
          life_gen_000.gif
  magick life_gen_000.gif -define convolve:scale=0.05 \
                           -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
          life_clut.gif -interpolate integer -clut \
          life_gen_001.gif
  magick life_gen_001.gif -define convolve:scale=0.05 \
                           -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
          life_clut.gif -interpolate integer -clut \
          life_gen_002.gif
  magick life_gen_002.gif -define convolve:scale=0.05 \
                           -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
          life_clut.gif -interpolate integer -clut \
          life_gen_003.gif
  magick life_gen_003.gif -define convolve:scale=0.05 \
                           -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
          life_clut.gif -interpolate integer -clut \
          life_gen_004.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="life_gen_000.gif"
     ><IMG SRC="life_gen_000_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="life_gen_001.gif"
     ><IMG SRC="life_gen_001_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="life_gen_002.gif"
     ><IMG SRC="life_gen_002_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="life_gen_003.gif"
     ><IMG SRC="life_gen_003_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="life_gen_004.gif"
     ><IMG SRC="life_gen_004_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!-- <CODE EXECUTE NOIMAGE OUT=life_gen_000_mag.gif>
  magick life_gen_*.gif -scale 90x90 \
          -set filename:fname '%t_mag' +adjoin '%[filename:fname].gif'
</CODE> -->

Remember the above images have been enlarged, to see the original 'tiny' image
generated click the enlarged image. </P>

As you can see the 'Life' patterns behave as they should (if you are familar
with the patterns).  The 'blinker' in the top left corner flips back and
forth, while the 'glider' in the bottom moved 1 diagonal step toward it, over
the 4 'generations' we iterated the life rules.  </P>

<A HREF="../images/glider_gun.gif"
   ><IMG SRC="../images/glider_gun.gif"   WIDTH=50 HEIGHT=36
         ALIGN=right VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>

And here is a larger example known as <A
HREF="http://en.wikipedia.org/wiki/Gun_%28cellular_automaton%29" >Gosper's
Glider Gun</A>, where I generate an animation of 60 frames from a special life
pattern. The actual size of the image being used is shown to the right, but
I scale the resulting animation for better viewing. <BR CLEAR=all HEIGHT=1>

<DIV ALIGN=center>
<table class="table table-sm table-hover" CELLSPACING=0 CELLPADDING=5 width="90%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE EXECUTE  SCRIPT IMAGE=glider_gun_anim.gif>
  magick glider_gun.gif life_pattern.gif
  for i in `seq 59`; do
    magick life_pattern.gif -define convolve:scale=0.05 \
            -morphology Convolve '3:1,1,1 1,10,1 1,1,1' \
            life_clut.gif -interpolate integer -clut \
            -write life_pattern.gif  miff:-
  done | magick - -scale 500% \
                 -set delay 10 -layers Optimize -loop 0  glider_gun_anim.gif
  magick glider_gun.gif -scale 500% life_pattern.gif
</samp></pre></TD></TR></TABLE>
  <A HREF="life_pattern.gif"
     ><IMG SRC="life_pattern.gif"   WIDTH=250 HEIGHT=180
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="glider_gun_anim.gif"
     ><IMG SRC="glider_gun_anim.gif"  WIDTH=250 HEIGHT=180
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the reason the glider 'explodes' on the bottom edge is because of
the default '<A HREF="../misc/#virtual" >Virtual Pixel</A>' handling that
convolve uses, and the loss of the life information as it goes beyond the
bounds of the image. </P>

More life pattern images can be found in the <A
HREF="http://www.radicaleye.com/lifepage/patterns/contents.html" >Life Pattern
Catalog</A>, though you will need to recolor (negate) the images for use in
the above life processor. </P>

I'll leave it as an exercise for someone to put the above into a script, that
can generate a life sequence for some particular input image. </P>

<BR>

This is just one example of whole range of '<I>Cellular Automata</I>' that IM
could process.  Of course their are many faster dedicated programs for 'Life'
and 'Cellular Automata', which generally do exactly the same thing, but
I wanted to show that IM is flexiable enough to do it as well. </P>

As the results are simple binary images, you can also use IM's <A
HREF="../morphology/#morphology" >Morphology</A> methods such as <A
HREF="../morphology/#hmt" >Hit and Miss Pattern Searching</A> or <A
HREF="#correlate_search" >Cross-Correlation</A>  to search for specific life
patterns, making using IM for life reseach more practical, if slow. </P>

<HR><!-- ---------------------------------------------------------------- -->
</div></main><footer class="magick-footer"><div class="container-fluid">
Created: 26 May 2010 (Separated from "morphology") <BR>
Updated: 26 March 2013 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Major Input:
        <A HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred Weinhaus</A>,
        &lt;fmw at alink dot net&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://imagemagick.org/Usage/convolve/</CODE>
</div></footer></body></HTML>
