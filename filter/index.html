<HTML><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" >
<link rel="stylesheet" href="../assets/usage.css">
<TITLE>Resampling Filters -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/filter/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Resampling Filters</H1>

<DIV ALIGN=justify>

<B>Index</B><BR>
<TABLE CELLSPACING=0>
<TR VALIGN=top><TD COLSPAN=2>
<A HREF="../"
   ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
   > ImageMagick Examples Preface and Index</A>
</TD></TR>
<TR VALIGN=bottom><TD><DL>

<DD><A HREF="#artifacts"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Resampling Artefacts </A> - How good is Resize?
    <DL><DD><FONT SIZE=-1>
        <A HREF="#blocking" >Blocking</A>,&nbsp;
        <A HREF="#ringing"  >Ringing</A>,&nbsp;
        <A HREF="#aliasing" >Aliasing</A>,&nbsp;
        <A HREF="#blurring" >Blurring</A>
    </FONT></DD></DL>
    <UL>
    <LI><A HREF="#photoshop"
        > ImageMagick Resize VS Photoshop Resize</A>
    </UL>
&nbsp;

<DD><A HREF="#filter"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Resampling Filters</A>
    <UL>
    <LI><A HREF="#interpolated" >Interpolated Filters</A>
        <DL><DD><FONT SIZE=-1> <A HREF="#point"             >Point</A>,&nbsp;
            <A HREF="#box"               >Box</A>,&nbsp; <A HREF="#triangle"
            >Triangle</A>,&nbsp; <BR><A HREF="#interpolate_other" >Other
            Interpolation Filters</A> <BR><A HREF="#hermite"
            >Hermite</A>,&nbsp; <A HREF="#lagrange-i"
            >Lagrange</A>,&nbsp; <A HREF="#catrom-i"          >Catrom</A>
            </FONT></DD></DL>
    <LI><A HREF="#gaussian" >Gaussian Blurring Filter</A>
        <UL>
        <LI><A HREF="#gaussian"       >Gaussian</A>,&nbsp;
        <LI><A HREF="#sigma"   >Sigma Expert Control</A>
        <LI><A HREF="#gaussian_other" >Other Gaussian-like Filters</A>
            <DL><DD><FONT SIZE=-1> <A HREF="#quadratic"
                >Quadratic</A>,&nbsp; <A HREF="#spline"         >Spline</A>
                </FONT></DD></DL>
        </UL>
    <LI><A HREF="#support" >Filter Support Expert Control</A>
    <LI><A HREF="#blur" >Filter Blur Expert Control</A>
    <LI><A HREF="#gaussian_interpolator" >Gaussian Interpolator Filter</A>
    <LI><A HREF="#windowed" >Windowed Sinc Filters</A>
        <UL>
        <LI><A HREF="#window_how" >How Windowing Filters Work</A>
        <LI><A HREF="#windowing" >The Various Windowing Filters</A>
            <DL><DD><FONT SIZE=-1>
                <A HREF="#sinc"     >Sinc</A>,&nbsp;
                <A HREF="#hann"     >Hann</A>,&nbsp;
                <A HREF="#hamming"  >Hamming</A>,&nbsp;
                <A HREF="#blackman" >Blackman</A>,&nbsp;
                <A HREF="#bohman"   >Bohman</A>,&nbsp;
            <BR><A HREF="#kaiser"   >Kaiser</A>,&nbsp;
                <A HREF="#bartlett" >Bartlett</A>,&nbsp;
                <A HREF="#parzen"   >Parzen</A>,&nbsp;
                <A HREF="#cosine"   >Cosine</A>,&nbsp;
                <A HREF="#welch"    >Welch</A>
            </FONT></DD></DL>
        <LI><A HREF="#lanczos" >Lanczos Filter</A>
        <LI><A HREF="#lobes" >Windowing Support Size in Lobes</A>
        </UL>
    </UL>
</DL></TD><TD><DL>

<DT><! HREF="#filter"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Resampling Filters (Cont)</A>
    <UL>
    <LI><A HREF="#lagrange" >Lagrange Filter</A>
    <LI><A HREF="#cubics" >Cubic Filters</A>
        <DL><DD><FONT SIZE=-1> <A HREF="#spline-c"       >Spline</A>,&nbsp; <A
            HREF="#catrom-c"       >Catrom</A>,&nbsp; <A HREF="#hermite-c"
            >Hermite</A>,&nbsp; <A HREF="#mitchell"       >Mitchell</A>
            </FONT></DD></DL>
        <UL>
        <LI><A HREF="#cubic_bc"       >Cubic BC Settings</A>
        </UL>
    <LI><A HREF="#cylindrical" >Cylindrical Filters</A> -- Filters for Distort
        <UL>
        <LI><A HREF="#cyl_interpolated" >Interpolated Cylindrical Filters</A>
        <LI><A HREF="#cyl_gaussian"     >Cylindrical Gaussian</A>
        <LI><A HREF="#jinc"             >Jinc Windowed Filters</A>
        <LI><A HREF="#distort_noop"     >Distort and the No-Op case</A>
            <DL><DD><FONT SIZE=-1>
                <A HREF="#lanczos_cylindrical" >Cylindrical Lanczos</A>,&nbsp;
                <A HREF="#lanczos2"            >Lanczos2</A>,&nbsp;
            <BR><A HREF="#lanczos_sharp"       >LanczosSharp</A>,&nbsp;
                <A HREF="#lanczos2sharp"       >Lanczos2Sharp</A>,&nbsp;
                <A HREF="#lanczos_radius"      >LanczosRadius</A>,&nbsp;
            <BR><A HREF="#robidoux"            >Robidoux</A>,&nbsp;
                <A HREF="#robidoux_sharp"      >Robidoux Sharp</A>
                <A HREF="#robidoux_soft"      >Robidoux Soft</A>
            </FONT></DD></DL>
        <LI><A HREF="#cyl_summary"      >Cylindrical Filters Summary</A>
        </UL>
    <LI><A HREF="#options" >Expert Filter Controls</a>
    <LI><A HREF="#summery" >Summary of Resize filters</A>
        <UL>
        <LI><A HREF="#compare" >Filter Comparison</A>
        <LI><A HREF="#best_filter" >Best Filter</A>?
        <LI><A HREF="#default_filter" >IM's Default Filter</A>
        </UL>
    </UL>
&nbsp;
<DT><A HREF="nicolas/"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Resampling by Nicolas Robidoux</A> (sub-section)
</DL>
</TD></TR></TABLE></P>

Here we get in to the lower level aspects of Resize and Distortion
of images, looking at the resampling filters that is used to determine
the final color of each individual pixel in the resulting image. </P>

This is extensive, long studied, and often full of opinion and personal
views rather than any hard qualitive facts, as it is imposible to determine
what constitutes a perfect resize image.  This is a proven fact, and makes for
a very large area of study that will never be finished. </P>

It is recommended you read and understand the <A HREF="../resize/" >Resize and
Scaling Operators</A>.

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="artifacts"></A>
<H2>Resampling Artefacts
<FONT SIZE=-1> - How good is IM Resize </FONT></H2>

Image resizing has to combat a very difficult problem.   How do you reduce an
array of values, into a smaller, or larger array of values so that it look
good to our eyes.  A lot of things can go wrong while attempting to do this,
but they fall into four basic categories..

<A NAME="blocking"></A>
<H3>Blocking</H3>

Essentially, if you enlarge an image simply by replicating pixels, you will
create larger rectangular blocks of pixels. In fact magnifying images using
either "<CODE><A HREF="../option_link.cgi?scale" >-scale</A></CODE>" or
"<CODE><A HREF="../option_link.cgi?sample" >-sample</A></CODE>" does exactly
that, producing an enlarged pixelated image. </p>

For example here I scale a small image, generating large blocks of color
rather that a nice smooth image.  Next to that is a 'resized' version, and
finally one using a Gaussian filter to blur it more than normal and replace
isolated pixels with round dots, to remove some of the blockiness.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert storm.gif  -scale  300%  storm_scaled.gif
  convert storm.gif  -resize 300%  storm_resized.gif
  convert storm.gif -filter Gaussian -resize 300%  storm_resized_gas.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
<TABLE><TR VALIGN=center><TD ALIGN=center>
  <A HREF="../images/storm.gif"
     ><IMG SRC="../images/storm.gif"                WIDTH=32  HEIGHT=32
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Original
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="storm_scaled.gif"
     ><IMG SRC="storm_scaled.gif"         WIDTH=96  HEIGHT=96
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Scaled
</TD><TD ALIGN=center>
  <A HREF="storm_resized.gif"
     ><IMG SRC="storm_resized.gif"         WIDTH=96  HEIGHT=96
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Resized
</TD><TD ALIGN=center>
  <A HREF="storm_resized_gas.gif"
     ><IMG SRC="storm_resized_gas.gif"         WIDTH=96  HEIGHT=96
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Gaussian Resized
</TD></TR></TABLE>
</NOBR></DIV></P>

The primary cause of 'blocking' is either badly anti-aliased source image, or
not enough smoothing (color mixing or blurring) between pixels to improve the
overall look of an image. </P>

It is also typically seen when a very low resolution image is being resized to
a much larger scale or for use on a high resolution device.  The most common
place this is seen is in the use of a bitmap image in user generated
newsletters and magazines that were then printed on very high resolution laser
printers. The newsletter looks great on screen, but comes out 'blocky' on the
printed page. </P>

This situation is very hard to fix, and generally best avoided, by using a
much higher resolution clipart, or using a scalable vector image (such as
SVG, and WMF format images).  </P>

Of course in some situations, blocking artifacts is actually desirable, and
enhanced in the results.  For example when you are trying to recreate some old
low-resolution video games on newer high resolution displays, keeping the old
'blockiness' of the image enhances the 'retro' look.  Or perhaps when you are
trying to rotate images, without generating and new, or merged colors. </P>

Techniques for actually preserving the 'blockiness', but filling in the
squares with diagonal lines, is known as <A
HREF="http://www.wikipedia.org/wiki/Pixel_art_scaling_algorithms" >Pixel Art
Scaling Algorithms</A>, and many such schemes have been developed.  On scheme
has been built into ImageMagick, with the <A HREF="../resize/#magnify"
>Magnify</A> operator.</P>


<A NAME="ringing"></A>
<H3>Ringing</H3>

Ringing is an effect you often see in very low quality JPEG images
close to sharp edges. It is typically caused by an edge being
over compensated for by the resize or image compression algorithm, or a
high quality filter being used with a bad support size. </P>

Here for example I use a special option to select a raw Sinc filter, on
an very sharp color change.  I also repeated the operation using IM's
default resize operator, with its default filter selection for image
enlargements.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 8x16 xc:'#444' xc:'#AAA' +append  gray_edge.gif
  convert gray_edge.gif -filter Sinc \
                         -resize 100x100\!  gray_edge_ringing.gif
  convert gray_edge.gif  -resize 100x100\!  gray_edge_resize.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="gray_edge.gif"
     ><IMG SRC="gray_edge.gif"                WIDTH=16  HEIGHT=16
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="gray_edge_ringing.gif"
     ><IMG SRC="gray_edge_ringing.gif"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gray_edge_resize.gif"
     ><IMG SRC="gray_edge_resize.gif"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV>

The above shows quite clearly the over compensation produced by the use of
a raw resize filter, without any of the optimization IM provides. The
second image, produced by the default IM enlargement filter also shows a
very slight ringing effect, but it is barely noticeable, and actually
desirable in that it perceptually sharpens the border. </P>

Here is another example of the ringing effect, this time by enlarging a
single pixel, on a gray background.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x1 xc: -bordercolor '#444' -border 4x4 \
          -define filter:lobes=5  -filter Sinc \
          -resize 100x100\!   dot_sinc.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="dot_sinc.gif"
     ><IMG SRC="dot_sinc.gif"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This image also clearly shows the secondary effects generated by the use
of an one dimensional filter.  That is, the ringing effect is strongest in
horizontal, and vertical (orthogonal) direction, with 45 degree secondary
ringing. </P>

And this time with a cylindrical filter (via the <A HREF="../distorts/#resize"
>Distort Resize Operation</A>), showing how it differs from the more normal
2 pass orthogonally aligned (tensor) filter which the <A
HREF="../resize/#resize" >Resize Operator</A> uses.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x1 xc: -bordercolor '#444' -border 4x4 \
          -define filter:lobes=5  -filter Jinc \
          -distort resize 100x100\! +repage dot_jinc.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="dot_jinc.gif"
     ><IMG SRC="dot_jinc.gif"     WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

These effects are not normally visible, and only seen here because of the use
of the use of a raw '<CODE>Sinc</CODE>' or '<CODE>Jinc</CODE>' filter (see <A
HREF="#windowed" >Windowed Filters</A> below) for some extreme enlargements.
Typically a 'raw' filter like this is not used.  </P>


<A NAME="aliasing"></A>
<H3>Aliasing and Moir&eacute; Effects</H3>

Aliasing effects are generally seen as the production of 'staircase' like
effects along edges of images. Often this is caused either by raw sampling of
the image such as using "<CODE><A HREF="../option_link.cgi?sample"
>-sample</A></CODE>", or overly sharpening of the image during resizing.  A
staircasing effect is most noticeable in strong minification of images, though
is rarely seen in IM. </P>

However, aliasing also has other effects, in particular large scale
Moir&eacute; patterns appearing in images containing some type of pixel level
pattern.  These low level patterns often produce large scale Moir&eacute;
patterns, including: patterns of parallel lines,  cloth weaves (silk exhibits
this effect in real life!), as well as brick and tile patterns in photos of
brick buildings, fences, and paving.  </P>

<A HREF="../img_photos/rings_sm_orig.gif"
 ><IMG SRC="../img_photos/rings_sm_orig.gif"         WIDTH=200  HEIGHT=200
       ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

For some examples of resized images producing strong Moir&eacute; effects see
the <A HREF="http://en.wikipedia.org/wiki/Moir%C3%A9_pattern" >Wikipedia,
Moir&eacute; Pattern</A> Page. </P>

The classic way of checking if a resize will produce aliasing problems, is by
minifying a <A HREF="../img_photos/rings_sm_orig.gif" >Rings Image</A> (see right).  This
image will often show Moir&eacute; effects when any form of resize is applied
at any scale.  Web browsers in particular show such Moir&eacute; effects when
displaying such an image due to the use of an ultra fast (but often poor)
resizing technique.  </P>

<BR CLEAR=all>

Here I show the 'rings' image resized using the strongly aliasing "<CODE><A
HREF="../option_link.cgi?sample" >-sample</A></CODE>" operator, the block
averaging "<CODE><A HREF="../option_link.cgi?scale" >-scale</A></CODE>"
operator  and the normal default "<CODE><A HREF="../option_link.cgi?resize"
>-resize</A></CODE>".

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rings_sm_orig.gif  -sample 100x100  rings_sample.png
  convert rings_sm_orig.gif  -scale  100x100  rings_scale.png
  convert rings_sm_orig.gif  -resize 100x100  rings_resize.png
</CODE></PRE></TD></TR></TABLE>
<TABLE WIDTH=80%><TR><TD ALIGN=center>
  <A HREF="rings_sample.png"
     ><IMG SRC="rings_sample.png"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>sample
</TD><TD ALIGN=center>
  <A HREF="rings_scale.png"
     ><IMG SRC="rings_scale.png"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>scale
</TD><TD ALIGN=center>
  <A HREF="rings_resize.png"
     ><IMG SRC="rings_resize.png"         WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>resize
</TD></TR></TABLE></DIV></P>

As you can see all the resize methods did produce some Moir&eacute;
effects, though IM's default resize operator produces the least amount of
this undesirable secondary patterns in the final image. </P>

To show the effects of only a slight resize, I cropped the corner from the
<A HREF="../img_photos/rings_lg_orig.png" >Large Rings Image</A>, the result of which is
shown first, and then reduced its size by just 5%.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rings_lg_orig.png -crop 105x105+0+0  rings_crop.png
  convert rings_crop.png    -sample 100x100    rings_crop_sample.png
  convert rings_crop.png    -scale  100x100    rings_crop_scale.png
  convert rings_crop.png    -resize 100x100    rings_crop_resize.png
</CODE></PRE></TD></TR></TABLE>
<TABLE WIDTH=80%><TR VALIGN=top><TD ALIGN=center>
  <A HREF="rings_crop.png"
     ><IMG SRC="rings_crop.png"   WIDTH=105 HEIGHT=105
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>cropped original
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=40 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="rings_crop_sample.png"
     ><IMG SRC="rings_crop_sample.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>sample
</TD><TD ALIGN=center>
  <A HREF="rings_crop_scale.png"
     ><IMG SRC="rings_crop_scale.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>scale
</TD><TD ALIGN=center>
  <A HREF="rings_crop_resize.png"
     ><IMG SRC="rings_crop_resize.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>resize
</TD></TR></TABLE></DIV></P>

As you can see even a slight resize will show up any aliasing a resize
operator may have. In fact if you look closely you may even seen a very light
Moir&eacute; effect in the original unscaled crop of the original starting
image, which is produced from the limitations of only using a raster image at
a density suitable for display on a computer screen.  That is how sensitive
this test image is in showing aliasing effects caused by shrinking images.
</P>

<A NAME="blurring"></A>
<H3>Blurring</H3>

Most people are familiar with blurring that can be generated by the use of
"<CODE><A HREF="../option_link.cgi?resize" >-resize</A></CODE>".  In fact
this is probably the number one complaint about any resize image, and with
good reason. Usually a very small resize will tend to produce a blurred
image, and resizing it again will only make it worse. </P>

The problem is that when you resize an image you are changing the image stored
as a 'grid' or array of pixels (known as a 'raster') to fit a completely
different 'grid' of pixels.  The two 'grids' will not match except in very
special cases, and as a result, the image data has to be modified to make it
fit this new pattern of dots.  Basically it is impossible to directly resize
an image and expect it to come out nicely, though a reasonable result can be
achieved. </P>

The result is an usually a slight blurring of the pixel data.  The better
the resize algorithm, the less blurring of sharp edges there is. </P>

However some resize filters, especially ones designed specifically for
enlarging images, often add a lot more blurring than necessary. This is to
combat '<A HREF="#blocking" >Blocking</A>' artifacts as demonstrated above.
</P>

For image minification a blurred edge is often used to avoid '<A
HREF="#ringing" >Ringing</A>' artifacts at sharp edges and reduce possible <A
HREF="#aliasing" >Aliasing</A> effects. This however is a poor man's
compromise and one that IM tries hard to avoid. </P>

Even so, a special expert <A HREF="../filter/#blur" >Filter Blur</A>
setting can be used to adjust the blurring that a filter provides. However be
warned that while a number smaller than 1.0 is supposed to reduce blurring, it
can also make it worse, depending on the exact filter and the resize ratios
that are being used.  No guarantees can be given. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.3.6-3 the <A HREF="../filter/#blur" >Filter Blur</A>
  setting was called "<CODE><A HREF="../option_link.cgi?support"
  >-support</A></CODE>", which was very misleading in exactly what it did.
  This option has been depreciated and is no longer available.
</I></FONT></TD></TR></TABLE></P>

The better method of fixing bluring effects cause by resize is to re-filter
the image using a sharpening operator.  See <A
HREF="../resize/#resize_unsharp" >Sharpen Resized Images</A> for more
details. </P>

<A NAME="photoshop"></A>
<H3>IM Resize vs other Programs</H3>

A practical comparison of IM's default resize operator to a number of other
programs in resizing a real-world image has been provided by, Bart van der
Wolf at...

<DIV ALIGN=center><A HREF="http://www.bvdwolf.nl/foto/resample/example1.html"
>Down-sampling Example</A></DIV></P>

Specifically, in summary for IM resize...
<BLOCKQUOTE><B><I>Although the amount of sharpening is a matter of taste, the
lack of aliasing artifacts produces the cleanest, most natural looking image
of them all.</I></B></BLOCKQUOTE></P>

He also goes on to look at a 'rings' test, to directly compare various
Photoshop resize methods against ImageMagick...

<DIV ALIGN=center><A HREF="http://www.bvdwolf.nl/foto/resample/down_sample.html"
>Down-sampling Methods</A></DIV></P>

These articles shows just how important doing resize correctly (and using the
right filtering methods) is to image processing. We look this at more closely
in the next section. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="filter"></A>
<H2>Resampling Filters</H2>

The "<CODE><A HREF="../option_link.cgi?filter" >-filter</A></CODE>" setting is
the key control on how "<CODE><A HREF="../resize/#resize" >Image
Resizing</A></CODE>" as well as "<CODE><A HREF="../distorts/#distort" >General
Distort Operator</A></CODE>", works to produce a clean result with the minimum
of <A HREF="#artifacts" >Resampling Artefacts</A>. </P>

This has been a topic of intense study during the late 1980's, and from which
<A HREF="http://www.cs.cmu.edu/~ph/" >Paul Heckbert</A>, a major researcher in
this field, produced and publicly released his "<CODE><FONT SIZE=+1><B><A
HREF="http://www.xmission.com/~legalize/zoom.html"
>zoom</A></B></FONT></CODE>" image resizing program.  This program became the
father of most image resizing programs used today, though many later programs
implement it poorly, as it is easy to get it wrong. For example have a look at
the results of testing <A
HREF="http://entropymine.com/resamplescope/notes/browsers/" >How web browsers
resize images</A>. </P>

In many ways, these filters are closely related to <A
HREF="../convolve/#intro" >Convolving Images</A>, and even the <A
HREF="../convolve/#blur" >Blurring Kernel</A>. They even suffer from the
similar problems. However filters are designed to improve the look of the
final result when resizing, or otherwise distorting an image. </P>

The names of the filters are a veritable "who's who" of image processing
experts and mathematicians of the past century (or more). They are usually not
a description of the filter, but just a label of the person who either first
published the filter (or filter family), or did the most research into that
filter.  This however makes it much harder to know whether
a '<CODE>Lagrange</CODE>' filter (named after Joseph-Louis Lagrange) is better
than, say, a '<CODE>Catrom</CODE>' filter (named after Edwin Catmull and
Raphael Rom).  </P>

Here I will explain the major aspects of Filters.  It is not vital that you
learn these things, but I decided to document a summary of what I learnt,
after completing research in this area, as part of a major overhaul and
expansion of the IM resize filter system, (IM 6.3.7-1). </P>

Special thanks goes to  <A HREF="http://www.fmwconcepts.com/fmw/fmw.html"
>Fred Weinhaus</A> for his help in the research during the re-development of
the Resize Filters.  He was especially eager for the addition of the '<CODE><A
HREF="#lagrange" >Lagrange</A></CODE>' family of filters, which did not exist
in IM resize before this overhaul. </P>

Also thanks goes to <A
HREF="http://ca.linkedin.com/pub/nicolas-robidoux/40/3ab/b73" >Nicolas
Robidoux</A>, who's mathematics helped solve a major fault in the <A
HREF="../distorts/#distort" >General Distort Operator</A>, and then develop <A
HREF="#cylindrical" >Cylindrical Filters</A>, that produce better
results that what you get with the <A HREF="../resize/#resize" >Resize Operator</A>.
</P>


<H3>How filters work</H3>

When resizing an image you are basically trying to determine the correct value
of each pixel in the new image, based on the pixels in the original source
image.  However these new pixels do not match exactly to the positions of the
old pixels, and so a correct value for these pixels needs to be determined
in some way. </P>

What is done is to try to use some type of weighted average of the original
source pixel values to determine a good value for the new pixel.

The real pixels surrounding the location of the new pixel forms
a 'neighbourhood' of contributing values.  The larger this neighbourhood is
the slower the resize.  This is a technique called <A
HREF="../convolve/#intro" >Convolution</A>.  </P>

The amount each real neighbouring pixel (known as a 'sample') contributes to
produce the final pixel is determined by a weighting function. This is the
'<I>filter</I>' that you can select using the "<CODE><A
HREF="../option_link.cgi?filter" >-filter</A></CODE>" setting.  That filter in
turn generally has an ideal neighbourhood size, which is known as the filter's
'<I>support</I>', though it is also known as its '<I>window</I>'.  A
pre-defined two dimensional '<I>filter</I>' is also known as a '<I>convolution
kernel</I>'.  </P>

<PRE><I>FUTURE: some diagrams may be helpful here</I></PRE>

The design of these weighting functions, or 'filters' is a very complex
business involving some complex mathematics, frequency analysis, and even
Fourier Transforms.  A good starting point if you are interested in this is <A
HREF="http://en.wikipedia.org/wiki/Nyquist-Shannon_sampling_theorem#Application_to_multivariable_signals_and_images"
>Wikipedia: Nyquistâ€“Shannon sampling theorem</A>.  However, you really don't
need to go that far to understand existing filters and their effects on
images. </P>

<H3>The Filters</H3>

<A NAME="interpolated"></A>
<H3>Interpolated Filters</H3>

The simplest type of resize filter functions are <B>Interpolative</B> methods.
These take a specific pixel location in the source image and try to simply
determine a logical color value of the image at that location based on
the colors of the surrounding pixels. </P>

As there is only ever a fixed and minimal number of pixels involved, this type
of filter is a very fast method of resizing or otherwise distorting images.
However, this is also the filter's downfall, as it will not merge a larger
number of pixels together to form an image that is greatly smaller than the
original image.  That in turn can result in strong <A HREF="#aliasing"
>Aliasing and Moir&eacute; Effects</A>. </P>

Interpolation is usually only used for 'point' sampling images, when image
scaling is either not known or needed.  For example, when rotating image or
minor distortions, the image's scaling or size does not change, and as such an
interpolation can produce a reasonable result, though not a very accurate one.
For more information see IM's <A HREF="../misc/#interpolate" >Interpolation
Setting</A>. </P>

It is not however suitable for general image resizing. </P>


<A NAME="point"></A>
<H4>Point</H4>

Using a "<CODE><A HREF="../option_link.cgi?filter" >-filter</A></CODE>"
setting of '<CODE><B>Point</B></CODE>' basically means to use an unscaled
interpolation filter.  For the <A HREF="../resize/#resize" >Resize
Operator</A>, it will just select the closest pixel to the new pixels
position, and that is all.  </P>

This means that the <A HREF="../resize/#resize" >Resize Operator</A> will
simply use the color of an actual pixel in the source image will be used.  No
attempt will be made to merge colors or generate a better color for the
resulting image. As a result using <NOBR>"<CODE>-filter point -resize
...</CODE>"</NOBR> will produce the same result as "<CODE><A
HREF="../option_link.cgi?sample" >-sample</A></CODE>" (see <A
HREF="../resize/#sample" >Sampling Operator</A>), though the latter is
faster as it code is specifically designed to resizing images by point
sampling, with controls to tune the exact sampling point. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  For the <A HREF="../distorts/#distort" >Distort Operator</A> selecting
  "<CODE><A HREF="../option_link.cgi?filter" >-filter</A> Point</CODE>", will
  force the use of <A HREF="../misc/#interpolate" >Interpolated Point
  Sampling</A> instead of a <A HREF="#cylindrical"> Cylindrical
  Filter</A>.   See <A HREF="../distorts/#distort_filter" >Image Filters in
  the Distort Operator</A> for more detail.  </P>

  If you desire the same <A HREF="../misc/#interpolate" >Interpolated Point
  Sampling</A> for normal image resize you can use the <A
  HREF="../resize/#interpolative-resize" >Interpolative Resize</A> operator
  instead. Or use point filtered <A HREF="../distorts/#resize" >Distort
  Resize</A> for the same result. </P>

</I></FONT></TD></TR></TABLE></P>

Here I start with a 10x10 pixel hash pattern and reduce it in size, before
scaling so that you can see the result.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 10x10 pattern:gray50  checks_10.gif
  convert checks_10.gif -filter point -resize 9x9  checks_point-1.gif
  convert checks_10.gif -filter point -resize 8x8  checks_point-2.gif
  convert checks_10.gif -filter point -resize 7x7  checks_point-3.gif
  convert checks_10.gif -filter point -resize 6x6  checks_point-4.gif
  convert checks_10.gif -filter point -resize 5x5  checks_point-5.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=bottom><TD ALIGN=center>
  <A HREF="checks_10.gif"
     ><IMG SRC="checks_10_mag.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>&nbsp;
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=50 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="checks_point-1.gif"
     ><IMG SRC="checks_point-1_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Point-1
</TD><TD ALIGN=center>
  <A HREF="checks_point-2.gif"
     ><IMG SRC="checks_point-2_mag.gif"   WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Point-2
</TD><TD ALIGN=center>
  <A HREF="checks_point-3.gif"
     ><IMG SRC="checks_point-3_mag.gif"   WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Point-3
</TD><TD ALIGN=center>
  <A HREF="checks_point-4.gif"
     ><IMG SRC="checks_point-4_mag.gif"   WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Point-4
</TD><TD ALIGN=center>
  <A HREF="checks_point-5.gif"
     ><IMG SRC="checks_point-5_mag.gif"   WIDTH=50 HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Point 50%
</TD></TR></TABLE></DIV></P>
<!-- <CODE EXECUTE SCRIPT>
  convert checks_10.gif -scale 1000% checks_10_mag.gif
  convert checks_point-1.gif -scale 1000% checks_point-1_mag.gif
  convert checks_point-2.gif -scale 1000% checks_point-2_mag.gif
  convert checks_point-3.gif -scale 1000% checks_point-3_mag.gif
  convert checks_point-4.gif -scale 1000% checks_point-4_mag.gif
  convert checks_point-5.gif -scale 1000% checks_point-5_mag.gif
</CODE> -->

All that is really happening is that single rows and columns of pixels are
removed across the image.  Even at this level, you will get extreme <A
HREF="#blocking" >blocking</A> and <A HREF="#aliasing" >aliasing</A> in the
resulting image, and can in specific cases like the above produce a completely
unrealistic result. </P>

As such, a '<CODE>Point</CODE>' filter, or the faster equivelent <A
HREF="#sample" >Sampling Operator</A>, is not recommended for normal image
resizing.  </P>


<A NAME="box"></A>
<H4>Box</H4>

The '<CODE><B>Box</B></CODE>' filter setting is exactly the same as
'<CODE>point</CODE>' with one slight variation.  When shrinking images it will
average, and merge the pixels together. The smaller the resulting image the
more pixels will be averaged together. </P>

<A HREF="graph_filter_box.jpg"
   ><IMG SRC="graph_filter_box.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

Here is a graph of the filter's weighting function, from which you can see why
it is called a '<CODE>Box</CODE>' filter. </P>

Basically any pixel that falls inside the 'Box' will be directly used to
calculate the color of the new pixel.   Now as the filter is only 1/2 a pixel
wide, and that means for an image that is not actually being resized, only one
pixel the closest pixel, will be used.  In other words when no scaling is
involved (or only magnification) the nearest pixel to the new location will
form the color of the new pixel.  </P>

However if an image is being made smaller, more of the source image will be
compressed into the bounds of that 'box'.  The result is that more pixels will
be averaged together to produce the color for the pixel in the smaller image.
</P>

For example here is an enlarged view of a checkerboard pixel pattern
as it is being slowly compressed using a '<CODE>Box</CODE>' filter.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks_10.gif -filter box -resize 9x9  checks_box-1.gif
  convert checks_10.gif -filter box -resize 8x8  checks_box-2.gif
  convert checks_10.gif -filter box -resize 7x7  checks_box-3.gif
  convert checks_10.gif -filter box -resize 6x6  checks_box-4.gif
  convert checks_10.gif -filter box -resize 5x5  checks_box-5.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=bottom><TD ALIGN=center>
  <A HREF="checks_10.gif"
     ><IMG SRC="checks_10_mag.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>&nbsp;
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=50 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="checks_box-1.gif"
     ><IMG SRC="checks_box-1_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box-1
</TD><TD ALIGN=center>
  <A HREF="checks_box-2.gif"
     ><IMG SRC="checks_box-2_mag.gif"   WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box-2
</TD><TD ALIGN=center>
  <A HREF="checks_box-3.gif"
     ><IMG SRC="checks_box-3_mag.gif"   WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box-3
</TD><TD ALIGN=center>
  <A HREF="checks_box-4.gif"
     ><IMG SRC="checks_box-4_mag.gif"   WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box-4
</TD><TD ALIGN=center>
  <A HREF="checks_box-5.gif"
     ><IMG SRC="checks_box-5_mag.gif"   WIDTH=50 HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box 50%
</TD></TR></TABLE></DIV></P>
<!-- <CODE EXECUTE SCRIPT>
  convert checks_box-1.gif -scale 1000% checks_box-1_mag.gif
  convert checks_box-2.gif -scale 1000% checks_box-2_mag.gif
  convert checks_box-3.gif -scale 1000% checks_box-3_mag.gif
  convert checks_box-4.gif -scale 1000% checks_box-4_mag.gif
  convert checks_box-5.gif -scale 1000% checks_box-5_mag.gif
</CODE> -->

As you can see, more and more pixels become merged together as the image is
resized smaller using a '<CODE>Box</CODE>' filter, but that the merger occurs
in specific, equally spaced, rows and columns.  This causes all sorts of
artifacts and Moir&eacute; or <A HREF="#aliasing" >Aliasing</A> effects when
both shrinking images and enlarging. </P>

It is recommended that '<CODE>Box</CODE>' filtering be used for 'binning'
images.  That is, reducing images by integer multiples to ensure that every
pixel in the result is an average of the same number of neighbouring pixels
(the 'bin').  The resulting image will thus remain clean looking, just as in
the final image above. </P>

It is also recommended that much faster the <A HREF="../resize/#scale" >Scale
Operator</A> is used instead of the 'Box Filter'.  It will produce almost
identical results, except in a special case of reducing images by just a few
pixels. When 'binning' it will produce identical results. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The <A HREF="../resize/#scale" >Scale Operator</A> is not exactly the same
  as a 'Box Filter', as it is implemented using a special 'Pixel Mixing'
  algorithm.  For exact details see <A HREF="../resize/#pixel_mixing" >Scale
  Internals</A>.

</I></FONT></TD></TR></TABLE></P>

When enlarging both '<CODE>Point</CODE>' and '<CODE>Box</CODE>' filters will
produce the same 'pixel replication' of rows and columns, as they all result
in using a simple 'nearest-neighbour' selection.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 5x5 pattern:gray50  checks_5.gif
  convert checks_5.gif -filter box   -resize 6x6    checks_box+1.gif
  convert checks_5.gif -filter box   -resize 7x7    checks_box+2.gif
  convert checks_5.gif -filter box   -resize 8x8    checks_box+3.gif
  convert checks_5.gif -filter box   -resize 9x9    checks_box+4.gif
  convert checks_5.gif -filter box   -resize 10x10  checks_box+5.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=bottom><TD ALIGN=center>
  <A HREF="checks_5.gif"
     ><IMG SRC="checks_5_mag.gif"      WIDTH=50 HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>&nbsp;
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=50 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="checks_box+1.gif"
     ><IMG SRC="checks_box+1_mag.gif"   WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box+1
</TD><TD ALIGN=center>
  <A HREF="checks_box+2.gif"
     ><IMG SRC="checks_box+2_mag.gif"   WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box+2
</TD><TD ALIGN=center>
  <A HREF="checks_box+3.gif"
     ><IMG SRC="checks_box+3_mag.gif"   WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box+3
</TD><TD ALIGN=center>
  <A HREF="checks_box+4.gif"
     ><IMG SRC="checks_box+4_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box+4
</TD><TD ALIGN=center>
  <A HREF="checks_box+5.gif"
     ><IMG SRC="checks_box+5_mag.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Box+5
</TD></TR></TABLE></DIV></P>
<!-- <CODE EXECUTE SCRIPT>
  convert checks_5.gif -scale 1000% checks_5_mag.gif
  convert checks_box+1.gif -scale 1000% checks_box+1_mag.gif
  convert checks_box+2.gif -scale 1000% checks_box+2_mag.gif
  convert checks_box+3.gif -scale 1000% checks_box+3_mag.gif
  convert checks_box+4.gif -scale 1000% checks_box+4_mag.gif
  convert checks_box+5.gif -scale 1000% checks_box+5_mag.gif
</CODE> -->

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The <A HREF="../resize/#scale" >Scale Operator</A> also produces similar
  results, but with some pixel color mixing, when enlarging, unless enlarging
  by an integer scaling factor.

</I></FONT></TD></TR></TABLE></P>


<A NAME="triangle"></A>
<H4>Triangle</H4>

<A HREF="graph_filter_triangle.jpg"
   ><IMG SRC="graph_filter_triangle.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

The '<B>Triangle</B>' or '<CODE><A HREF="../misc/#bilinear"
>Bilinear</A></CODE>' interpolation filter just takes the interpolation of the
nearest neighbourhood one step further.  Instead of just directly averaging
the nearby pixels together, as '<CODE>Box</CODE>' does, it weights them
according to how close the new pixels position is to the the original pixels
within the neighbourhood (or '<I>support</I>' region).  The closer the new
pixel is to a source image pixel, the more color that pixel contributes.  </P>

This produces a more global averaging of colors when images are being reduced
in size.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks_10.gif -filter triangle -resize 9x9 checks_tri-1.gif
  convert checks_10.gif -filter triangle -resize 8x8 checks_tri-2.gif
  convert checks_10.gif -filter triangle -resize 7x7 checks_tri-3.gif
  convert checks_10.gif -filter triangle -resize 6x6 checks_tri-4.gif
  convert checks_10.gif -filter triangle -resize 5x5 checks_tri-5.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=bottom><TD ALIGN=center>
  <A HREF="checks_10.gif"
     ><IMG SRC="checks_10_mag.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>&nbsp;
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=50 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="checks_tri-1.gif"
     ><IMG SRC="checks_tri-1_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri-1
</TD><TD ALIGN=center>
  <A HREF="checks_tri-2.gif"
     ><IMG SRC="checks_tri-2_mag.gif"   WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri-2
</TD><TD ALIGN=center>
  <A HREF="checks_tri-3.gif"
     ><IMG SRC="checks_tri-3_mag.gif"   WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri-3
</TD><TD ALIGN=center>
  <A HREF="checks_tri-4.gif"
     ><IMG SRC="checks_tri-4_mag.gif"   WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri-4
</TD><TD ALIGN=center>
  <A HREF="checks_tri-5.gif"
     ><IMG SRC="checks_tri-5_mag.gif"   WIDTH=50 HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri
</TD></TR></TABLE></DIV></P>
<!-- <CODE EXECUTE SCRIPT>
  convert checks_tri-1.gif -scale 1000% checks_tri-1_mag.gif
  convert checks_tri-2.gif -scale 1000% checks_tri-2_mag.gif
  convert checks_tri-3.gif -scale 1000% checks_tri-3_mag.gif
  convert checks_tri-4.gif -scale 1000% checks_tri-4_mag.gif
  convert checks_tri-5.gif -scale 1000% checks_tri-5_mag.gif
</CODE> -->

As you can see as the corner pixels were near perfect matches to the corners
of the original image they are more visible, but toward the middle where none
of the nearby pixels exactly match up with the new pixel being generated, you
get a more average color of the whole neighbourhood. </P>

The result for the checkerboard pixel pattern is a tendancy to fade in and out
of an average gray color. </P>

However as the '<I>support</I> neighbourhood is larger, more pixels will be
involved when you enlarge the image. Thus producing averaging of colors when
generating the pixels being added to the image. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert checks_5.gif -filter triangle -resize 6x6  checks_tri+1.gif
  convert checks_5.gif -filter triangle -resize 7x7  checks_tri+2.gif
  convert checks_5.gif -filter triangle -resize 8x8  checks_tri+3.gif
  convert checks_5.gif -filter triangle -resize 9x9  checks_tri+4.gif
  convert checks_5.gif -filter triangle -resize 10x10 checks_tri+5.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=bottom><TD ALIGN=center>
  <A HREF="checks_5.gif"
     ><IMG SRC="checks_5_mag.gif"      WIDTH=50 HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>&nbsp;
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=50 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="checks_tri+1.gif"
     ><IMG SRC="checks_tri+1_mag.gif"   WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri+1
</TD><TD ALIGN=center>
  <A HREF="checks_tri+2.gif"
     ><IMG SRC="checks_tri+2_mag.gif"   WIDTH=70 HEIGHT=70
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri+2
</TD><TD ALIGN=center>
  <A HREF="checks_tri+3.gif"
     ><IMG SRC="checks_tri+3_mag.gif"   WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri+3
</TD><TD ALIGN=center>
  <A HREF="checks_tri+4.gif"
     ><IMG SRC="checks_tri+4_mag.gif"   WIDTH=90 HEIGHT=90
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri+4
</TD><TD ALIGN=center>
  <A HREF="checks_tri+5.gif"
     ><IMG SRC="checks_tri+5_mag.gif"   WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Tri+5
</TD></TR></TABLE></DIV></P>
<!-- <CODE EXECUTE SCRIPT>
  convert checks_tri+1.gif -scale 1000% checks_tri+1_mag.gif
  convert checks_tri+2.gif -scale 1000% checks_tri+2_mag.gif
  convert checks_tri+3.gif -scale 1000% checks_tri+3_mag.gif
  convert checks_tri+4.gif -scale 1000% checks_tri+4_mag.gif
  convert checks_tri+5.gif -scale 1000% checks_tri+5_mag.gif
</CODE> -->

For large scale enlargements the result acts as if a gradient of colors
was added between each and every pixel.  For example, here I generate a
very small image with a single white pixel (the display is an enlarged view).
I then enlarge that image enormously.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert xc: -bordercolor black -border 2x0 pixel_5.gif
  convert pixel_5.gif  -filter triangle -resize 300x  pixel_triangle.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=bottom><TD ALIGN=center>
  <A HREF="pixel_5.gif"
     ><IMG SRC="pixel_5_mag.gif"   WIDTH=100 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Single Pixel Image
  <BR>(magnified)
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=35 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="pixel_triangle.gif"
     ><IMG SRC="pixel_triangle.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Triangle Filter Enlarged
</TD></TR></TABLE></DIV></P>
<!-- <CODE EXECUTE>
  convert pixel_5.gif        -scale 2000% pixel_5_mag.gif
</CODE> -->

If you were to graph the colors in the above image (using the "<CODE><A
HREF="../scripts/im_profile" >im_profile</A></CODE>" script), you will see a
replica of the triangular filter graph.

<!--<CODE EXECUTE>
  im_profile pixel_triangle.gif plot_triangle.gif
</CODE>-->
<DIV ALIGN=center>
  <IMG SRC="plot_triangle.gif"
       ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Profile]"></A>
  <BR>Profile of Image
</DIV></P>

As you can see the central pixel was merged with the neighbouring pixels to
produce a linear gradient of colors between those points. </P>

All the interpolation filters, produce similar gradient patterns between
neighbouring pixels and is also the reason why they are so well suited to
image enlargements. </P>

<A NAME="hermite"></A>
<A NAME="hermite-i"></A>
<A NAME="interpolate_other"></A>
<H4>Other Interpolation Filters</H4>

<A HREF="graph_interpolation.jpg"
   ><IMG SRC="graph_interpolation.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

To the right I have graphed the various interpolation filters, except for
'<CODE>Point</CODE>' which is actually very special case of an unscaled
'<CODE>Box</CODE>' filter (a pure '<CODE><A HREF="../misc/#nearest"
>NearestNeighbor</A></CODE>' interpolation). </P>

Other interpolation filters include '<CODE><B>Hermite</B></CODE>' which is
very similar to triangle in results, but producing a smoother round off for
enlargements, that smooths gradient transitions.  Click on the <A
HREF="graph_lagrange_interpolate.jpg" >graph on the right</A> to see a graph
of these three filter functions. <BR CLEAR=all></P>

<A NAME="lagrange-i"></A>

<A HREF="graph_lagrange_interpolate.jpg"
   ><IMG SRC="graph_lagrange_interpolate.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

The '<CODE><B>Lagrange</B></CODE>' filter has been called a 'universal'
interpolation filter. By varying the 'support' size (See the <A
HREF="#support" >Support Expert Setting</A> below), it can generate
all the previously looked at interpolation filters (except
'<CODE>Hermite</CODE>').

The default settings (a Lagrange order 3 filter (support=2.0) as shown as the
purple line on the graph right) provides a reasonable 'cubic' filter.  It
works very well though the gradient change can result in some noticeable  <A
HREF="#blocking" >blocking</A> effects on enlargement, though with bitmap
images and line drawings this can be a good thing. </P>

More on the other <A HREF="#lagrange" >Lagrange Filter</A> orders later. </P>

<A HREF="graph_filter_catrom.jpg"
   ><IMG SRC="graph_filter_catrom.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

<A NAME="catrom"></A>
<A NAME="catrom-i"></A>

The '<CODE><B>Catrom</B></CODE>' (Catmull-Rom) filter is a well known standard
<A HREF="#cubics" >Cubic Filter</A> often used as an interpolation function, and
is available under the same name.  This filter produces a reasonably sharp
edge, but without a the pronounced gradient change on large scale image
enlargements that a '<CODE>Lagrange</CODE>' filter can produce.  </P>

It is basically equivelent to a built-in 'unsharp resize' (see <A
HREF="../resize/#resize_unsharp" >Sharpened Resized Images</A>), though some consider it
far too sharp, and does not provide  any control of the sharpening. </P>

What does make a '<CODE>Catrom</CODE>' filter more interesting is that it is
almost an identical cubic equivelent of a 2-lobe '<CODE><A HREF="#lanczos"
>Lanczos</A></CODE>' filter, which is probably the most commonly used <A
HREF="#windowed" >Windowed-Sinc Filter</A> (see below). </P>

We will also look at this filter more closely later in <A
HREF="#cubics" >Cubic Filters</A>. </P>


<H4>Interpolation and IM's Interpolate Setting</H4>

The <A HREF="../misc/#interpolate" >Interpolate</A> setting of IM which is
used to produce an unscaled 'point' lookup of images in operators like the <A
HREF="../transform/#fx" >FX DIY Operator</A> ("<CODE><A
HREF="../option_link.cgi?fx" >-fx</A></CODE>") and <A
HREF="../color_mods/#clut" >Color Lookup Replacement Operator</A> ("<CODE><A
HREF="../option_link.cgi?clut" >-clut</A></CODE>"), and some older <A
HREF="../warping/#circular" >Circular Distortion</A> functions are based on
these simple interpolation resize filters. However they are currently
implemented using separate code and also have different setting names. </P>

These <A HREF="../misc/#interpolate" >Interpolation Settings</A> include:
'<CODE><A HREF="../misc/#nearestneighbor" >NearestNeighbor</A></CODE>',
implementing the '<CODE>Point</CODE>' (or unscaled '<CODE>Box</CODE>') filter,
and '<CODE><A HREF="../misc/#bilinear" >BiLinear</A></CODE>' to get an
unscaled '<CODE>Triangle</CODE>' filter. </P>

<I>ASIDE: At this time the smoothed triangle filter '<CODE>Hermite</CODE>' has
not been directly implemented as an <A HREF="../misc/#interpolate"
>Interpolation Setting</A>, which is a shame as it is quite a good
interpolation filter. </I><P>

<A NAME="gaussian"></A>
<H3>Gaussian Blurring Filters</H3>

In the complex mathematics of Fourier Transforms into frequency domains,
resize filters are meant to remove any high frequency noise that may be
present.  This noise is caused by the sampling of a real world image into
pixels, and when you resize an image, that noise appears as aliasing and
Moir&eacute; effects. </P>

Because of this the Gaussian Bell Curve became a natural early candidate as a
resizing or resample filter, as it is the ideal model for real world effects.
</P>

<H4>Gaussian</H4>

<A HREF="graph_filter_gaussian.jpg"
   ><IMG SRC="graph_filter_gaussian.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

The <B>Gaussian</B> filter is a very special filter that generates that same
'bell curve' shape in the frequency domain.  This makes it very useful as an
image filter as it guarantees a good removal of this high frequency noise in a
highly controllable way. </P>

However if you examine the filter graph, you will see that at a distance of
one pixel from the sampling point, you have a non-zero value.  In fact it is
quite a high value indeed.  This results in a huge amount of blurring of the
individual pixels, even when no resize is actually performed.  </P>

For example here I have resized the standard IM logo using a Gaussian filter
and again using the normal IM filter ('<CODE>Lanczos</CODE>' in this case,
which we will look at later)

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert logo:  -filter Gaussian  -resize 150x logo_gaussian.png
  convert logo:                    -resize 150x logo_normal.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=bottom><TD ALIGN=center>
</TD><TD ALIGN=center>
  <A HREF="logo_gaussian.png"
     ><IMG SRC="logo_gaussian.png"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <BR>Gaussian
</TD><TD ALIGN=center>
  <A HREF="logo_normal.png"
     ><IMG SRC="logo_normal.png"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <BR>Normal Resize
</TD></TR></TABLE></DIV></P>

If you look closely you will see that the left '<CODE>Gaussian</CODE>'
filtered image is more blurry than the normal resize. Especially with regard
to the detail of the smaller stars around the wand and on the wizard's hat.
</P>

This blurring of the image is the trade off you get for removing all the <A
HREF="#aliasing" >aliasing</A> effects in image reduction, as well as all <A
HREF="#blocking" >blocking</A> effects on image enlargement. It will also,
never produce any <A HREF="#ringing" >ringing</A> effects (when applied
perfectly). But all that is at the cost of extreme <A HREF="#blurring"
>blurring</A> for the resulting image. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

In fact, during large scale enlargements, this filter will generate round
dots, rather than square looking dots. For example, here I greatly enlarge a
3x3 pixel image with a single dot in the center.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert xc:red -bordercolor yellow -border 1 \
          -filter Gaussian   -resize 99x99  -normalize dot_gaussian.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="dot_gaussian.jpg"
      ><IMG SRC="dot_gaussian.jpg"      WIDTH=99 HEIGHT=99
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see a single pixel enlarges into perfectly circular dot. Only
Gaussian and Gaussian-like filters will do this. </P>

<A NAME="sigma"></A>
<H4>Gaussian Sigma Expert Control</H4>

You can control the Gaussian Filter directly using an a special
expert option "<CODE><A HREF="../option_link.cgi?define" >-define</A>
filter:sigma=<I>{value}</I></CODE>" to specify the actual 'sigma' value of the
Gaussian curve. </P>

By default this value is '<CODE>0.5</CODE>' which is also the same size as the
<A HREF="#box" >Box Filter</A>. In many ways you can regard a Gaussian Filter
as essentially a 'blurred box'. </P>

This expert option was added to allow for the creation of very very small
Gaussian Blurs, without reducing the <A HREF="#support" >Filter's
Support</A> range (see below). </P>

However increasing the 'sigma' could cause the filter to become clipped. As
such when increasing the 'sigma' value the default 'support'
(<CODE>2.0</CODE>) is also increased by a similar amount.  This only happens
on increases in the default 'sigma' value.  The <A HREF="#support" >Support
Expert Setting</A> can be used to override this automatic effect, but it is
typically not necessary.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE>filter:sigma</CODE>' expert option only works for the <A
  HREF="#gaussian" >Gaussian Filter</A>.  No other filters are effected by
  this expert control.  </P>

  A more generalised control, for other filters can be achievd using <A
  HREF="#blur" >Blur Filter Expert Control</A> which we will look at
  later. </P>
</I></FONT></TD></TR></TABLE></P>


<A NAME="spline"></A>
<A NAME="quadratic"></A>
<A NAME="gaussian_other"></A>
<H4>Other Gaussian-like Filters</H4>

<A HREF="graph_gaussian.jpg"
   ><IMG SRC="graph_gaussian.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

If you study the comparative graphs to the right you will see that
'<B><CODE>Quadratic</CODE></B>' filter as well as the slightly more complex
'<B><CODE>Spline</CODE></B>' filter follow the weighting curve of the
'<CODE>Gaussian</CODE>' filter quite well. And being polynomial functions they
are also a lot faster to calculate, which was why they were originally
invented. </P>

While '<CODE>Quadratic</CODE>' is very slightly more blurry than the <A
HREF="#gaussian" >Gaussian Filter</A>, the '<CODE>Spline</CODE>' filter is
even more blurry, with an equivelent <A HREF="#sigma" >Sigma</A>
setting of approximatally '<CODE>0.65</CODE>'.  This makes
a '<CODE>Spline</CODE>' filter the most blurry filter provided without
modifications.  </P>

Examining the graphs you will see that like the <A HREF="#gaussian" >Gaussian
Filter</A> and unlike <A HREF="#interpolate_other" >Interpolation Filters</A>
they have a non-zero value at a distance of 1.0 from the sampling point. This
causes the nearby pixels to merge their colors, and is the cause of the
blurring you see.  The '<CODE>Spline</CODE>' filter having the highest value at
the 1.0 distance producing the largest amount of blurring in any resized (or
distorted) image.  </P>

This extra blurriness removes the last of any 'blocking' effects that may be
present in large scale enlargements.  And could be used with a <A
HREF="../resize/#resize_unsharp" >Sharpen Resized Images</A> technique to
enlarge line drawing with very little 'staircase effects' in the results. </P>

The '<B><CODE><A HREF="#mitchell" >Mitchell</A></CODE></B>' filter is also
shown in the comparison graph.  This filter also has a some blurring at the
1.0 distance from the sampling point, which also makes this filter slightly
blurry, much like the other filters we have seen.  However it also has some
negative weighting in its curve, which while producing <A HREF="#ringing"
>ringing</A> effects (see <A HREF="#windowed" >Window Sinc Filters</A>
later), offsets that bluriness near sharp edges. </P>


<A NAME="support"></A>
<H3>Filter Support Expert Control</H3>

The Gaussian filter is known as an IIR (Infinite Impulse Response) filter,
which simply means that the response 'curve' it uses never reaches zero.  That
is, no matter how far away from the sampling point you get, you will still
have some non-zero contribution to the result from very distant pixels.  </P>

In mathematical terms this is actually a good thing, as it means the result is
much more mathematically perfect. In practical application it is very bad, as
an infinite filter requires you to use a weighted average of every pixel in the
original image, to generate each and every new pixel in the destination image.
That means that large images would take a very very long time to resize
perfectly using this filter.  </P>

However for the '<CODE>Gaussian</CODE>' filter anything beyond a range of
about 2 pixels (4 times its default 'sigma' setting) from the sampling point
will generally produce very little effect in terms of the final result, and as
such can be generally be ignored. Even 3 times the sigma is generally regarded
as reasonable. This range is known as the filter's '<I>support window</I>' and
is the program's practical limit for the filter.

If you really want, you can change the 'support' of a filter using the special
expert setting  "<CODE><A HREF="../option_link.cgi?define" >-define</A>
filter:support=<I>{value}</I></CODE>". </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example here I resize an image with a single pixel using the smaller
support value of 1.25, or 2-1/2 times the sigma value.(see the <A
HREF="graph_gaussian_support.jpg" >resulting graph</A> right).  This is of
course smaller that the normal generally accepted minimum of 3 times the sigma
value.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert pattern:gray5 -crop 5x1+0+3 +repage pixel_5.gif
  convert pixel_5.gif  -filter gaussian -define filter:support=1.25 \
          -resize 300x  pixel_gaussian.png
</CODE></PRE></TD></TR></TABLE>

</TD><TD>
<A HREF="graph_gaussian_support.jpg"
   ><IMG SRC="graph_gaussian_support.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TR></TABLE>

<DIV ALIGN=center>
<!--<CODE EXECUTE>
  im_profile pixel_gaussian.png plot_gaussian.gif
</CODE>-->
<TABLE><TR><TD ALIGN=center>
  <A HREF="pixel_5.gif"
     ><IMG SRC="pixel_5.gif"   WIDTH=100 HEIGHT=20
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Single Pixel Image
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=25 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="pixel_gaussian.png"
     ><IMG SRC="pixel_gaussian.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Gaussian Filtered
</TD>
</TD></TR></TABLE>
  <IMG SRC="plot_gaussian.gif"
       ALIGN=middle VSPACE=5 HSPACE=5 BORDER=0 ALT="[IM Profile]"></A>
  <BR>Profile of Image
</DIV></P>

By using the smaller '<CODE>support</CODE>' setting, the 'step' (where the
support window cuts off the function) was moved to the 1.25 position. That in
turn, results in a larger 'stop' in the filter's profile, and results in an
'aliasing' effects that you can see in the enlargement.  That is the wiggle
near the 'peak' of the graph, as well as a sudden 'drop' at the edges of the
filter's 'support' limits.  </P>

You can think of 'support' as being a sliding 'window' across the pixels being
averaged together to produce the enlarged image result. As the support size is
1.25, the filter's total support area is 2.5 pixels wide (unscaled during
image enlargements), as such you can have either 2 or 3 pixels involved in the
horizontal resizing phase. </P>

As this support 'window' slides across the image, each pixel entering or
leaving will generate the sudden 'change' in the filters 'curve'.  That is the
cause of the slight jiggles in the results.  That is, at these points, a pixel
is being added or removed from the total number of pixels being averaged
together according to the filter weighting curve.  </P>

This in turn produces four such 'jiggles' or 'zig-zags' in the resized image,
An initial two on the outside edges when the single white pixel enters/leaves
the support range, and a second pair of jiggles as a second black pixel
(making a three pixel weighted average) enters/leaves the support range.  </P>

If there wasn't such a sudden 'stop' in the filter, that is, the filter goes
to zero at the support limit setting, then you would not see the 'jiggles' and
you would not have the visible effect. </P>

Using a support size set to an integer or half-integer (such as the default
'support' setting for a '<CODE>Gaussian</CODE>' filter of '2.0') would always
ensure that whenever a new pixel enters the support range, another pixel is
leaving, so that the same number of pixels is always part of that average.
</P>

That would remove the two 'center' jiggles, but it will not not remove the
initial jiggles on the outside, marking the support limits. </P>

Even sharp slope changes (discontinuities) in the filter, such as you get from
a <A HREF="#triangle" >Triangle</A>, or a <A HREF="#lagrange" >Lagrange</A>
filter can generate visible artifacts in the resulting image. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Previous to IM v6.3.6-3 the 'support' for the Gaussian filter was set to this
  value of '<CODE>1.25</CODE>' producing <A HREF="#ringing" >Ringing</A>
  effects in enlargements (such as shown above). For this reason the 'support'
  for Gaussian was changed to '<CODE>1.5</CODE>' ensure the same number of
  pixels were always being averaged, and to reduce the smaller step. </P>

  As of IM v6.6.5-0 the default 'support' setting for Gaussian was increased
  to a value of '<CODE>2.0</CODE>'.  This has little effect on the overall
  speed of the filter, but makes the 'stop' practically non-existent.  It also
  simplified filter coding for other special uses of this filter, specifically
  for <A HREF="../distorts/#area_resample" >EWA distortions</A>, and <A
  HREF="../mapping/#blur" >Variable Blur Mapping</A>. </P>

</I></FONT></TD></TR></TABLE></P>

Note however that if you use a very large support setting then of course more
pixels will need to be averaged together making the resize operation slower,
without any real improvement in results. Only the <A HREF="#windowed"
>Windowed Sinc/Jinc</A> and <A HREF="#lagrange" >Lagrange</A> filters can
generally produce a better result by using a support window that is larger
than 2.0.  </P>

Remember these are 'expert' options, and as such you are more likely to make
things worse rather than better by using these options. That is why they are
not a simple command line option, but provided via the special "<CODE><A
HREF="../option_link.cgi?define" >-define</A></CODE>" option. Of course you
are welcome to play, just as I have done above, so as to try and understand
things better, and IM provides these options so that you can do just that.
</P>



<A NAME="blur"></A>
<H3>Filter Blur Expert Control</H3>

A special expert option, "<CODE><A HREF="../option_link.cgi?define"
>-define</A> filter:blur=<I>{value}</I></CODE>" can be used to adjust amount
of blurring that a filter provides. A value of '<CODE>1.0</CODE>' producing
the default action, while smaller and larger values adjust overall
'blurriness'. </P>

Basically this linearly enlarges or shrinks the filter's curve along the
X axis (distance of pixel form the sampling point), and typically make
a filter more or less blurry, overall. </P>

Using a smaller setting results in the filter's function (and its support
window) becoming smaller. For <A HREF="#gaussian" >Gaussian</A> and <A
HREF="#gaussian_other" >Gaussian-like</A> filters the effect is as if you
multiplied the filters 'sigma' value (default=0.5) by this 'blur' factor.
</P>

This setting will also enlarge or shrink the filters <A HREF="#support"
>Support Window</A> by the same amount so as to prevent clipping, but this can
be overridden using the <A HREF="#support" >Support Expert Filter
Setting</A>. </P>

For example, here I resize an image with three different 'blur' settings,
using a <A HREF="#spline" >Gaussian-like Spline Filter</A>..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=logo_blur_1.0.png>
  for blur in 0.5 1.0 1.5; do \
    convert logo: -define filter:blur=$blur -filter Spline \
            -resize 150x logo_blur_$blur.png; \
  done
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0><TR VALIGN=top><TD ALIGN=center>
  <A HREF="logo_blur_0.5.png"
     ><IMG SRC="logo_blur_0.5.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>blur 0.5
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/left.gif" WIDTH=20 HEIGHT=20 VSPACE=40 ALT="<==">
</TD><TD ALIGN=center>
  <A HREF="logo_blur_1.0.png"
     ><IMG SRC="logo_blur_1.0.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>blur 1.0
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=40 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="logo_blur_1.5.png"
     ><IMG SRC="logo_blur_1.5.png"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>blur 1.5
</TD></TR></TABLE>
</DIV></P>

As you can see, this special setting will let you control the overall
blurriness of the result for '<CODE>Spline</CODE>' filter. </P>

As the size of the 'support window' is also scaled by the <A
HREF="#blur" >Filter Blur</A> setting, using very small scaling values
can cause the resampling to 'miss' all pixels, or generate only zero weighted
pixels.  As a result regular 'black' lines or blocks will be generated. For
example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -define filter:blur=0.1 -filter Gaussian \
          -resize 100x100  rose_black_bars.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="rose_black_bars.png"
      ><IMG SRC="rose_black_bars.png"      WIDTH=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Increasing the size of the support window (before it is scales by blur), may
help prevent these effects, but as most filters will only produce zero
weightings for pixels that fall outside their 'natural' support range, it will
not work for all filters. The only filters that will typically generate useful
non-zero values over the whole support range is the <A HREF="#box" >Box
Filter</A> and the <A HREF="#windowed" >Sinc/Jinc Windowed Filters</A>.
</P>

Similar effects can be seen with <A HREF="#cyl_interpolated" >Cylindrical
Filters</A>, when the filters support becomes too small to always find at
least one pixel to sample. </P>

The <A HREF="#lagrange" >Lagrange Filters</A> uses <A HREF="#blur"
>Support Expert Filter Setting</A> to determine the appropriate 'order' to fit
into the 'support window', and thus polymorphs into various other forms (see
below). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Using bad support settings with filters containing negative weightings
  (basically any of the filters we will look at next) can produce inverse
  sharpening and negation effects, and disproportionately stronger aliasing
  effects. In rare cases it can even generate infinite weighted colors
  (which get clamped to pure black and white in normal non_HDRI versions of
  IM). </P>

  Caution and expertise is recommended when using this special option with
  any filter.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.3.6-3 the '<CODE>filter:blur</CODE>' define was mistakenly
  set by the option "<CODE>-support</CODE>", which was very misleading in
  exactly what it did.  This option has been depreciated, and no longer
  available.
</I></FONT></TD></TR></TABLE></P>


<A NAME="gaussian_interpolator"></A>
<H3>Gaussian Interpolator Filter Variant</H3>

<A HREF="graph_blurred.jpg"
   ><IMG SRC="graph_blurred.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

A <A HREF="#blur" >Blur Control</A> value of '<CODE>0.75</CODE>' on <A
HREF="#gaussian_other" >Gaussian-like Filters</A>, or using a <A
HREF="#sigma" >Sigma Control</A> value of '<CODE>0.375</CODE>' for the
<A HREF="#gaussian" >Gaussian Filter</A> will generate a variation I call a
<B>Gaussian Interpolator</B>. </P>

This sharpened Gaussian filter as similar proprieties as the <A
HREF="#interpolate_other" >Interpolation Filters</A> we looked at above.  But
does not contain any sharp stops, or other gradient changes that can be
noticeable in enlarged images.  In this respect it is much like the "<CODE><A
HREF="#hermite" >Hermite</A></CODE>" filter (see graph), but with
non-symmetrical skew that does seem to work better as an interpolator.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE>
  convert logo: -filter Gaussian -resize 150x logo_gaussian.png
  convert logo: -define filter:blur=0.75 -filter Gaussian \
          -resize 150x logo_gaussian_interpolate.png
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0><TR VALIGN=top><TD ALIGN=center>
  <A HREF="logo_blur_1.0.png"
     ><IMG SRC="logo_blur_1.5.png"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <BR>Gaussian
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=40 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="logo_gaussian_interpolate.png"
     ><IMG SRC="logo_gaussian_interpolate.png"
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <BR>Gaussian Interpolator
  <BR><FONT SIZE=-1>(blur=0.75 or sigma=0.375)</FONT>
</TD></TR></TABLE>
</DIV></P>


In fact I find it makes the Gaussian filter produce much more acceptable
results, which is not too sharp, and not to blurry. </P>

However reducing the <A HREF="#blurring" >blurring</A> of the filter will
enhance the <A HREF="#aliasing" >aliasing</A> effects, thus more likely to
generate large scale Moir&eacute; effects from low pixel level patterns.  This
is the trade off of using a less blurry form of the filter. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE>
  convert rings_crop.png -filter gaussian -resize 100x100  rings_gaussian.png
  convert rings_crop.png -filter gaussian -define filter:blur=0.75 \
                              -resize 100x100  rings_gaussian_interpolate.png
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0><TR VALIGN=top><TD ALIGN=center>
  <A HREF="rings_gaussian.png"
     ><IMG SRC="rings_gaussian.png"   WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=30 BORDER=1 ALT="[IM Output]"></A>
  <BR>Gaussian
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=40 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="rings_gaussian_interpolate.png"
     ><IMG SRC="rings_gaussian_interpolate.png"   WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=30 BORDER=1 ALT="[IM Output]"></A>
  <BR>Gaussian Interpolator
  <BR><FONT SIZE=-1>(blur=0.75 or sigma=0.375)</FONT>
</TD></TR></TABLE>
</DIV></P>


<A NAME="windowed"></A>
<H3>Windowed Sinc Filters</H3>

<A NAME="sinc"></A>
<H4>Sinc Filters</H4>

Mathematics has determined that the ideal filter for resizing image (using
a 2-pass 'tensor' resize technique) is the the <I>Sinc()</I> function.  (See
<A
HREF="http://en.wikipedia.org/wiki/Nyquist-Shannon_sampling_theorem#Application_+to_multivariable_signals_and_images"
>Nyquist-Shannon sampling theorem</A>). </P>

   <A HREF="graph_sinc.jpg"
      ><IMG SRC="graph_sinc.gif"   WIDTH=180 HEIGHT=120
            ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

The <I>Sinc()</I> being mathematically perfect has some special features that
I would like to point out.  First at every integer distance from the weighting
function for the filter becomes zero.  This is very important as it means that
the filter does not blur the image more than necessary (unlike <A
HREF="#gaussian" >Gaussian Filters</A>). It also means if an image is
resampled without resizing (a "no-op" resize) the image remains completely
unaffected by the filter. It is thus an interpolative filter though a very
complex one. </P>

The <I>Jinc()</I> function is closely related to <I>Sinc()</I>, and has
proprieties that make it useful as a filter for 2-dimensional filtering, such
as used by the <A HREF="../distorts/#distort" >General Image Distortion
Operator</A>.  More about this function later in <A HREF="#cylindrical"
>Cylindrical Filters</A>.  For now just note that it could also be used as the
base function for <A HREf="#jinc" >Windowed Jinc Filters</A>. </P>

The other major difference between <I>Sinc()</I> and <I>Jinc()</I> based
filters and previous filters we have looked at is that many of the weights are
negative.  That is, they will subtract some of the nearby color pixels from
the final color, for each pixel in the image. </P>

This may seem a little strange, but it results in a strong sharpening of the
edges of objects. Of course any negative weights generally need to be offset
by lots more positive weights further along the curve, which produces the wave
like function you see extending out a long range from the sampling point. </P>

These extra 'lobes' of positive (and negative) weights causes <A
HREF="#ringing" >ringing</A> artifacts in images which contain very strong
color boundaries, such as in high contrast line drawings, or boundary such as
a red roof to a blue sky.  These ringing effects can become even more
pronounced if filters based on these functions is applied improperly. </P>

<H4>Windowing Functions</H4>

Unfortunately this function is also IIR (Infinite Impulse Response) function,
That is to say it has effects going all the way to infinities, just like the
<A HREF="#gaussian" >Gaussian Filter</A> previously. </P>

This means that to use 'Sinc', you would need to generate a weighted average
of every pixel in the image (and beyond) in order to create the best
representation for each and every new pixel in the destination image.  This is
prohibitively expensive, making the direct use of these perfect filters
impractical. Not that you would want to due to ringing effects.  </P>

But unlike the <A HREF="#gaussian" >Gaussian Filter</A>, the 'Sinc' function
does not just taper down to near zero a short distance from the sample point.
In fact, even at 10 pixels away from the sampling point (see graph above), you
can get an appreciable effect on the final result. However resizing an image
using a filter that has a support distance of 10 would require an averaging of
at least 20x20 or 400 pixels per pixel in the final result.  And that would
produce a very slow resize.  </P>

As a consequence, using a raw form "<CODE>Sinc</CODE>" filter not recommended,
and almost never used, though by using <A HREF="#options" >Expert
Filter Controls</A> IM will not prevent you from doing this, if that is what
you really want to do. </P>

What is recommended and provided are 'windowed' forms of the Sinc function,
which have been developed by image processing experts, that can be used to
'limit' the infinite Sinc (and Jinc) functions to a more practical size.
These <I>Windowing Filters</I> include filters such as; '<CODE>Blackman</CODE>',
'<CODE>Bohman</CODE>', '<CODE>Hann</CODE>', '<CODE>Hamming</CODE>'
'<CODE>Lanczos</CODE>',  '<CODE>Kaiser</CODE>', '<CODE>Welch</CODE>',
'<CODE>Bartlett</CODE>', and '<CODE>Parzen</CODE>'.  </P>


<A NAME="window_how"></A>
<H4>How Windowed Filters Work</H4>

   <A HREF="graph_sinc_windowing.jpg"
      ><IMG SRC="graph_sinc_windowing.gif"   WIDTH=180 HEIGHT=120
            ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

For example, the graph to the right shows three functions (click to get an
enlarged view). The red function is the mathematically ideal <I>Sinc()</I>
function, which stretches off to infinity.  The green function is a "Hann"
windowing function (based on a simple Cosine() curve .  This is multiplied
with the <I>Sinc()</I> to modulate the more distant components of the filter,
reaching zero (or near zero) at the edge of the support window (4.0 pixel
units is distance by default for this filter). </P>

Basically by selecting '<CODE>Hann</CODE>' for the "<CODE><A
HREF="../option_link.cgi?filter" >-filter</A></CODE>" selection you are in
reality selecting the '<I>Hann()</I>' '<I>Windowing Function</I>' to modulate
the '<I>Weighting function</I>' such as '<I>Sinc()</I>' (or '<I>Jinc()</I>').
</P>

As such, '<I>Windowed Filters</I>' are really two functions.  Either the Sinc
or the Jinc function (depending on the image processing operator), and the
'Windowing Function' you have specifically selected as the filter to use.  (See
<A HREF="#options" >Expert Filter Controls</A> below). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before v6.3.6-3, IM made the grave mistake of actually using the windowing
  functions directly as the filter's weighting function.  This in turn caused
  all these filters (except Lanczos) to produce badly <A HREF="#aliasing"
  >aliased</A> images, when used for resizing.   As a consequence the filters
  were often mis-understood or rarely used by IM users.   This has now been
  fixed.
</I></FONT></TD></TR></TABLE></P>

<A NAME="windowing"></A>
<A NAME="welch"></A>
<A NAME="cosine"></A>
<A NAME="bartlett"></A>
<A NAME="hamming"></A>
<A NAME="hann"></A><A NAME="hanning"></A>
<A NAME="kaiser"></A>
<A NAME="blackman"></A>
<A NAME="bohman"></A>
<A NAME="parzen"></A>
<H4>The Various Windowing Filters</H4>

<A HREF="graph_windowing.jpg"
   ><IMG SRC="graph_windowing.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

To the right is a graph of all the various windowing functions that IM has
available at the time of writing (more was added later).  Yes, there are a lot
of them, as windowing functions have been the subject of intense study by
numerous signal processing experts. </P>
All of the windowed filter functions will generally be used to modulate a Sinc
(or Jinc) weighting function using a support of either 3, or 4 for Sinc (3 or
4 lobes), depending on the class of windowing function being used (see below).
For example a '<CODE>Blackman</CODE>' windowing filter will use 4 lobes, but
'<CODE>Lanzcos</CODE>' will use 3 lobes. This is dependant on your IM version,
so check the <A HREF="#options" >Verbose Filter Expert Option</A> if you want
to be sure. </P>

As you can see all the windowed filtered functions produce a muted form of the
original <I>Sinc()</I> function that is also shown. And other than the amount
of <A HREF="#ringing" >ringing</A> a specific filter generates there is often
very little to distinguish one windowed filter from another. </P>

Probably one of the best windowed filters is '<B><CODE>Lanczos</CODE></B>'.
While other people swear by the '<B><CODE>Blackman</CODE></B>',
'<B><CODE>Bohman</CODE></B>', '<B><CODE>Hann</CODE></B>' (a cosine tappered
bell), '<B><CODE>Hamming</CODE></B>' (cosine bell variant),
'<B><CODE>Cosine</CODE></B>' (single cosine lobe); as windowing functions.  All
these functions are based on the use of a Sinc, or a Sine/Cosine functions in
their formulation, which supposedly ensures the function will have a good
frequency response. </P>

The other windowing filters include '<B><CODE>Welch</CODE></B>' (parabolic),
'<B><CODE>Parzen</CODE></B>' (cubic spline), '<B><CODE>Kaiser</CODE></B>'
(Bessel), and probably simplest '<B><CODE>Bartlett</CODE></B>'
(triangular or linear).  Typically these functions were created for their
simplicity and speedy calculation, though they are typically regarded as having
a poor 'frequency response'. Also many of these windowing functions are used
as resampling filters in their own right.  For example the
'<CODE>Bartlett</CODE>' (which is probably the real odd ball of all the
windowing functions) is actually the same mathematical function used for
a '<CODE>Triangle</CODE>' filter, as well as the '<CODE>Bilinear</CODE>'
interpolation filter. </P>

All the functions (except '<CODE>Bartlett</CODE>') form two basic categories
of windowing functions. </P>

<UL>
<LI>A tapering 'bell' shaped curve, such as '<CODE>Hamming</CODE>',
    '<CODE>Hann</CODE>', '<CODE>Kaiser</CODE>', '<CODE>Blackman</CODE>',
    '<CODE>Bohman</CODE>', and '<CODE>Parzen</CODE>'. </P>

<LI>And an untappered 'lobe' type windowing function which quickly falls to
    zero, before being 'cut off' by the windows support, such as
    '<CODE>Lanczos</CODE>', '<CODE>Welch</CODE>', and
    '<CODE>Cosine</CODE>'. </P>

</UL></P>

If you study the above window function graph you can see how the shapes of the
two styles of filter differ.  However the two categories of windowing
functions do not seem to be as important as the overall 'frequency response'
you get from using a trigonometric defined curve.  </P>

The tappering 'bell' shaped windowing functions will use a  <A
HREF="#lobes" >Lobes Support</A> over 4 lobes of the Sinc Weighting
function (or Jinc function in cylindrical (distort) resampling).  The
untappering 'lobe' type of windowing filters will default to using a 3 lobe
support.  This results in a rough equivalence between the two types of
windowing filter, due to difference in the windowing function roll off.  This
also means that the untappering windowed filters will, by default, be slightly
faster that the tappering ones. </P>

The default number of lobes that filters should have was discussed in the IM
Forums Discussion, <A HREF="../forum_link.cgi?f=22&t=20942" >Add Cosine
windowing?</A>.  Of course if you want you can change the <A
HREF="#lobes" >Lobes Support</A> or even just the general support of
any of the resize filters.  They are all about the same only with very slight
variations in the amount of ringing and blocking effects that is produced.
</P>

<A HREF="graph_windowing_support.jpg"
   ><IMG SRC="graph_windowing_support.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

To the right is the same windowing functions but using the default <A
HREF="#lobes" >Lobes Support</A> as defined by IM according to the
tappered/untappered nature of the function. </P>

As you can see over the first two lobes (the primary ones with the most
influence) there is very little difference between any of the filters, and all
show a very similar 'roll-off' over that range. However the ordering of the
functions have not changed much, with the extremes still being between
'<B><CODE>Welch</CODE></B>' and '<B><CODE>Parzen</CODE></B>', and with
'<B><CODE>Lanczos</CODE></B>' falling squarely in the middle of the resulting
curve roll-offs. </P>

<A HREF="graph_windowed_sinc.jpg"
   ><IMG SRC="graph_windowed_sinc.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

And to the right is the resulting windowed-sinc filters that would be provided
by an user selecting those windowing functions using the above defaults.  As
you can see the final weighting curves are all very similar, and as expected
all are sandwiched between the extremes of '<B><CODE>Welch</CODE></B>' and
'<B><CODE>Parzen</CODE></B>'. </P>

You can look at more detailed definitions and graphs of most of these various
windowing functions, and their results in the Fourier Frequency Spectrum on <A
HREF="http://en.wikipedia.org/wiki/Window_function" >Wikipedia, Window
function</A>. </P>

<BR>

<B>In summery:</B> I have not found a great deal of difference in results
between these various windowing functions.  Also my reading of research papers
of results all seemed to be more of a qualitative opinion of their
suitability, rather than anything concrete. </P>

My feeling is that just about any windowing function can be used, but if I was
to pick one you are better sticking to the most popular '<CODE>Lanczos</CODE>'
windowing filter. It is in the middle of all the above filters, has good
frequency spectrum response, and is generally a good choice as a resampling
filter. </P>

On the other hand an image processing expert, who has been instrumental in
ImageMagick's Resampling filters, disagrees with this. Though he selects
filters based more on the exact requirements for specific images. You can see
his suggestions and comments in <A HREF="nicolas/" >Techniques Recommended by
Nicolas Robidoux</A>.

<A NAME="lanczos"></A>
<H3>Lanczos Filter</H3>

We have mentioned the '<B><CODE>Lanczos</CODE></B>' filter a number of times
already.  It is probably the most well known of the <A HREF="#windowed"
>Windowed Filters</A>, which falls in the middle of the range of windowed
filters we have seen.  Essentially  it does not 'roll-off' too fast, or to
slow, and has a good frequency response in the resulting fourier transform.
</P>

Basically '<B><CODE>Lanczos</CODE></B>' makes a great starting point for any
sort of filter work, and has been used extensivally in the recent development
of <A HREF="#jinc" >Windowed Jinc Cylindrical Filters</A> (see below). </P>

The '<B><CODE>Lanczos</CODE></B>' filter basically uses the first 'lobe' of the
<I>Sinc()</I> function, to window the <I>Sinc()</I> function. That is, the
filter's weighting function is used to set the filter's own windowing function.
Many people see this as being a good reason to select it over the many other
Windowed Sinc Filters. Though there is little to no real evidence that it is the
best, it is a solid middle range filter. </P>

By default IM defines the '<CODE>Lanczos</CODE>' filter as having 3 'lobes'.
The reason for this is because the windowing function itself is 'untappered',
in that it is just a single lobe that cuts off, with the functions first zero
crossing coinciding with the window support limits. See <A
HREF="#window_how" >How Windowed Filters Work</A> above.  </P>

<A HREF="graph_lanczos_filters.jpg"
   ><IMG SRC="graph_lanczos_filters.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

However a 2-lobed '<B><CODE>Lanczos2</CODE></B>' filter (Lanczos with
a default lobes of 2, added for easy user selection) has also been found to be
popular, as it will avoid the positive <A HREF="#ringing" >Ringing
Artefacts</A> that can be generated by Windowed-Sinc filters. </P>

The '<CODE>Catrom</CODE>' (actually the 'Catmull-Rom Filter'), is almost an
exact duplicate of the '<CODE>Lanczos2</CODE>' filter though as it is a <A
HREF="#cubics" >Cubic Filter</A> it is much faster to generate
mathematically. That however is typically not a problem with the way IM caches
filter values before processing images. </P>

Having said this, a long <A HREF="../forum_link.cgi?t=20992&p=85257"
>Discussion in the IM forums</A> seems to indicate that for orthogonal
(tensor) resizing, a 4 lobe '<CODE>Lanczos</CODE>' actually works better for
shrinking images, while preventing <A HREF="#aliasing" >Moir&eacute</A> in
images of objects with very fine patterns, but at the cost of more <A
HREF="#ringing" >Ringing</A>. </P>


<A NAME="lobes"></A>
<H3>Windowing Size in Lobes</H3>

As I mentioned, the underlying Sinc (and Jinc) filter function is actually
infinite in size.  Though by default IM limits them using the specified
windowing funtion to a much smaller, more practical size. </P>

However there may be some situations where you really want to try and get a
much better, more exact resizing of the image using a much larger, and slower
window (support) size.  That can even be done quite simply using the <A
HREF="#support" >Filter Support</A> expert control, just as we did for
<A HREF="#gaussian" >Gaussian-like</A> filters. </P>

The windowing function itself will (in most cases) reduce the Sinc (and Jinc)
to zero over the  <A HREF="#support" >support</A> setting range. But as
the windowing function is scaled to fit the 'support' window, the resulting
filter function will also change. </P>

<A HREF="graph_lanczos_lobes.jpg"
   ><IMG SRC="graph_lanczos_lobes.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

For example, to the right I have graphed the '<CODE>Lanczos</CODE>' windowed
filters, against the <I>Sinc()</I> function as a reference, using various
'support' settings from 2 to 8. Note that the actual size of the filter is
limited by the actual support size used.  The smaller the 'support' the faster
the filter, but the less exactly the function follows the mathematically ideal
<I>Sinc()</I> function.  </P>

Look closely at each of the graphed curves.  The 'green' (support=2) curve
only has the main central peak, plus one negative 'lobe' (Equivelent to
a '<CODE>Lanczos2</CODE>' filter). After this the function is just zero, and
not used.  The next 'purple' (support=3, and the default
'<CODE>Lanczos</CODE>' filter) curve, has a much larger first negative 'lobe',
then a smaller positive 'lobe'.  This continues on with more lobes being
added, as the support size increases by integer increments. The additional
lobes are smaller and smaller in height, producing less and less influence on
the final result, but with the initial 'lobes' becoming higher (more
influence, and hence more <A HREF="#ringing" >Ringing</A> effects). </P>

For best effect you would use a support setting, to generate a filter with
that many up/down 'lobes' in it.  That is you would have the windowing
function, and thus the 'support' of the filter, end at a 'zero-crossing'.
</P>

However while the <I>Sinc()</I> function has 'lobe' (zero-crossings) at
integer 'support' settings, the <I>Jinc()</I> weighting function does not.
This presents a problem for users wanting to adjust the support window for
a filter being used with the <A HREF="../distort../distorts//#distort" >Distort
Operator</A>.  In fact, <I>Jinc()</I> has 'zero crossings' at highly <A
HREF="http://en.wikipedia.org/wiki/Irrational_number" >irrational numbered</A>
positions.   These zero crossings are very difficult to work out without being
a mathematics expert. </P>

To make it easier to set a filter in terms of the number of 'lobes' another
special setting was created, "<CODE><A HREF="../option_link.cgi?define"
>-define</A> filter:lobes=<I>{integer}</I></CODE>". </P>

If the filter is being used by a 2 dimensional image resampling operator such
as the <A HREF="../distorts/#distort" >General Distortion Operator</A>, which
generally  the use of <I>Jinc()</I> as the base function, it will look up
a table of the first 20 zero crossings for the filter, and set the '<A
HREF="#support" >support</A>' setting to that value.  This means you
don't have to try to find the appropriate support setting for the
<I>Jinc()</I> function, just specify the number of lobes you want to use. </P>

Because of this it is better to specify Windowed Sinc or Jinc filters in terms
of the number of 'lobes' you want the filter to contain, rather than
specifying
a more direct '<A HREF="#support" >support</A>' setting. If neither
<I>Sinc()</I> or <I>Jinc()</I> functions are used for the filter definition,
then the the '<CODE>filter:lobes</CODE>' setting is used to calculate the
appropriate '<A HREF="#support" >support</A>' setting for the filters
usage. </P>

Note however that a '<CODE>filter:support</CODE>' setting will override any
'<CODE>filter:lobes</CODE>' setting given, so it is better to only define the
'<CODE>filter:lobes</CODE>' expert option, especially if using the <A
HREF="../distorts/#distort" >General Distortion Operator</A>. </P>


<A NAME="lagrange"></A>
<H3>Lagrange Filter</H3>

Just as the '<CODE><A HREF="#gaussian" >Gaussian</A></CODE>' filter is
a mathematically slow function (not that it affects the overall speed very
much thanks to IM's caching of results), the <A HREF="#windowed"
>Sinc/Jinc Windowed Filters</A> are even slower and more complex to compute
due to the need to compute trigonometric functions for use in both weighting
and windowing functions.  </P>

The '<B><CODE>Lagrange</CODE></B>' filter however generates a piece-wise cubic
polynomial function to approximate a windowed filter. (See <A
HREF="http://en.wikipedia.org/wiki/Lagrange_polynomial" >Wikipedia: Lagrange
Polynomial</A>). Just as  <A HREF="#windowed" >Windowed Filters</A> are
adjustable according to the <A HREF="#support" >Support Setting</A>,
the '<CODE>Lagrange</CODE>' filter also will adjust itself according to that
setting. </P>

The default <A HREF="#support" >support</A> setting of 2.0 generates
a '<CODE>Lagrange</CODE>' filter (order 3).  This filter is quite good for
both enlargement and shrinking of images. with minimal <A HREF="#blocking"
>blocking</A> and <A HREF="#ringing" >ringing</A> effects and no <A
HREF="#blurring" >blurring</A> effects. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The <A HREF="#support" >Support Expert Control</A> is really
  defining the 'order' of the Lagrange filter that should be used.  That is,
  the default 2.0 support Lagrange filter, generates a Lagrange filter of
  order 3 (order = support &times 2 - 1, thus support=2.0 => Lagrange-3
  filter).  This is why you can really only use a setting in half-integer
  sizes.  </P>

  As such, to get a Lagrange order 4 filter you would use the option</I>
  &nbsp; <NOBR><CODE>-define filter:support=2.5</CODE></NOBR>
</FONT></TD></TR></TABLE></P>

<A HREF="graph_lagrange_windowed.jpg"
   ><IMG SRC="graph_lagrange_windowed.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

With larger <A HREF="#support" >support</A> settings, the
'<CODE>Lagrange</CODE>' filter generates <A HREF="#windowed" >Windowed Sinc
Filters</A> without needing a complex trigonometric function calculation, or
even additional windowing functions.  The larger the support setting the
closer the filter emulates a <I>Sinc()</I> function, but also the slower the
calculation. (see graph of larger support Lagrange filters left).  <BR
CLEAR=all></P>

<A HREF="graph_lagrange_interpolate.jpg"
   ><IMG SRC="graph_lagrange_interpolate.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

Using smaller <A HREF="#support" >support</A> settings and the
'<CODE>Lagrange</CODE>' filter emulates most of the various <A
HREF="#interpolated" >Interpolated Filters</A>. That is, a support size of
'<CODE>0.5</CODE>' will generate the '<CODE>Box</CODE>' filter, and
'<CODE>1.0</CODE>' a '<CODE>Triangle</CODE>' filter. </P>

The <A HREF="#support" >support</A> setting is limited to adjustments
by half-integers, and using any other support factor is not very productive.
<BR CLEAR=all></P>

<A HREF="graph_lagrange_even.jpg"
   ><IMG SRC="graph_lagrange_even.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

The other half-integer support, Lagrange Filters (generating even orders),
produce a very disjoint set of filter weightings, and much like the
'<CODE>Box</CODE>' filter, they can produce some strong <A
HREF="#blocking" >blocking</A> resize artifacts.  On the other hand
for small scale resize this can ensure that images keep sharp for very small
resize adjustments. </P>

These 'even' ordered '<CODE>Lagrange</CODE>' filters actually highlight the
main disadvantage of using this filter, which is that the weighting function
is not a 'smooth' gradient. In large scale enlargements this means you can get
visible changes in the generated gradient. This is rarely a problem however,
except in those extreme cases. </P>

Basically it represents a filter that universally creates an appropriate for
the current '<A HREF="#support" >support</A>' setting, regardless of how big
or small that setting is.  It is a self-windowing resize filter.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
   ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE><A HREF="#lagrange" >Lagrange</A></CODE>' filter was not fully
  defined and usable until IM version v6.3.7-1.
</I></FONT></TD></TR></TABLE></P>

<A NAME="cubics"></A>
<A NAME="spline-c"></A>
<A NAME="hermite-c"></A>
<A NAME="catrom-c"></A>
<H3>Cubic Filters</H3>

As many image experts were trying to find a better and faster-to-calculate
filter for image resizing, a family of filters evolved, and became known as
Cubic Filters.  These are much like the <A HREF="#lagrange" >Lagrange
Filters</A> shown previously, and were made up of a smaller fixed set of
piece-wise sections.  However unlike Lagrange filters the pieces were designed
to fit together to form a smooth curve, to reduce sharp <A
HREF="#blocking" >blocking</A> effects. </P>

<A HREF="graph_cubics.jpg"
   ><IMG SRC="graph_cubics.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

Shown in the graph left are four such 'smooth' cubic filters that are
pre-defined within IM, and well known for use as resize filters. </P>

The '<B><CODE>Spline</CODE></B>' filter (also used as an alias and default
seetings for the general '<CODE>Cubic</CODE>' filter function) emulates a <A
HREF="#gaussian" >Gaussian Blurring Filter</A>. This curve is also
known as a 'B-Spline' interpolation curve, and is also commonly used for
drawing smooth lines through a collection of points.  It is also often used for
camera and object motions in animations, to produce a smooth flow though the
user provided control points. </P>

Also shown is '<B><CODE>Catrom</CODE></B>', or more correctly the 'Catmull-Rom
Filter' or the 'Keys Cubic Convolution' which generates a smooth non-blurring
form of <A HREF="#interpolated" >Interpolation Filter</A>. However it
can overshot slightly.  It is essentually an ideal self-sharpened filter, and
as such also the function commonly used for basic <A HREF="../misc/#bicubic"
>Bi-Cubic Interpolation</A>. </P>

And finally the '<B><CODE>Hermite</CODE></B>' Cubic filter, which is type of
smoothed triangular <A HREF="#interpolated" >Interpolation Filter</A>,
That will smooothly slow (roll off) at the input coordinates.  Basically it
rounds off strong edges while preserving flat 'color levels' in the original
image. </P>

<H4>Cubic Filter Families</H4>

The above are the most common 'named' filters of the Cubic Curves, but they
also belong to specific families of Cubic Filters. </P>

The '<B>B-Spline' family</B> of cubics is essentually equivelent to various
degrees of <A HREF="#blurring" >blurring</A> of the results.
Typically ranging from the very <A HREF="#blurring" >blurry</A>
'<CODE>Spline</CODE>' filter, and the edge rounding but <A
HREF="#blocking" >blocky</A> results of the '<CODE>Hermite</CODE>'
filter. </P>

Then there was the '<B>Cardinal' family</B>, which produces filters
compromising between <A HREF="#blocking" >blocking</A> and <A
HREF="#ringing" >ringing</A> artifacts and from which the
'Catmull-Rom Filter' ('<CODE>Catrom</CODE>') evolved as a balanced compromise
of these artifacts.  </P>

These two families then merged to form the '<B>Keys Cubic Filter Family</B>',
which linked the 'Catmull-Rom Filter' (Keys <B>&alpha;</B> = 0.5) with the
'B-Spline Cubic Filter' (Keys  <B>&alpha;</B> = 0.0). </P>

The Keys family of filters also has the special property of preserving any
linear (affine) gradient that may exist across the image.  The <A
HREF="#ringing" >ringing</A> and <A HREF="#blurring"
>blurring</A> effects of a keys family filter would only come into play when
an image contains strong color changes, rather than smooth gradients of color.
</P>

Confused by the variety?  Of course you are. So was everyone else! </P>

The problem is that the results of filters are often very subjective,
dependant on the image, and the restrictions of the 'family' you are using.
Just what made a good filter really depended on who you asked, whether you
were enlarging or shrinking, and what image you were processing.  </P>

In some ways it still is, confusing. It took me over two years of muddling
around, reading, and playing with the various filters to come up with the
start of this summery, and even now it is still evolving.  Image resizing is
a very subjective area, difficult (actually its proven to be imposible) to
quantify in any real way. There is no such thing as a 'perfect' resize. </P>


<A NAME="mitchell"></A>
<H4>Mitchell-Netravali Filter</H4>

Into this, Don P. Mitchell and Arun N. Netravali, came out with a paper, '<A
HREF="http://www.cs.utexas.edu/users/fussell/courses/cs384g/lectures/mitchell/Mitchell.pdf"
>Reconstruction Filters in Computer Graphics</A>', which formulated two
variables known as 'B' (as used for 'B-spline' curves) and 'C' (as used for
the 'Cardinal' curves and equivalent to the 'Keys' filter <B>&alpha;</B>
value).  With these two values you can generate any smoothly fitting
(continuious first derivative) piece-wise cubic filter. </P>

<IMG SRC="../img_diagrams/cubic_survey.gif" WIDTH=301 HEIGHT=320
     ALIGN=right VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>

More importantally they then surveyed a group of 9 image processing experts,
rather than just relying on their own oppion, to classify the <A
HREF="#artifacts" >Artefacts</A> produced by slightly enlarging images using
various values of B and C. The results of that survey are shown in the
recreated diagram to the right.  The 'green' area represented values the
experts regarded as producing an acceptable result, while the various other
areas produce the various types of <A HREF="#artifacts" >Artefacts</A>. </P>

This image is important, as it really shows the relationships between the
various <A HREF="#artifacts" >Artefacts</A> and the various different types
of filters that can be produced. </P>

You can also see from the results why the 'Keys' family of filters became so
important, as one of the better methods of generating good cubic filters. Its
filters basically fell in a line directly through the area regarded as
'acceptable' by the image processing experts.  </P>

From this survey, Mitchell and Netravali determined that the best filter was
a 'Keys' family filter, which fell in the middle of the acceptable area, using
B,C values of 1/3,1/3.  This filter is now known as the 'Mitchell-Netravali
Filter' and is available in IM as the '<B><CODE>Mitchell</CODE></B>' filter
setting.  Basically it is a compromise of all the resize artifacts.  It is
also the default filter used for IM image enlargements. </P>

All the built-in 'named' Cubic filters: '<CODE>Mitchell</CODE>',
'<CODE>Robidoux</CODE>', '<CODE>Catrom</CODE>', '<CODE>Spline</CODE>', and
'<CODE>Hermite</CODE>'; have also been marked in the above diagram, showing
what those experts would think of those specific filters.  Also shown are the
lines representing the 'B-Spline', 'Cardinal' and 'Keys' filter families. </P>

Internally all these filters only differ by the pre-defined B,C settings of
the filter, in fact IM uses the same internal function to generate all cubic
filters, only with different B,C settings to define those filters. </P>

<A NAME="cubic_bc"></A>
<H4>Cubic B,C Expert Controls</H4>

You can use the special expert settings to set the B,C settings that a <A
HREF="#cubics" >Cubic Filter</A> is using. </P>

To do this you need to select the general '<CODE>Cubic</CODE>' filter
'function' (or any of the other named cubic filters), and the desired
'<CODE>b</CODE>' and '<CODE>c</CODE>' expert settings. For example...

<PRE>   -filter Cubic
   -define filter:b=<I>value</I>
   -define filter:c=<I>value</I></PRE>

The expert settings will override the internal defaults for the given filter
when it is used by a resize or distort operator. As such the order of the
above options does not matter, as long as you have "<CODE><A
HREF="../option_link.cgi?define" >-define</A></CODE>" or "<CODE><A
HREF="../option_link.cgi?set" >-set</A></CODE>" all the global expert settings
desired before the image processing operator is used.  </P>

If one of the '<CODE>b</CODE>' or '<CODE>c</CODE>' settings has not been
defined or set, its value will be calculated from the other value on the
assumption that you are wanting a 'Keys' family filter (along the dotted line
in the Mitchell-Netravali Survey diagram).  Remember the '<CODE>c</CODE>' is
equivalent to the Keys <B>&alpha;</B> setting, while '<CODE>b</CODE>' can be
thought of as a cubic spline 'blur' setting. </P>

These expert settings provide a good way for users to 'tune' their image
resizing to get exactly what they want (whether they are using <A
HREF="../resize/#resize" >Resize</A> or <A HREF="../distorts/#distort"
>Distort</A>). </P>

The '<CODE>b</CODE>' setting is easier of the two to understand. Just think of
'b' as 'bluriness'.  A value of b=0 is the very sharp (Catmull-Rom filter),
which tends to produce a negative halo <A HREF="#ringing" >Ringing</A> and
some <A HREF="#aliasing" >Aliasing or MoirÃ©</A> effects.  A value of b=1 tends
to produce an overly blurry (the Spline or Gaussian-like) effect. </P>

This makes it easy for experts (or even normal users) to adjust this value to
find a filter that is 'good to them'.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD ALIGN=justify>
To the right is a table of the B,C values for the specifically 'named' <A
HREF="#cubics" >Cubic Filters</A>. </P>

Remember '<CODE>Hermite</CODE>' is the only built-in cubic filter that does
not form part of the 'Keys' filter family. It also has the smallest support
('<CODE>1.0</CODE>') of all the BC Cubic filters, and does not contain
a negative lobe. </P>

The '<CODE><A HREF="#robidoux" >Robidoux</A></CODE>' and '<CODE><A
HREF="#robidoux_sharp" >RobidouxSharp</A></CODE>' filters are very similar to
'<CODE>Mitchell</CODE>', but rather than the result of a survey, they were
determined mathematically for special use as a <A HREF="#cylindrical"
>Cylindrical Filter</A>. </P>

The '<CODE><A HREF="#robidoux" >Robidoux</A></CODE>' filter is the default
filter used by the <A HREF="../distorts/#distort" >General Distort Operator</A>
(see below). </P>

</TD><TD>&nbsp;</TD><TD>
<TABLE BORDER=1 BGCOLOR="#CCCCCC">
<TR><TH>Filter</TH>   <TH>B<BR>&nbsp;blur&nbsp;</TH>
                                         <TH>C<BR>Keys&nbsp;&alpha;</TH></TR>
<TR><TD>Hermite</TD>  <TD ALIGN=center>0.0</TD><TD ALIGN=center>0.0</TD></TR>
<TR><TD>Spline</TD>   <TD ALIGN=center>1.0</TD><TD ALIGN=center>0.0</TD></TR>
<TR><TD>Catrom</TD>   <TD ALIGN=center>0.0</TD><TD ALIGN=center>1/2</TD></TR>
<TR><TD>Mitchell</TD> <TD ALIGN=center>1/3</TD><TD ALIGN=center>1/3</TD></TR>
<TR><TD>Robidoux</TD>
                <TD ALIGN=center>0.3782</TD><TD ALIGN=center>0.3109</TD></TR>
<TR><TD>Robidoux<BR>Sharp</TD>
                <TD ALIGN=center>0.2620</TD><TD ALIGN=center>0.3690</TD></TR>
<TR><TD>Robidoux<BR>Soft</TD>
                <TD ALIGN=center>0.6796</TD><TD ALIGN=center>0.1602</TD></TR>
</TABLE>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE>Parzen</CODE>' windowing filter uses a '<CODE>Spline</CODE>'
  filter as its windowing function.  As such you can re-define this windowing
  filter in terms of B,C expert options.  How useful this is, and what effect
  it has on the resulting windowed Sinc (or Jinc), is unknown, and not
  recommended.

</I></FONT></TD></TR></TABLE></P>

<A NAME="cylindrical"></A>
<H3>Cylindrical Filters
<FONT SIZE=-1>- for Distort</FONT></H3>

As we have touched on a number of times already, the <A
HREF="../distorts/#distort" >Distort Operator</A> uses the filter setting to
resample images in a slightly different way to the <A HREF="../resize/#resize"
>Resize Operator</A>. </P>

Specifically <A HREF="../distorts/#distort" >Distort</A> applies the filter
using the 'radial' distance between the 'sample point' and the actual pixels
within the sampling area of the source image, to determine weights of each
pixel and thus the final color at the sample point. </P>

<A HREF="../resize/#resize" >Resize</A> in contrast, processes the image twice
using orthogonally aligned filters. Once in the X direction, and then again in
the Y direction, it is thus limited to simple rectangular resizing of images,
and does not involve the use of <A HREF="../misc/#virtual"
>Virtual-Pixels</A>.  </P>

That is to say <A HREF="../distorts/#distort" >Distort</A> applies the filters
to produce '<I>Cylindrical</I>' shapes rather than 'Box' shapes, so as to
allow free-form distortions of images, including rotations and variable
scaling (stretching and compression) in any direction, not just along the X or
Y axis.</P>

Because of this the filters themselves often need to be adjusted or are
designed specifically for this type of usage. </P>


<A NAME="cyl_interpolated"></A>
<H4>Interpolated Cylindrical Filters</H4>

Here I use a '<CODE><A HREF="#box" >Box</A></CODE>' filter to enlarge a single
pixel image by 30 times using the equivalent <A HREF="../resize/#resize"
>Resize</A> and <A HREF="../distorts/#distort" >Distort</A> operators.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert xc:  -bordercolor black -border 1 \
          -filter Box   -resize 3000%      dot_resize_box_black.png
  convert xc:  -bordercolor black -border 1 \
          -filter Box   +distort SRT 30,0  dot_distort_box_black.png
</CODE></PRE></TD></TR></TABLE><NOBR>
<TABLE CELLPADDING=0 CELLSPACING=0><TR VALIGN=bottom>
<TD ALIGN=center>
  <A HREF="dot_resize_box_black.png"
     ><IMG SRC="dot_resize_box_black.png"
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <BR>Resize

</TD><TD ALIGN=center>
  <A HREF="dot_distort_box_black.png"
     ><IMG SRC="dot_distort_box_black.png"
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <BR>Distort
</TD></TR></TABLE>
</NOBR></DIV></P>

As you can see when the '<CODE><A HREF="#box" >Box</A></CODE>' filter is used
as a Cylindrical filter you get a circle (or a cylinder in 3 dimensions).
However because of the way the filter is handled you get some areas where two
pixels are sampled (equally) to produce a perfect mid-tone gray. </P>

You can think of a cylindrical box filter converting the source image into
a whole set of overlapping circlular pixels that are blended (not added)
together. </P>

Here is a more colorful example of the results of expanding an image using
a 'Cylindrical Box' filter for enlargement...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert \( xc:red   xc:white xc:black +append \) \
          \( xc:blue  xc:lime  xc:white +append \) \
          \( xc:black xc:red   xc:blue  +append \) -append \
          -filter Box   +distort SRT 30,0  color_box_distort.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="color_box_distort.gif"
      ><IMG SRC="color_box_distort.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

With a distorted image, these circular pixels are also distorted into
a set of overlapping ellipses.  For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert \( xc:red   xc:white xc:black +append \) \
          \( xc:blue  xc:lime  xc:white +append \) \
          \( xc:black xc:red   xc:blue  +append \) -append \
          -alpha set -virtual-pixel transparent -filter Box \
          +distort Perspective '0,0 0,0  0,3 0,90 3,0 90,30 3,3 90,60' \
          color_box_distort.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="color_box_distort.png"
      ><IMG SRC="color_box_distort.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The support 'radius' for a cylindrical '<CODE>Box</CODE>' filter is
  increased from '<CODE>0.5</CODE>' to '<CODE>0.707</CODE>'
  (<CODE>sqrt(2)/2</CODE>). This ensures the filter will always find at least
  one source pixel in the circular sample area (diagonally).  This is the
  minimum practical support size for any cylindrical filters. </P>

  No other filter has this coverage problem, requiring an increase in support.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  If the support is not at least '<CODE>0.707</CODE>', then you may get areas
  of your image in which the filter 'misses' all source pixels, and thus
  produce a <A HREF="../distorts/#distort_failure" >Resampling Failure</A>. </P>

  Using a larger support setting also produces interesting patterns. As
  'circles' become larger, and more pixels will become blended together.
  For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert \( xc:red   xc:white xc:black +append \) \
          \( xc:blue  xc:lime  xc:white +append \) \
          \( xc:black xc:red   xc:blue  +append \) -append \
          -filter Box -define filter:support=0.83 \
          +distort SRT 30,0  color_box_distort_overlap.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="color_box_distort_overlap.png"
      ><IMG SRC="color_box_distort_overlap.png"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE> </P>
  The result is a sort of circular form of a <A HREF="../misc/#blend" >Blend
  Interpolation</A>. </P>

  At a support of 1.0 or larger every resample will be a 'box' or 'average'
  blending of at least two pixels. </P>


</I></FONT></TD></TR></TABLE></P>
<BR>

Here is a comparison of a number of the interpolation filters.  Gray colors
are used so that you can see over and undershoots.  The top line using
an orthogonal resize, while the bottom line uses a cylindrical distortion.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  for filter in box triangle hermite lagrange catrom
  do
    convert xc:gray80  -bordercolor gray20 -border 2 \
            -filter $filter   -resize 2000%      dot_resize_$filter.png
    convert xc:gray80  -bordercolor gray20 -border 2 \
            -filter $filter   +distort SRT 20,0  dot_distort_$filter.png
  done
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0 WIDTH=80%><TR><TD ALIGN=center>
  <A HREF="dot_resize_box.png"
     ><IMG SRC="dot_resize_box.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="dot_distort_box.png"
     ><IMG SRC="dot_distort_box.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR>Box
</TD><TD ALIGN=center>
  <A HREF="dot_resize_triangle.png"
     ><IMG SRC="dot_resize_triangle.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="dot_distort_triangle.png"
     ><IMG SRC="dot_distort_triangle.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR>Triangle
</TD><TD ALIGN=center>
  <A HREF="dot_resize_hermite.png"
     ><IMG SRC="dot_resize_hermite.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="dot_distort_hermite.png"
     ><IMG SRC="dot_distort_hermite.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR>Hermite
</TD><TD ALIGN=center>
  <A HREF="dot_resize_lagrange.png"
     ><IMG SRC="dot_resize_lagrange.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="dot_distort_lagrange.png"
     ><IMG SRC="dot_distort_lagrange.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR>Lagrange
</TD><TD ALIGN=center>
  <A HREF="dot_resize_catrom.png"
     ><IMG SRC="dot_resize_catrom.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="dot_distort_catrom.png"
     ><IMG SRC="dot_distort_catrom.png"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR>Catrom
</TD></TR></TABLE>
</NOBR></DIV></P>

You can see how the results are similar but with different syles of <A
HREF="#artifacts" >Artefacts</A> being generated, both internally and
externally (ringing), by the two different ways in which the filter is being
applied.  The internal artifacts is especially evident in the
'<CODE>Triangle</CODE>' filter.  </P>

However remember that interpolation filters are not particularly good for
extreme minification (shrinking) of distorted images, but they are very good
for magnification (enlarging). </P>


<A NAME="cyl_gaussian"></A>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

<H4>Cylindrical Gaussian</H4>

The one filter which produces no difference in results between an
orthogonal 'resize' and a cylindrical 'distort' forms,  is the special
'<CODE><A HREF="#gaussian" >Gaussian</A></CODE>' filter...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert xc:red -bordercolor yellow -border 1 \
          -filter Gaussian   +distort SRT 33,0  -normalize  dot_distort.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
   <A HREF="dot_distort.jpg"
      ><IMG SRC="dot_distort.jpg"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is actually one of the special proprieties of this filter (known as
separability), and one of the reasons why many cylindrical resampling
implementations use it as the default filter.  It was the default for the
original EWA paper, but is also very blurry in its results. ImageMagick also
used it when distorts were first implemented, but not any more.  </P>

Just as it is for orthogonal resize, a '<CODE>Gaussian</CODE>' filter will
produce absolutely no <A HREF="#aliasing" >Aliasing Artefacts</A> in the
resulting image, even when you apply it to the special 'rings' image. But the
cost of this is a blurry result, even if little or no distortion is actually
involved.  </P>

Similarly as given in the discussion on the <A HREF="#sigma" >Sigma
Expert Control</A>, you can also use this filter as a type of interpolated
filter. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As of IM v6.6.5-0, IM no longer used this filter, by default for <A
  HREF="../distorts/#distort" >Image Distortions</A>. Instead another filter
  '<CODE><A HREF="#robidoux" >Robidoux</A></CODE>' filter specifically
  designed to produce a sharper result is used. </P>

  In any case, before this version distortions were also very blurry due to
  a mistake in its implementation. Upgrade if you have an older version and
  want to use <A HREF="../distorts/#distort" >Image Distortions</A>. </P>

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.6.7-6, IM would use a slightly larger 'sigma' value for
  a Cylindrical Gaussian, of 1/sqrt(2) or approximatally 0.707, instead of
  1/2.  This resulted in a slightly more blurry result, which was to reduce
  posible <A HREF="#aliasing" >Aliasing Artefacts</A>. </P>

  This was a mistake which was created by following a research papers
  recommendation, in passing the larger support for a <A
  HREF="#cyl_interpolated" >Cylindrical Box Filter</A>, into the
  Gaussian Filter. The reasoning that was put forward was that Gaussian is
  essentually a blurred box. It isn't. A Gaussian is a blurred impulse not
  a blurred box.  This version removed that mistake, which now means you
  should get equivelent results with either resize or distort, when the
  gausian filter is used. </P>

  I personally find using this slightly larger sigma value does indeed smooth
  out any 'blocking' artifacts along aliased diagonal edges when doing
  enlargements of line drawings.  But that is a special case. </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="jinc"></A>
<H4>Windowed Jinc Cylindrical Filters</H4>

   <A HREF="graph_jinc.jpg"
      ><IMG SRC="graph_jinc.gif"   WIDTH=180 HEIGHT=120
            ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

The <I>Jinc()</I> function (sometimes inaccurately called
a '<CODE>Bessel</CODE>' filter) is the 'Sinc' equivalent for use with
a cylindrical filtering operation.  Though very similar and closely related to
<I>Sinc()</I>, it is designed to filter a rectangular array of values using
a radial or cylindrical distance, rather than only in orthogonal (axis
aligned) directions. </P>

If you look at the provided graph of the <I>Jinc()</I> function, you will find
that its first 'zero-crossing', representing first ring of near neighbours,
falls between the values of 1.0 (for orthogonal neighbours) and the square
root of 2.  That is the zero crossing has an approximate value of
'<CODE>1.2196699</CODE>'. </P>

The way <I>Jinc()</I> function works is that if the sampling point is equal to
an actual pixel value, the <I>Jinc()</I> function will assign a positive value
to the slightly closer orthogonal neighbouring pixels, but then assign
a similar negative value to the slightly further diagonal neighbours, and so
on as it moves further though the 2 dimentional array of values.   As a result,
when no scaling (distortion) is performed the contributions of the neighbours
should, in theory, cancel each other out. </P>

This is why the <I>Jinc</I> filter is mathematically the preferred solution to
cylindrical resampling of a square array, and thus the 'ideal' filter for <A
HREF="../distorts/#distort" >Distort</A> elliptical resampling method (EWA).
This is not to say it is a 'perfect' filter from a human point of view.  </P>

Because of this, selecting any <A HREF="#windowed" >Windowed Filter</A> while
using the <A HREF="../distorts/#distort" >Distort Operator</A>, will
substitute the normal '<I>Sinc()</I>' function with the equivalent
'<I>Jinc()</I>' function. </P>

As the <I>Jinc()</I> function has zero crossings are at non-integer positions,
it is very important to specify the filters support in terms of special <A
HREF="#lobes" >Lobes Support Setting</A> introduced above for <A
HREF="#windowed" >Windowed Sinc Filters</A>.  </P>

The biggest problem with using a 'Windowed Jinc' filter is when the source
image contains a pixel level hash pattern (such as provided by
"<CODE>pattern:gray50</CODE>", see <A
HREF="https://legacy.imagemagick.org/script/formats.php#builtin-patterns"
>Built-In Patterns</A>).  In this situation all the orthogonal neighbours are
different to diagonal neighbours, and as a result, the image becomes heavily
blurred by the '<I>Jinc()</I>' function. </P>

However just about any other pattern, such as lines, edges, corners, all
remain quite sharp and clear when using a 'Windowed Jinc' filter, making it
still a good function to use. </P>

This 'problem' can be a good thing, as it means that 2-dimentional cylindrical
Jinc derived filter can be used as method of removing strong pixel hash type
patterns from images, such as those generated by a <A
HREF="../quantize/#dither" >Color Reduction Dither</A>, without greatly
effecting the sharpness of the rest of the image. That is it could be used as
a 'Dither Removal Method' (see below). </P>


<A NAME="distort_noop"></A>
<H3>Distort and Filters in the No-Op case</H3>

Ideally, no-op distortion should return exactly the same image. But as you
have seen in previous examples, this may not actually happen. </P>

The resize (2-pass 1 dimensional) filters: Lanczos (Sinc-Sinc), Lanczos2,
Catrom, Hermite, Triangle, and many other resize filters do have this
property.  The pixel pattern is preserved exactly if the image is not scaled.
</P>

On the other hand smoothing or blurring filters, like Gaussian, Cubic, and
Quadratic will blur an image if applied to a nearly no-op case.  Note that
even the resize filter default, Mitchell-Netravali, also contains some blur in
it, as is basicaly a blend of  B-spline 'Cubic' smoothing filter and the
Cublic two-lobe sinc equivelent Catmull-Rom filter. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The resize operator will by default short-circuit itself, so as to do
  nothing for the no-op case.  As such unless you specifically specify
  a filter you can not generate a 'noop' resize.  </P>

  Distort will never short-circuit for the no-op case, and that is to ensure
  consistancy in animations in which the distortion scaling may pass through
  the 'no-op' case.  This is something that is typically not a concern with
  resize. </P>

</I></FONT></TD></TR></TABLE></P>

While many resize filters will preserve images in the no-op case.  Cylindrical
(distort) methods, will basically never produce a perfect no-op distortion.
Any no-op distort will at least minimally distort the colors of an image, even
though the image itself is not distorted. </P>

What happens is that by using a cylindrical filter, the contribution of
orthogonal neighbourhood pixels will be different to that for diagonal
neighbourhood pixels.  They are essentually different distances from the
lookup point (centered on an actual pixel for the no-op case.  The 'Jinc'
function tries to reduce this color distortion by canceling out the
contributions of the orthogonal neighbours with that of the diagonal
neighbours.  That is actually part of its mathematical definitation. </P>

In the worst case, a 'pixel level hash', every diagonal pixel neighbour is
different to every orthogonal pixel neighbour.  In this case the filter
weightings will enhance rather than cancel the contributions.  As a result
this type of image will tend to produce very sever color distortions for
a no-op distortion of any image containing a 'pixel level hash'.  </P>

Here for example I actually use this special property to remove a hash
pattern from an image. No scaling is used, just a distortion applied
2-dimentional 'convolution' on the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert -size 100x100 pattern:gray50  hash.png
  convert hash.png -filter Lanczos -distort resize 100% hash_removed.png
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=5 CELLPADDING=0><TR VALIGN=top><TD ALIGN=center>
<TD ALIGN=center>
  <A HREF="hash.png"
     ><IMG SRC="hash.png"        WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 VSPACE=40 ALT="==>">
</TD><TD ALIGN=center>
  <A HREF="hash_removed.png"
     ><IMG SRC="hash_removed.png"        WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The reason the percieved gray-level of the hash is so much darker than the
  the overall gray-level of the hash is because of the way <A
  HREF="../color_basics/#perception" >Human Color Perception</A> works.</P>

  The fix is to include '<CODE>-set colorspace RGB</CODE>' in the above to
  tell IM that we are resizing in linear-RGB colorspace See <A
  HREF="../resize/#resize_colorspace" >Resizing with Colorspace
  Correction</A>. </P>

</I></FONT></TD></TR></TABLE></P>

The above is actually equivelent to a <A HREF="../convolve/#intro"
>Convolution</A> with a Jinc-like kernel function.  </P>

But as you can see the special property of the Jinc Function (in this case
EWA Lanczos, or Jinc windowed Jinc), completely removed the hash pattern that
was strongly present in the original image. The only part where it now remains
is along the edges, where the 'abyss' (no virtual pixel contribution) that
surrounds the image proper, can effect the results. </P>

The actual number of lobes of a Windowed Jinc filter, has an enormous bearing
on the results as well.  With 2 lobes, a 'pixel level hash' has a tendancy to
be preserved, though dulled or blurred.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert hash.png -filter Lanczos2 -distort resize 100% hash_2_lobes.png
</CODE></PRE></TD></TR></TABLE></P>

The contribution of the windowing method applied to the Jinc function, will
also have major influence on this effect. In some case even enhance the hash
pattern further. </P>

</TD><TD>
  <A HREF="hash_2_lobes.png"
     ><IMG SRC="hash_2_lobes.png"        WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The question thus arises of how to tune the distort filters so as to minimize
the color distortions generated by the filter for a no-op distortion.  The way
Nicolas Robidoux decided to do this was by selecting a blur (rescaling of the
support of the filter kernel) that tends to preserve orthogonal edges as much
as posible. </P>

<A NAME="lanczos_cylindrical"></A>
<H4>Cylindrical Lanczos Filter</H4>

Now as discussed above "</B><A HREF="#lanczos" ><CODE>Lancoz</CODE></A></B>"
is normally defined as a '<I>Sinc()</I>' function used both the weighting and
windowing of the filter. </P>

But when used as an EWA cylindrical filter, BOTH of the weighting functions
will be replace by the '<I>Jinc()</I>' function.  That is not only is the
weighting function replaced (as it is for the other linear windowed filters),
but it also replaces the windowing function, producing a Jinc windows Jinc
weighting function.  </P>

As such a 'Cylindrical Lanczos' will select a "Jinc windowed Jinc" with the
same number of lobes (default 3). This technique was first advocated by
Andreas Gustafsson, in thesis on  <A
HREF="http://www.gson.org/thesis/warping-thesis.pdf" >Interactive (Local)
Image Warping</A> (page 24).  He specifically used a 2-lobed Cylindrical
Lanczos (Jinc windowed Jinc) filter which he named '<CODE>Lanczos2D</CODE>'
(see next).  This was simply an obvious extension for the planar (EWA)
situation. Hence the use of the same name.  </P>

For more info on this see this <A HREF="../forum_link.cgi?f=22&t=19823&p=79247"
>Post in BC-splines Discussion</A>. </P>


<A NAME="lanczos2"></A>
<H4>Lanczos2 - 2-lobed Lanczos</H4>

For convenience this two lobed version, simply named
'<CODE><B>Lanczos2</B></CODE>', was included in IM v6.6.4-10, specially for
use in distortions.</P>

It is really just a cylindrical '<CODE>Lanczos</CODE>' (Jinc-Jinc) filter with
a '<CODE>filter:lobes=2</CODE> expert setting. See the <A
HREF="graph_jinc.jpg" >graph above</A>, and as IM filter automatically
switches between using <I>Sinc()</I>, and <I>Jinc()</I> functions as
appropriate, it is not just for a '2D' (cylindrical) use. </P>

It can can also be used for resize too (as a Sinc-Sinc function), though
I don't recommend it as it is probably a bit too small, and becomes pratically
equivelent to the various other cubic functions. </P>


<A NAME="lanczos_sharp"></A>
<H4>LanczosSharp - A slighly sharpened Lanczos</H4>

It was observed that windowing a <I>Jinc()</I> function leads to much blurrier
EWA distort results, than analogous windowed <I>Sinc()</I> function, in the
orthogonal resize results (especially with thin lines).  This was particularly
the case for mild distortions.  Basically, the <I>Jinc()</I> function has some
special properties and windowing the <I>Jinc()</I> function messes up those
specific and desirable properities.  </P>

With some calculation, Nicolas Robidoux, Professor of Mathematics at
Laurentian University, was able to work out a slightly sharper version of
a 3-lobed Cylindrical Lanczos, now available as
'<CODE><B>LanczosSharp</B></CODE>', that to some extent fixed the problem for
distorting images. </P>

However the resulting filter still has the strong blurring of low level 'pixel
hash' patterns, of <A HREF="#jinc" >Windowed Jinc Cylindrical Filters</A>.
</P>

<A NAME="lanczos2sharp"></A>
<H4>Lanczos2 Sharpened</H4>

<A HREF="graph_cyl_lanczos_2.jpg"
   ><IMG SRC="graph_cyl_lanczos_2.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

The same problem was more severe in '<CODE>Lanzcos2</CODE>' filters, so
Nicolas also produce a sharper '<CODE><B>Lanczos2Sharp</B></CODE>' filter,
using a slightly larger <A HREF="#blur" >Blur Expert Control</A>.  This
resulted in a filter with only minimal blurring for vertical or horizontal
lines in a 'no distort' case. </P>

This sharpened filter results in a small shift of the zero point, so that it
is now located at approximatally '<CODE>1.1684</CODE>'.  This may not seem
like much but it makes a huge difference in the amount of blur the filter
generates for images with little to no distortion. </P>

<A NAME="lanczos_radius"></A>
<H4>Lanczos Radius</H4>

<A HREF="graph_cyl_lanczos_3.jpg"
   ><IMG SRC="graph_cyl_lanczos_3.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

This is an EWA Lanczos filter that is blurred (sharpened) so that the number of
lobes used (3 by default) fits into an integer support radius.  That is
a 3 lobe EWA Lanczos (based on a Windowed Jinc) is sharpened to have a support
of exactly radius 3. </P>

You can use the <A HREF="#lobes" >Lobes Expert Control</A>, to achieve the
same result, but as it involves an adjustment based on the known zero crossing
of the Jinc function, but it is not an easy calculation to make. </P>

Nicolas recommended the addition of this filter so you don't need to do that
calculation, and allow you to test out this very specifically sharpened
filter. </P>

<I>FUTURE: table of blur factors to the Jinc Windowed Jinc filters.<BR>
Include number of lobes as a reference. </I></P>


<A NAME="robidoux"></A>
<H4>Robidoux Cylindrical Filter</H4>

<A HREF="graph_robidoux.jpg"
   ><IMG SRC="graph_robidoux.gif"   WIDTH=180 HEIGHT=120
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>


Strangely, experiments were showing that using a <A HREF="#mitchell"
>Mitchell-Netravali</A> filter as a cylindrical filter was producing near
equivalent 'sharp' results for the 'no distort' case.  And yet the filter has
no relationship to its use as a cylindrical filter, as it was selected by a
'social study' for orthogonal (resize) filtering. </P>

The '<CODE>Mitchell</CODE>' filter was especially good at preserving low-level
'pixel hash' patterns, which normal <A HREF="#jinc" >Windowed Jinc Filters</A>
destroyed in cylindrically filtered images. </P>

Nicolas then found that by a bizarre coincidence that '<CODE>Mitchell</CODE>'
was extremely close to the 'sharpened' form of '<CODE>Lanzcos2</CODE>' filter
discussed above. </P>

This in turn lead to him developing a <A HREF="#cubics" >Keys Cubic
Filter</A> which preserves vertical (and horizontal) lines perfectly.  Also
this new filter does so at a lesser computational cost, as a cubic function is
very cheap to compute than a Jinc function. </P>

This cubic filter has been added to IM as the '<CODE><B>Robidoux</B></CODE>'
filter, as of IM v6.6.5-0, and is also the default filter used by <A
HREF="../distorts/#distort" >Distort</A> and its <A
HREF="../distorts/#area_resample" >Elliptical Weighted Resampling</A> method,
specifically due to its minimal-blur propriety for images with only minimal
distortion. </P>

That is not to say that it is 'the best' filter to use, and even Nicolas likes
to use other filters, but it is a very good compromise, just as
'<CODE>Mitchell</CODE>' is a good compromise for orthogonal (tensor) resizing.
</P>

I have marked this filter on the "<A HREF="../img_diagrams/cubic_survey.gif"
>Cubics Map</A>" generated by the <A HREF="#mitchell" >Mitchell-Netravali
Survey</A>, so you an see just how closely related to the '<CODE><A
HREF="#mitchell" >Mitchell</A></CODE>' filter it is.  It would in fact make
a reasonable filter for either orthogonally resized or cylindrically distorted
images. </P>

<A NAME="robidoux_sharp"></A>
<H4>Robidoux Sharp Cylindrical Filter</H4>

The '<CODE><B>RobidouxSharp</B></CODE>' filter is a slightly sharper version
of the '<CODE><A HREF="#robidoux" >Robidoux</A></CODE>' filter, though some
feel that the results are too sharp. </P>

It is designed specifically so as to preserve images containing pure black and
white pixels with the minimum of error, in the "no-distort" case.
Specifically that the weightings the orthogonal neighbouring pixels, exactly
match the negative weightings of diagonal neighbouring pixels in
a 'no-distort' case. </P>

By coincidence the  '<CODE><A HREF="#mitchell" >Mitchell</A></CODE>' filter
happens to fall almost exactly between the '<CODE><A HREF="#robidoux"
>Robidoux</A></CODE>' filter and the '<CODE><A HREF="#robidoux_sharp"
>RobidouxSharp</A></CODE>' filter, and all belong to the <A
HREF="#cubics" >Cubic Keys</A> family of filters. </P>

As such users can select from any of these three filters to control the
blur-sharpness of results in near 'no-distort' situations. </P>

For details of this filter see the <A
HREF="../forum_link.cgi?f=22&t=19823&p=83898" >BC-splines</A> discussion on IM
Forums. </P>


<A NAME="robidoux_soft"></A>
<H4>Robidoux Soft Cylindrical Filter</H4>

This was added much later, and is very different to the other Cylindrical
filters seen.  Yes it is much more blurry to make it more useful for
upsizing or enlarging images, which allows it to avoid some staircasing
effects on photos of brick buildings. </P>

For more info on this see this <A
HREF="../forum_link.cgi?f=22&t=19823&p=109820" >Post in BC-splines
Discussion</A>. as well as this discussion from a <A
HREF="http://www.luminous-landscape.com/forum/index.php?topic=77949.msg723814#msg723814"
>photo processing forum discussion</A>. </P>



<A NAME="cyl_summary"></A>
<H4>Cylindrical Filter Summary</H4>

Nicolas Robidoux in the long, and on going, forum discussion on the <A
HREF="../forum_link.cgo?p=83754" >Proper Scaling of a Jinc Filter in EWA</A>
gives this as a summary of cylindrical filters... </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1>
  If Robidoux is too soft and RobidouxSharp too aliased, I suggest that you
  try Mitchell (with distort Resize), which is pretty much halfway. </P>

  Because JPEG involves a (Discrete) Cosine Transform, I am not surprised that
  the filters based on Fourier considerations (Lanczoses et al, whether resize
  with Sinc or distort with Jinc) generally do better than those based on
  "good approximations of smooth functions" (those based on Keys cubics:
  Robidoux, Mitchell, RobidouxSharp, CatRom, whether with resize or distort).
  That advantage appears to be less with PNGs (which does not destroy
  information through the Fourier domain). </P>

</FONT></TD></TR></TABLE></P>

Nicolas has a lot more to say. So much he has his own section <A
HREF="nicolas/" > Resampling by Nicolas Robidoux</A> which is now
a separate and extensive page in its own right. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="options"></A>
<H3>Expert Filter Controls</H3>

In the various sections above I introduce a large number of special 'expert'
controls, which will allow you to modify the various filters in various ways.
You define these expert settings using <A HREF="../basics/#define" >Global
Define Setting</A> (or equivalent  <A HREF="../basics/#set" >Set
Option</A>). </P>

A full summary of all the expert option in the <B>IM Command Line Options
Reference Page</B> for "<CODE><A HREF="../option_link.cgi?filter"
>-filter</A></CODE>". </P>

The "<CODE><A HREF="../option_link.cgi?filter" >-filter</A></CODE>" setting is
in fact only used to lookup and set the expert controls appropriately so as to
define the given 'named' resize filter.  These settings will override
those default values as specified above, at the time filter is setup for
a specific resize or distortion image processing operation. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE><A HREF="../option_link.cgi?filter" >-filter</A></CODE>" setting
  'Point' completely bypasses all the above filter setup, and degenerates into
  an unscaled 'Nearest Neighbor' direct lookup (resize), or interpolated
  lookup (distort). Thus this named filter setting effectively turns off the
  scaled image lookup filter completely.
</I></FONT></TD></TR></TABLE></P>

Now while they are available. I would like to make one final point.
<DIV ALIGN=center><B>
    Unless you are an expert (or just playing) -- It is best NOT use them!
</B></DIV></P>

There are few people who are expert at image processing, and unless you know
exactly what filters do and how changing them effects the filtering method,
all you are likely to do is destroy the effectiveness your image processing,
and produce a bad looking results. Especially in images other than your test
cases. </P>

That is not to say users should not use them, and many IM Examples do make use
of them, but it is usually done to provide some special effect. When a special
option is used the reason for its use is also explained, and you should stick
to the recipe given for that effect. </P>

You are of course welcome to use them and you can generate some very
interesting and highly unusual effects by making use of them. </P>

<H4>The 'verbose' Filter Control</H4>

The setting "<CODE>filter:verbose</CODE>" is perhaps your best friend in
figuring out and understanding the other filter controls. </P>

For example you can verify that the Lanczos filter is defined in terms of
a Sinc windowed Sinc support 3.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE IMAGE=filter_verbose.txt OUT=filter_verbose.txt>
  convert null: -filter Lanczos -define filter:verbose=1 \
          -resize 2    null:    | grep '^#'
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="filter_verbose.txt"
     ><IMG SRC="filter_verbose.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Note that internally the Lanczos filter is defined in terms of a fast
polynomial equivalent 'SincFast' (4 lobe) function, rather than a full 'Sinc'
function which is defined in terms of far more computationally intensive
Trigonometric Library functions.  </P>

Here we see that the Lanczos filter is defined as a Jinc windowed Jinc filter
when used with as a cylindrical (<A HREF="../distorts/#area_resample" >EWA
Algorithm</A>) "-distort" filter.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE IMAGE=filter_verbose2.txt OUT=filter_verbose2.txt>
  convert null: -filter Lanczos -define filter:verbose=1 \
          -distort SRT 0   null:   | grep '^#'
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="filter_verbose2.txt"
     ><IMG SRC="filter_verbose2.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

The '<CODE>filter:verbose</CODE>' setting is the only way users can check on
exactly what the final resultant filter is, due to the use of the various
expert settings. </P>

After the '#' commented header of filter settings, a set of data points
generated by the filter is returned.  These are specifically provided for
graphing the filters data, and lets you further verify and check just what the
filter is producing without making guesses from the results of test images.
</P>

For example, extract the data of a Welch Windowed Sinc Filter...
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert null: -filter Welch -define filter:verbose=1 \
          -resize 2 null:  &gt; filter_welch.dat
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

Or the raw Welch Windowing Function that was used in the above, with the
window function scaled a support range of 0 to 1.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert null: -define filter:filter=Box \
                -define filter:window=Welch \
                -define filter:support=1.0 \
                -define filter:verbose=1 \
           -resize 2 null:  &gt; window_welch.dat
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

You can then plot that data with the "<A HREF="http://www.gnuplot.info/"
>gnuplot</A>" command (like I did in <A HREF="#windowed" >Windowed Sinc
Filters</A> above)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  gnuplot
    set grid
    plot "window_welch.dat" with lines
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

<H4>Other Examples of Expert Filter Controls</H4>

Create a 'Raw 8 lobed Sinc' filter can be set using...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -define filter:filter=Sinc
  -define filter:lobes=8
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

Use the Blackman windowing function directly as a filter (as IM did by
mistake, before v6.3.6-3).

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -define filter:filter=Blackman
  -define filter:support=4.0
</CODE></PRE></TD></TR></TABLE>
</DIV>

The windowing function will default to 'Box' when undefined. </P>

A 'Box' windowing function will result in no windowing of the base filter
function.  For example a 'Gaussian' filter by default has a 'Box' windowing
function. The only effect a box windowing function has is a clipping of
windowed area of the function.  See <A HREF="#support" >Filter Support Expert
Control</A> above. </P>


Force the use a raw Jinc function (explicitly setting 'Box' windowing)
using...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -define filter:filter=Jinc
  -define filter:window=Box
  -define filter:lobes=3
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

A 12 lobed 'Lanczos' windowed filter clipped to just the first 8 lobes of the
resulting windowed filter...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -filter Lanczos
  -define filter:win-support=12
  -define filter:support=8
</CODE></PRE></TD></TR></TABLE>
</DIV>
This makes it about four times faster, by ignoring (support clipping at 8) the
window-modulated 'tail' (to 12) of the resulting windowed-sinc filter.  This
however may result in some extra but minor artifacts as a result of the
support clipping. </P>


Using Gaussian to 'blur' an image! This is equivalent to a -gaussian 5x2
operation, but by using a no-op distort!

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -filter Gaussian
  -define filter:sigma=2
  -define filter:support=5
  -distort SRT 0
</CODE></PRE></TD></TR></TABLE>
</DIV>

Note: you can not use -resize for this, as it may short circuit the operation
and result in operation not being performed at all. </P>


Create a different filter from the 'Mitchell-Netravali' survey.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -filter Cubic
  -define filter:b=0.5
  -define filter:c=0.5
</CODE></PRE></TD></TR></TABLE>
</DIV>

Create your own 'Keys Cubic' filter with &alpha; value of 0.4...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -filter Cubic
  -define filter:c=0.4
</CODE></PRE></TD></TR></TABLE>
</DIV> </P>

Nicholas Robidoux creating this weird filter while exploring '<A
HREF="../forum_link.cgi?t=20007" >Interpolating EWA
Filters</A>'

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -define filter:blur=.7071067811865475
  -define filter:c=.49257366
  -define filter:b=2.089813051319261
  -filter Cubic
</CODE></PRE></TD></TR></TABLE>
</DIV> </P>

When used to enlarge images. Pixels are converted into diamond like patterns
in a scheme that is simular to <A HREF="../misc/#interpolate_simple"
>Blend</A> but using diamonds instead of squares. </P>


Any use of the expert options are at your own risk.  They are not meant for
production use, but as a method for exploring or producing tricky or otherwise
impossible resize functions. </P>

Use at your own peril! </P>


<A NAME="summery"></A>
<H3>Summary of Resize Filters</H3>

The following is my own personal view after studying, recoding, and
documenting all the above filters available in ImageMagick.  If you think I
may be wrong or like to express your opinion, I invite you to express your
views on the IM forum, and invite me to respond. </P>

<A HREF="#interpolated" >Interpolation Filters</A>, such as
'<CODE>Hermite</CODE>', are ideal when greatly enlarging images, producing a
minimum of blur in the final result, though the output could often be
artificially sharpened more in post-processing. </P>

<A HREF="#gaussian" >Gaussian-like Blurring Filters</A>, such as
'<CODE>Mitchell</CODE>', work best for images which basically consist of line
drawings and cartoon like images. You can control the <A
HREF="#blurring" >blurring</A> versus the <A HREF="#aliasing"
>aliasing</A> effects of the filter on the image using the special <A
HREF="#blur" >Filter Blur Setting</A>. </P>

<A HREF="#windowed" >Windowed Sinc/Jinc Filters</A>, and the <A
HREF="#lagrange" >Lagrange</A> equivalent are the best filters to use with
real-world images, and especially when shrinking images.  All of them are very
similar in basic results.  A larger support, or better still, lobe count
setting, will generally produce an even better result, though you may get more
<A HREF="#ringing" >ringing</A> effects as well, but at a higher
calculation cost. </P>

The <A HREF="#cubics" >Cubic Filters</A> are a mixed bag of fast and
simple filters, of fixed support (usually 2.0) which produces everything from
the '<CODE>Hermite</CODE>' smooth interpolation filter, the qualitatively
assessed '<CODE>Mitchell</CODE>' for image enlargements, the very blurry
Gaussian-like '<CODE>Spline</CODE>' filter, or a sharp, windowed-sinc type of
filter using '<CODE>Catrom</CODE>'.  </P>

Generally if the resize results are acceptable as is, leave things alone,
as you are more likely to make things worse, not better. </P>

<A NAME="compare"></A>
<H4>Filter Comparison</H4>

<I>Enlargement...</I></P>

To give a final comparison, here I present a selection of 12 representative
resize filters.  The image is an enlargement of an aliased step in an one pixel
wide line, on a dark gray background. The original image itself 'aliased' so
you should be able to see how well various filters remove any existing
aliasing effects.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert -size 10x6 xc:grey20 +antialias -draw 'fill white line 4,0 5,5' \
          -filter {<I>filter_type</I>} -resize 100x   {<I>result</I>}
</CODE></PRE></TD></TR></TABLE>
   <A HREF="montage_enlarge.png"
      ><IMG SRC="montage_enlarge.png"
            ALIGN=middle VSPACE=2 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The above starts with the <A HREF="#interpolated" >Interpolated
Filters</A> and continues with  the  <A HREF="#gaussian" >Gaussian
Blurring Filters</A>, showing how much blurring these filters produce, and in
doing so remove the 'aliasing' in the original image.  No ringing is produced
by these filters. </P>

The second line starts with three <A HREF="#windowed" >Windowed Sinc
Filters</A> showing the heavy ringing effects they can produce.  Remember
these filters are really designed for shrinking images, not enlarging.  This
continues into the '<CODE>Lagrange</CODE>' using its default 'interpolating'
setting, and '<CODE>Catrom</CODE>' interpolated cubic filter. </P>

The final image is the '<CODE>Mitchell</CODE>' filter showing what the
'experts' subjectively agreed was the best 'ideal' filter to use for enlarging
images, with a minimal of all four <A HREF="#artifacts" >Resampling
Artefacts</A> present in the final result. </P>

I myself agree with their findings, but only for enlargements. </P>

This is why '<CODE>Mitchell</CODE>' is the default 'enlargement' filter used by
IM. </P>

<I>Shrinking...</I></P>

To get an idea of the <A HREF="#aliasing" >aliasing</A> effects, here I shrink
the crop of <A HREF="../img_photos/rings_lg_orig.png" >Large Rings Image</A> that we made
earlier (<CODE>105x105</CODE> pixels in size), to see what sort of
Moir&eacute; effects each of the same 12 representative filters generates.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert rings_crop.png -filter {<I>filter_type</I>} -resize 100x {<I>result</I>}
</CODE></PRE></TD></TR></TABLE>
   <A HREF="montage_shrink.png"
      ><IMG SRC="montage_shrink.png"
            ALIGN=middle VSPACE=2 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see <A HREF="#interpolated" >Interpolated Filters</A> filters
are very heavily aliased moir&eacute; effect, which is caused as a side-effect
of the blocking artifacts these produce. </P>

On the other hand the blurring artifacts of the <A HREF="#gaussian"
>Gaussian Blurring Filters</A> removed all that blocking Moir&eacute; effects
from the resulting image, though with a general blurring (indistinct lines) in
the resulting image.  The '<CODE><A HREF="#gaussian" >Gaussian</A></CODE>'
Filter itself does show a barely noticeable aliasing effect caused by its
infinite (IIR) filter being clipped by the <A HREF="#support" >Filter
Support Setting</A>, but that is very minor. </P>

On the other hand the <A HREF="#windowed" >Windowed Sinc Filters</A>
produce a very sharp looking image with circular mori&eacute; effects, of
about equal intensity across all three representative filters.  This is caused
by the ringing artifacts these filters produce, generating interferance
patterns. </P>

Finally the cubic filters also show some very light moriÃ© effects, but only
due to negative lobe ringing.  The '<CODE><A HREF="#mitchell"
>Mitchell</A></CODE>' filter, producing the least ringing effect. </P>

Note that '<CODE>Mitchell</CODE>' does generate very minor effects from almost
all the resize artifacts. That is: grid-like moir&eacute; - aliasing/blocking,
circular-like mori&eacute; - ringing, and blurring of the lines.  All the
artifacts are however at very minimal levels, which is why it is a good all
round filter. </P>

Here is another comparison, but this time heavily shrinking a <A
HREF="../img_photos/rings_sm_orig.gif" >Smaller Rings Image</A> smaller.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert rings_sm_orig.gif -filter {<I>filter_type</I>} -resize 100x {<I>result</I>}
</CODE></PRE></TD></TR></TABLE>
   <A HREF="montage_smaller.png"
      ><IMG SRC="montage_smaller.png"
            ALIGN=middle VSPACE=2 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see the <A HREF="#interpolated" >Interpolated Filters</A> produce
lots of <A HREF="#aliasing" >aliasing artifacts</A>, while the <A
HREF="#gaussian" >Gaussian Blurring Filters</A> tend to blur out more lines
than the others. But all the other filters tend to produce a reasonable job.
</P>


<A NAME="best_filter"></A>
<H4>The Best Filter?</H4>

That is something you will need to work out yourself. Often however it depends
on what type of image and resizing you are doing. </P>

For enlarging images '<CODE>Mitchell</CODE>' is probably about the best filter
you can use, while basically any of the <A HREF="#windowed" >Windowed
Filters</A> (default is '<CODE>Lanczos</CODE>') are good for shrinking images,
especially when some type of low level pattern is involved.  However if you
have no patterns, but lots of straight edges (such as GIF transparency), you
may be better off using sharpened <A HREF="#gaussian" >Gaussian
Filter</A> or again a '<CODE>Mitchell</CODE>', so as to avoid strong ringing
effects. </P>

The '<CODE>Lagrange</CODE>' filter is also quite good, especially with
a larger <A HREF="#support" >Filter Support Setting</A>, for shrinking
images.  </P>

For those interested I recommend you look at the IM User
Discussion topic <A HREF="../forum_link.cgi?f=1&t=19425" >a way to compare
image quality after a resize?</A> which basically shows that their is no way
of quantitatively  determining "The Best Filter", only a qualitative or
subjective "Best Filter". </P>

The choice is yours, and choice is a key feature of ImageMagick. </P>


<A NAME="default_filter"></A>
<H4>IM's Default Filter...</H4>
It is for these reasons that '<CODE>Mitchell</CODE>' is the default filter for
enlargement, as well as for shrinking images involving transparency, or images
containing a Palette (or colormap).  However the '<CODE>Lanczos</CODE>' will
be used in all other cases, that is shrinking normal images (typically
photographs).  </P>

For <A HREF="../distorts/#distort" >Distort</A>, the filter setting defaults
to the '<CODE>Robidoux</CODE>' filter which was specifically designed to
minimize image blurring when no actual distortion takes place. </P>

You can of course override these choices. </P>

<A NAME="nicolas"></A>
<H3>Nicolas Robidoux</H3>

Nicolas Robidoux is an image processing expert with a lot more to say and
recommend about trying to get the absolute best results from your image
resizing. </P>

So much so he has his own section... <BR>
<A HREF="nicolas/" >Resampling by Nicolas Robidoux</A>. </P>


<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 10 October 2012 (split from resize) <BR>
Updated: 14 Feburary 2013 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/filter/</CODE>
</ADDRESS></BODY></HTML>
