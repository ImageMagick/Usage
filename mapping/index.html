<!DOCTYPE html>
<html lang="en">
<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>
  <title>Image Mapped Effects -- ImageMagick Examples</title>
  <link rel="icon" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="shortcut" href="../img_www/favicon.ico" type="image/x-icon">
  <link rel="canonical" href="https://usage.imagemagick.org/mapping/">
</head>
<body>
  <main class="container mx-auto px-3 py-4" style="max-width: 800px" role="main">
    <div class="magick-template">
      <div class="magick-header">
        <h1>ImageMagick Examples --<br>
        <img src="../img_www/space.gif" width="50" height="1"> Image Mapped Effects</h1>
        <div>
          <dl>
            <dt><b>Index</b></dt>
            <dt>
              <a href="../"><img src="../img_www/granitesm_left.gif" border="0" width="15" height="15"> ImageMagick Examples Preface and Index</a>
            </dt>
            <dd>
              <a href="#intro"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Introduction to Image Mapping</a>
            </dd>
            <dd>
              <a href="#distort"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Distorting Images using Image Mapping</a>
            </dd>
            <dd>
              <a href="#distortion_maps"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Absolute Distortion Lookup Maps</a>
              <ul>
                <li>
                  <a href="#distortion_maps">Absolute Distortion Maps</a>
                </li>
                <li>
                  <a href="#compose_distort">Absolute Distortion Composition</a>
                </li>
                <li>
                  <a href="#no-op_distortion_map">No-op Distortion Map Revisited</a>
                </li>
                <li>
                  <a href="#distortion_problems">Problems with Distortion Maps</a>
                </li>
                <li>
                  <a href="#undefined_masking">Set Undefined Pixels using a Mask</a>
                </li>
                <li>
                  <a href="#distortion_unified">Unified Distortion Image</a>
                </li>
                <li>
                  <a href="#hourglass">Hourglass Distortion Map</a>
                </li>
                <li>
                  <a href="#spherical">Spherical Distortion Map</a>
                </li>
                <li>
                  <a href="#circlar_arc">Circular Arc Distortion Map</a>
                </li>
                <li>
                  <a href="#polar">Polar Distortion Map</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#displacement_maps"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Relative Displacement Lookup Maps</a>
              <ul>
                <li>
                  <a href="#displacement_maps">Relative Displacement Maps</a>
                </li>
                <li>
                  <a href="#composite_displace">Composite Displace Operator</a>
                </li>
                <li>
                  <a href="#displace_simple">Simple Displacement Examples</a>
                </li>
                <li>
                  <a href="#displace_graph">Displacement Graphing</a>
                </li>
                <li>
                  <a href="#displace_areas">Area Displacement</a>
                </li>
                <li>
                  <a href="#water_ripples">Rippled Water Reflections</a>
                </li>
                <li>
                  <a href="#displace_2d">2 Dimensional Displacement Maps</a>
                </li>
                <li>
                  <a href="#displace_cylinder">Cylindrical Displacment</a>
                </li>
                <li>
                  <a href="#displace_mirror">Fractured Mirror</a>
                </li>
              </ul>
            </dd>
            <dd>
              <a href="#blur"><img src="../img_www/granitesm_right.gif" border="0" width="15" height="15"> Variable Blur Mapping</a>
              <ul>
                <li>
                  <a href="#blur_ellipse">Elliptical Blurring</a>
                </li>
                <li>
                  <a href="#blur_aspect">Blur with Variable Aspect Ratio</a>
                </li>
                <li>
                  <a href="#blur_angle">Blur with Variable Angle</a>
                </li>
              </ul>
            </dd>
          </dl>Distorting or modifying image using some sort of secondary 'mapping' image that controls the process. Be it replacing colors, variably bluring the image, or distorting images by specifying source coordinates absolutely or relativally.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="intro" id="intro"></a>
          <h2>Introduction</h2>As you have seen in the previous sections on <a href="../compose/">Composition</a>, <a href="../warping/">Simple Warping</a>, and <a href="../distorts/">Distorting</a>, you can modify images in many different ways. However they all are limited to the specific methods that have been built into ImageMagick. You can even 'roll your own' image distortion using the <a href="../transform/#fx">'FX' DIY Operator</a>, or directly modify the values of an image using operators such as <a href="../transform/#evaluate">Evaluate</a> or <a href="../transform/#function">Function</a>, or even the various <a href="../color_mods/#level">Level</a> operators. However distortions take a lot of calculations (and time) to do there task, and if you plan to do the same task against multiple images, having IM repeat all those calculations can be a real waste of time. The other aspect is that it is very hard to limit the effects of the distortion in a free form way. You can't simple edit or modify the distortion that you want to apply. You have limited control. <b>Image Mapping</b> is different. You use an extra 'mapping' image to control what parts of an image is to be modified, and by how much, or in what way. It does not have to modify the whole image, nor does it have to modify the image in some pre-defined or pre-programmed way. You can create a 'map' that can modify an image in <i>ANY</i> posible way, without limitation. You can also <i>edit</i> or further modify the mapping, to adjust or limit its effect, making it more complex, by merging different maps together, or just smooth or blur the effect. And finally you can <i>save</i> the mapping so as to use it again later. It is the 'map' image controls the results. As the modification is 'map' controlled, there is usally very little calculation needed to be performed by ImageMagick, as such 'image mapping' is in general <i>very fast</i>. It is also <i>repeatable</i>, as you can apply the same very complex map, to any number of images, to get the exact same modification. That is, to say you can apply it to a whole directory of images very quickly. In essence what <i>Image Mapping</i> does is move the slow, and complex mathematics of a particular effect from a specific image, to a more general 'map' image. once that 'map' is generated it can then be applied to a lot of actual images very quickly. <a name="image_maps" id="image_maps"></a>
          <h3>What are Image Maps</h3>Mapping images are basically "Look Up Tables" or LUTs that define how a particular effect sould be applied to an image on an individual pixel by pixel bases. That is, wether an effect is applied and to what degree is completely controled by the image map. Essentually an image is an array of values, and what those values mean depends on the mapping process that is being applied. They could indicate...
          <ul>
            <li>a direct replacement value (color lookup),</li>
            <li>which image a color should come from (image masking),</li>
            <li>how much a pixel should be lighted or darkened (highlighting),</li>
            <li>specify a the source coordinate (distortion),</li>
            <li>or a location relative to the current position (displacement).</li>
            <li>how much to blur pixels at this location</li>
          </ul>Many of these we have already seen in <a href="../compose/">Image Composition</a>, and in a sense image mapping is just another way of merging multiple images together. In fact many image mapping techniques are simply implemented as specialized compose methods! Just remember true image composition is really just the overlying if two real color images in various ways (specifically the <a href="../compose/#duff-porter">Duff-Porter Alpha Composition Methods</a>). Image mapping more generally involves using specialised images that modify one images in a special way. The hardest part about image mapping is to generate a particular 'map' for a particular effect. And this is where a lot of the work, effort and techniques that are present on this page is involved with. Once you have a map however, you can use it many times with many different images very quickly.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="distort" id="distort"></a>
          <h2>Distorting Images using Image Mapping</h2>While the various distortion operators described in the previous sections of IM Exampled (such as <a href="../warping/">Simple Image Warping</a> and <a href="../distorts/">General Image Distortions</a>), you are restricted to just the various types distortions that have been programmed into the IM graphics library, generally using specific mathematical equations and formulas. However there are times where you want to design your own distortion in a more freeform and less mathematical way. For example to generate a more complex distortion, such a mapping an image into a particular shape, or with a particular complex lens effect, that is easier to draw than to define mathematically. Sometimes you just want to be able to repeat your distortion over a large number of images and avoid having to re-calculate the distortion over and over. The solution is to pre-calculate your distortion, and save it as special look-up table (LUT) in the form of a grayscale image. That is, for each output pixel, we look-up the LUT, then use that value to look-up the color from the source image. That is, three steps are needed.
          <ol>
            <li>Look-up up each destination pixel in the LUT</li>
            <li>Map the LUT value to the source image location (two methods)</li>
            <li>Look-up the color from the source image</li>
          </ol>As an image is used for the 'lookup table' of the distortion, you can create, or modify a the distortion map using an image editor, such as '<code>Gimp</code>' or '<code>PhotoShop</code>', giving you the freedom to do some really fancy and complex distortions. You must remember however that just like all other distortion methods we have seen, the lookup is pplied as a <a href="#mapping">Reverse Pixel Mapping</a>. That is, for each pixel in the destination image, we look-up the color of the pixel from the source image, using the distortion method being applied. In this case the method is to look-up the source coordinate from the provided Look-up Table Image.<br>
          Now there are two ways of using an image map to determine where in the source image a color shoul dbe looked up... <b>absolute</b> or <b>relative</b>. With <b>absolute</b> coordinate lookup a <a href="#distortion_maps">Distortion Map</a> converts the LUT color value directly into a coordinate in the source image from which to look up the color to use. It does not matter where the color in the LUT is, each color refers to the exact lookup point to use. The distortion LUT images will have a gradient of colors, but any warping or distortion of that graident will achieve the same effect when the map is applied. With <b>relative</b> coordinate lookup a <a href="#displacement_maps">Displacement Map</a> uses the color value to offset the current coordinate to figure out the location in the source image to lookup the color. This means a pure-grey LUT image is used with lighter and darker areas defining how pixels are to be shifted or displaced by the map, regardless of their location in the map. Both methods have advantages and disadvantages, as you will see.
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="distortion_maps" id="distortion_maps"></a>
          <h2>Absolute Distortion Lookup Maps</h2>Creating an <b>Absolute Distortion LUT Map</b> is the simpler of the two methods to both understand, create distortion LUT maps for, and to apply. However, as you will see, it has a very serious drawbacks making them less practical than a <a href="#displace">Relative Displacement Map</a>. It is the color at any particular point in the 'Distortion Map' directly refers to a location in the source image. That is, the greyscale gradient across the 'map' defined the 'texture' that is to be placed at that location. Now consider that the Map image is acually an image of a complex opject such as a tee-shirt, with complex folds and ripples. If that shirt has a gradient across it, you can map any flat image onto that shirt. That is, the power of an absolute distortion map. Any 'black' pixel in the LUT image (color value 0) will be thought of as the left-most pixel or '<code>0</code>' X coordinate of the source image, while anything that is 'white' in the LUT (value 1), is to be thought of as the right-most pixel (the width of the source image). Note that this LUT will only look-up the X or horizontal position of color in the source image. It will not change the height or Y positions of colors. So lets try this with a simple plain gray-scale horizontal gradient for the LUT. <!-- <CODE EXECUTE>
    magick -size 75x75 gradient: -rotate 90 map_gradient_x.gif
</CODE>> -->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif \( -size 75x75 gradient: -rotate 90 \) \
          -fx 'p{v*w,j}'      distort_noop.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_gradient_x.gif"><img src="map_gradient_x.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="distort_noop.gif"><img src="distort_noop.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Note that this did not make any real changes in mapping the source image to the destination image. That is, because the X coordinate that we looked up from the distortion map, was the same position we were looking up the color for. By simply flipping the gradient over the look-up of the pixels is also flipped, creating a mirror image. That is, white is on the left and 'black' is on the right, and a horizontal gradient across the image. <!-- <CODE EXECUTE>
    magick -size 75x75 gradient: -rotate -90 map_gradient-x.gif
</CODE>> -->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
    magick koala.gif \( -size 75x75 gradient: -rotate -90 \) \
          -fx 'p{v*w,j}'      distort_mirror_x.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_gradient-x.gif"><img src="map_gradient-x.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="distort_mirror_x.gif"><img src="distort_mirror_x.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>If we take the original gradient and compress it using a contrast enhancement operator, we can get a much more useful distortion.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 gradient: -rotate 90 \
          -sigmoidal-contrast 8,50%      map_compress.gif
  magick koala.gif  map_compress.gif -fx 'p{v*w,j}'  distort_compress.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_compress.gif"><img src="map_compress.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="distort_compress.gif"><img src="distort_compress.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Notice that the sides of the distortion is stretched while the center is compressed. We can expand this to two dimensions by using 2 distortion maps, one to adjust the X coordinate, the other for the Y coordinate.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick map_compress.gif -rotate 90 map_compress_y.gif
  magick koala.gif  map_compress.gif map_compress_y.gif \
          -fx 'p{u[1]*w,u[2]*h}'   distort_compress_2D.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_compress.gif"><img src="map_compress.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <a href="map_compress_y.gif"><img src="map_compress_y.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="distort_compress_2D.gif"><img src="distort_compress_2D.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>As you can see the above recreated a variation of the implosion method, though only by compressing the images along the X and Y axis (simultaneously), rather than radially as the <a href="#implode">Implode</a> operator does. The key here is whatever you do to the absolute distortion map, you will do to the final image of whatever image you are applying it to. That is, the power of distoprtion maps. <a name="compose_distort" id="compose_distort"></a>
          <h3>Composite 'Distort' Method</h3>So far we have been using <a href="../transform/#fx">FX, General DIY Operator</a> to apply absolute distortion maps. This provides a way to exactly taylor and tweek exactly what you are doing but is also very slow. The <a href="../compose/#compose">Composition Operator</a> "<code>Distort</code>" encodes a very similar formula we have been using above. Though it has been implemented in a way that also makes it a little more compatible with the "<code>Displace</code>" composition operator that we will look at later in <a href="#displacement_maps">Relative Displacement Maps</a>.
          <p>So lets repeat the last 'implode' example using a "<code>Distort</code>" composition.</p>
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  map_compress.gif map_compress_y.gif \
          -compose Distort  -define compose:args=37.5x37.5 -composite \
          distort_compose.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_compress.gif"><img src="map_compress.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <a href="map_compress_y.gif"><img src="map_compress_y.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="distort_compose.gif"><img src="distort_compose.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Note the use of the "<a href="../basics/#define">Define Setting</a>" "<code>compose:args</code>" in the above. This value is a multiplyer against the LUT gradient that is used (centered on a perfect gray). The value used '<code>37.5</code>' in the is half the width and height of the image (75 pixels). You can change that multiplier to expand or contract the overall scale of the distortion. If the "<code>compose:args</code>" values are NOT defined, it will default to the correct values. If the value is set to zero, no distortion will be applied in that direction. If you wanted to set the composition arguments automatically you can use the following equivelent <a href="../basics/#set_option">Set "option:"</a> method to calculate it...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  map_compress.gif map_compress_y.gif \
          -set option:compose:args '%[fx:w/2]x%[fx:h/2]' \
          -compose Distort  -composite \
          distort_compose_set.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_compose_set.gif"><img src="distort_compose_set.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Or undefine it so as to let IM calculate the correct values (for a 2D Distort)...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif  map_compress.gif map_compress_y.gif \
          -compose Distort -define compose:args='' -composite \
          distort_compose_default.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_compose_default.gif"><img src="distort_compose_default.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><br>
          <a name="no-op_distortion_map" id="no-op_distortion_map"></a>
          <h3>No-op Distortion Map</h3>Before we get any further I would like to just step back a moment a have another look at the the 'noop' example above. This actually will blur the image slightly, as the formula as I have outlined is actually not exactly correct. Getting the 'no-op' copy of the original is a good test that you have the mathematics of your distortion correct.
          <p>That is, when given a perfect gradient, you can map each pixel from the source image to the destination image. That is, the LUT 'white' (or 1.0) value will map exact to right-most (or bottom-most) pixel in the destination.</p>For testing no-op distortions we use a 'pixel checks image' (EG: "<code>pattern:gray50</code>") as it will show up any distortion, and thus any problem in the applied mathematics used. So lets try to apply a no-op distortion to the methods we have so far used...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 pattern:gray50 \
          \( gradient: -rotate 90 \) \( gradient: -flip \) \
          -fx 'p{u[1]*w,u[2]*h}'    distort_fx_check.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_fx_check.gif" width="75" height="75"><img src="distort_fx_check.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 pattern:gray50 \
          \( gradient: -rotate 90 \) \( gradient: -flip \) \
          -set option:compose:args '%[fx:w/2] x %[fx:h/2]' \
          -compose Distort  -composite  distort_compose_check.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_compose_check.gif" width="75" height="75"><img src="distort_compose_check.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see BOTH methods failed to reproduce the 'pixel check' image. Though they did so in slightly different ways due to the way the coordinates are calculated. What happened is that scaling factor, from color lookup, to pixel coordinate, is out by 1 pixel. For details as to why this has happened see, <a href="../distorts/#control_coordinates">Distorts, Image Coordinates vs Pixel Coordinates</a>.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The FX distortion is centered on the upper right corner (pixel location 0,0), and generates duplicate virtual pixels along the bottom and right edges. That is, because it makes no attempt to change center of the scaling, from lookup color, to image coordinates used for the actual lookup. As such black pixels remain centered at pixel 0,0, even though the scaling is wrong.<br>
              <br>
              The compose "<code>Distort</code>" operator translates the coordinates so zero is in the center of the image, before the scaling is applied. It does this as part of the scaling for 'displacement maps' (see later). As such the inaccurate scaling pulls the edges of the image inward by 1/2 a pixel along each edge, while leaving the center of the image correct.</i></font></td>
            </tr>
          </table>Here is the corrected 'perfect no-op' versions for absolution distortion maps, which essentually uses Image Coordinates (width and height reduced by one), when calculating the scaling factor between color and coordients.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 pattern:gray50 \
          \( gradient: -rotate 90 \) \( gradient: -flip \) \
          -fx 'p{u[1]*(w-1),u[2]*(h-1)}'    distort_fx_check_correct.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_fx_check_correct.gif" width="75" height="75"><img src="distort_fx_check_correct.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 pattern:gray50 \
          \( gradient: -rotate 90 \) \( gradient: -flip \) \
          -set option:compose:args '%[fx:(w-1)/2] x %[fx:(h-1)/2]' \
          -compose Distort  -composite  distort_compose_check_correct.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_compose_check_correct.gif" width="75" height="75"><img src="distort_compose_check_correct.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>In actual fact the default values for "<code>compose:args</code>", if undefined, uses the correct scaling values.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 pattern:gray50 \
          \( gradient: -rotate 90 \) \( gradient: -flip \) \
          -compose Distort -define compose:args='' -composite \
          distort_compose_default_check.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_compose_default_check.gif" width="75" height="75"><img src="distort_compose_default_check.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>However it should be pointed out these slight inaccuracies are normally not that important when using distortions, so any slight differences is generally ignored. Just keep it in mind so you know about it when it does actually matter. <a name="distortion_problems" id="distortion_problems"></a>
          <h3>Problems with Distortion Maps</h3>Lets continue with out image distorting by attempting a rotation. For this generating the rotated map can be a little tricky, but can be done...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 gradient: -background black -rotate 45 \
          -gravity center -crop 75x75+0+0 +repage  map_rot45_x.png
  magick map_rot45_x.png  -rotate 90              map_rot45_y.png
  magick koala.gif  map_rot45_x.png   map_rot45_y.png \
          -compose Distort  -composite    distort_rot45.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_rot45_x.png"><img src="map_rot45_x.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_rot45_y.png"><img src="map_rot45_y.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="distort_rot45.gif"><img src="distort_rot45.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>And we now have another way of rotating any image. The biggest problem with this technique is that by creating our distortion maps using rotates, we introduced some oddly colored pixels along the sides of the diagonal edges. In the last example this caused some random pixels to be added in a line along the bottom right corner of the image. These 'random' colors are anti-aliasing values that the rotate introduced to produce a 'better' image. However for distortion maps, anti-aliased edge pixels can cause a real problems. Now we can try to better define the colors at the edges of the rotated LUT images. In this case we can generate a larger gradient image, then cropping the rotation down to the correct size.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x20 xc:white xc:black -size 115x75 gradient: \
          +swap -append   -rotate 45 \
          -gravity center -crop 75x75+0+0 +repage   map_rot45b_x.png
  magick map_rot45b_x.png  -rotate 90              map_rot45b_y.png
  magick koala.gif  map_rot45b_x.png   map_rot45b_y.png \
          -compose Distort  -composite     distort_rot45_better.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_rot45b_x.png"><img src="map_rot45b_x.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_rot45b_y.png"><img src="map_rot45b_y.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="distort_rot45_better.png"><img src="distort_rot45_better.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>In this way all the pixels in the LUT are now defined properly with no anti-alising. This now shows a slightly different problem. All the pixels in the final image are properly defined, but some pixels should not be part of the final image. They have no real meaning in resulting image. This represents the biggest problem with using an LUT to specify the absolute coordinates to get from the source image. You have no way of specifying what IM should do in these undefined areas. <a name="undefined_masking" id="undefined_masking"></a>
          <h3>Set Undefined Pixels using a Mask</h3>A more general way of solving the 'undefined pixel' problem is to define a map of what pixels are actually a valid defined result in the distortion. In other words a masking image. For example...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 xc:white -background black -rotate 45 \
          -gravity center -crop 75x75+0+0 +repage  map_rot45b_m.png
  magick distort_rot45_better.png map_rot45b_m.png \
          -alpha off -compose CopyOpacity -composite   distort_rot45_masked.png
</samp></pre>
                </td>
              </tr>
            </table><a href="distort_rot45_better.png"><img src="distort_rot45_better.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="map_rot45b_m.png"><img src="map_rot45b_m.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="distort_rot45_masked.png"><img src="distort_rot45_masked.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Now we have three images involved with the distortion map, and the results is getting complex indeed. Of course in a typical situation you probably will not need to go that far, but for the general case you do. <a name="distortion_unified" id="distortion_unified"></a>
          <h3>Unified Distortion Image</h3>You may however have noticed that all three maps are all grey scale images. This means it is quite reasonable to merge all the maps into a single distortion map image. For example, lets map the 'X distortion map' to the '<code>red</code>' channel, the 'Y map' to the '<code>green</code>', and the mask to the '<code>alpha</code>' or transparency channel, which makes it easier to handle.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick map_rot45b_x.png map_rot45b_y.png \( map_rot45b_m.png -negate \) \
          -alpha off -channel RGA -background black -combine  map_rot45u.png
</samp></pre>
                </td>
              </tr>
            </table><a href="map_rot45b_x.png"><img src="map_rot45b_x.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <a href="map_rot45b_y.png"><img src="map_rot45b_y.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <a href="map_rot45b_m.png"><img src="map_rot45b_m.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="map_rot45u.png"><img src="map_rot45u.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The '<code>blue</code>' channel in the <a href="../color_basics/#combine">Combined Channel Image</a> is not defined, so takes its value from the current "<a href="https://imagemagick.org/script/command-line-options.php?#background"><code>-background</code></a>" color, which I preset to '<code>black</code>' or a value of zero in the above.</i></font></td>
            </tr>
          </table>Now lets apply this unified distortion map to our koala image. This unfortunately requires two image processing steps, one to distort the image, and one to mask the result.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set   map_rot45u.png \
          \( -clone 0,1  -fx 'p{v.r*w,v.g*h}' \
             +clone -compose Dst_In -composite \) -delete 0,1 \
          distort_rot45_unified.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <a href="map_rot45u.png"><img src="map_rot45u.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="distort_rot45_unified.png"><img src="distort_rot45_unified.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>You can also use the "<a href="#compose_distort">Distort</a>" composition method directly using the unified distortion map image...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -alpha set   map_rot45u.png \
          -compose Distort -define compose:args='' -composite \
          distort_rot45_compose.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_rot45_compose.gif" width="75" height="75"><img src="distort_rot45_compose.gif" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>There is still an unused channel (<code>blue</code>) in the 'unified distortion map' image. One logical use for it is as a means to add highlights and shadows to the distorted image. (See <a href="../compose/#overlay">Overlay highlights</a>). You can see this technique taken one step further in the <a href="#spherical">Spherical Distortion Map</a> example below. <a name="hourglass" id="hourglass"></a>
          <h3>Hourglass Distortion Map</h3>Now I wanted an one dimensional distortion map, that scaled each row of the image differently based on that rows height. Sort of producing a real carnival fun house mirror distortion that makes fat people look very thin. In other words a sort of hourglass distortion. This is quite a complex LUT image, and after a lot of fiddling I came up with the following expression to generate the height variable, but horizontally linear gradient map.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:  -channel G \
          -fx 'sc=.15; (i/w-.5)/(1+sc*cos(j*pi*2/h)-sc)+.5' \
          -separate  map_hourglass.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="map_hourglass.png"><img src="map_hourglass.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>When generating gray-scale gradients, you can make the -fx operator 3 times faster, simply by asking it to only generate one color channel only, such as the '<code>G</code>' or green channel in the above example. This channel can then be <a href="../color_basics/#separate">Separated</a> to form the required gray-scale image. This can represent a very large speed boost, especially when using a very complex "<code><a href="https://imagemagick.org/script/command-line-options.php?#fx">-fx</a></code>" formula.</i></font></td>
            </tr>
          </table>The '<code>sc</code>' is the scaling factor for the hourglass (value ranges from 0 to 0.5), and allows you to adjust the magnitude of the distortion. Now lets apply this map to the built-in "<code>rose:</code>" image. Note that the 100x100 pixel map does not match the 70x46 pixel image. This complicates things, as we will need to scale the current pixel in the source image by the appropriate amount to match the distortion map we give, to look-up the location of that pixels color.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose:  map_hourglass.png \
          -fx 'p{ v.p{i*v.w/w,j*v.h/h}*w,  j}'  distort_hourglass.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_hourglass.png"><img src="distort_hourglass.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>If you look at this carefully the pixels X coordinate '<code>i</code>' is multiplied by the width of the distortion map image '<code>v.w</code>', and divided by the original images width '<code>w</code>', to produce '<code>i*v.w/w</code>. The same thing happens for the pixels Y coordinate, '<code>j*v.h/h</code>'. This re-scales the pixel coordinate in the destination image to match the distortion LUT image. The looked up coordinate is then scaled by multiplying the LUT value with the source images width, to become the X coordinate for the color look-up. If you have both an X and a Y distortion map, then you will have to repeat the scaled look-up for the Y map. Of course we have the same 'edge' distortions we saw previously, so lets change the <a href="../misc/#virtual">Virtual Pixel Setting</a> to transparency.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -alpha set  -virtual-pixel transparent -channel RGBA \
          map_hourglass.png  -fx 'p{ v.p{i*v.w/w,j*v.h/h}.g*w, j}' \
          distort_hourglass2.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_hourglass2.png"><img src="distort_hourglass2.png" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note the use of the "<a href="https://imagemagick.org/script/command-line-options.php?#channel"><code>-channel</code></a>" setting to ensure that "<code><a href="https://imagemagick.org/script/command-line-options.php?#fx">-fx</a></code>" will work with and return alpha channel (transparent) values from the source image. Specifically the transparent virtual pixels. Also note that when looking up the distortion map we ony looked up from the green channel (using '<code>v.p{}.g</code>'). If this is not done, the same channel as being process from the source image will be used, and for the map 'alpha' is not defined. This distortion map could be made even better by using a non-linear gradient so the image remains rectangular, with more distortion at the edges than in the middle, to give it a more 'rounded' or 'cylindrical' look. <i>Anyone like to give this a go? Mail Me</i> <a name="spherical" id="spherical"></a>
          <h3>Spherical Distortion Map</h3>In the previous <a href="#hourglass">Hourglass Distortion Map</a> example, I generated a gradient which was horizontally scaled by a cosine curve. With a little more work you can generate a spherical shape instead...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:  -channel R \
          -fx 'yy=(j+.5)/h-.5; (i/w-.5)/(sqrt(1-4*yy^2))+.5' \
          -separate  +channel     sphere_lut.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="sphere_lut.png"><img src="sphere_lut.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note however that the above is not strictly accurate. The compressed gradient remains a liner gradient, just compressed to fit within a circle. A more accurate representation would probably require the creation of a non-linear gradient. Which would in absolute position terms be a 'arccos()' function. Now this mapping also has some large areas which would be classed as invalid, so will need some type of masking to define what pixels will be valid and invalid in the final image. A simple circle will do in this case.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:black -fill white \
          -draw 'circle 49.5,49.5 49.5,0'    sphere_mask.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="sphere_mask.png"><img src="sphere_mask.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>And to complete we also need a shading highlight, such as developed in <a href="../transform/#shade_overlay">Overlay Highlights</a>, for use by <a href="../compose/#overlay">Overlay</a> or <a href="../compose/#hardlight">Hardlight</a> composition...
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick sphere_mask.png \
          \( +clone -blur 0x20 -shade 110x21.7 -contrast-stretch 0% \
             +sigmoidal-contrast 6x50% -fill grey50 -colorize 10%  \) \
          -composite sphere_overlay.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="sphere_overlay.png"><img src="sphere_overlay.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Remember the above shading will only matter within the bounds of the sphere object, so the fact that the shade overflows those bounds is not important. Actually if you like to try and come up with a better spherical shading, that produces an even better ball like image, would love to see it. So lets apply all three images: X coordinate LUT, Overlay Shading, and Transparency Mask; to an actual image of the right size (for simplicity).
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick lena_orig.png -resize 100x100   sphere_lut.png   -fx 'p{ v*w, j }' \
          sphere_overlay.png   -compose HardLight  -composite \
          sphere_mask.png -alpha off -compose CopyOpacity -composite \
          sphere_lena.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../img_photos/lena_orig.png"><img src="../img_photos/lena_orig.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="sphere_lena.png"><img src="sphere_lena.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a>
          </div>This particular example shows the most powerful aspect of a <a href="#distortion_map">Absolute Distortion Map</a>. You can define a gradient on any freeform object (not nessarially mathematically), so that any image can be mapped onto that object, whether it be curves, wrinkles, folds, etc. Simply put, once you have the object mapping worked out you can map any image onto its surface. Then to make it more realistic looking, you can overlay a second mapping, to add highlights, shadows, edges, and other features. Of course as all three images are grayscale, you can combine them into a single <a href="#distortion_unified">Unified Distortion Map</a> image, for easy storage. In this case I'll make it a more spherical distortion by re-using the X coordinate distortion LUT for the Y coodinate as well.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick sphere_lut.png   \( +clone -transpose \) \
          sphere_overlay.png   \( sphere_mask.png -negate \) \
          -channel RGBA  -combine    spherical_unified.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="spherical_unified.png"><img src="spherical_unified.png" width="100" height="100" align="middle" vspace="0" hspace="5" border="0" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>It is a rather pretty map. But if trying to interprete it, remember that: the 'red' and 'green' channels are the X and Y coodinate LUT, 'blue' is the high light and shadow effects overlay, and the transparency channel holds the invalid pixel mask for the final image. So lets apply it using the "<a href="#compose_distort">Distort</a>" composition method.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick mandrill_grid_sm.jpg   spherical_unified.png  \
          \( -clone 0,1 -alpha set -compose Distort -composite \) \
          \( -clone 1   -channel B -separate +channel \) \
          \( -clone 2,3 -compose HardLight -composite \) \
          \( -clone 4,1 -compose DstIn -composite \) \
          -delete 0--2  spherical_mandrill.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../img_photos/mandrill_grid_sm.jpg"><img src="../img_photos/mandrill_grid_sm.jpg" width="100" height="100" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="spherical_mandrill.png"><img src="spherical_mandrill.png" width="100" height="100" align="middle" vspace="5" hspace="5" border="0" alt="[IM Output]"></a>
          </div>In sequence...
          <ul>
            <li>we apply the distortion map (which includes the mask)</li>
            <li>extract the shading map from the unified image map</li>
            <li>apply the shading map to the distorted image</li>
            <li>restore the mask lost from the shading operation</li>
            <li>delete all but the final image and save it</li>
          </ul>The complexity of this is purely due to the need extract the shading mask, and restoring the alpha mask the shading removed. <a name="circlar_arc" id="circlar_arc"></a>
          <h3>Circular Arc Distortion Map</h3>Just to show just what is really possible by using positional distortion maps, here is an absolute distortion LUT, similar to what is provided by the <a href="#arc">'Arc' Distortion Method</a> above. Basically instead of calculating the coordinate mappings for each and every pixel in each and every image being distorted, we save those calculated coordinates into the two X and Y coordinate gray-scale LUT maps. That is, we pre-calculate the whole distortion into a simpler look-up table image, allowing it to be applied over, and over, and over, without needing further square roots or trigonometric functions.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -pointsize 30 -font Candice label:Anthony -trim +repage \
          -gravity center -resize 95x95 -crop 100x100+0+0\! \
          -flatten text_image.jpg
  magick -size 100x100 xc: -channel G  -fx 'atan(j/(i+.5))*2/pi' \
          -separate   -flip -flop       map_p_angle.png
  magick -size 100x100 xc: -channel G  -fx '1-hypot(i,j)/(w*1.6)' \
          -separate   -transverse       map_p_radius.png
  magick text_image.jpg   map_p_angle.png map_p_radius.png \
              -fx 'p{u[1]*w,u[2]*h}'    distort_p_curved.jpg
</samp></pre>
                </td>
              </tr>
            </table>
            <table cellspacing="0" cellpadding="0">
              <tr>
                <td align="center">
                  <a href="text_image.jpg"><img src="text_image.jpg" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <font size="1"><br>
                  Color Source</font>
                </td>
                <td align="center"><img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "><br>
                &nbsp;</td>
                <td align="center">
                  <a href="map_p_angle.png"><img src="map_p_angle.png" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <font size="1"><br>
                  Angle - X Map</font>
                </td>
                <td align="center"><img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "><br>
                &nbsp;</td>
                <td align="center">
                  <a href="map_p_radius.png"><img src="map_p_radius.png" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <font size="1"><br>
                  Radius - Y Map</font>
                </td>
                <td align="center"><img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"><br>
                &nbsp;</td>
                <td align="center">
                  <a href="distort_p_curved.jpg"><img src="distort_p_curved.jpg" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <font size="1"><br>
                  Curved Text</font>
                </td>
              </tr>
            </table>
          </div>Of course generating that distortion map was difficult, but once it has been done once, using any means you like (even artistically using an image editor like "<code>Gimp</code>" ), you can then reuse it on a huge number of images. <a name="polar" id="polar"></a>
          <h3>Polar Distortion Map</h3>Sometimes you may need the destination image to be defined by the distortion map, rather than the source image, just to make things work correctly. For example, if we want to map some text into a circle (also known as a polar transform), you really need to be able to use an image that is about 3 to 4 times long than it is high (high aspect ratio) or the result will not be very readable. To do that we place the distortion map images before the color source image, so that the first (X map) image will be used to set the size of the final result, rather than the input source image.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x100 xc:  -channel G \
          -fx 'atan2(i-w/2,h/2-j)/pi/2 + .5' \
          -separate  map_p_angular.png
  magick -size 100x100 xc:  -channel G \
          -fx 'rr=hypot(i-w/2,j-h/2); (.5-rr/70)*1.2+.5' \
          -separate  map_p_radial.png
  magick -font Candice -gravity center -size 200x50 \
                                label:'Around  the  World'    text.jpg
  magick map_p_angular.png map_p_radial.png text.jpg \
                 -fx 'u[2].p{ u*u[2].w, v*u[2].h }' distort_p_circle.jpg
</samp></pre>
                </td>
              </tr>
            </table>
            <table cellspacing="0" cellpadding="0">
              <tr>
                <td align="center">
                  <a href="map_p_angular.png"><img src="map_p_angular.png" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <font size="1"><br>
                  Angular - X Map</font>
                </td>
                <td align="center"><img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "><br>
                &nbsp;</td>
                <td align="center">
                  <a href="map_p_radial.png"><img src="map_p_radial.png" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <font size="1"><br>
                  Radial - Y Map</font>
                </td>
                <td align="center"><img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "><br>
                &nbsp;</td>
                <td align="center">
                  <a href="text.jpg"><img src="text.jpg" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <font size="1"><br>
                  Color Source</font>
                </td>
                <td align="center"><img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"><br>
                &nbsp;</td>
                <td align="center">
                  <a href="distort_p_circle.jpg"><img src="distort_p_circle.jpg" width="100" height="100" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <font size="1"><br>
                  Circled Text</font>
                </td>
              </tr>
            </table>
          </div>Essentially the color source image can now be any size or aspect ratio, and things will be handled correctly, however you may need to adjust the generation of the distortion map to handle the source images aspect ratio correctly. In generating the above maps, the value '<code>70</code>' controls the final size of the circle, along which the mid-line is placed. The '<code>1.2</code>' value on the other hand controls the vertical scaling of the image into the circle, allowing you to adjust the height of the distorted text.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Remember this "<a href="https://imagemagick.org/script/command-line-options.php?#fx"><code>-fx</code></a>" expression requires the distortion maps to be given first, and the color source to be given as the third (index 2) image. However this will also mean that any meta-data that is stored in the source image will also be lost.</i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The problem with this distortion map is that there is a very sharp disjunction of colors in the 'X map' (caused by an asymptote in the mathematics). This line must remain sharp when you do any color look-up, or resizing of the map, to produce a larger image. That is, you will need to ensure that any resize or interpolated look-up of this map does not produce a grey look-up color along that asymptotic line.<br>
              <br>
              If you do generate grey look-ups along this line, you will get a line of colored pixels (looked up from the middle of the image) in your final result.<br>
              <br>
              Because of this it is recommend you always generate this distortion map at the size you need for the final image, and never use any scaling technique previously shown.</i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                You can use this for other effects too, like a circular checkerboard...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick map_p_angular.png map_p_radial.png \
          -size 150x90 pattern:checkerboard \
          -fx 'u[2].p{ u*u[2].w, v*u[2].h }'   distort_check_circle.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="distort_check_circle.gif"><img src="distort_check_circle.gif" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Try some of the other <a href="https://imagemagick.org/script/formats.php#builtin-images">Built-In Patterns</a> that IM provides with the above for other interesting effects.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The above clearly shows the limits of image distortions using "<a href="https://imagemagick.org/script/command-line-options.php?#fx"><code>-fx</code></a>". Near center of the image, the radial lines are becoming aliased as pixel merging of a large areas into a single pixel does not take place. On the other hand the edges of the image, particularly the corners, show an appropriate blurring the radial lines.<br>
              <br>
              The cause is that "<a href="https://imagemagick.org/script/command-line-options.php?#fx"><code>-fx</code></a>" (and most older distortion methods) only so simple unscaled interpolated look-ups of the colors in the source image. This means that as the image scales smaller the source image pixels are not merged together to produce the correct color for the destination pixel.<br>
              <br>
              This is not a problem for areas of enlargement (as in the corners) only of extreme compression (center). As such one solution is the use of <a href="super-sample">Super Sampling</a>, but all this does is postpone the problems to a higher level of compression.</i></font></td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>The same asymptotic line (sudden change) in the distortion map (center to bottom of image) also produces a sharp color change along that line in the above example. Compare that line with the other radial lines (like to the from center to the top of the image) which get very fuzzy as it approces the edge of the image due to interpolated look-up previously noted.<br>
              <br>
              This may be a problem when generating a circular pattern with a tileable image (such as the above), and may require some special handling to avoid visible differences in that part of the image.<br>
              <br>
              To avoid this it may be better to distort the top half of the image separately to the bottom half so as to avoid the asymptotic region.<br>
              <br></i></font></td>
            </tr>
          </table><a name="shuffling" id="shuffling"></a>
          <h3>Shuffling Rows</h3>In this example we do something a little more unusual... Shuffling the rows of an image at random. First we create a map, that has a gradient for X (red channel), a random noise image for the Y (green channel).
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick rose: \
          \( -size 46x70 gradient: -rotate -90 \) \
          \( -size 1x46 gradient: -spread 23 -scale 70x46\! \) \
          -compose Distort -define compose:args='' -composite \
          rose_row_shuffle.png
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/rose.png"><img src="../images/rose.png" width="70" height="46" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="rose_row_shuffle.png"><img src="rose_row_shuffle.png" width="70" height="46" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>Unfortunately "<a href="https://imagemagick.org/script/command-line-options.php?#spread"><code>-spread</code></a>" seems to include virtual pixels in its selection of pixels to swap, and means some rows become duplicates, while others are lost completely. In otherwords the 'shuffle' imagemap is not quite right. <i>Do you have a better solution to shuffling pixels?</i><br>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="displace" id="displace"></a> <a name="displacement_maps" id="displacement_maps"></a>
          <h2>Relative Lookup Displacement Maps</h2>As you can see creating a <a href="#distortion_maps">Absolute Distortion Map</a> is reasonably easy to create and use. However it has a serious problem when a distortion has 'undefined' regions, or areas where the distortion goes 'outside' the normal bounds of the source image. A more serious problem is that you are always dealing with gradents, which define the absolute coordinates for the color lookup. No part of the mapping image is simple, or clean, or easy to modify or edit by hand. Special techniques and mathematics is needed in there creation and use. That that generally means there is very little in the way of 'artistic' development involved. There is however another method of using a Lookup Table, to specify the coordinates in which to get the final color. By using a <b>Relative Displacement Map</b>. Instead of the 'map' defining the exact coordinate in which to lookup each pixels color from the source image, it instead defines an offset or <i>displacement</i> relative to the current position. Now an offset could be a positive or negative value, and a negative value requires a little trickiness to encode into a color value. So what they do is define 'pure gray' and being a 0 displacement of the coordinate (no change). They then make 'black' mean a maximum negative displacement, and 'white' to mean a maximum positive displacement. This can be hard to describe so lets look at an example. First we create a test image to 'displace'.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -font Candice -gravity center -size 150x50 \
                                           label:'Anthony'    label.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="label.jpg"><img src="label.jpg" width="150" height="50" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Now I'll use some 'magick' to create a 'pure gray' image with 'pure white' and 'pure black' areas.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  echo "P2 5 1 255\n 127 0 127 255 127" |\
                magick - -scale 150x50\! -alpha off   displace_map.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displace_map.jpg"><img src="displace_map.jpg" width="150" height="50" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Now to use this image as a 'displacement map' we get the 'gray value' from the displacement map, and add it either (or both) the X and Y coordinate. That is we displace the lookup by a relative amount from the current position according to the 'greyness' of the displacement map. The 'value' is handled in a special way, so that a 'pure-gray' will mean a zero displacement of the lookup point (just the Y coodinate in this case) but a 'maximum displacement' is used for a 'white' (positive) or 'black' (negative) value. For example, lets apply the displacement map to our "label" image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick label.jpg  displace_map.jpg  -virtual-pixel Gray \
          -fx 'dy=10*(2*v-1); p{i,j+dy}'   displaced.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displaced.jpg"><img src="displaced.jpg" width="150" height="50" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see the various sections of the image looked like they 'moved' according to the color of the displacement map. A 'white' region will add the given 'displacement value' to the lookup point, so in that area each pixel looks up the source image '10' pixels 'south-ward' (positive Y direction). As a result it looks as if the source image moved upward. Remember it is the lookup that is displaced, NOT the actual image itself, which is why it appeared to move upward or a negative direction for white. A similar effect was also seen for the areas with a 'black' displacement. The source image appeared to move downward, because the lookup displacement was done in a negative direction. Think about it carefully. You will also notice that the 'displaced lookup' can actually look beyond the normal image bounds allowing you to use a <a href="../misc/#virtual-pixel">Virtual Pixel</a> setting to control these out of bounds pixels. In the above I just requested that a gray pixel be returned. The 'maximum displacement' value '<code>10</code>' in the above example is very important, and is the maximum relative distance any part of the source image appears to move, for a 'pure white' or 'pure black' displacement value in the mapping image. You can not displace the lookup, and thus the input image anything further than this value. Other shades of gray between the maximum white or black values and the central no-displacement 50% gray value, will displace the lookup by an appropriate amount. As such a 25% gray value will displace the lookup by 1/2 the displacement value in the negative direction, while a 75% gray will displace by 1/2 that value in the positive direction. This value is a key difference between a <a href="#distortion_map">Absolute Distortion Map</a> and <a href="#displacement_map">Relative Displacement Map</a>. You can increase or decrease the relative displacements, making the image more or less distorted, simply by changing the displacement value, without needing to change the displacement map at all. Also as a 'zero-displacement' map is just a solid 50% or pure gray, and not a complex gradient, you can start with a simple gray image, and artistically lighten or darken areas to generate the desired displacements. You can do this simply by drawing shapes or areas, rather then needing a complex and exact mathematical formula. And finally as all the displacements are relative, wild values such as produced by edge-effects does not produce wild or random pixel colors. In fact as you will see smoothing or blurring <a href="#displacement_map">Displacement Maps</a> is actually a good thing as it removes the disjoint or discontinuous 'cutting' effect you can see in the above example. <b>In summary</b> A displacement map are much more controllable, and artistic, providing localized displacements without the need for complex and exacting mathematics, and are very forgiving with regard to mistakes, edge effects, or even displacement map blurring. It is ideal for simple 'displacement' type distortions such as when generating effects such as water, waves, distorting mirrors, the bending of light, lens-like effects, or frosted or bubbles glass effects. On the other hand highly mathematical distortions such as 'polar', rotational, and 'perspective' distortions, or other real-world 3-d type mappings, are not easily achieved. That is, not to say it is impossible, as later we will show that you can in fact magick between the two styles of maps, just more difficult. <a name="composite_displace" id="composite_displace"></a>
          <h2>Composite Displacement Method</h2>We have used <a href="../transform/#fx">DIY FX Operator</a> was used to do the displacement mapping, so you can see what is actually being done. But it is a slow technique. But their is an equivelent built-in <a href="../compose/#compose">Composition Operator</a>, "<code>Displace</code>". Here is how you you use it...
          <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
    magick {<i>image</i>} {<i>displacement_map</i>} \
            -compose Displace   -define compose:args={<i>X</i>}x{<i>Y</i>} \
            -composite   {<i>result</i>+}

    magick {<i>image</i>} {<i>displacement_map</i>} \
            -compose Displace   -set option:compose:args {<i>X</i>}x{<i>Y</i>} \
            -composite   {<i>result</i>+}

    magick composite {<i>displacement_map</i>} {<i>image</i>} \
              -displace {<i>X</i>}x{<i>Y</i>}    {<i>result</i>+}
</samp></pre>
              </td>
            </tr>
          </table>
          <p>Note the order, expecially in the "<code>magick composite</code>" command.</p>The use of "<code>-set</code>" instead of define also allows you to use <a href="../basics/#arg_percent">Percent Escapes</a> in the argument. The '<i>X</i>' and '<i>Y</i>' values define the direction and 'maximum displacement' that will be used for 'white' and 'black' colors in the given displacement map. You can define either one, or both values, so as to allow you to displace in any particular direction. That is, normally displacement maps provide a linear displacement in some random direction with a maximum intensity controlled by the '<i>X</i>' and '<i>Y</i>' values. The 'map image' then sets how much of that maximum is applied from a negatative maximum (black) to a positive maximum (white), with a perfect gray meaning no displacement of the lookup for that pixel. For example, here is the same Y displacement example we had above...
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick label.jpg  displace_map.jpg  -virtual-pixel Gray \
          -compose Displace -define compose:args=0x10 -composite \
          displaced_y.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displaced_y.jpg"><img src="displaced_y.jpg" width="150" height="50" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can also make use of other setting like "<code><a href="https://imagemagick.org/script/command-line-options.php?#geometry">-geometry</a></code>" and "<code><a href="https://imagemagick.org/script/command-line-options.php?#gravity">-gravity</a></code>" settings, to adjust the area the displacement map is overlayed on the image. The pixel look up resulting from the displacement map can still reference areas outside the overlaid part of the image, duplicating them inot the overlayed area. <!--
<A NAME="convertion"></A>
<H3>Absolute to Relative Map Conversion</H3>

You can magick absolute position distortion maps, directly into an equivalent
displacement map, on the condition that the vector scaling is set to the size
of the original image.  It just requires some extra processing.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

For example, here I magick the 'trapezoidal' X positional map created above
into a X displacement map.

<table class="table table-sm table-hover table-striped" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE _EXECUTE>
  magick map_p_trapezoidal.png -interpolate integer \
          -fx '(u-i/w)/2+.5'   map_p2d_trapezoidal.png
</samp></pre></TD></TR></TABLE>
</TD><TD>
  <A HREF="map_p2d_trapezoidal.png"
     ><IMG SRC="map_p2d_trapezoidal.png"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 width="100%">
<TR VALIGN=bottom><TD width="100%" ALIGN=justify>

Okay so we now have a displacement map, lets try it using the fast "<A
HREF="https://imagemagick.org/script/command-line-options.php?#displace" ><CODE>-displace</CODE></A>" composite
operator.

<table class="table table-sm table-hover table-striped" CELLSPACING=0 CELLPADDING=5 width="100%" bgcolor="#f8f8f8">
<TR><TD><PRE><CODE _EXECUTE>
  magick composite map_p2d_trapezoidal.png box_image.png \
            -displace 100x0   distort_p2d_trapezoidal.png
</samp></pre></TD></TR></TABLE>
</TD><TD>
  <A HREF="distort_p2d_trapezoidal.png"
     ><IMG SRC="distort_p2d_trapezoidal.png"          WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As this displacement map was just a converted positional distortion map,
the invalid areas remain 'clipped' or 'pegged' to the edge colors of the
source image (black). </P>
-->
          <a name="displace_simple" id="displace_simple"></a>
          <h3>Simple Displacement Examples</h3>A displacement map of raw areas of colors, without any smooth transition will generaly produce disjoint (discontinuous) displacements between the different areas in the resulting image, just as you saw above. You can in fact produce a displacement map that 'fractures' as if you were looking into a cracked mirror, using this technique. For example see the <a href="#displace_mirror">Fractured Mirror</a> below. You can produce nicer and smoother results if the colors smoothly flowed from one area to another. For example, by bluring the displacement map you generate a wave like transtion between the displaced areas...
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick displace_map.jpg  -blur 0x10   dismap_wave.jpg
  magick label.jpg  dismap_wave.jpg  -virtual-pixel Gray \
          -compose Displace -define compose:args=0x10 -composite \
          displaced_wave_y.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="dismap_wave.jpg"><img src="dismap_wave.jpg" width="150" height="50" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                <a href="displaced_wave_y.jpg"><img src="displaced_wave_y.jpg" width="150" height="50" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Rather than displace the image in a Y direction you can also use a map to displace the image in a X direction resulting in a sort of compression wave.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick label.jpg  dismap_wave.jpg  -virtual-pixel Gray \
          -compose Displace -define compose:args=10x0 -composite \
          displaced_wave_x.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displaced_wave_x.jpg"><img src="displaced_wave_x.jpg" width="150" height="50" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>By using the same displacement map for both X and Y directions, we can add both a compression wave as well as an amplitude wave.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick label.jpg  dismap_wave.jpg  -virtual-pixel Gray \
          -compose Displace -define compose:args=10x10 -composite \
          displaced_wave_xy.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displaced_wave_xy.jpg"><img src="displaced_wave_xy.jpg" width="150" height="50" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that the image is still displaced in a single linear direction, resulting in the above image being stretched on the downward slope, and squeezed together on the upward slope. That is, the distortion is being performed at an angle or 'vector', with both horizontal and vertical components. You can see that this effect is remarkably like it is underwater, with the image being distorted by gentle ripples on the water's surface. A distortion map however can contain multiple copies of the original image, just as you can in a reflected or refracted images...
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  echo "P2 3 1 255\n 255 127 0 " | magick - -scale 150x50\! dismap_copy.jpg
  magick label.jpg  dismap_copy.jpg \
          -compose Displace -define compose:args=66x0 -composite \
          displaced_copy.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="dismap_copy.jpg"><img src="dismap_copy.jpg" width="150" height="50" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a><br>
                <a href="displaced_copy.jpg"><img src="displaced_copy.jpg" width="150" height="50" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You can also create mirrored flips or flops of parts of the image, by using gradients. For example, here you can use a linear displacement map, to copy pixels from one side of the image to the other.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 50x150 gradient: -rotate -90  -alpha off  dismap_mirror.png
  magick label.jpg  dismap_mirror.png \
          -compose Displace -define compose:args=150x0 -composite \
          displaced_mirror.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="dismap_mirror.png"><img src="dismap_mirror.png" width="150" height="50" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                <a href="displaced_mirror.jpg"><img src="displaced_mirror.jpg" width="150" height="50" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Can figure out how this displacement map works? &nbsp; As a hint figure out what displacement the left most and the right most edges have, then see how the rest of the image fits into that. However as you are again using a gradient image you loose the simplicity of displacement maps. As such mirrors are either better done using a direct <a href="../warping/#flip">Flip Operation</a> on the image, or by using a <a href="#distortion_maps">Absolute Distortion Map</a> instead. Note that by flipping the gradient over, you shrink the image.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 50x150 gradient: -rotate 90  -alpha off  dismap_shrink.png
  magick label.jpg  dismap_shrink.png \
          -compose Displace -define compose:args=150x0 -composite \
          displaced_shrink.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="dismap_shrink.png"><img src="dismap_shrink.png" width="150" height="50" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a><br>
                <a href="displaced_shrink.jpg"><img src="displaced_shrink.jpg" width="150" height="50" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The above also demonstrates a particular problem that displacement maps have. When an area (or all) of an image gets compressed by more than 50%, you will start to generate <a href="../filter/#aliasing">Aliasing Artefacts</a>. this is particularly noticable in the staircased 'aliased' edges that is clearly visible. As previously discussed, one solution to this is to <a href="../distorts/#super_sample">Super Sample</a> the number of pixels being used to generate each output pixel. To do that we enlarge both the image and displacement map, then resize the resulting image back to its more normal size. This will allow more pixels to take part in the setting of a specific pixel in the result, and thus produce better image. For example...
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick label.jpg  dismap_shrink.png  -resize 200% \
          -compose Displace -define compose:args=400x0 -composite \
          -resize 50%    displaced_resize.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displaced_resized.jpg"><img src="displaced_resized.jpg" width="150" height="50" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>A much better and smoother result, though perhaps a little fuzzy too. <a name="displace_graph" id="displace_graph"></a> <b>Graphing a gradient</b> Directly resulting from the above examples was an idea that by using Y displacements of a simple line, you can generate a graph of the colors of a displacement map. For example, here I generate a mathematical <code>sinc()</code> function ( which is defined as '<code>sin(x)/x</code>'), and graph that gradient by using it as a displacement map...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 121x100 xc: -fx 'sin(i*24/w-12)/(i*24/w-12)/1.3+.2' \
                                                      gradient_sinc.gif
  magick -size 121x100 xc: -draw 'line 0,50 120,50'     graph_source.gif
  magick graph_source.gif gradient_sinc.gif \
          -compose Displace -define compose:args=0x49 -composite \
          displace_graph.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="gradient_sinc.gif"><img src="gradient_sinc.gif" width="121" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="graph_source.gif"><img src="graph_source.gif" width="121" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="displace_graph.gif"><img src="displace_graph.gif" width="121" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
          </div>As you can see it works, though I wouldn't like to use it for mathematical plots. Better to use a proper graphing package. This technique however is useful as a dirty method of plotting the intensities of a row or column of pixels in an image. What it does do is show how large differences in displacements can easily produce a discontinuity or non-smooth result. Basically as only each individual pixel in the "graph source" is only looked at one at a time, without averaging, a large difference in the displaced lookup from one pixel to the next, can produce a large color change in the result. The moral is that displacement work best not only with smooth displacement maps, but also with displacing images that contains large areas or shades of color. It does not work so well for sharp thin lines. Of course you can improve things by again <a href="../distorts/#super_sample">Super Sampling</a> the distort map...
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick graph_source.gif gradient_sinc.gif  -resize 400% \
          -compose Displace -define compose:args=0x196 -composite \
          -resize 25%   displace_graph_2.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displace_graph_2.gif"><img src="displace_graph_2.gif" width="121" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The result is a lot better, though not as good as what can be achieved using a graphing package. Still only ImageMagick was used in its creation. Here is another version of the same graph, but this time using a solid color, which works a lot better than displacing a thin line.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 121x50 xc:white xc:black -append \
          gradient_sinc.gif  -resize 400% \
          -compose Displace -define compose:args=0x196 -composite \
          -resize 25%   displace_graph_3.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displace_graph_3.gif"><img src="displace_graph_3.gif" width="121" height="100" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table><a name="displace_areas" id="displace_areas"></a>
          <h3>Area Displacement (Linear)</h3>Lets try a more logical displacement problem. Moving an area of an image in a straight line from one location to another. As we have seen a 'pure gray' image will not cause any displacement, while a 'white' color will cause a positive lookup displacement from the source image. For example lets create such an image....
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 xc:gray50 -fill white \
          -draw 'circle 37,37 37,20'  dismap_spot.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="dismap_spot.jpg"><img src="dismap_spot.jpg" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Now when we apply this image the contents of the area marked should have a copy of whatever appears in the direction of the given displacement value. So lets try a displacement value of <i>X</i>+10 and <i>Y</i>+10 or '<code>10x10</code>'...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif dismap_spot.jpg \
          -compose Displace -define compose:args=10x10 -composite \
          displace_spot.png
</samp></pre>
                </td>
              </tr>
            </table><a href="dismap_spot.jpg"><img src="dismap_spot.jpg" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="displace_spot.png"><img src="displace_spot.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>As you can see the contents of the marked area now contains a copy of the image that was <code>+10,+10</code> pixels to the South-East. Basically a image of the koala's 'tail'. In other words, within the circle the image was displaced North-East, or <code>-10,-10</code> pixels. Remember the displacement is of the lookup, so the source image is shifted by a negative amount due to the <a href="../distorts/#mapping">Reversed Pixel Mapping</a>. The image displaces in the reverse direction! Note also that it is the image within the area marked that is moved. You are not displacing the image marked, but displacing the image <i>INTO</i> the area marked. And finally note the sharp discontinuity at the edges of the circle. Areas inside the marked area are moved, while the areas outside remain exactly as they were. These are the facts, so it is worth repeating.
          <div align="center">
            <b>Displacement moves images in oppisite direction to the value.<br>
            Only the areas marked not gray will be displaced.<br>
            Sharp color changes produce sharp image discontinuities.</b>
          </div>So lets try something more practical. Lets move the center between the nose and eyes of the koala, located at '<code>32,22</code>', to the center of our white (full positive displacement) circle at '<code>37,37</code>'. That needs a displacement value of '<code>-5,-15</code>' (remeber it is a reversed direction)...
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif dismap_spot.jpg \
          -compose Displace -define compose:args=-5x-15 -composite \
          displace_head.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displace_head.png"><img src="displace_head.png" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>And there we have a nicely centered copy of the central part of the koalas head. But the image is still 'disjoint', and using a negative value is not very nice. The solution is to use a black spot instead, but also to blur the edges of that spot. Also lets make it larger to encompass more of the koala's head. So here is out 'positive movement spot' image...
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 xc:gray50 -fill black \
          -draw 'circle 37,37 37,17'  -blur 0x5  dismap_area.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="dismap_area.jpg"><img src="dismap_area.jpg" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>You do not want to blur the image too much or the center of the spot will no longer be a flat black color. Alternatively you could just <a href="../color_mods/#normalize">Normalize</a>, <a href="../color_mods/#level">Reverse Level Adjust</a> the image to ensure that the drawn area is black, and surrounding parts are perfect grays. You will see this done a lot in later examples. Now lets repeat that last 'head' displacing using our black 'fuzzy spot' displacement map.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif dismap_area.jpg \
          -compose Displace -define compose:args=5x15 -composite \
          displace_area.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="displace_area.png"><img src="displace_area.png" width="75" height="75" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>As you can see we move move the image <code>+5,+15</code> into the 'fuzzy' area, but this time the border of the area is smoother and connected to the rest of the image. Of course the ears on the edge of the circle was distorted by the fuzzy edge, and the body of the koala compressed as well, but it is still a lot better than what we had before. To prevent the 'tearing' of the image you see on the trailing side, or leaving copies of the displaced part, you want to expand that spot, or make a more complex gradient type of displacement image. For example suppose you want to move the koalas head from its starting position at '<code>32,22</code>', to the center of the image at '<code>37,37</code>', or a movement of <code>+5,+15</code> pixels, but you want to adjust the whole image to this change, to give a much smoother effect. To do this you will want the maximum displacement of black (a positive image displacement) at '<code>37,37</code>' and displacing by a value of <code>+5,+15</code>. but you also want the make sure the rest of the image remains intact by 'pinning' the corners at 50% gray. That is, perfect for a <a href="../canvas/#shepards">Shepard's Interpolated Sparse Gradient</a>.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 xc:  -sparse-color  Shepards \
          '37,37 black   0,0 gray50  74,74 gray50  0,74 gray50  74,0 gray50' \
          dismap_move.jpg
  magick koala.gif dismap_move.jpg \
          -compose Displace -define compose:args=5x15 -composite \
          displace_move.png
</samp></pre>
                </td>
              </tr>
            </table><a href="dismap_move.jpg"><img src="dismap_move.jpg" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="displace_move.png"><img src="displace_move.png" width="75" height="75" align="middle" vspace="2" hspace="5" border="1" alt="[IM Output]"></a>
          </div>As you can see you get a larger area of displacement spread is spread over the whole image. The result is a much more smoothly changing image than the tighter 'spot' method used before. This is actually exactly equivalent to the <a href="../distorts/#shepards">Shepard's Distortion</a> but only for an one moving control point. It is also the exact same method used in Fred Weinhaus script '<code><a href="http://www.fmwconcepts.com/imagemagick/shapemorph/">shapemorph</a></code>', but with some animation. In summary: For small localized displacements a 'blurred spot' displacements can be used. But for larger displacements over a longer distance, a larger smooth gradient displacement map should be used to prevent tearing or duplicating the source image.
          <div align="center">
            <font size="+2"><b><img src="../img_www/const_barrier.gif" width="39" height="35" align="top"> Under Construction <img src="../img_www/const_hole.gif" width="144" height="50" align="middle"></b></font>
          </div><a name="simple_morph" id="simple_morph"></a>
          <h3>Simple Displacement Morphing</h3>
          <pre>Modifying the Size of Displacement Vectors</pre>
          <pre>Two Image Morphing</pre>
          <pre>Random 1D Displacements</pre><a name="water_ripples" id="water_ripples"></a>
          <h3>Rippled Water Reflections</h3>As mentioned before displacement maps are especially useful for generating water and glass like distortions. <a href="flower.jpg"><img src="flower.jpg" width="150" height="80" align="right" vspace="0" hspace="5" border="1" alt="[IM Output]"></a> For this example I generated a small image by <a href="../crop/#crop">Cropping</a> a flower image. Now I want to make it look like it is sitting on some rippled water. To generate ripples, I need a sine wave gradient of the same size which I can generate using the <a href="../transform/#evaluate_cos">Evaluate Sin Function</a>. The number '<code>8</code>' represents the number of 'waves' that will be added to the gradient.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 150x80 gradient:  -evaluate sin 8  wave_gradient.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="wave_gradient.png"><img src="wave_gradient.png" width="150" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Now lets distort that image using the an angled displacement vector, not just a simple vertical or horizontal distortion, so as to give it more emphasis.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick composite wave_gradient.png  flower.jpg -displace 5x5 flower_waves.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flower_waves.png"><img src="flower_waves.png" width="150" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                Now that does not seem very interesting, but what if you flip that image compress it vertically and append it to the original...
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick flower_waves.png -flip \
          flower.jpg  +swap -append  flower_waves_2.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flower_waves_2.png"><img src="flower_waves_2.png" width="150" height="160" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Unfortunately it still looks rather artificial. The reason is that the reflection looks the same at both the top and bottom of the image. It has no sense of 'depth' to it. The reflection is also the same brightness as the original image which is rarely the case. To make it more realistic you need to use ripple pattern that varies in intensity. The following uses some fancy <a href="../transform/#gradient_math">Gradient Mathematics</a> to 'attenuate' the wave gradient we were using above. That is, we made the wave pattern linearly smaller as it goes from top to the bottom. This trickiness ensures that the waves finishes at the pure-gray or 'no displacement' color at the bottom of the image (which is later flipped).
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick -size 150x80 gradient: \
          \( wave_gradient.png \
             +clone -compose multiply -composite \) \
          \( -clone 0 -negate -evaluate divide 2 \
             -clone 1 -compose plus -composite \) \
          -delete 0-1      waves_decreasing.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="waves_decreasing.png"><img src="waves_decreasing.png" width="150" height="80" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr valign="top">
              <td width="100%" align="justify">
                So lets apply this gradient, to form a new reflection of the flower. I also darkened the reflected image slightly to represent some light being lost into the water itself, making it seem more like a water reflection.
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick flower.jpg  waves_decreasing.png  \
          -compose Displace -define compose:args=8x8 -composite \
          -flip   +level 0,80% \
          flower.jpg  +swap -append   flower_in_water.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="flower_in_water.png"><img src="flower_in_water.png" width="150" height="160" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note that as the distorted image is <a href="../warping/#flip">Flipped</a> to form a reflection. Also the image will have less 'ripples' at the top of the 'water' closest to where it joins the original image, than at the bottom. This gives the distortion a sense of distance from the viewer. You can make it even more realistic by distorting the wave displacement maps with a slight rotation, arc, or just with 'random' displacements. This will give the waves a more natural look. Though it is better to do it before it is 'attenuated' so that the 'depth' is added afterward. Try it, experiment, and let me know what you come up with.
          <pre>Future Animated Ripples -
  Using -function Sinusoid with phase changing</pre><br>
          <a name="displace_2d" id="displace_2d"></a>
          <h3>2-Dimensional Displacement Mapping</h3>So far all the relative displacement maps have only displace the image in one direction only. Though that direction can be set to any angle desired by setting the appropriate '<code><i>X</i>x<i>Y</i></code>' displacement value or 'vector'. However you can produce a much more complex displacement where the image is displaced in any direction by any amount, by using two separate displacement. To do this we need to create two displacement maps, one for each of the X and Y directions separately. Here are the commands you can use...
          <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
magick {<i>image</i>} {<i>X displacement</i>} {<i>Y displacement</i>} \
        -compose Displace   -define compose:args={<i>X</i>}x{<i>Y</i>} \
        -composite   {<i>result</i>+}

magick {<i>image</i>} {<i>X displacement</i>} {<i>Y displacement</i>} \
        -compose Displace   -set option:compose:args {<i>X</i>}x{<i>Y</i>} \
        -composite   {<i>result</i>+}

composite {<i>X displacement</i>} {<i>image</i>} {<i>Y displacement</i>} \
          -displace {<i>X</i>}x{<i>Y</i>}    {<i>result</i>+}
</samp></pre>
              </td>
            </tr>
          </table>Note the input image order in the "<code>magick composite</code>" command. the wierd ording is caused by the need to abuse the "<code>magick composite</code>" option handling, as well as historical reasons. It is vital you get this correct. Because of this I recommend you use the "<code>magick</code>" command, rather than "<code>magick composite</code>".
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify"><font size="-1"><i>Before IM v6.4.4 using 2 separate displacement maps for separate X and Y displacements was a hit or miss affair. It sometimes worked, and sometimes did not. It is not recommended to attempt to even try to use it on IM's older than this version.</i></font></td>
            </tr>
          </table>Also, like with <a href="#distortion_unified">Unified Distortion Maps</a> you can use a single "Unified Displacemant Map". If only one displacement image is provided, then the X displacement will be looked up from the 'red' channel, the Y displacement will be looked up from the 'green' channel, and any alpha mask will also be transfered from the displacement map to the final image. The 'blue' channel is ignored.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Internally both "<code>magick</code>" and "<code>magick composite</code>' actually merge the two images (if provided) so as to generate a 'unified displacement map', before passing that to the internal API.<br>
              <br>
              This does not effect the previous 'linear displacements' we looked and previously as the displacement map given was a greyscale image, so both 'red' and 'green' channels were identical.</i></font></td>
            </tr>
          </table><a name="displace_cylinder" id="displace_cylinder"></a>
          <h3>Cylindrical Displacement</h3>Something that has come up a number of times in the IM forums is a way of mapping an image onto a cylinder, such as to overlay it on a coffee mug, or a soft drink can. This is the solution...
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick rose: -background black -gravity south -splice 0x8 \
          \( +clone -sparse-color barycentric '0,0 black 69,0 white' \) \
          \( -clone 1 -function arcsin 0.5 \) \
          \( -clone 1 -level 25%,75% \
                 -function polynomial -4,4,0 -gamma 2 \
                 +level 50%,0 \) \
          -delete 1 \
          -virtual-pixel black  -define compose:args=17x7 \
          -compose Displace  -composite   rose_cylinder.png
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="rose_cylinder.png"><img src="rose_cylinder.png" align="middle" vspace="0" hspace="5" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The above is very complex but in essence uses two separate displacements simultaneously. An arcsin() compression in the X direction, and a circular arc displacement in the Y direction. Here is what the command is doing...
          <ul>
            <li>Load the "rose" image and add some space for the vertical displacement</li>
            <li>Create a horizontal mathematical gradient for later mathematical functions</li>
            <li>magick a copy of the gradient to generate a compressing displacement map</li>
            <li>magick another copy to a vertical elliptical arc displacement</li>
            <li>remove the linear gradient</li>
            <li>prepare and do the displacement</li>
          </ul>Result... A rose wrapped correctly into 30 degree isometric view of a cylinder. Break apart the above command to save and view the individual displacement maps. The key to remember is that the two map displacement performs the lookups of both X and Y values, to work out what pixel should end up at the location of the lookup. Remember the displacement is not an actually a displacement of the source image, but a displacement of the lookup into the source image. This displacement distortion method has been built into the "<code><a href="http://www.fmwconcepts.com/imagemagick/cylinderize/">cylinderize</a></code>" script by Fred Wienhaus. <a name="displace_mirror" id="displace_mirror"></a>
          <h3>Fractured Mirror</h3>You can create a 'fractured mirror' look to an image by generating random areas of X and Y displacements.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre><code execute="" script="" random="" image="mirror_areas.gif">
  magick dragon_sm.gif -sparse-color voronoi '  \
                  %[fx:rand()*w],%[fx:rand()*h]  red
                  %[fx:rand()*w],%[fx:rand()*h]  lime
                  %[fx:rand()*w],%[fx:rand()*h]  black
                  %[fx:rand()*w],%[fx:rand()*h]  yellow
               ' -interpolate integer -implode 1     mirror_areas.gif
</code><code execute="" script="">  magick  mirror_areas.gif -channel R  -separate   mirror_dismap_x.gif
  magick  mirror_areas.gif -channel G  -separate   mirror_dismap_y.gif

  magick composite mirror_dismap_x.gif  dragon_sm.gif  mirror_dismap_y.gif -alpha off \
            -background white -virtual-pixel background -displace 7 \
                                                        mirror_displaced.gif

  magick  mirror_areas.gif -edge 1 -threshold 20% \
            -evaluate multiply .7 -negate               mirror_cracks.gif
  magick composite mirror_displaced.gif  mirror_cracks.gif -compose multiply \
                                                        mirror_cracked.gif
</code></pre>
                </td>
              </tr>
            </table>
            <table cellspacing="0" cellpadding="0">
              <tr>
                <td align="right">
                  <a href="mirror_areas.gif"><img src="mirror_areas.gif" width="82" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;">
                </td>
                <td align="left">
                  <a href="mirror_dismap_x.gif"><img src="mirror_dismap_x.gif" width="82" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="../images/dragon_sm.gif"><img src="../images/dragon_sm.gif" width="82" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="mirror_dismap_y.gif"><img src="mirror_dismap_y.gif" width="82" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;">
                </td>
                <td>&nbsp;</td>
              </tr>
              <tr>
                <td>&nbsp;</td>
                <td align="right">
                  <a href="mirror_displaced.gif"><img src="mirror_displaced.gif" width="82" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a> <a href="mirror_cracks.gif"><img src="mirror_cracks.gif" width="82" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
                <td align="left">
                  <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="mirror_cracked.gif"><img src="mirror_cracked.gif" width="82" height="100" align="middle" vspace="5" hspace="5" border="1" alt="[IM Output]"></a>
                </td>
              </tr>
            </table>
          </div>Four randomly displaced areas are generated using a randomized <a href="../canvas/#voronoi">Voronoi Sparse Color</a> image. This is then given an <a href="../warping/#implode">Implosion Distortion</a> to warp those areas into the center of the image. As each of the four colored areas remain solid colors, each area will contain an undistorted, but displaced copy of the original image. However each area will have displaced the image in a different way, just as each shard of a fractured mirror would. To finish off the mirror, <a href="../transform/#edge">Edge Detection</a> is used to outline the edges of the regions and thus the fractured nature of the resulting image. That is, the cracks are also made visible.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/reminder.gif" width="20" height="16"><img src="../img_www/space.gif" width="20" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Technically I did not have to separate the 'red' and 'green' channels in colored random displacement map that was generated. I could have used them directly as X displacement is looked up from the 'red' channel, and Y displacement is looked up from the 'green' channel. That is, I could have used the "mirror_areas.gif" image directly as a "unified displacement map".</i></font></td>
            </tr>
          </table>
          <div align="center">
            <font size="+2"><b><img src="../img_www/const_barrier.gif" width="39" height="35" align="top"> Under Construction <img src="../img_www/const_hole.gif" width="144" height="50" align="middle"></b></font>
          </div><a name="shepards" id="shepards"></a>
          <h3>Shepards Displacement</h3><a name="random" id="random"></a>
          <h3>Random Displacements</h3><a name="lensing" id="lensing"></a>
          <h3>Lensing Effects</h3><a name="frosted_glass" id="frosted_glass"></a>
          <h3>Frosted Glass Effects</h3><a name="dispersion" id="dispersion"></a>
          <h3>Dispersion Effects (rotated displacements)</h3><a name="dispersion_displace" id="dispersion_displace"></a>
          <h3>Dispersion Effects with Randomized Displacement</h3>FUTURE: Other possible distort / displace mapping examples
          <ul>
            <li>Raytrace a gradient onto 3D objects so that later ANY image can be be mapped onto those objects.
              <ul>
                <li>X and Y gradient mapped images</li>
                <li>Pure Gray Image for color, highlights and shading</li>
              </ul>
            </li>
          </ul>
          <hr>
          <!-- ---------------------------------------------------------------- -->
          <a name="blur" id="blur"></a>
          <h2>Variable Blur Mapping</h2>Added to ImageMagick version 6.5.4-0, the "<code><a href="https://imagemagick.org/script/command-line-options.php?#compose">-compose</a></code>" method '<code>Blur</code>' provides you with a method of replacing each individual pixel by an Elliptical Gaussian Average (a blur) of the neighbouring pixels, according to a mapping image.
          <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
            <tr>
              <td>
                <pre class="bg-light text-dark mx-4"><samp>
    magick composite -blur {<i>Xscale</i>}[x{<i>Yscale</i>}[+{<i>angle</i>}]]<!--
-->          blur_map  image   result

    magick image  blur_map \
        -define compose:args='{<i>Xscale</i>}[x{<i>Yscale</i>}[+{<i>angle</i>}]]' \
        -compose blur -composite   result

    magick image  blur_map \
        -set option:compose:args '{<i>Xscale</i>}[x{<i>Yscale</i>}[+{<i>angle</i>}]]' \
        -compose blur  -composite   result
</samp></pre>
              </td>
            </tr>
          </table>
          <p>Note that this <a href="../compose">Image Composition</a> requires the use of an operational argument, which can be set in a number of ways. See <a href="../basics/#artifact">Globally Defined Artifacts</a> for more details. By using a variable map to control the blur you can blur one part of an image, while leaving another part completely alone, or you can produce effects such as <a href="../photos/#tilt_shift">Tilt-Shift Effect</a>, where a real world image is made to appear more like a small artifical model.</p>For example, here I blur one half of an image of a koala while leaving the other half completely un-blurred...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 37x75 xc:black -size 38x75 xc:white +append  blur_map_bool.gif
  magick koala.gif blur_map_bool.gif \
          -compose blur -define compose:args=3 -composite \
          blur_koala_bool.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="0" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="blur_map_bool.gif"><img src="blur_map_bool.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_koala_bool.gif"><img src="blur_koala_bool.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
          </div><!--
TESTING equivelence with blur and gaussian blur

    blur=1
    magick ~/im/images/koala.gif \
            \( -clone 0 -blur 0x$blur -set label blur \) \
            \( -clone 0 +level-colors white \
               -clone 0 +swap -define compose:args=$blur \
               -compose blur -composite -set label ewa \) \
            \( -clone 0 -gaussian 0x$blur -set label gaussian \) \
            -delete 0 miff:- | \
      montage - -background gray -geometry +2+2 show:

-->
          As you can see any pixel that was 'white' on the 'blur_map' image was blurred using the maximum value of '<i>sigma</i>' given, while anything that was 'black' was not blurred at all. In other words you have a very simple masked blur. Of course this could have been achieved in many other ways, but that does not explain where the power of blur mapping is. What makes this blur mapping versitile is that it is variable across the image. That is, if the blur mapping color is gray in color, than you will get a corresponding smaller blurred result, using a smaller 'neighbourhood', for that pixel. Black however is not blurred, while white is maximumally blurred, by the values given. One thing to note is that only the areas blurred will take extra time needed. Pixels which are not blurred, do not need this extra processing. This makes the above much faster than either using a <a href="#mask">Masked Composite</a> which is the same as bluring the whole image and merging the results. This time saving can be even more important when dealing with large blurs of very small areas of an image. For example, lets make the koala progressivally more blurry toward his feet...
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 gradient:black-white blur_map_gradient.gif
  magick koala.gif blur_map_gradient.gif \
          -compose blur -define compose:args=3 -composite \
          blur_koala_gradient.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="0" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="blur_map_gradient.gif"><img src="blur_map_gradient.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_koala_gradient.gif"><img src="blur_koala_gradient.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
          </div>And here is the same blur again but showing how the blur varies with the height.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick blur_map_bool.gif blur_map_gradient.gif \
          -compose blur -define compose:args=15 -composite \
         blur_edge_gradient.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="blur_map_bool.gif"><img src="blur_map_bool.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="0" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="blur_map_gradient.gif"><img src="blur_map_gradient.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_edge_gradient.gif"><img src="blur_edge_gradient.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
          </div>For a practical example of Variable Mapped Blurs, have a look at <a href="../photos/#tilt_shift">Photo Tilt Shift Effect</a>, and <a href="../fonts/#var_blur">Distance Blurred Shadow Font</a>. Note that it is the neighbourhood around each individual pixel that is used to generate the 'blurred color' for that pixel. That means that even though you may specify some part of an image to not be blurred, colors from that unblurred area may be used as part of the blur of surrounding pixels. That is, just because an area is not blurred does not mean that colors from that area is not used as part of result of other blurred pixels. That is colors from the unblurred area can 'leak' into the surrounding blurred areas. To blur a background without including foreground pixels you need to use a <a href="../masking/#read_mask">Read Mask Technique</a> to prevent them being read as part of the blur operatotion. <a name="blur_ellipse" id="blur_ellipse"></a>
          <h3>Elliptical Blurring</h3>The '<code>Blur</code>' compose setting uses a different technique to the normal <a href="../blur/#blur">Blur or Gaussian Blur Operators</a>, as it is implemented by using a Gaussian <a href="../distorts/#area_resample">Elliptical Area Resampling</a> algorithm that was developed for scaled image resampling as part of <a href="../distorts/#distort">Generalized Distortion Operator</a>. The elliptical area used for the neighbourhood resampling, also makes this method of blurring more versitile than a normal uniform 'circluar' blur provided by the operators "<code><a href="https://imagemagick.org/script/command-line-options.php?#blur">-blur</a></code>" and "<code><a href="https://imagemagick.org/script/command-line-options.php?#gaussian-blur">-gaussian-blur</a></code>". The ellipse itself is defined by the '<i>width</i>', '<i>height</i>' of the sigma for the blurred area. The ellipse can also be rotated from an orthogonal alignment by the given '<i>angle</i>' (clock-wise). For example in the following diagram we show how the blurred color of a single pixel will get its color from a rotated elliptical area, based on the given sigma values. The pixels in this area are then weighted averaged together according to a <a href="../filter/#gaussian">Gaussian Filter</a> (using an elliptical distance formula, to produce the blurred color. <!-- <CODE EXECUTE>
  magick koala.gif \( +clone -size 75x75 xc: \
             -compose blur -define compose:args=5x1-30 -composite \) \
          -compose over -bordercolor blue -border 1x1    +append \
          -gravity North -background LightSteelBlue -splice 17x0 \
          -draw "stroke Firebrick fill None \
                 path 'M 40,45  A 4,1 -30  0,0 40,55 \
                                A 4,1 -30  1,0 40,45 Z' " \
          -draw "stroke Firebrick fill None \
                 path 'M 131,50 L 56,40 M 131,50 L 35,60' " \
          elliptical_average.gif
</CODE>-->
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif -compose blur -define compose:args=5x1-30 -composite \) \
             elliptical_blur.gif
  # ... other commands to create diagram of blur effect ...
</samp></pre>
                </td>
              </tr>
            </table><a href="elliptical_average.gif"><img src="elliptical_average.gif" align="middle" vspace="2" hspace="2" border="0" alt="[IM Output]"></a>
          </div>As mentioned, this is exactly the same color lookup method that is used by the <a href="../distorts/#distort">Generalized Distortion Operator</a> to generate the colors for its distorted images, as it allows for a scaled (and filtered) merge of an area of the source image into one pixel, especially in extreme distortions such as exampled in <a href="../distorts/#horizon">Viewing Distant Horizons</a>. For more details of this process see <a href="../distorts/#area_resample">Area Resampling</a> and <a href="../filter/#filter">Resampling Filters</a>.
          <p>As an example of the elliptical controls available for variable blur mapping, lets use a black dot using the same gradient blur map we used before. But this time we will scale a long thin horizontal ellipse '<code>30x0</code>', rather than a circle. The 'x0' may seem weird but basically means no vertical blurring should be seen, just an ellipse of smallest height needed to generate a good result.</p>
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 75x75 xc: -draw 'circle 36,36 36,8'  black_circle.gif
  magick black_circle.gif blur_map_gradient.gif \
          -compose blur -define compose:args=15x0 -composite \
          blur_horizontal.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="black_circle.gif"><img src="black_circle.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="0" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="blur_map_gradient.gif"><img src="blur_map_gradient.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_horizontal.gif"><img src="blur_horizontal.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
          </div>As you can see the amount of the blur is still varied with the map image provided, producing very little blur at the top of the image, and a lot of blur at the bottom. But also notice that the bottom edge is blurred horizontally equally in both directions, but not vertically, producing a sharp cut off in the vertical direction. By either rotating the long thin ellipse by giving a third <i>angle</i> argument, or by directly defining a vertical ellipse, you can blur the image vertically only...
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick black_circle.gif blur_map_gradient.gif \
          -compose blur -define compose:args=0x15 -composite \
          blur_vertical.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="blur_vertical.gif"><img src="blur_vertical.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Note however that the blur was not applied equally! The top half appears less blurred than the bottom, because that is what the 'mapping image' told it to do. This in turn distorts the image making it appear a little truncated by the blurring effect. Finally lets do this one more time but with a horizontal ellipse rotated by a fixed 45 degree angle.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick black_circle.gif blur_map_gradient.gif \
          -compose blur -define compose:args=15x0+45 -composite \
          blur_angle.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="blur_angle.gif"><img src="blur_angle.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>The image may appear very odd, but that is because the variable blur map is vertical while the blur itself is angled, producing the odd looking effect, due to the way the ellipse angle and the angle of the blur map do not align.
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/expert.gif" width="23" height="26"><img src="../img_www/space.gif" width="17" height="16"></td>
              <td align="justify" width="100%"><font size="-1"><i>Note that using long thin ellipses like this is actually a lot faster that using a single large circle. In fact the "<code><a href="https://imagemagick.org/script/command-line-options.php?#blur">-blur</a></code>" operator gets its speed by using two separate horizontal and vertical blurs, where as the "<code><a href="https://imagemagick.org/script/command-line-options.php?#gaussian">-gaussian</a></code>" blur operator does a full 2 dimensional <a href="../morphology/#convolve">convolution</a> in a simpler way to the '<code>Blur</code>' composition method just described.</i></font></td>
            </tr>
          </table><a name="blur_aspect" id="blur_aspect"></a>
          <h3>Blur with Variable Aspect Ratio</h3>So far the we have varied the size of the elliptical area used for the blur using 'blur map'. However the while the size of the ellipse and even its angle can be rotated, it shape and angle remains fixed. Now the 'blur map' is an image that is composed of three color channels: red, green, and blue. As we used a grey-scale image all three color channels had the same values. However internally the width of the ellipse is scaled by just the red channel value, while the height is scaled by the green channel value. Any effect of the blue channel value is typically ignored except in a special case which we will look at later. This means the elliptical shape or its 'aspect ratio' can be varied by using different maps for the individual red and green channels. As with a normal blur map a zero (or 'black' in just that channel) value will result in minimal width or height, while a maximum value (or 'white') will result in the blur amount given. For example, here I can divide the image so that two quarters of the image is blurred horizontally (red channel is maximal) while making the other areas blur vertically (green channel is maximal). For this example I generated with width and height maps separately, before <a href="../color_basics/#combine">Combining</a> them into a single and now colorful 'blur map'. In normal practice you can create the map in any way you like, or even use pre-prepared maps for specific blur effects.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 2x2 pattern:gray50 -sample 75x75! blur_map_r.gif
  magick blur_map_r.gif -negate blur_map_g.gif
  magick blur_map_r.gif blur_map_g.gif -background black \
          -channel RG -combine blur_map_aspect.gif
  magick black_circle.gif blur_map_aspect.gif \
          -compose blur -define compose:args=10x10 -composite \
          blur_aspect.gif
</samp></pre>
                </td>
              </tr>
            </table><a href="blur_map_r.gif"><img src="blur_map_r.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="0" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="blur_map_g.gif"><img src="blur_map_g.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_map_aspect.gif"><img src="blur_map_aspect.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a><br>
            <a href="black_circle.gif"><img src="black_circle.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="0" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="blur_map_aspect.gif"><img src="blur_map_aspect.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_aspect.gif"><img src="blur_aspect.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
          </div>You can of course still set a fixed angle to the ellipse.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick black_circle.gif blur_map_aspect.gif \
          -compose blur -define compose:args=15x15+45 -composite \
          blur_aspect_angle.gif
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="blur_aspect_angle.gif"><img src="blur_aspect_angle.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>
          <table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
            <tr valign="top">
              <td><img src="../img_www/warning.gif" width="28" height="28"><img src="../img_www/space.gif" width="12" height="16"></td>
              <td align="justify"><font size="-1"><i>Before IM version 6.5.8-8 a bug was found in the handling of an angled vertical elliptical blur.</i></font></td>
            </tr>
          </table><a name="blur_angle" id="blur_angle"></a>
          <h3>Blur with Variable Angle</h3>So far the angle of the ellipse used for bluring the image has been a constant angle over the whole image. That is, the ellipse used for the blur has always been at the same angle, even though the aspect ratio of the ellipse can be varied by modifying the red and green channels of the blur map. As of IM v6.5.8-8 you can provide variable an angle to the blur, using the blue channge of the blur mapping image. This is gone by giving two angles to the blur arguments. The first angle argument is used to define the angle for a zero ('0' or 'black') value in the blue channel, while the second angle given is used to define the maximum ('QuantumRange' or 'white') value of the blue channel. If only one angle value is given, then that angle is used to set the angles for both zero and maximum 'blue' channel value which basically means the angle becomes fixed, regardless of what value is present in the blue channel of the 'blur map' image. This is why in previous examples, the angle has been constant. For example, here I use a horizontally blurring ellipse, but then vary the angle of the ellipse using the blue channel over the angle range from '+0' to '+360' around the center of the image. The map generation uses a polar gradient, the details of which can be found in <a href="../canvas/#gradient_distort">Distorted Gradients</a>. Note how when placing that gradient into the blue channel, I use the "<code><a href="https://imagemagick.org/script/command-line-options.php?#background">-background</a></code>" color setting with the <a href="../color_basics/#combine">Combine Operator</a> to ensure both the red and green channels are set to a maximum ('white') value, so it does not scale the angled ellipse. Of course that means in the final mapping image white means use the maximum angle, while yellow (or zero blue channel value) means the minimum angle.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 100x300 gradient: -rotate 90 \
          +distort Polar '36.5,0,.5,.5' +repage -flop gradient_polar.jpg
  magick gradient_polar.jpg -background white \
          -channel B -combine blur_map_angle.jpg
  magick koala.gif blur_map_angle.jpg \
          -compose blur -define compose:args=5x0+0+360 -composite \
          blur_rotated.jpg
</samp></pre>
                </td>
              </tr>
            </table><a href="gradient_polar.jpg"><img src="gradient_polar.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_map_angle.jpg"><img src="blur_map_angle.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a><br>
            <a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="0" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="blur_map_angle.jpg"><img src="blur_map_angle.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_rotated.jpg"><img src="blur_rotated.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
          </div>The result is as you can see a rotationally blurred image. Compare the result with the blur mapping that was used. At the top of the image the angle, the gradient was either white or black, which with the arguments used means the ellipse was angled at either 0 or 360 so the ellipse remained horizontal. at the bottom the graident was pure gray, so an angle midway between the rangle given was use, or 180 degrees. This means the ellipse is again horizontal. But at the sizes the image the gradient was either 25% or 75% gray. thus the angle was either 90 or 270 degress making the ellipse rotate vertically. All the other angles follow though causing the ellipse to rotate smoothly around the image. However the center of the resulting image was blurred really weirdly! That is because the ellipse size remained constant and does not get appropriatally smaller toward the middle of the image. The solution is to also set the ellipse size using the red and green channels. For example.
          <div align="center">
            <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="90%" bgcolor="#F8F8F8">
              <tr>
                <td>
                  <pre class="bg-light text-dark mx-4"><samp>
  magick -size 106x106 radial-gradient: -negate \
          -gravity center -crop 75x75+0+0 +repage gradient_radial.jpg
  magick gradient_radial.jpg gradient_radial.jpg gradient_polar.jpg \
          -channel RGB -combine blur_map_polar.jpg
  magick koala.gif blur_map_polar.jpg \
          -compose blur -define compose:args=10x0+0+360 -composite \
          blur_polar.jpg
</samp></pre>
                </td>
              </tr>
            </table><a href="gradient_radial.jpg"><img src="gradient_radial.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="gradient_radial.jpg"><img src="gradient_radial.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="gradient_polar.jpg"><img src="gradient_polar.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_map_polar.jpg"><img src="blur_map_polar.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a><br>
            <a href="../images/koala.gif"><img src="../images/koala.gif" width="75" height="75" align="middle" vspace="2" hspace="2" border="0" alt="[IM Output]"></a> <img src="../img_www/plus.gif" width="20" height="20" align="middle" alt=" + "> <a href="blur_map_polar.jpg"><img src="blur_map_polar.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a> <img src="../img_www/right.gif" width="20" height="20" align="middle" alt="==&gt;"> <a href="blur_polar.jpg"><img src="blur_polar.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
          </div>A much better result. Note however that while the result looks good, the blurring ellipse is not properly curved in an arc as it should be for a true rotationally blurred image. As such the above is only an approximation of a true rotational blur. But for small blur distances (equating to blur angle) it quite good. The better way to do rotational blurs is to use a special <a href="..distorts/#rotation_blur">Polar-Depolar Distortion Technique</a>, or the currently miss-named <a href="../blur/#radial-blur">Radial Blur Operator</a>. By changing the angle range used for the ellipse angle (blue channel) you can easily magick the above into a radial blur that becomes more blurry with distance from the center.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif blur_map_polar.jpg \
          -compose blur -define compose:args=5x0+90+450 -composite \
          blur_radial.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="blur_radial.jpg"><img src="blur_radial.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>But you can also do much more than these radial/rotational blurs, as you can rotate and scale the blur anywhere by any amount over the whole image. You have total control. For example you can make a very weird mixture of the two by using different angle range so the angle of the blur ellipse does not match the angle around the image center.
          <table border="0" cellspacing="0" cellpadding="0" width="100%" align="center">
            <tr>
              <td width="100%" align="justify">
                <table class="table table-sm table-hover table-striped" cellspacing="0" cellpadding="5" width="100%" bgcolor="#F8F8F8">
                  <tr>
                    <td>
                      <pre class="bg-light text-dark mx-4"><samp>
  magick koala.gif blur_map_polar.jpg \
          -compose blur -define compose:args=10x0+0+180 -composite \
          blur_weird.jpg
</samp></pre>
                    </td>
                  </tr>
                </table>
              </td>
              <td>
                <a href="blur_weird.jpg"><img src="blur_weird.jpg" width="75" height="75" align="middle" vspace="2" hspace="2" border="1" alt="[IM Output]"></a>
              </td>
            </tr>
          </table>Basically you now have complete control of the how and what parts of the image will be blurred. And with the use of templates you can create a whole library of blurring effects.
          <hr>
          <!-- ---------------------------------------------------------------- -->
        </div>
      </div>
    </div>
  </main>
  <footer class="text-center pt-3 my-3 text-body-secondary border-top">
    <div class="small">
      Created: 14 January 2009 (distorts sub-division)<br>
      Updated: 7 January 2019<br>
      Author: <a href="https://antofthy.gitlab.io/anthony.html">Anthony Thyssen</a>, &lt;Anthony.Thyssen@gmail.com&gt;<br>
      Examples Generated with: <img src="version.gif" align="absmiddle" alt="[version image]"><br>
      URL: <code>https://usage.imagemagick.org/mapping/</code>
    </div>
  </footer>
</body>
</html>
