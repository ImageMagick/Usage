<HTML><HEAD>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
<TITLE>Cutting and Bordering -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/crop/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Cutting and Bordering</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="#crop"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Crop (cutting up images in a free form way)</A>
    <UL>
    <LI><A HREF="#crop"
        >The basic crop operator</A>
    <LI><A HREF="#crop_missed"
        >The Missed Image (from a bad crop)</A>
    <LI><A HREF="#crop_page"
        >Crop an Image with Existing Virtual Canvas</A>
    <LI><A HREF="#crop_repage"
        >Removing Virtual Canvas from Results</A> using +repage <B>***</B>
    <LI><A HREF="#crop_viewport"
        >Viewport Crop with Virtual Canvas Adjustments</A>
    <LI><A HREF="#crop_gravity"
        >Crop Relative to Gravity</A>
    <LI><A HREF="#crop_percent"
        >Crop a Percentage of an Image</A>
    <LI><A HREF="#crop_tile"
        >Tile Cropping, sub-dividing one image into multiple images</A>
    <LI><A HREF="#crop_tile_centered"
        >Centered Tile Cropping, leaving remainders around the edge</A>
    <LI><A HREF="#crop_strip"
        >Strip Cropping, cropping out rows and columns</A>
    <LI><A HREF="#crop_quad"
        >Quadrants, cutting around a single point</A>
    <LI><A HREF="#crop_neg_offset"
        >Using Negative Offsets, remove bottom or left edge</A>
    <LI><A HREF="#crop_equal"
        >Cropping into roughly Equally Sized Divisions</A>
    <LI><A HREF="#crop_spaced"
        >Separating Spaced-out Tiling Images</A>
    </UL>
<DD><A HREF="#border"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Adding/Removing Image Edges</A>
    <UL>
    <LI><A HREF="#border"
        >Border, adding space around the edge of an image</A>
    <LI><A HREF="#frame"
        >Frame,  adding 3D-like borders to images</A>
    <LI><A HREF="#shave"
        >Shave,  removing the edges from images</A>
    <LI><A HREF="#extent"
        >Extent, direct image size adjustment</A>
    </UL>
<DD><A HREF="#splice"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Adding/Removing Rows, Columns and Edges</A>
    <UL>
    <LI><A HREF="#splice"
        >Splice, adding a row, column or edge</A>
    <LI><A HREF="#chop"
        >Chop, removing a row, column or edge</A>
    </UL>
<DD><A HREF="#advanced"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Advanced Cropping Techniques</A>
    <UL>
    <LI><A HREF="#crop_aspect"
        >Crop to a Given Aspect Ratio</A>
    </UL>
<DD><A HREF="#trim"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Trim, the 'Auto-Crop' Operator</A>
    <UL>
    <LI><A HREF="#trim"
        >Using Trim</A>
    <LI><A HREF="#trim_color"
        >Trimming with a Specific Color</A>
    <LI><A HREF="#trim_oneside"
        >Trimming just One Side of an Image</A>
    <LI><A HREF="#trim_fuzz"
        >Trimming 'Fuzzy' Images</A> -- Low Quality JPEG Images
    <LI><A HREF="#trim_noisy"
        >Trimming 'Noisy' Images</A> -- Scanned or Video Images
    </UL>
</DL></P>

Here we explore the ImageMagick operations which allow you to put your images
under the knife, and add frames and borders around the image.  That is we look
at operations which Changes an image's size, without scaling the image
content. </P>

You may think this is a simple operation and it is.  So simple, that IM
provides a huge number of ways and methods of actually doing this task.  So
many that I needed to give it its own page of examples just to demonstrate
them all.  </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="crop"></A>
<H2>Crop <FONT SIZE=3>(cutting images down to size)</FONT></H2>

<H3>Crop and Canvas Page</H3>

The "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" image operator
will simply cut out the part of all the images in the current sequence at the
size and position you specify by its geometry argument.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:                    rose.gif
  convert rose: -crop 40x30+10+10  crop.gif
  convert rose: -crop 40x30+40+30  crop_br.gif
  convert rose: -crop 40x30-10-10  crop_tl.gif
  convert rose: -crop 90x60-10-10  crop_all.gif
</CODE><CODE EXECUTE ERR=crop_error.txt
>  convert rose: -crop 40x30+90+60  crop_miss.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
 <A HREF="rose.gif"
    ><IMG SRC="rose.gif"                  WIDTH=70  HEIGHT=46
          ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
 <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
 <A HREF="crop.gif"
    ><IMG SRC="crop.gif"
          ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
 <A HREF="crop_br.gif"
    ><IMG SRC="crop_br.gif"
          ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
 <A HREF="crop_tl.gif"
    ><IMG SRC="crop_tl.gif"
          ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
 <A HREF="crop_all.gif"
    ><IMG SRC="crop_all.gif"
          ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
 <A HREF="crop_miss.gif"
    ><IMG SRC="crop_miss.gif"
          ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

Just so you can check on exactly what happened here is output from
"<CODE>identify</CODE>" on the results of the crop above.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOWARN OUT=crop_indent.txt>
  identify rose: crop.gif crop_br.gif crop_tl.gif \
                 crop_all.gif crop_miss.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="crop_indent.txt"
     ><IMG SRC="crop_indent.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Notice that the size of the displayed image (its <A
HREF="../basics/#virtual_canvas" >Virtual Canvas</A>) has not been effected by
the "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" operation.
The actual image itself has been cropped, and may be smaller, but the canvas
on which the GIF image is displayed is still the same size as the original
canvas. </P>

You will also notice that the size of the actual image produces may not be the
actual size you requested from the crop.   It could be very much smaller that
what you expected, as the crop itself was either partially or fully outside
the actual image area being cropped. </P>

You will also notice that the 'offset' of the image on the <A
HREF="../basics/#virtual_canvas" >Virtual Canvas</A> was in many cases also
changed so that the pixels of cropped image is still in exactly the same
position as they were in the original image. That is the image contents itself
does not move, even though the actual image itself is smaller. </P>

This means if you now modify the smaller image, then overlay the image (using
<A HREF="../layers/#flatten" >image layering operators</A> back over the
original, it will fit back exactly where the sub-image originally came from.
</P>

That is IM retains the 'virtual canvas', 'page', or 'layering' information of
the image so as to preserve it for later use.  This is especially important
for the correct working for GIF animation handling. For more information on
this see.  <A HREF="../anim_basics/#deconstruct" >Deconstruct GIF
Animations</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
   ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  GIF images make active use of the 'page' or 'virtual canvas', size and
  offset information in images cropped by IM.  If you don't want this
  information remove it with "<CODE><A HREF="../option_link.cgi?repage"
  >+repage</A></CODE>" immediately after the "<CODE><A
  HREF="../option_link.cgi?crop" >-crop</A></CODE>". </P>

  Note that many image formats don't save this virtual page/canvas
  information information, so saving to such formats automatically removes
  it.  JPEG is a typical example of a format that removes this info. </P>

  The PNG format doesn't make much use of page/canvas info (except in the
  multi-png (MNG) format) but it does saves the page offset information
  (even negative offsets).   IM will also add a small amount of meta-data to
  preserve the virtual canvas size for later use by other IM commands. </P>

  Because of this preservation, I strongly recommend you still apply a
  "<CODE><A HREF="../option_link.cgi?repage" >+repage</A></CODE>" even when
  saving to JPEG or other page-less image format when you will not need that
  information, as a pre-caution, and to make it obvious you don't what it.
  </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="missed"></A>
<A NAME="crop_missed"></A>
<H3>The Missed Image (from a bad crop)</H3>

The last image in the above example (EG: "<CODE>crop_miss.gif</CODE>") also
produced special empty image.  Such images can be produced by operations such
as <A HREF="#crop" >Crop</A>, <A HREF="#trim" >Trim</A>, <A
HREF="../anim_basics/#compare" >Layer Comparison</A>, and even <A
HREF="../anim_opt/#optframe" >GIF Animation Optimizations</A>, that generate
empty or non-sensible results. </P>

For example in the previous example above, the "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>" operation missed the actual
image it was cropping, so it produced this special 'missed' image, as well as
some informational warning messages...  </P>

<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="crop_error.txt"
     ><IMG SRC="crop_error.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

The output image, or 'missed' image, is a minimal image, one pixel in size at
a 0 offset, but with original images page or canvas size, as well as any other
meta-data the image may have associated. Here it represents the 'empty' or
'zero sized' image that should have been returned by "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>", but as no image format can
output an image of 'zero' dimensions, a single transparent pixel image is used
instead. </P>

Just so you can see more clearly, here is the "<CODE><A
HREF="../basics/#identify" >identify</A></CODE>" output of the missed image,
as well as a 'IM pixel enumeration' of that single pixel image, showing that
it only contains one single transparent pixel.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOWARN OUT=crop_miss_ident.txt>
  identify crop_miss.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="crop_miss_ident.txt"
     ><IMG SRC="crop_miss_ident.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  crop_miss.gif  crop_miss_data.txt
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="crop_miss_data.txt"
     ><IMG SRC="crop_miss_data.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

This 'missed' image is basically same as creating a "<CODE><A
HREF="../files/#null" >null:</A></CODE>" image but with the original source
images page or virtual canvas size set (but not its offset), and all other
image meta-data, such as GIF animation timing delays. The GIF disposal method
however may be modified to ensure animations remain correct, after cropping.
</P>

Basically you need to keep in mind that "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>" and other similarly related
operators can produce a special 'missed' image.  As such you should plan to
look for the warning message, or this special 'Missed Image' when writing a
script using IM, if such a minimal image is possible and can cause you
problems. </P>

If you don't want the warning message (for example you expect and handle, the
occasionally 'missed' image), you can add a "<CODE><A
HREF="../option_link.cgi?quiet" >-quiet</A></CODE>" <A
HREF="../basics/#controls" >Operational Control Setting</A> to the command
line.  This tells IM to not output informational warning messages, only real
errors. </P>

At this time there is no method to remove any 'missed', or "<CODE><A
HREF="../files/#null" >null:</A></CODE>" images from the current image
sequence. However such a method has been proposed for a future release of IM.
Mail me if you find you need such a method. </P>


<A NAME="crop_page"></A>
<H3>Crop an image with existing Virtual Canvas</H3>

If an image already has an existing <A HREF="../basics/#virtual_canvas"
>Virtual Canvas</A>, (for example a frame of a GIF animation), then the
"<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" operation will be
applied relative to the virtual canvas, and NOT to the actual image. </P>

That is it will try to preserve the offset of the actual pixel data of the
cropped image on the canvas.  That is a specific pixel before the crop should
still be located at the same offset relative to the virtual canvas afterward.
In this way cropping of layered images, or GIF animations will continue to
work right, even though the 'canvas' itself was not cropped. </P>

Here we create an image centered on a page canvas, and we crop it in various
ways.  As before the canvas size itself is not modified by the operation.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=crop_page_ident.txt>
  convert rose: -shave 12x0 -repage 64x64+9+9  paged.gif
  convert paged.gif -crop 32x32+16+16  crop_page.gif
  convert paged.gif -crop 32x32+0+0    crop_page_tl.gif
  convert paged.gif -crop 32x32+32+32  crop_page_br.gif
  convert paged.gif -crop 60x60+2+2    crop_page_all.gif
  convert paged.gif -quiet -crop 32x32+56+56  crop_page_miss.gif
<n>  identify paged.gif crop_page.gif crop_page_tl.gif crop_page_br.gif \
           crop_page_all.gif crop_page_miss.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged.gif"
     ><IMG SRC="paged.gif"                WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="crop_page.gif"
     ><IMG SRC="crop_page.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_page_tl.gif"
     ><IMG SRC="crop_page_tl.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_page_br.gif"
     ><IMG SRC="crop_page_br.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_page_all.gif"
     ><IMG SRC="crop_page_all.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_page_miss.gif"
     ><IMG SRC="crop_page_miss.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="crop_page_ident.txt"
     ><IMG SRC="crop_page_ident.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

That last example in the above was of course, the special <A
HREF="#crop_missed" >Missed Image</A>.  Note that I suppressed the normal
warning message from IM using a "<CODE><A HREF="../option_link.cgi?quiet"
>-quiet</A></CODE>" setting. </P>

Just so you can see just what is going on, lets have a closer look at the
paged crop of the lower right corner of the image.  Here I have drawn a
semi-transparent square over the area that was cropped.

<A NAME="crop_area"></A>
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert paged.gif -page 64x64+32+32 -size 32x32 xc:'#fff8' \
          -matte  -background none  -mosaic    crop_area_br.png
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged.gif"
     ><IMG SRC="paged.gif"                WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="crop_area_br.png"
     ><IMG SRC="crop_area_br.png"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="crop_page_br.gif"
     ><IMG SRC="crop_page_br.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

From this you can see just what is happening.   Even though the crop is
contained completely in the page canvas, the crop did not cover the actual
image completely. The result is that the actual image is smaller than the user
may have intended, but still positioned on a larger canvas or page. </P>


<A NAME="crop_repage"></A>
<H3>Removing Virtual Canvas from Results</H3>

If this <A HREF="../basics/#virtual_canvas" >Virtual Canvas</A> information is
not wanted, then you can use the special "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>" operator to reset the
page canvas and position to match the actual cropped image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -crop 40x30+10+10  +repage  repage.gif
  convert rose: -crop 40x30+40+30  +repage  repage_br.gif
  convert rose: -crop 40x30-10-10  +repage  repage_tl.gif
  convert rose: -crop 90x60-10-10  +repage  repage_all.gif
  convert rose: -quiet  -crop 40x30+90+60  +repage  repage_miss.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"                 WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="repage.gif"
     ><IMG SRC="repage.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="repage_br.gif"
     ><IMG SRC="repage_br.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="repage_tl.gif"
     ><IMG SRC="repage_tl.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="repage_all.gif"
     ><IMG SRC="repage_all.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="repage_miss.gif"
     ><IMG SRC="repage_miss.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

This is of course the result new users of IM would normally have expected from
the "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" operator.  It
is actually such a common thing to do that you could call it a rule of thumb.
</P>

<DIV ALIGN=center><B>
       Always use "<CODE><A HREF="../option_link.cgi?repage"
                  >+repage</A></CODE>" after any 'crop' like operation.
<BR>        Unless you actually need to preserve that info.
</B></DIV></P>

The last image in the above is of course the special <A HREF="#crop_missed"
>crop missed image</A>, but I supressed the warning message using the
"<CODE><A HREF="../option_link.cgi?quiet" >-quiet</A></CODE>" operational
setting.  <P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  For IM version 5 and earlier the "<CODE><A
  HREF="../option_link.cgi?repage" >+repage</A></CODE>" operation was handled
  by a "<CODE>-page +0+0</CODE>" argument sequence, usually just before saving
  to format that uses virtual canvas and offset information, such as GIF.  But
  that was only usable when either reading or writing the image to a file,
  preventing its use between multiple image processing operations.  <P></P>

  With IM version 6, <A HREF="../basics/#cmdline" >command line
  restructure</A>, the "<CODE><A HREF="../option_link.cgi?page"
  >-page</A></CODE>" option became purely an image read/create setting for
  use in creating <A HREF="../anim_basics/#gif_anim" >GIF animations</A> and
  <A HREF="../layers/#flatten" >Layers of Images</A>. As such separate
  "<CODE><A HREF="../option_link.cgi?repage"
  >-repage</A></CODE>" and "<CODE><A HREF="../option_link.cgi?set"
  >-set</A> page</CODE>" operators were added to allow users to set or change
  the virtual canvas information.

</I></FONT></TD></TR></TABLE></P>


<A NAME="crop_viewport"></A> <H3>Viewport Cropping with Virtual Canvas
Adjustments</H3>

From ImageMagick version 6.2.4-5, you can add a new special flag to the
"<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" argument. This
flag '<CODE>!</CODE>' will tell crop to adjust the  <A
HREF="../basics/#virtual_canvas" >Virtual Canvas</A> information of the
returned image so that it is relative to the area cropped.  </P>

In other words, regardless of the resulting size of the actual image cropped,
the canvas and offset of the image returned will be adjusted to match the area
you requested cropped.  You can think of this flag as cropping an image to
match a 'window' or 'viewport' of the crop area.  Even if half the image is
not visible in that 'window', the virtual canvas and offset of the part
returned will match that 'viewport'. </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -crop 40x30+10+10\!  crop_vp.gif
  convert rose: -crop 40x30+40+30\!  crop_vp_br.gif
  convert rose: -crop 40x30-10-10\!  crop_vp_tl.gif
  convert rose: -crop 90x60-10-10\!  crop_vp_all.gif
  convert rose: -quiet -crop 40x30+90+60\!  crop_vp_miss.gif
</CODE><CODE EXECUTE NOWARN OUT=crop_vp_ident.txt>
  identify rose.gif  crop_vp.gif crop_vp_br.gif crop_vp_tl.gif \
              crop_vp_all.gif  crop_vp_miss.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"                  WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="crop_vp.gif"
     ><IMG SRC="crop_vp.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_vp_br.gif"
     ><IMG SRC="crop_vp_br.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_vp_tl.gif"
     ><IMG SRC="crop_vp_tl.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_vp_all.gif"
     ><IMG SRC="crop_vp_all.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_vp_miss.gif"
     ><IMG SRC="crop_vp_miss.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="crop_vp_ident.txt"
     ><IMG SRC="crop_vp_ident.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE>!</CODE>' character has special significance to some UNIX
  shells, like "<CODE>csh</CODE>", and must be escaped with a backslash,
  even when placed inside quotes.
</I></FONT></TD></TR></TABLE></P>

Notice how the canvas size of the image returned now matches the area in which
the image was cropped. </P>

For crops of images that are completely within the actual image, the result
will be equivalent to following the crop with a "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>". However any partial or
missed cropping of the image, the result will a larger canvas and a possible
offset to the resulting image.  As such this is no substitute for doing a
"<CODE><A HREF="../option_link.cgi?repage" >+repage</A></CODE>" after cropping
to reset page/canvas information. </P>

However you can follow a 'viewport crop' with a <A HREF="../layers/#flatten"
>Flatten</A> to 'fill out' the images new virtual canvas with real pixels.
That is you will be left with an image that is guaranteed to be the size of the
requested crop, with any 'missed' areas filled out with the current "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>" color 'viewport'.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

For example when <A HREF="../thumbnails/#pad" >Padding out an Image</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -crop 100x100-15-25\! -background skyblue -flatten \
          crop_viewport.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="crop_viewport.gif"
     ><IMG SRC="crop_viewport.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Flattening an image after a viewport crop is actually equivalent to using the
<A HREF="#extent" >Extent Operator</A> (see below), to provide a 'padded
crop'. </P>

A 'viewport crop' flag is also very important when cropping GIF animations, as
it not only adjusts the canvas size, but also insures all the image frames are
still correctly positioned within the cropped area.  Without this option
cropping a GIF animation is very difficult requiring external correction of
the image canvas size and offsets.  For and example of this, see <A
HREF="../anim_mods/#crop_viewport" >Animation Crop, with the canvas too</A>.
</P>

In many ways a 'viewport crop' is closely related to the special <A
HREF="../distorts/#distort_viewport" >Viewport Distort Setting</A> in that
both act is if they are a 'window' into the resulting image.  Both can be used
as a 'cropping' method. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE>!</CODE>' flag can NOT be used when generating multi-image
  <A HREF="#crop_tile" >Tiled crops</A>, or with equal-area tile cropping,
  where it has a different meaning. See the appropriate sections below.
</I></FONT></TD></TR></TABLE></P>


<A NAME="crop_gravity"></A>
<H3>Crop relative to Gravity</H3>

The offset position of the "<CODE><A HREF="../option_link.cgi?crop"
>-crop</A></CODE>" by default is relative to the top-left corner of the image.
However by setting the "<CODE><A HREF="../option_link.cgi?gravity"
>-gravity</A></CODE>" setting, you can tell "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>" to cut the image relative to
either the center, corner, or an edge of the image. </P>

The most common use of a gravitated crop, is to crop the '<CODE>center</CODE>'
of an image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -gravity Center  -crop 32x32+0+0 +repage  crop_center.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="crop_center.gif"
     ><IMG SRC="crop_center.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The "<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" setting
does not just effect the initial 'zero' position of the crop but it also
effects the direction of the crop offset. </P>

For example if you use a "<CODE><A HREF="../option_link.cgi?gravity"
>-gravity</A></CODE>" of '<CODE>South</CODE>', and offset of
'<CODE>+0+5</CODE>' will offset the crop area upward, instead of downward as
it normally would.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -gravity South  -crop 20x20+0+5   crop_south.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="crop_south.gif"
     ><IMG SRC="crop_south.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note the position of the crop example above.  I purposely left off the
"<CODE><A HREF="../option_link.cgi?repage" >+repage</A></CODE>" operation so you
can see how the crop area was displaced from the bottom edge of the image.
</P>

Also notice that the crop area is not only relative to bottom (southern) edge,
but that the area is center 'justified' to be middle of the bottom edge.  This
is done with all gravity effected operations. </P>


<A NAME="crop_percent"></A>
<H3>Crop a Percentage of an Image</H3>

The "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" operator also
understands how to crop an image to just a percentage of its original size.

For example this will half the size of the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:   -crop 50%x+0+0      crop_half.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="crop_half.gif"
     ><IMG SRC="crop_half.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  If only one size number is given, then that value is used for both the width
  and height percentages and the final size of the area that is being cropped
  will be rounded to nearest integer.   The offset is not optional.
</I></FONT></TD></TR></TABLE></P>

Note that while the size can be a percentage the offset will always be in
pixels.  You can not provide an offset as a percentage of the image size. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:   -crop 50%x+30+20      crop_percent.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="crop_percent.gif"
     ><IMG SRC="crop_percent.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  When a crop is given with an offset you <B>must</B> supply an
  '<CODE>x</CODE>' symbol in the argument so that the argument can be
  interpreted correctly. This is especially important when only a single
  number is provided for both width and height of the crop area. </P>

  As such you can not use an argument like '<CODE>50%+30+20</CODE> which
  is an error, and will result in crop silently doing nothing.

</I></FONT></TD></TR></TABLE></P>

More commonly a percentage crop is done from the center of an image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -gravity Center -crop 50x80%+0+0  crop_percent_center.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="crop_percent_center.gif"
    ><IMG SRC="crop_percent_center.gif"
          ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The percentage symbol '<CODE>%</CODE>' can appear anywhere in an argument,
  and if given will refer to both width and height numbers.  It is a flag
  that just declares that the 'image size' parts are a percentage fraction
  of the images virtual canvas or page size.  Offsets are always given in
  pixels.
</I></FONT></TD></TR></TABLE></P>

You can also use a 'viewport crop' flag with percentage crops, to
automatically set the canvas size and offset of the crop, to the area being
cropped.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -gravity Center -crop 50%\!  crop_percent_vp.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="crop_percent_vp.gif"
     ><IMG SRC="crop_percent_vp.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  You can not use percent sizes for tile cropping (see next).  As such if the
  offset is not provided, and a percent size is given (as above) an offset of
  +0+0 is assumed. </P>

</I></FONT></TD></TR></TABLE></P>

The '<CODE>!</CODE>' flag means a "<CODE><A HREF="../option_link.cgi?repage"
>+repage</A></CODE>" is not needed. Caution however is still recommended, for
input images that may also have virtual canvas size and offsets.  </P>

<A NAME="crop_tile"></A>
<H3>Tile Cropping, sub-dividing one image into multiple images</H3>

One of the more useful aspects of crop is when you don't give a specific
position to the crop command.  That is you give a size, and not a position
within the image to crop.  In this case instead of generating just one image,
crop generates a whole series of images..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=tiles_ident.txt>
<c>  convert rose: -shave 12x0 -repage 64x64+9+9  paged.gif
<z>  convert paged.gif  +gravity -crop 32x32  tiles_%d.gif
<n>  identify paged.gif tiles_?.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged.gif"
     ><IMG SRC="paged.gif"                 WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="tiles_0.gif"
     ><IMG SRC="tiles_0.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="tiles_1.gif"
     ><IMG SRC="tiles_1.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="tiles_2.gif"
     ><IMG SRC="tiles_2.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="tiles_3.gif"
     ><IMG SRC="tiles_3.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="tiles_ident.txt"
     ><IMG SRC="tiles_ident.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

If you just want to extract a specific number of tiles from an image have a look
at <A HREF="#crop_equal" >Cropping into roughly Equally Sized Divisions</A>
below. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  It is a good idea to make sure gravity is turned off using "<CODE><A
  HREF="../option_link.cgi?gravity" >+gravity</A></CODE>".  This is because in
  one special case (centered percentage crop) the gravity setting can turn
  off tile cropping.  Other effects of gravity on tiled cropping is also
  undefined.
</I></FONT></TD></TR></TABLE></P>

By using "<CODE><A HREF="../option_link.cgi?mosaic" >-mosaic</A></CODE>" or
"<CODE><A HREF="../option_link.cgi?flatten" >-flatten</A></CODE>" image
layering operators, (see <A HREF="../layers/#flatten" >Layer Flatten</A>)  you
can layer these images all on top of each other, restoring the original image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tiles_[0-3].gif -background white -mosaic  tiles_mosaic.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tiles_mosaic.gif"
     ><IMG SRC="tiles_mosaic.gif"            WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However as you can see the virtual canvas of the image has been filled with
the background color by "<CODE><A HREF="../option_link.cgi?mosaic"
>-mosaic</A></CODE>". </P>

An alternative is to use "<CODE><A HREF="../option_link.cgi?layers"
>-layers</A> merge</CODE>" (see <A HREF="../layers/#merge" >Layer Merge</A>),
which merges the multiple layer images into a new layer image just large
enough to hold all the given images.  That is the virtual canvas is not filled
in, as  "<CODE><A HREF="../option_link.cgi?mosaic" >-mosaic</A></CODE>" or
"<CODE><A HREF="../option_link.cgi?flatten" >-flatten</A></CODE>" layering
methods would.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tiles_[0-3].gif -background none -layers merge  tiles_layered.gif
</CODE><CODE EXECUTE NOWARN OUT=tiles_layered_ident.txt
>  identify tiles_layered.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tiles_layered.gif"
     ><IMG SRC="tiles_layered.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE>
  <A HREF="tiles_layered_ident.txt"
     ><IMG SRC="tiles_layered_ident.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</PRE></TD></TR></TABLE>
<TD></TD></TABLE></P>

If you had reset the the canvas and offset information using "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>" then the images no
longer contain the offset from where they were cropped, nor the original size
of the source image. In that case you can re-join all the images together
again using the special '<CODE>concatenation</CODE>' mode of
"<CODE>montage</CODE>". You will need to tell montage how many rows or columns
of images were extracted from the original image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -crop 20x20  +repage  +adjoin  rose_tiles_%02d.gif
  montage -mode concatenate -tile 4x  rose_tiles_*.gif   rose_rejoined.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
    <A HREF="rose_tiles_00.gif"
       ><IMG SRC="rose_tiles_00.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tiles_01.gif"
       ><IMG SRC="rose_tiles_01.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tiles_02.gif"
       ><IMG SRC="rose_tiles_02.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tiles_03.gif"
       ><IMG SRC="rose_tiles_03.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_tiles_04.gif"
      ><IMG SRC="rose_tiles_04.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tiles_05.gif"
      ><IMG SRC="rose_tiles_05.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tiles_06.gif"
      ><IMG SRC="rose_tiles_06.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tiles_07.gif"
      ><IMG SRC="rose_tiles_07.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_tiles_08.gif"
      ><IMG SRC="rose_tiles_08.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tiles_09.gif"
      ><IMG SRC="rose_tiles_09.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tiles_10.gif"
      ><IMG SRC="rose_tiles_10.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tiles_11.gif"
      ><IMG SRC="rose_tiles_11.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
    <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
    <A HREF="rose_rejoined.gif"
       ><IMG SRC="rose_rejoined.gif"
            ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Note that the names of the individual images is from
"<CODE>rose_tiles_00.gif</CODE>" to "<CODE>rose_tiles_11.gif</CODE>", which
simply the sequence number of the tiles in memory.  This  is not very nice as
the filenames give no easy indication of the actual position each tile belongs
to, or the total number of tiles per row and column. </P>

As of IM v6.4.8-4 you can also use special <A HREF="../files/#save_escapes"
>Filename Percent Escapes</A> to generate and include special labels into the
output filename. Using this with <A HREF="../transform/#fx_escapes" >FX
Percent Escapes</A> you can calculate a different 'tile position' for each
image.  For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -crop 20x20 \
          -set filename:tile "%[fx:page.x/20+1]_%[fx:page.y/20+1]" \
          +repage +adjoin "rose_tile_%[filename:tile].gif"
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
  <IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1 ALIGN=middle ALT="==>">
</TD><TD>
    <A HREF="rose_tile_1_1.gif"
       ><IMG SRC="rose_tile_1_1.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tile_2_1.gif"
       ><IMG SRC="rose_tile_2_1.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tile_3_1.gif"
       ><IMG SRC="rose_tile_3_1.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_tile_4_1.gif"
       ><IMG SRC="rose_tile_4_1.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_tile_1_2.gif"
       ><IMG SRC="rose_tile_1_2.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
     <A HREF="rose_tile_2_2.gif"
       ><IMG SRC="rose_tile_2_2.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
     <A HREF="rose_tile_3_2.gif"
       ><IMG SRC="rose_tile_3_2.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
     <A HREF="rose_tile_4_2.gif"
       ><IMG SRC="rose_tile_4_2.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_tile_1_3.gif"
       ><IMG SRC="rose_tile_1_3.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
     <A HREF="rose_tile_2_3.gif"
       ><IMG SRC="rose_tile_2_3.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
     <A HREF="rose_tile_3_3.gif"
       ><IMG SRC="rose_tile_3_3.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
     <A HREF="rose_tile_4_3.gif"
       ><IMG SRC="rose_tile_4_3.gif"
             ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Will generate the tile image filenames "<CODE>rose_tile_1_1.gif</CODE>" to
"<CODE>rose_tile_4_3.gif</CODE>", which is a much better file naming scheme.
Tricky but it does work. </P>

Unfortunately you can not format the number generated by a <A
HREF="../basics/#arg_percent" >Percent Escapes</A>, to include padding
with zeros or specify an exact number of floating point digits.  At least not
at this time.  </P>

<A NAME="crop_tile_centered"></A>
<H3>Centered Tile Cropping</H3>

In a <A HREF="../forum_link.cgi?t=16276" >IM Forum Discussion</A> a request
was made to center the tile cropping so as to distributed he 'remainder
images' evenly around the edges.  By doing this we maximize the effect of the
complete tiles by placing them in the center of the image.  Of course you also
end up with more incomplete edge tiles. </P>

The solution was to center the input image on a virtual canvas, that was some
multiple of the tile size wanted. </P>

For example to tile crop the "<CODE>rose:</CODE>" image (<CODE>70x46</CODE>
pixels in size) into the maximum number of full <CODE>30x20</CODE> tiles, in
the center of the image (and surrounded by reminder tiles) you would do the
following.

<OL>
<LI>First calculate the number of full tiles you can get from the image
    by dividing the image sizes...
    <DIV ALIGN=center><PRE>70x46 / 30x20 => 2x2 full tiles + remainder</PRE></DIV></P>

<LI>Now add 2 more rows and columns to hold the remainder images (if needed)
    <DIV ALIGN=center><PRE>2x2 + 2x2 => 4x4 tile images</PRE></DIV></P>

<LI>Multiply the tile size by this to get the virtual canvas size.
    <DIV ALIGN=center><PRE>30x20 * 4x4 => 120x80 canvas size</PRE></DIV></P>

<LI>Subtract the original image size and divide into two for the centering
    offset.
    <DIV ALIGN=center><PRE>( 120x80 - 70x46 ) / 2 => +25+17</PRE></DIV></P>
</OL>

So the virtual canvas and centering offset is <CODE>120x80+25+17</CODE>. </P>

And here we use the above calculations perform a Centered Tile Crop...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -repage 120x80+25+17 -crop 30x20 +repage rose_30x20_%02d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="rose_30x20_00.gif"
      ><IMG SRC="rose_30x20_00.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_30x20_01.gif"
      ><IMG SRC="rose_30x20_01.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_30x20_02.gif"
      ><IMG SRC="rose_30x20_02.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_30x20_03.gif"
      ><IMG SRC="rose_30x20_03.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_30x20_04.gif"
      ><IMG SRC="rose_30x20_04.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_30x20_05.gif"
      ><IMG SRC="rose_30x20_05.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_30x20_06.gif"
      ><IMG SRC="rose_30x20_06.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_30x20_07.gif"
      ><IMG SRC="rose_30x20_07.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_30x20_08.gif"
      ><IMG SRC="rose_30x20_08.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_30x20_09.gif"
      ><IMG SRC="rose_30x20_09.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_30x20_10.gif"
      ><IMG SRC="rose_30x20_10.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_30x20_11.gif"
      ><IMG SRC="rose_30x20_11.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_30x20_12.gif"
      ><IMG SRC="rose_30x20_12.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_30x20_13.gif"
      ><IMG SRC="rose_30x20_13.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_30x20_14.gif"
      ><IMG SRC="rose_30x20_14.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_30x20_15.gif"
      ><IMG SRC="rose_30x20_15.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

If you want to preserve the original offset location of the tiles, but remove
the centering offset, you can do a relative offset adjustment using
<NOBR>"<CODE>-repage -25-17\!</CODE>"</NOBR> (replacing the "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>" in the above).  </P>

If you did not add two columns and rows to the number of tiles and thus
generate a negative offset you can effectively ignore the remainder edge
tiles, and only output full and complete tiles that exist in the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -repage 60x40-5-3 -crop 30x20 +repage rose_ctiles_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="rose_ctiles_0.gif"
      ><IMG SRC="rose_ctiles_0.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_ctiles_1.gif"
      ><IMG SRC="rose_ctiles_1.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_ctiles_2.gif"
      ><IMG SRC="rose_ctiles_2.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_ctiles_2.gif"
      ><IMG SRC="rose_ctiles_3.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Basically as the remainders are now 'outside' the calculated virtual canvas
the "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" operator does
not know they were there and ignores them. </P>

Again replacing the "<CODE><A HREF="../option_link.cgi?repage"
>+repage</A></CODE>" in the above, with a relative offset adjustment using the
negated offset values <NOBR>"<CODE>-repage +5+3\!</CODE>"</NOBR> will restore
the original offset locations from which the tiles were cropped. </P>


An alternative for a centered tile crop and ignoring reminders is to simply
replace the virtual canvas setting with an appropriate crop.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -gravity center -crop 60x40+0+0 +gravity +repage \
          -crop 30x20 +repage rose_ctiles2_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <IMG SRC="../img_www/space.gif" WIDTH=10 HEIGHT=1 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="rose_ctiles2_0.gif"
      ><IMG SRC="rose_ctiles2_0.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_ctiles2_1.gif"
      ><IMG SRC="rose_ctiles2_1.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_ctiles2_2.gif"
      ><IMG SRC="rose_ctiles2_2.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_ctiles2_2.gif"
      ><IMG SRC="rose_ctiles2_3.gif"
            ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

The above is easier to understand, but is also a little slower, as you are now
performing two crops. However less calculations are needed. </P>

But if you want to recover the original tile offsets, you will still need to
calculate the relative offset you needed, in which case you may as well do the
task by the former faster method using the images virtual canvas. </P>

<BR>

<A NAME="crop_strip"></A>
<H3>Strip Cropping, cropping out rows and columns</H3>

With IM version 6.1.1, a "<CODE><A HREF="../option_link.cgi?crop"
>-crop</A></CODE>" was enhanced so that if one of the size arguments missing,
or set to zero, then the missing size argument is set to the size of the image
canvas/page.  In most cases this is large enough to cover the image located on
the canvas, <I>if the related offset is also set to zero</I>. </P>

This small change allows you to easily cut out a single row or column from
the image, without needing a huge number like '<CODE>999999</CODE>' to cover
the size of image. </P>

For example, here we extract a simple row and column from our 'paged' rose
image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=strip_ident.txt>
<c>  convert rose: -shave 12x0 -repage 64x64+9+9  paged.gif
<z>  convert paged.gif  -crop 20x0+30+0  strip_column.gif
<z>  convert paged.gif  -crop 0x20+0+30  strip_row.gif
<n>  identify paged.gif strip_column.gif strip_row.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged.gif"
     ><IMG SRC="paged.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="strip_column.gif"
     ><IMG SRC="strip_column.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="strip_row.gif"
     ><IMG SRC="strip_row.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE>
  <A HREF="strip_ident.txt"
     ><IMG SRC="strip_ident.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</PRE></TD></TR></TABLE>
</DIV></P>

If you remove both offsets as well as one size argument, you can divide the
image into a series of strips or columns, instead of tiles.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert rose: -crop 40x30+10+10  crop.gif
<z>  convert crop.gif -quiet -crop  20x  strips_%d.gif
</CODE><CODE EXECUTE NOIMAGE OUT=strips_ident.txt
>  identify crop.gif strips_?.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="crop.gif"
     ><IMG SRC="crop.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="strips_0.gif"
     ><IMG SRC="strips_0.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="strips_1.gif"
     ><IMG SRC="strips_1.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="strips_2.gif"
     ><IMG SRC="strips_2.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="strips_3.gif"
     ><IMG SRC="strips_3.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE>
  <A HREF="strips_ident.txt"
     ><IMG SRC="strips_ident.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</PRE></TD></TR></TABLE>
</DIV></P>

Notice that tile cropping, strip or otherwise, is across the whole page canvas
of the image, and as such is aligned to that canvas, and NOT just the actual
image.  This is why the first and last actual image generated in the above
example is only 10 pixels wide. </P>

Of course if a specific tile, or in this case 'column' misses the actual image
on the virtual canvas (such as the last image in the above), then a <A
HREF="#crop_missed" >crop missed image</A> is generated. </P>

The warning that IM would have normally produced was suppressed using
a "<CODE><A HREF="../option_link.cgi?quiet" >-quiet</A></CODE>" setting. This
is not recommended unless you are expecting such an event, and are prepared
for it, such as in a script. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  It is possible for an image to be positioned such that it does not even
  appear on its own page or virtual canvas, or be so large that the page
  canvas can only contain a small window or part of the image. </P>

  In such rare cases, strip cropping without any size arguments will get the
  image sub-division wrong, and produce respectively, <A HREF="#crop_missed"
  >missed images</A>, or smaller tiles of only the parts within the virtual
  canvas bounds.  </P>

  The "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" operator
  however will not be fixed to handle these rare special cases, as doing so
  will prevent its use in other cases, such as those exampled below. </P>

  If this is a problem for you, sanitize the page offsets of the image before
  cropping by using "<CODE><A HREF="../option_link.cgi?repage"
  >+repage</A></CODE>" to remove the virtual canvas before attempting to
  generate the tile images.

</I></FONT></TD></TR></TABLE></P>

As an alternative way of dividing images into separate rows, look at the
special script "<CODE><A HREF="../scripts/divide_vert"
>divide_vert</A></CODE>".  This program will let you divide up an image
according to horizontal 'gaps' of solid single color.  For example, if given
an image of simple text, it will divide it into alternating images of 'lines'
and 'gaps'.  A simple option lets you remove those gaps. </P>


<A NAME="crop_quad"></A>
<H3>Quadrants, cutting around a single point</H3>

As any of the crop size numbers are missing then they are replaced with the
size of the image canvas of the image you are cropping.  This should in most
cases result in the whole of the image in that dimension becoming part of the
crop result. </P>

This allows, with cautious use of the arguments, is the ability to crop and
image into quarters around a specific point (with that specific pixel placed
as the top-right pixel of the bottom-left quadrant image).  You do not need to
know how big the image is to do this. </P>

For example here I crop the image into quadrants around the point 30,40
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert rose: -shave 12x0 -repage 64x64+9+9  paged.gif
<z>  convert paged.gif  -crop 30x40+0+0  quadrant_tl.gif
<z>  convert paged.gif  -crop 0x40+30+0  quadrant_tr.gif
<z>  convert paged.gif  -crop 30x0+0+40  quadrant_bl.gif
<z>  convert paged.gif  -crop    +30+40  quadrant_br.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged.gif"
     ><IMG SRC="paged.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="quadrant_tl.gif"
     ><IMG SRC="quadrant_tl.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="quadrant_tr.gif"
     ><IMG SRC="quadrant_tr.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="quadrant_bl.gif"
     ><IMG SRC="quadrant_bl.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="quadrant_br.gif"
     ><IMG SRC="quadrant_br.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

Of course if the point you were cropping around missed the actual image, then
two or even three of the resulting quadrant images will be the special <A
HREF="#crop_missed" >crop missed error</A> images. </P>


<A NAME="crop_neg_offset"></A>
<H3>Using Negative Offsets, remove bottom or left edge</H3>

Their is no reason that you can not use a negative offset with "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>".  In fact at times it can
have very definite benefits. </P>

For example lets take our paged rose image and progressively crop it
with larger negative offsets.  We will not supply an image size to "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>" argument, so it will default
to the images canvas size.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert rose: -shave 12x0 -repage 64x64+9+9  paged.gif
<z>  convert paged.gif  -crop -10-10  neg_offset_1.gif
<z>  convert paged.gif  -crop -20-20  neg_offset_2.gif
<z>  convert paged.gif  -crop -30-30  neg_offset_3.gif
<z>  convert paged.gif  -crop -40-40  neg_offset_4.gif
<z>  convert paged.gif  -crop -50-50  neg_offset_5.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged.gif"
     ><IMG SRC="paged.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="neg_offset_1.gif"
     ><IMG SRC="neg_offset_1.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="neg_offset_2.gif"
     ><IMG SRC="neg_offset_2.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="neg_offset_3.gif"
     ><IMG SRC="neg_offset_3.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="neg_offset_4.gif"
     ><IMG SRC="neg_offset_4.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="neg_offset_5.gif"
     ><IMG SRC="neg_offset_5.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

As you can see steadily decreasing the offset to a larger negative value
slowly results in the bottom and right edges being 'chopped' off, the last
example almost missing the actual image. If we took this one step further a <A
HREF="#crop_missed" >Missed Image</A> will be generated.  It's a bit like
using a "<CODE><A HREF="../option_link.cgi?chop" >-chop</A></CODE>" operator but
without a "<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>"
setting.  See <A HREF="#chop" >Chop, Removing Edges</A>.  </P>

Of course by using "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>"
you may need to use a "<CODE><A HREF="../option_link.cgi?repage"
>+repage</A></CODE>" operator to adjust the canvas/page information, where a
"<CODE><A HREF="../option_link.cgi?chop" >-chop</A></CODE>" automatically
performs such an adjustment.  That's life. </P>

<A NAME="crop_equal"></A>
<H3>Cropping into roughly Equally Sized Divisions</H3>

The biggest problem with <A HREF="#crop_tile" >Tile Cropping</A> is that you
can only define the final size of each tile.  This works great when the image
size is an exact multiple of the desired tile size, but as you have seen if
this is not the case you can end up with 'short' tiles on the right and bottom
edges. </P>

For example lets again divide the built in rose image, but try to divide it
into 3x3 tiles.  The original image is 70x46 pixels so divided by 3 make each
tile 23x15 pixels...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -crop 23x15  +repage  +adjoin  rose_23x15_%02d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="rose_23x15_00.gif"
      ><IMG SRC="rose_23x15_00.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_23x15_01.gif"
      ><IMG SRC="rose_23x15_01.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_23x15_02.gif"
      ><IMG SRC="rose_23x15_02.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_23x15_03.gif"
      ><IMG SRC="rose_23x15_03.gif"
           ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_23x15_04.gif"
      ><IMG SRC="rose_23x15_04.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_23x15_05.gif"
      ><IMG SRC="rose_23x15_05.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_23x15_06.gif"
      ><IMG SRC="rose_23x15_06.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_23x15_07.gif"
      ><IMG SRC="rose_23x15_07.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_23x15_08.gif"
      ><IMG SRC="rose_23x15_08.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_23x15_09.gif"
      ><IMG SRC="rose_23x15_09.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_23x15_10.gif"
      ><IMG SRC="rose_23x15_10.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_23x15_11.gif"
      ><IMG SRC="rose_23x15_11.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_23x15_12.gif"
      ><IMG SRC="rose_23x15_12.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_23x15_13.gif"
      ><IMG SRC="rose_23x15_13.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_23x15_14.gif"
      ><IMG SRC="rose_23x15_14.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_23x15_15.gif"
      ><IMG SRC="rose_23x15_15.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Well as you can see this did not work, because the rose image can not be
exactly divided into 3 equally sized tiles. In this case you end up with
a 1 pixel 'short' tile.  Even if you expand the size of the tile to 24x16
pixels, you will still end up with a tile that is 2 pixels 'shorter' than the
other tiles. </P>

This situation gets worse as the number of tiles wanted gets larger.
For example try sub-dividing a length of 100 into 30 tiles.  It is
impossible. You either use a length of 3 and get 34 tiles, or 4 and get
25 tiles.  Getting exactly 30 equal sized tiles is impossible! </P>

As of IM v6.5.8-9 you can now add the special '<CODE>@</CODE>' flag to the
"<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" argument.  This
flag tells the "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>"
operator to try its best to equally divide the image into the <I>number of
tiles</I> given.  For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -crop 3x3@  +repage  +adjoin  rose_3x3@_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="rose_3x3@_0.gif"
      ><IMG SRC="rose_3x3@_0.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_3x3@_1.gif"
      ><IMG SRC="rose_3x3@_1.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_3x3@_2.gif"
      ><IMG SRC="rose_3x3@_2.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_3x3@_3.gif"
      ><IMG SRC="rose_3x3@_3.gif"
           ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_3x3@_4.gif"
      ><IMG SRC="rose_3x3@_4.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_3x3@_5.gif"
      ><IMG SRC="rose_3x3@_5.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_3x3@_6.gif"
      ><IMG SRC="rose_3x3@_6.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_3x3@_7.gif"
      ><IMG SRC="rose_3x3@_7.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
    <A HREF="rose_3x3@_8.gif"
      ><IMG SRC="rose_3x3@_8.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

The result is that the image was divided into tiles which have slightly
different sizes. However the tile size will differ by 1 pixel at the most!
Check it out! </P>

As a bonus, you can also sub-divide the image so that each tile will
'overlap' its neighbours. You do this by not only using a '<CODE>@</CODE>'
flag but also specifying the number of pixels of overlap you want. </P>

For example lets divide the rose into quarters but with a 20 pixel overlap.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -crop 2x2+20+20@  +repage  +adjoin  rose_2x2+20+20@_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="rose_2x2+20+20@_0.gif"
      ><IMG SRC="rose_2x2+20+20@_0.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_2x2+20+20@_1.gif"
      ><IMG SRC="rose_2x2+20+20@_1.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
<BR><A HREF="rose_2x2+20+20@_2.gif"
      ><IMG SRC="rose_2x2+20+20@_2.gif"
            ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="rose_2x2+20+20@_3.gif"
      ><IMG SRC="rose_2x2+20+20@_3.gif"
           ALIGN=middle VSPACE=4 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Again all the pieces will only differ in size by one pixel at the most! Though
in this case the resulting images are the same size, as the rose can divide by
2, equally. That however would not be the case if the overlap or the image was
an odd number in size. In that case the bigger element will be along the top
and left edge.  With three tiles however the bigger (or smaller) element will
be placed in the middle! </P>

You can even use a negative overlap to 'skip' exactly that many pixels between
tiles!  Exactly how you should apply the operator depends on exactly what
pixels you want to 'overlap', or 'skip'.  And that depends on the 'edge'
characteristics of the image (see <A HREF="#crop_spaced" >Separating
Spaced-out Tiling Images</A> below). </P>

As with any use of the "<CODE><A HREF="../option_link.cgi?crop"
>-crop</A></CODE>" operator, it is recommended you use a  "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE> to remove the 'page'
offset if it is not wanted.  But the cropped image offset information can be
very useful, which is why it is preserved.  You can for example use it to name
the output files, or find out the size and locations of the tiles that IM
calculated. </P>

Note that equal sized tile cropping, is the only situation in which the
"<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" operator ignores
the actual virtual canvas of the image when figuring out what part of the
image is cropped.  That is the calculations for tile cropping is based on
real image size rather than virtual canvas size.  Even so the final tile
offsets will still be relative to the original virtual canvas. </P>

This crop option can also be used as an alternative to the <A HREF="#shave"
>Shave Operator</A> for 'paged' images. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM version v6.6.1-0, equal-sized tile cropping for images with
  a virtual canvas offset was broken.
</I></FONT></TD></TR></TABLE></P>


<A NAME="crop_spaced"></A>
<H3>Separating Spaced-out Tiling Images</H3>

Often you have an image that has fixed sized tiles which are separated by
a fixed amount of space.  The new '<CODE>@</CODE>' flag crop operator will let
you more easily crop out those tiles, either including or skipping the
surrounding space. </P>

The main problem however is that while the 'tile' images have a fixed amount
of space around them the amount of space around the edge is usually not so
fixed.  This produces three basic styles of edge characteristics to a set of
'spaced' images.  and each type need to be handled slightly differently. </P>

<!--<CODE EXECUTE>
  convert font_[1-5].gif -bordercolor white -border 0 miff:- |\
    montage - -tile x1  -geometry +3+3 -background Lime  montage.gif
  convert montage.gif -trim +repage spaced.gif
  convert montage.gif -bordercolor Lime -border 3x3 edged.gif
</CODE>-->

<B>Montaged Tiles</B></P>

Here the original images were simply given a fixed sized border before being
appended together. The result is that you will always have an even number of
pixel spacing between tiles.  More importantly the 'edge spacing' is exactly
half the spacing that was placed between the tiles.  </P>

This is in fact how the "<CODE><A HREF="../montage/" >montage</A></CODE>"
spaces the tiling 'cells', and it was using this command the example shown
image below was generated. </P>

As the images were just simply tiled together you can use either a normal <A
HREF="#crop_tile" >Tile Cropping</A> (if you know the tile size), or use <A
HREF="#crop_equal" >Equal Sized Cropping</A> (if you know the number of
tiles), to separate the sub-images and the surrounding border. </P>

There is basically no overlap between the tiles, and a simple <A HREF="#shave"
>Shave Operator</A>, can then be used to remove that border from the resulting
tiles.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert montage.gif -crop 5x1@ +repage +adjoin montage_%d.gif
  convert montage_?.gif -shave 3x3 montage-3_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="montage.gif"
     ><IMG SRC="montage.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
  <A HREF="montage_0.gif"
     ><IMG SRC="montage_0.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="montage_1.gif"
     ><IMG SRC="montage_1.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="montage_2.gif"
     ><IMG SRC="montage_2.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="montage_3.gif"
     ><IMG SRC="montage_3.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="montage_4.gif"
     ><IMG SRC="montage_4.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<TR><TD>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
  <A HREF="montage-3_0.gif"
     ><IMG SRC="montage-3_0.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="montage-3_1.gif"
     ><IMG SRC="montage-3_1.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="montage-3_2.gif"
     ><IMG SRC="montage-3_2.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="montage-3_3.gif"
     ><IMG SRC="montage-3_3.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="montage-3_4.gif"
     ><IMG SRC="montage-3_4.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

<B>Same Spacing around Edge</B></P>

Here the sub-images were not only 'spaced-out' by 6 pixels but also has
a 6 pixel spacing around the edge, making it look rather neat and tidy.  </P>

This is handled by using the default <A HREF="#crop_equal" >Equal Sized
Cropping</A> with the appropriate amount of pixel 'overlap'. For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert edged.gif -crop 5x1+6+6@ +repage +adjoin edged+6_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="edged.gif"
     ><IMG SRC="edged.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="edged+6_0.gif"
      ><IMG SRC="edged+6_0.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="edged+6_1.gif"
      ><IMG SRC="edged+6_1.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="edged+6_2.gif"
      ><IMG SRC="edged+6_2.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="edged+6_3.gif"
      ><IMG SRC="edged+6_3.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="edged+6_4.gif"
      ><IMG SRC="edged+6_4.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Note how the operator separated the images so that they remain the same
size, but with a 6 pixel overlap.  This is specifically what it was designed
to do. </P>

By using a negative offset, you tell IM that the overlapping area (spacing
parts) should not be included in the final results.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert edged.gif -crop 5x1-6-6@ +repage +adjoin edged-6_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="edged.gif"
     ><IMG SRC="edged.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="edged-6_0.gif"
      ><IMG SRC="edged-6_0.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="edged-6_1.gif"
      ><IMG SRC="edged-6_1.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="edged-6_2.gif"
      ><IMG SRC="edged-6_2.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="edged-6_3.gif"
      ><IMG SRC="edged-6_3.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="edged-6_4.gif"
      ><IMG SRC="edged-6_4.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

If I was to go further and subtract more pixels I can even trim some of the
white border from the above numbers.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert edged.gif -crop 5x1-8-8@ +repage +adjoin edged-8_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="edged.gif"
     ><IMG SRC="edged.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
  <A HREF="edged-8_0.gif"
     ><IMG SRC="edged-8_0.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="edged-8_1.gif"
     ><IMG SRC="edged-8_1.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="edged-8_2.gif"
     ><IMG SRC="edged-8_2.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="edged-8_3.gif"
     ><IMG SRC="edged-8_3.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="edged-8_4.gif"
     ><IMG SRC="edged-8_4.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

You can even use this as an alternative method for the <A HREF="#shave" >Shave
Operator</A>, by simply specifying a 1 tile crop...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert edged+6_0.gif -crop 1x1-6-6@ +repage tile-shave.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="edged+6_0.gif"
     ><IMG SRC="edged+6_0.gif"
           ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="tile-shave.gif"
      ><IMG SRC="tile-shave.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>


<B>Simply Spaced Tiles</B></P>

The simplest spaced-out tiled images has no edge spacing, or has had that edge
spacing <A HREF="#trim" >Trimmed</A> from the image.  However for this to be
handled you need to tell IM of this special situation, by including BOTH
'<CODE>@</CODE>' and '<CODE>!</CODE>' flags.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert spaced.gif -crop 5x1+6+6@\! +repage +adjoin spaced+6_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="spaced.gif"
     ><IMG SRC="spaced.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="spaced+6_0.gif"
      ><IMG SRC="spaced+6_0.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="spaced+6_1.gif"
      ><IMG SRC="spaced+6_1.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="spaced+6_2.gif"
      ><IMG SRC="spaced+6_2.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="spaced+6_3.gif"
      ><IMG SRC="spaced+6_3.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="spaced+6_4.gif"
      ><IMG SRC="spaced+6_4.gif"
            ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Note that the images on the edges of this sub-division are slightly shorter
than the images in the middle.  This is why this special 'mode' of operation
is NOT the default, even though it is actually simpler than the previous
spaced-out tile category.  </P>

Also note that when using both '<CODE>@</CODE>' and '<CODE>!</CODE>' flags,
a single tile crop (vertically in this case) does not have any effect, as both
the top and the bottom of the tile are 'edges', and thus has no 'edge space'
to be removed.  </P>

Again by using a negative value for the overlap, you can tell IM not to
include the overlapping (spacing) area in the tile crop results.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert spaced.gif -crop 5x1-6-6@\! +repage +adjoin spaced-6_%d.gif
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD>
  <A HREF="spaced.gif"
     ><IMG SRC="spaced.gif"
           ALIGN=middle VSPACE=4 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD>
   <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
</TD><TD>
   <A HREF="spaced-6_0.gif"
      ><IMG SRC="spaced-6_0.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="spaced-6_1.gif"
      ><IMG SRC="spaced-6_1.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="spaced-6_2.gif"
      ><IMG SRC="spaced-6_2.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="spaced-6_3.gif"
      ><IMG SRC="spaced-6_3.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
   <A HREF="spaced-6_4.gif"
      ><IMG SRC="spaced-6_4.gif"
            ALIGN=middle VSPACE=4 HSPACE=8 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE>!</CODE>' character has special significance to some UNIX
  shells, like "<CODE>csh</CODE>", and must be escaped with a backslash,
  even when placed inside quotes.
</I></FONT></TD></TR></TABLE></P>

With these formulas you should should now be able to tile crop images that form
a grid, even when the images are overlapping, or spaced out. </P>

Even if the specific problem you have does not fall exactly into on of the
above cases, you should be able to either add or remove edge pixels
appropriately so that the image does fall into one of the above categories of
spaced-out images.  </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="border"></A>
<H2>Adding/Removing Image Edges</H2>

<H3>Border, adding space around the image</H3>

Often you simply want to add a little working space around the edge of an
image, but you don't want to need or depend on knowing the size of an image to
do so. </P>

Now there are many ways to add extra space to an image, outside of direct
space additions, including <A HREF="../layers/#append" >appending blank
images or labels</A>, <A HREF="../compose/#src" >composing '<CODE>Src</CODE>'
overlays</A>, or even just <A HREF="../layers/#flatten" >positioning the
image on a larger canvas</A>.  But these methods usually need at least some
idea of how big the image you are working with actually is. </P>

One of the simplest form of image space additions is "<CODE><A
HREF="../option_link.cgi?border" >-border</A></CODE>" operation.  The color of
the space added is "<CODE><A HREF="../option_link.cgi?bordercolor"
>-bordercolor</A></CODE>" setting.  Here is some straight forward examples..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -bordercolor SkyBlue    -border 10x10 border.gif
  convert rose:                          -border 15x6  border_default.gif
  convert rose:  -bordercolor LimeGreen  -border 10x0  border_sides.gif
  convert rose:  -bordercolor Tomato     -border  0x10 border_topbot.gif
  convert rose: -matte -bordercolor none -border 10    border_none.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="border.gif"
     ><IMG SRC="border.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="border_default.gif"
     ><IMG SRC="border_default.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="border_sides.gif"
     ><IMG SRC="border_sides.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="border_topbot.gif"
     ><IMG SRC="border_topbot.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="border_none.gif"
     ><IMG SRC="border_none.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

Note last example image above.  The border color was set to be the transparent
color "<CODE>none</CODE>", but for this to work as expected we needed to
ensure the image actually contained a 'matte' or 'alpha' channel.  </P>

Also note that is the vertical and horizontal border sizes are the same
you can omit the second number in the border, using just a single number.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As shown above the default color used by the "<CODE><A
  HREF="../option_link.cgi?border" >-border</A></CODE>" operator  is a light
  gray as it matches nicely the default grey page color of web pages on the
  WWW.
</I></FONT></TD></TR></TABLE></P>

You can specify borders as a percentage of the image size...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -border 10%x10%  border_percent.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border_percent.jpg"
     ><IMG SRC="border_percent.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Internally what is really happening is that "<CODE><A
HREF="../option_link.cgi?border" >-border</A></CODE>" creates a new image of
the right size, then overlays the original source image over this new
background. </P>

This is itself a very useful operation in ImageMagick, for setting the
background of transparent and semi-transparent images.  That is the seemingly
useless "<CODE>-border 0</CODE>" operation is, in IM version 6, a very useful
one.  For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert star.gif -bordercolor LimeGreen -border 0  star_background.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="star.gif"
     ><IMG SRC="star.gif"
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="star_background.gif"
     ><IMG SRC="star_background.gif"
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
</NOBR></DIV></P>

Of course there are lots of other ways to <A HREF="../masking/#remove" >Remove
Alpha Transparency</A>. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The fact that adding a border to images with transparency, also by default
  fills the transparent background of the image, has been the cause of some
  debate amongst IM users and the development team.  A summary of this debate
  is given on <A HREF="../misc/#border" >Border, Frame and use of
  BorderColor</A>.
</I></FONT></TD></TR></TABLE></P>


<A NAME="border_compose"></A>
<H4>Border and Alpha Composition</H4>

The overlay of the image onto the bordercolor canvas is controlled
by the "<CODE><A HREF="../option_link.cgi?compose" >-compose</A></CODE>"
setting, which by default is set to '<CODE><A HREF="../compose/#over"
>Over</A></CODE>' alpha compositing.  If it is set to come other
setting, the "<CODE><A HREF="../option_link.cgi?border" >-border</A></CODE>"
operation may produce unexpected results. </P>

For example here are some of the more interesting uses of "<CODE><A
HREF="../option_link.cgi?compose" >-compose</A></CODE>" with the "<CODE><A
HREF="../option_link.cgi?border" >-border</A></CODE>" image operator, when
applied to an image containing some transparent areas.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert star.gif -bordercolor LimeGreen \
                   -compose {<I>operation</I>} -border 5  {<I>result</I>}
</CODE></PRE></TD></TR></TABLE>
  <A HREF="border_compose.jpg"
     ><IMG SRC="border_compose.jpg"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The choice between using '<CODE>Over</CODE>' and '<CODE>Copy</CODE>'
essentially decides if you want to preserve the transparency in the image or
not. </P>

For example here is the same 'star' image with transparency, but this time the
border was added without destroying the images transparency.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  star.gif  -bordercolor LimeGreen   -compose Copy \
                     -border 5     star_border_copy.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="star_border_copy.gif"
     ><IMG SRC="star_border_copy.gif"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


The '<CODE><A HREF="../compose/#src" >Src</A></CODE>' compose will add a
transparent border to an image (if it has an alpha channel), regardless of the
current  "<CODE><A HREF="../option_link.cgi?bordercolor"
>-bordercolor</A></CODE>" setting.  Basically the background canvas "<CODE><A
HREF="../option_link.cgi?border" >-border</A></CODE>" generated is ignored.
</P>

The '<CODE><A HREF="../compose/#dst" >Dst</A></CODE>' may not seem to be very
useful, but can be used to generate a canvas the same size (or a little
bigger) than the original image.  The original image is only used to determine
the final size of the canvas.  For more examples see <A
HREF="../canvas/#sized" >Canvases Sized to an Existing Image</A>.  </P>

For more information on the various "<CODE><A
HREF="../option_link.cgi?compose" >-compose</A></CODE>" methods see the <A
HREF="../compose/" >Alpha Compositing Examples</A>. </P>

<A NAME="border_canvas"></A>
<H4>Border and Virtual Canvas</H4>

When "<CODE><A HREF="../option_link.cgi?border" >-border</A></CODE>" is
applied to an image containing a virtual canvas, it will still add the border
around the actual image on that virtual canvas, and NOT around the whole
canvas. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert rose: -shave 12x0 -repage 64x64+9+9  paged.gif
<z>  convert paged.gif         -border 5x5        paged_border.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged.gif"
     ><IMG SRC="paged.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="paged_border.gif"
     ><IMG SRC="paged_border.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

Note that the size of the virtual canvas was also increased by twice the
border thickness to accommodate the added border. </P>

This of course means you can not simply add a <A HREF="#border" >Border</A> to
a typical GIF animation directly, unless you want to actually identify the
individual sub-frames of the animation (for example see the script <A
HREF="../anim_basics/#montage" >Animation Frame Montage</A> which uses this as
an option to 'frame' the overlay images).  If you want to add a border, you
should <A HREF="../anim_basics/#coalesce" >Coalesce</A> the animation first to
remove any <A HREF="../anim_opt/#frame_opt">Frame Optimizations</A> it may
have first. </P>


<A NAME="frame"></A>
<H3>Frame, adding a 3D-like border</H3>

The "<CODE><A HREF="../option_link.cgi?frame" >-frame</A></CODE>" operator is
very similar to "<CODE><A HREF="../option_link.cgi?border"
>-border</A></CODE>", and if you look at the first example image generated
below, you will find that it will produce exactly the same result, except it
used the "<CODE><A HREF="../option_link.cgi?mattecolor" >-mattecolor</A></CODE>"
rather than "<CODE><A HREF="../option_link.cgi?bordercolor"
>-bordercolor</A></CODE>".  Note "<CODE><A
HREF="../option_link.cgi?bordercolor" >-bordercolor</A></CODE>" is still used
in the generation framed images, see below.  </P>

To use "<CODE><A HREF="../option_link.cgi?frame" >-frame</A></CODE>" properly
you need to supply four arguments to the command, instead of just 2. The extra
arguments specify the width of the 'outside' and 'inside' bevels of the frame
being produced. </P>

Here are some examples of using the "<CODE><A HREF="../option_link.cgi?frame"
>-frame</A></CODE>" operator with various settings.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:                     -frame 10x10      frame.gif
  convert rose:                     -frame 15x6+2+2   frame_wierd.gif
  convert rose: -mattecolor SkyBlue -frame 6x6+2+2    frame_blue.gif
  convert rose: -mattecolor Tomato  -frame 10x10+5+5  frame_red.gif

  convert rose:    -frame 10x10+10+0    frame_rasied.gif
  convert rose:    -frame 10x10+6+0     frame_rasied_part.gif
  convert rose:    -frame 10x10+0+6     frame_sunken_part.gif
  convert rose:    -frame 10x10+0+10    frame_sunken.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="frame.gif"
     ><IMG SRC="frame.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="frame_wierd.gif"
     ><IMG SRC="frame_wierd.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="frame_blue.gif"
     ><IMG SRC="frame_blue.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="frame_red.gif"
     ><IMG SRC="frame_red.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="frame_rasied.gif"
     ><IMG SRC="frame_rasied.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="frame_rasied_part.gif"
     ><IMG SRC="frame_rasied_part.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="frame_sunken_part.gif"
     ><IMG SRC="frame_sunken_part.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="frame_sunken.gif"
     ><IMG SRC="frame_sunken.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

Using multiple frame operations can also produce weirder framing styles.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:       -frame 10x10+3+3                    frame_normal.gif
  convert rose:       -frame 3x3+3+0      -frame 7x7+3+0  frame_popped.gif
  convert rose:       -frame 7x7+0+3      -frame 3x3+0+3  frame_pressed.gif
  convert rose: -frame 3x3+3+0 -frame 4x4 -frame 3x3+0+3  frame_inverted.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="frame_normal.gif"
     ><IMG SRC="frame_normal.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="frame_popped.gif"
     ><IMG SRC="frame_popped.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="frame_pressed.gif"
     ><IMG SRC="frame_pressed.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="frame_inverted.gif"
     ><IMG SRC="frame_inverted.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The default "<CODE><A HREF="../option_link.cgi?mattecolor"
  >-mattecolor</A></CODE>" is a slightly darker gray than that of the default
  setting of "<CODE><A HREF="../option_link.cgi?bordercolor"
  >-bordercolor</A></CODE>".  This also allows it to match the default gray
  color of web pages on the WWW (used by early browsers such as
  "<CODE>mosaic</CODE>" and "<CODE>netscape</CODE>".  (See below)
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  While "<CODE><A HREF="../option_link.cgi?frame" >-frame</A></CODE>" may
  actually use the "<CODE><A HREF="../option_link.cgi?mattecolor"
  >-mattecolor</A></CODE>"  color, it also generates four more extra colors
  from this base for use in drawing the frame.  That is five related colors
  will likely be added to an image, not just one.
</I></FONT></TD></TR></TABLE></P>


<A NAME="frame_montage"></A>

With some effort you can even reproduce a "<CODE>montage</CODE>"-like
framed image complete with text label.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:   -mattecolor grey  -background grey  -frame 3x3+0+3 \
          -gravity South -splice 0x15 -annotate 0x0 'A Red Rose' \
          -frame 6x6+3+0    frame_montage.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="frame_montage.gif"
     ><IMG SRC="frame_montage.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="frame_plasma"></A>

You can even use a semi-transparent "<CODE><A
HREF="../option_link.cgi?mattecolor" >-mattecolor</A></CODE>" for the frame
"<CODE><A HREF="../option_link.cgi?frame" >-frame</A></CODE>" and then
'underlay' an interesting pattern (such as a <A
HREF="../canvas/#plasma_fractal" >Fractal Plasma Canvas</A>), to produce a
more colorful frame.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<r>  convert rose:  -matte -mattecolor '#CCC6' -frame 10x10+3+4 \
          \( -size 100x100 plasma:fractal -normalize -blur 0x1 \) \
          -compose DstOver -composite   frame_plasma.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="frame_plasma.gif"
     ><IMG SRC="frame_plasma.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Alternatively you can color the frame separately, (generated using a special
'<A HREF="../compose/#dst">Dst</A>' composition setting), then overlay the
picture into the frame once you have it colored.  But that is getting very
tricky indeed. </P>

For more advanced techniques of using frames see <A
HREF="../thumbnails/#frame" >Framing Techniques</A>. </P>


<A NAME="frame_border"></A>
<H4>Frame and Alpha Composition</H4>

Frame is closely related to the "<CODE><A HREF="../option_link.cgi?border"
>-border</A></CODE>" operator.  Not only is a frame drawn using the "<CODE><A
HREF="../option_link.cgi?mattecolor" >-mattecolor</A></CODE>", but this
operator will also make use of the "<CODE><A
HREF="../option_link.cgi?bordercolor" >-bordercolor</A></CODE>" setting to
define the background on which the frame is initially drawn. </P>

Now for images which have no transparency, the "<CODE><A
HREF="../option_link.cgi?bordercolor" >-bordercolor</A></CODE>" will not be
visible, as it is overlaid by the image itself.  But for images that do
contain some transparent areas, the background color does become visible.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert star.gif  -frame 6x6+2+2 star_framed.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="star_framed.gif"
     ><IMG SRC="star_framed.gif"          WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In other words "<CODE><A HREF="../option_link.cgi?frame" >-frame</A></CODE>"
acts as if you take your image and overlay it on a picture frame with a solid
color background.  As such any part of your image that is transparent will be
replaced by the "<CODE><A HREF="../option_link.cgi?bordercolor"
>-bordercolor</A></CODE>" which by default is a light grey color. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The fact that adding a frame to images with transparency, also by default
  fills the transparent background of the image with the bordercolor has
  caused some debate amongst IM users and the Development team.  A summary
  of this debate is given on <A HREF="../misc/#border" >Border, Frame and use
  of BorderColor</A>.
</I></FONT></TD></TR></TABLE></P>

If you want to preserve the transparency of the image, while framing it,
you have two solutions. </P>

The first is to used transparent "<CODE><A
HREF="../option_link.cgi?bordercolor" >-bordercolor</A></CODE>" such as
'<CODE>none</CODE>'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert star.gif -bordercolor none  -frame 6x6+2+2  star_framed_none.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="star_framed_none.gif"
     ><IMG SRC="star_framed_none.gif"          WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The other solution and the preferred method is ensure the transparent pixels
are preserved when the image is added to the frame.  This is done by using a
special "<CODE><A HREF="../option_link.cgi?compose" >-compose</A></CODE>"
method called '<CODE><A HREF="../compose/#copy" >Copy</A></CODE>'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert star.gif -compose Copy  -frame 6x6+2+2  star_framed_copy.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="star_framed_copy.gif"
     ><IMG SRC="star_framed_copy.gif"          WIDTH=64  HEIGHT=64
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The use of "<A HREF="../option_link.cgi?bordercolor"
  >-bordercolor</A></CODE>" as the background image for both "<CODE><A
  HREF="../option_link.cgi?border" >-border</A></CODE>" and "<CODE><A
  HREF="../option_link.cgi?frame" >-frame</A></CODE>" was added to IM with
  version 6.1.4.  Before this the background canvas generated consisted of a
  black canvas onto which the border, or frame was drawn.  </P>

  This use of black was especially bad for the "<CODE>montage</CODE>"
  command which makes heavy usage of the internal "<CODE><A
  HREF="../option_link.cgi?frame" >-frame</A></CODE>" function in its internal
  processing. (See <A HREF="../montage/#bg" >Montage Background and
  Transparency Handling</A>)

</I></FONT></TD></TR></TABLE></P>


<A NAME="frame_compose"></A>

As you can see the "<CODE><A HREF="../option_link.cgi?frame"
>-frame</A></CODE>" operator, like "<CODE><A HREF="../option_link.cgi?border"
>-border</A></CODE>", also uses the "<CODE><A
HREF="../option_link.cgi?compose" >-compose</A></CODE>" setting to define how
the source image is overlaid onto the background frame.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert star.gif -bordercolor LimeGreen \
          -compose {<I>operation</I>} -frame 6x6+2+2  {<I>result</I>}
</CODE></PRE></TD></TR></TABLE>
  <A HREF="frame_compose.jpg"
     ><IMG SRC="frame_compose.jpg"
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The use of a "<CODE><A HREF="../option_link.cgi?compose" >-compose</A></CODE>"
setting of '<CODE><A HREF="../compose/#copy" >Copy</A></CODE>' becomes very
important if you also want to use the "<CODE><A
HREF="../option_link.cgi?bordercolor" >-bordercolor</A></CODE>" setting in
"<CODE>montage</CODE>" frames.  See <A HREF="../montage/#bg" >Montage
Background and Transparency Handling</A> for more details. </P>

<A NAME="frame_canvas"></A>
<H4>Frame and Virtual Canvas</H4>

As with <A HREF="#border_canvas" >Border and Virtual Canvas</A> frame is
also applied around the actual image on that virtual canvas, and NOT around
the whole canvas.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert rose: -shave 12x0 -repage 64x64+9+9  paged.gif
<z>  convert paged.gif         -frame 5x5+2+2     paged_framed.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged.gif"
     ><IMG SRC="paged.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="paged_framed.gif"
     ><IMG SRC="paged_framed.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

Note that the size of the virtual canvas was also increased by twice the border
thickness to accommodate the added frame. </P>

This of course means you can not simply add a <A HREF="#frame" >Frame</A> to
a typical GIF animation directly, unless you want to actually identify the
individual sub-frames of the animation (for example see <A
HREF="../anim_basics/#montage" >Animation Frame Montage</A>).  If you want to
add a border, you should <A HREF="../anim_basics/#coalesce" >Coalesce</A> the
animation first to remove any <A HREF="../anim_opt/#frame_opt">Frame
Optimizations</A> it may have first. </P>


<A NAME="shave"></A>
<H3>Shave, removing edges from an image</H3>

The reverse of the "<CODE><A HREF="../option_link.cgi?border"
>-border</A></CODE>" or "<CODE><A HREF="../option_link.cgi?frame"
>-frame</A></CODE>" operators, is "<CODE><A HREF="../option_link.cgi?shave"
>-shave</A></CODE>", which if given the same arguments, will remove the space
added by these commands. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert border.gif -shave 10x10 shave.gif
  convert border.gif -shave 10x0  shave_sides.gif
  convert border.gif -shave  0x20 shave_topbot.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="border.gif"
     ><IMG SRC="border.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="shave.gif"
     ><IMG SRC="shave.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shave_sides.gif"
     ><IMG SRC="shave_sides.gif"
           ALIGN=middle VSPACE=5 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="shave_topbot.gif"
     ><IMG SRC="shave_topbot.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

The main thing to keep in mind about these three operators is that they add
and remove space on <I>opposite</I> sides of the images, not just one side, or
adjacent sides. </P>

If you want to only remove one edge of an image, then you will need to use the
"<CODE><A HREF="../option_link.cgi?chop"
>-chop</A></CODE>" operator instead.  (See the <A HREF="#chop" >Chop
Examples</A> below). </P>

As before all the operators "<CODE><A HREF="../option_link.cgi?border"
>-border</A></CODE>", "<CODE><A HREF="../option_link.cgi?frame"
>-frame</A></CODE>", and "<CODE><A HREF="../option_link.cgi?shave"
>-shave</A></CODE>", only effect the real image on the virtual canvas
and not the virtual canvas itself. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert rose: -shave 12x0 -repage 64x64+9+9  paged.gif
<c>  convert paged.gif         -border 5x5        paged_border.gif
<z>  convert paged_border.gif  -frame  5x5+2+2    paged_frame.gif
<z>  convert paged_frame.gif   -shave  10x10      paged_shave.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged.gif"
     ><IMG SRC="paged.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="paged_border.gif"
     ><IMG SRC="paged_border.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="paged_frame.gif"
     ><IMG SRC="paged_frame.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="paged_shave.gif"
     ><IMG SRC="paged_shave.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

An alternative to using shave is to use the new <A HREF="#crop_equal" >Equal
Sized Tile Cropping</A> operator.  The advantage of this operator is that
unlike  "<CODE><A HREF="../option_link.cgi?shave" >-shave</A></CODE> it will
not modify the canvas size of the resulting image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert paged_frame.gif   -crop  1x1-10-10@     paged_tile_shave.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="paged_frame.gif"
     ><IMG SRC="paged_frame.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="paged_tile_shave.gif"
     ><IMG SRC="paged_tile_shave.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM version v6.6.1-0, equal-sized tile cropping for images
  with a canvas offset (such as the above) was broken.
</I></FONT></TD></TR></TABLE></P>


<A NAME="extent"></A>
<H3>Extent, Direct Image Size Adjustment</H3>

After some discussions,
an operator to directly adjust the final size of an image size was
added to IM version 6.2.4.  The "<CODE><A HREF="../option_link.cgi?extent"
>-extent</A></CODE>" operator. </P>

If the image size increases, space will be added to right or bottom edges of
the image.  If it decreases the image data is just junked or cropped to fit
the new image size.  In both cases the top left area of the image will likely
remain unaffected.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -background skyblue -extent 100x60     extent_enlarge.gif
  convert rose: -background skyblue -extent  40x40     extent_shrink.gif
  convert rose: -background skyblue -extent 100x40     extent_wider.gif
  convert rose: -background skyblue -extent  40x60     extent_taller.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="extent_enlarge.gif"
     ><IMG SRC="extent_enlarge.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="extent_shrink.gif"
     ><IMG SRC="extent_shrink.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="extent_wider.gif"
     ><IMG SRC="extent_wider.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="extent_taller.gif"
     ><IMG SRC="extent_taller.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

As you can see it will fill any new areas with the "<CODE><A
HREF="../option_link.cgi?background" >-background</A></CODE>" color of any new
areas added to the image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM version v6.3.2, "<CODE><A HREF="../option_link.cgi?extent"
  >-extent</A></CODE>" just cleared the memory of any new areas to zero, or
  straight black.  It did not fill the areas with  "<CODE><A
  HREF="../option_link.cgi?background" >-background</A></CODE>" color.
</I></FONT></TD></TR></TABLE></P>

Also after IM v6.3.2, "<CODE><A HREF="../option_link.cgi?extent"
>-extent</A></CODE>" will use the "<CODE><A HREF="../option_link.cgi?gravity"
>-gravity</A></CODE>" to define where the areas added/removed are positioned
relative to the original image. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -gravity north  -extent 100x80 extent_north.gif
  convert rose:  -gravity south  -extent 100x80 extent_south.gif
  convert rose:  -gravity east   -extent 100x80 extent_east.gif
  convert rose:  -gravity west   -extent 100x80 extent_west.gif
  convert rose:  -gravity center -extent 100x80 extent_center.gif
  convert rose:  -gravity center -extent  40x80  extent_center2.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="extent_north.gif"
     ><IMG SRC="extent_north.gif"        WIDTH=100 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="extent_south.gif"
     ><IMG SRC="extent_south.gif"        WIDTH=100 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="extent_east.gif"
     ><IMG SRC="extent_east.gif"         WIDTH=100 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="extent_west.gif"
     ><IMG SRC="extent_west.gif"         WIDTH=100 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="extent_center.gif"
     ><IMG SRC="extent_center.gif"       WIDTH=100 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="extent_center2.gif"
     ><IMG SRC="extent_center2.gif"      WIDTH=40 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

The last example in the above show that extent can also do centered crops, but
without the need for a "<CODE><A HREF="../option_link.cgi?repage"
>-repage</A></CODE>", though it does 'flatten' the image with the current
"<CODE><A HREF="../option_link.cgi?background" >-background</A></CODE>" color.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

You can even use offsets, which basically means the <A HREF="#extent" >Extent
Operator</A> is simply a straight forward <A HREF="#crop" >Crop</A> with
background padded fill, regardless of position.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -background skyblue -extent 100x100-15-25 extent.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="extent.png"
     ><IMG SRC="extent.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


This ability to both crop and extend an image according to gravity makes the
operator perfect for padding or cropping an image so that it fits into to a
specific sized area, for example see <A HREF="../thumbnails/#pad" >Pad/Fill a
Thumbnail to Fit</A>.  </P>


<A NAME="extent_compose"></A>

Note that "<CODE><A HREF="../option_link.cgi?extent" >-extent</A></CODE>"
works by using the same 'overlay' technique that both the <A HREF="#border"
>Border</A> and <A HREF="#frame" >Frame</A> operators uses.  As such by
default using it with an image containing transparency will replace the
transparency with the current "<CODE><A HREF="../option_link.cgi?background"
>-background</A></CODE>" color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert star.gif  -background LimeGreen  -extent 80x80-10-10  star_extent.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="star_extent.gif"
     ><IMG SRC="star_extent.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Again the solution to this is to either set an appropriate "<CODE><A
HREF="../option_link.cgi?compose" >-compose</A></CODE>" method, or set the
"<CODE><A HREF="../option_link.cgi?background" >-background</A></CODE>" color
to '<CODE>None</CODE>'. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="splice"></A>
<H2>Adding/Removing Rows, Columns and Edges</H2>

<A NAME="splice"></A>
<H3>Splice, adding rows, columns and edges</H3>

The "<CODE><A HREF="../option_link.cgi?splice" >-splice</A></CODE>" operator is
new to IM version 6, see <A HREF="../misc/#splice" >Splice, example of
the creation of a new image operator</A>. </P>

It basically provides the much needed ability to add a row, column of space
into the middle or one edge of an image. The color for the space inserted
comes from the "<CODE><A HREF="../option_link.cgi?background"
>-background</A></CODE>" color setting.  </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose:  -background blue  -splice 20x10+40+30  splice.gif
  convert  rose:  -background blue  -splice 20x0+40+0    splice_column.gif
  convert  rose:  -background blue  -splice 0x10+0+30    splice_row.gif
  convert  rose:  -background blue  -splice 20x10        splice_topleft.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="rose.gif"
     ><IMG SRC="rose.gif"                  WIDTH=70  HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="splice.gif"
     ><IMG SRC="splice.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="splice_column.gif"
     ><IMG SRC="splice_column.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="splice_row.gif"
     ><IMG SRC="splice_row.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="splice_topleft.gif"
     ><IMG SRC="splice_topleft.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  If the background color is not set, IM will attempt to determine this
  value from the image itself.  This means that for some images it may be
  white (the normal default), on others it may black, or for the GIF format
  it could be whatever background color was set to when that image
  was saved. <P>

  What this basically means is that if you don't set "<CODE><A
  HREF="../option_link.cgi?background" >-background</A></CODE>" color, its
  default value depends on the image, and you could get just about anything.
  <P>

  </I></FONT><CENTER><B>   Always set "<CODE><A
  HREF="../option_link.cgi?background" >-background</A></CODE>",
  before using an operator that uses it.  </B></CENTER>

</TD></TR></TABLE></P>

Now while adding a row and column to an image is good, the "<CODE><A
HREF="../option_link.cgi?splice" >-splice</A></CODE>" operator is ideal for
adding space to just one edge of an image.  Which edge is determined by using
the  "<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" option
and the splice geometry setting.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose: -background blue  -splice 0x10  splice_top.gif
  convert  rose: -gravity south \
                 -background blue  -splice 0x10  splice_bottom.gif
  convert  rose: -background blue  -splice 20x0  splice_left.gif
  convert  rose: -gravity east \
                 -background blue  -splice 20x0  splice_right.gif
  convert  rose: -gravity southeast \
                 -background blue  -splice 20x10  splice_botright.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="splice_top.gif"
     ><IMG SRC="splice_top.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="splice_bottom.gif"
     ><IMG SRC="splice_bottom.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="splice_left.gif"
     ><IMG SRC="splice_left.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="splice_right.gif"
     ><IMG SRC="splice_right.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="splice_botright.gif"
     ><IMG SRC="splice_botright.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

One of the most common uses of splice is to add space in which to draw
a label.  (See <A HREF="../annotating/#labeling" >Labeling Images</A>)

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose: -gravity South  -background LimeGreen  -splice 0x15 \
           -annotate 0x0 'Rose'    splice_label.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="splice_label.gif"
     ><IMG SRC="splice_label.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="chop"></A>
<H3>Chop, removing rows, columns and edges</H3>

The natural inverse of "<CODE><A HREF="../option_link.cgi?splice"
>-splice</A></CODE>" is the much older  "<CODE><A
HREF="../option_link.cgi?chop" >-chop</A></CODE>" operator.  Given the same
argument as "<CODE><A HREF="../option_link.cgi?splice" >-splice</A></CODE>"
and the same "<CODE><A HREF="../option_link.cgi?gravity" >-gravity</A></CODE>"
setting, "<CODE><A HREF="../option_link.cgi?chop" >-chop</A></CODE>" will
restore the image to its original form.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  splice.gif       -chop  20x10+40+30   splice_chop.gif
  convert  splice_chop.gif  -chop  20x10+30+20   chop.gif
  convert  chop.gif -background grey \
                           -splice 20x10+30+20   chop_splice.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="splice.gif"
     ><IMG SRC="splice.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="splice_chop.gif"
     ><IMG SRC="splice_chop.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="chop.gif"
     ><IMG SRC="chop.gif"
         ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
 <A HREF="chop_splice.gif"
   ><IMG SRC="chop_splice.gif"
         ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

I continued processing the last example to show how you can reverse the order of
the "<CODE><A HREF="../option_link.cgi?splice" >-splice</A></CODE>" and "<CODE><A
HREF="../option_link.cgi?chop" >-chop</A></CODE>" so as to 'clear' a row or
column (or both) from the middle of an image without using draws or overlays.
</P>

Chop is more commonly used to cut of a single edge from an image, using
gravity to select that edge.   For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  frame_red.gif                 -chop  0x10  chop_top.gif
  convert  frame_red.gif                 -chop 10x0   chop_left.gif
  convert  frame_red.gif -gravity East   -chop 10x0   chop_right.gif
  convert  frame_red.gif -gravity South  -chop  0x10  chop_bottom.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="frame_red.gif"
     ><IMG SRC="frame_red.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="chop_top.gif"
     ><IMG SRC="chop_top.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="chop_left.gif"
     ><IMG SRC="chop_left.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="chop_right.gif"
     ><IMG SRC="chop_right.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="chop_bottom.gif"
     ><IMG SRC="chop_bottom.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

As an alternative to using "<CODE><A HREF="../option_link.cgi?chop"
>-chop</A></CODE>" for removing a single edge, you can in fact use the more
universal "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" operator
instead.  This does not require the use of "<CODE><A
HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" to get the bottom or
right edges, however does require you to "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>" the canvas of the image
afterward.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  frame_red.gif  -crop +0+10 +repage  crop_edge_top.gif
  convert  frame_red.gif  -crop +10+0 +repage  crop_edge_left.gif
  convert  frame_red.gif  -crop -10+0 +repage  crop_edge_right.gif
  convert  frame_red.gif  -crop +0-10 +repage  crop_edge_bottom.gif
</CODE></PRE></TD></TR></TABLE><NOBR>
  <A HREF="frame_red.gif"
     ><IMG SRC="frame_red.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="crop_edge_top.gif"
     ><IMG SRC="crop_edge_top.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_edge_left.gif"
     ><IMG SRC="crop_edge_left.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_edge_right.gif"
     ><IMG SRC="crop_edge_right.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="crop_edge_bottom.gif"
     ><IMG SRC="crop_edge_bottom.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</NOBR></DIV></P>

This relies on the fact that if "<CODE><A HREF="../option_link.cgi?crop"
>-crop</A></CODE>" is not given an image area to remove, it will default to the
size of the image canvas (not the actual image but the images virtual canvas).
This means you can (for simple images) remove image edges by just offsetting
the crop area being cut. </P>

The method of using "<CODE><A HREF="../option_link.cgi?crop"
>-crop</A></CODE>" to 'chop' image edges, was discovered and published by Don
Sheythe, and after some discussion was deemed to be a 'feature'
of IM, and thus included here. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="advanced"></A>
<H2>Advanced Cropping Techniques</H2>

<A NAME="crop_aspect"></A>
<H3>Crop to a Given Aspect Ratio</H3>

You can crop images to fit a specific aspect ratio, but it is tricky
and uses some DIY mathematical techniques. For example you can write a script
to do the calculations and then do the <A HREF="#crop" >Crop</A>. </P>

Or in IM v6 you can so calaculations with the <A
HREF="../distorts/#distort_viewport" >Distort Viewport</A>, to extract the
desired part of the image during a <A HREF="../distorts/#distort_noop" >No-Op
Distortion</A>, as described in <A HREF="../distorts/#centered_square"
>Centered Square Crop</A>. </P>

However in ImageMagick version 7, you can now do mathematical calculations
directly in commands like "<CODE><A HREF="../option_link.cgi?crop"
>-crop</A></CODE>" and "<CODE><A HREF="../option_link.cgi?extent"
>-extent</A></CODE>", thus by-passing the need miss-use "<CODE><A
HREF="../option_link.cgi?distort" >-distort</A></CODE>". </P>

This is discussed in detail in the IM Developers Forum <A
HREF="../forum_link.cgi?t=33448" >Crop to Aspect Ratio</A>. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="trim"></A>
<H2>Trim, the 'Auto-Crop' Operator</H2>

The "<CODE><A HREF="../option_link.cgi?trim" >-trim</A></CODE>" operator
is a very close relation to the highly versatile "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>" operator discussed <A
HREF="#crop" >above</A>.  However instead of supplying an argument, this
operator attempts to remove any borders or edges of an image which did does
not change in color or transparency. In other words it removes the 'boring'
bits surrounding an image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that in ImageMagick version 5 and before, an auto-crop operation was
  achieved by using a '<CODE>0x0</CODE>' argument to the "<CODE><A
  HREF="../option_link.cgi?crop" >-crop</A></CODE>" operator.  This is no
  longer the case, as 'zero' size arguments in crop now denote 'infinite' or
  'to the limit of the image size'. <P>

  As such a '<CODE>0x0</CODE>' argument to crop now effectively means to
  crop the image into tiles, the size of the original image canvas.  In
  other words, with IM v6, the result will be the same as the original
  image, or a 'no-op'.

</I></FONT></TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example here we take the IM logo, which we resize, and 'trim' or
'auto-crop' all the surrounding extra space in the logo.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
    convert  logo: -resize 30%    -trim     trim.gif
</CODE></PRE></TD></TR></TABLE></P>

Two things should be noted from the above.  First is like "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>",  "<CODE><A
HREF="../option_link.cgi?trim" >-trim</A></CODE>" will retain the
canvas size of the image.  This means that the numerical arguments of the trim
can be extracted, to allow for further processing, or adjustment of the
of the image processing (see <A HREF="#trim_blur" >Trimming "Noisy" Images</A>
for an example of doing this). </P>

</TD><TD>
  <A HREF="trim.gif"
     ><IMG SRC="trim.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here we trim the image, but only to list the result on what part of the image
was trimmed, not the actual trimmed image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=trim_info.txt>
  convert  logo: -resize 30%   -trim  info:-
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="trim_info.txt"
     ><IMG SRC="trim_info.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

However if you don't care about this information, just junk it by resetting the
page information of the image either using a "<CODE><A
HREF="../option_link.cgi?repage" >+repage</A></CODE>" operator, or saving to a
format that does not save canvas information (such as the JPEG format).  Here
we do both, to make it clear, that we are junking the canvas information.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  logo: -resize 30%    -trim +repage    trim_repage.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="trim_repage.jpg"
     ><IMG SRC="trim_repage.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The second thing to note, is that trim did not actually trim right up to the
very edge of the final image.  This is especially noticeable in the lower right
corner of the logo image, where we can see a distinct gap between the foot and
its shadow and the trimmed edge. </P>

In this corner, the colors here became numerically different to the background
color of the image. So even though we can't see any real change in the image,
the "<CODE><A HREF="../option_link.cgi?trim" >-trim</A></CODE>" operator sees
a minor color change, so it did not trim as close to the image as we would
have expected.  </P>

If the image is all one color, then "<CODE><A HREF="../option_link.cgi?trim"
>-trim</A></CODE>" will trim the image down to a minimal single pixel
transparent <A HREF="#crop_missed" >Missed Image</A>.  This is logical and
prevents more serious problems if the image was left as is. </P>


<A NAME="trim_color"></A>
<H3>Trimming with a Specific Color</H3>

One of the most worrisome problems with "<CODE><A HREF="../option_link.cgi?trim"
>-trim</A></CODE>", especially in automated image processing scripts, is that
trim can be a little unpredictable.  It does not for example limit itself to
just a specific color, or even one color.  As such you should easily trim much
more than you expect. </P>

For example lets do a simple trim of a simple image of striped colors.
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 32x32 xc:red xc:green xc:blue +append stripes.gif
  convert stripes.gif  -trim +repage   stripes_trimmed.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="stripes.gif"
     ><IMG SRC="stripes.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="stripes_trimmed.gif"
     ><IMG SRC="stripes_trimmed.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see,  "<CODE><A HREF="../option_link.cgi?trim" >-trim</A></CODE>"
trimmed not just one color but two colors!  In an automatic script, this can be
very bad and produce unexpected results. </P>

If you know what color you want to trim from an image, then the better way is
to add a small one pixel wide "<CODE><A HREF="../option_link.cgi?border"
>-border</A></CODE>" of that color to the image.  Lets take
'<CODE>red</CODE>' in this case.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert stripes.gif -bordercolor red -border 1x1 \
          -trim +repage   stripes_trim_red.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="stripes.gif"
     ><IMG SRC="stripes.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="stripes_trim_red.gif"
     ><IMG SRC="stripes_trim_red.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Of course using "<CODE><A HREF="../option_link.cgi?border"
>-border</A></CODE>" like this also will change the canvas offset that
"<CODE><A HREF="../option_link.cgi?trim" >-trim</A></CODE>" took great pains
to preserve.  </P>

As such if you look at the result without removing the virtual canvas
information you can see that image was shifted.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  stripes.gif -bordercolor red -border 1x1  -trim  \
           stripes_trim_red_shifted.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="stripes_trim_red_shifted.gif"
     ><IMG SRC="stripes_trim_red_shifted.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


So lets try correcting the virtual canvas size (subtract
<CODE><I>border_width</I>x2</CODE> ) and offset (subtract
<CODE><I>border_width</I></CODE>)when trimming a specific color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  stripes.gif -bordercolor red -border 1x1  -trim  \
           -set page '%[fx:page.width-2]x%[fx:page.height-2]+%[fx:page.x-1]+%[fx:page.y-1]' \
           stripes_trim_red_fix.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="stripes_trim_red_fix.gif"
     ><IMG SRC="stripes_trim_red_fix.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that I am restoring canvas size and offset of the original image, that <A
HREF="#border" >Border Operator</A> enlarged and shifted in the above. The
"<CODE><A HREF="../option_link.cgi?trim" >-trim</A></CODE>" operation itself
preverved the image location correctly. It is as you can see a rather
un-wieldly adjustment.  </P>

Alternatively if you do not care about the canvas size (typical in a layered
image) you can use a far simplier <A HREF="../basics/#page" >Relative
Repage</A> to only adjusted the image's position on the enlarged canvas.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  stripes.gif -bordercolor red -border 1x1  -trim  \
           -repage -1-1\! stripes_trim_red_fix2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="stripes_trim_red_fix2.gif"
     ><IMG SRC="stripes_trim_red_fix2.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>



<A NAME="trim_oneside"></A>
<H3>Trimming Just One Side of an Image</H3>

As you saw above "<CODE><A HREF="../option_link.cgi?trim" >-trim</A></CODE>"
will trim as many sides as it can. Even going so far as removing two different
colors from different sides (or if very carefully arranged, four colours could
have been removed). This makes it a little more difficult when you want to
restrict the trimming to just one side. </P>

To guarantee that we only trim one side we need to add some color stripes to
the other side to protect the other three sides. </P>

Here is the process step-by-step for trimming just the 'left' or 'west' side
of the 'border' image we created previously. I used much thicker stripes than
is necessary so you can see them better in this example. Normally a single
pixel width is all that is needed.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert border.gif  -gravity East \
                      -background white -splice 5x0 \
                      -background black -splice 5x0  trim_protect.gif
  convert trim_protect.gif     -trim +repage         trim_oneside.gif
  convert trim_oneside.gif  -gravity East -chop 5x0  trim_west.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="border.gif"
     ><IMG SRC="border.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="trim_protect.gif"
     ><IMG SRC="trim_protect.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="trim_oneside.gif"
     ><IMG SRC="trim_oneside.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="trim_west.gif"
     ><IMG SRC="trim_west.gif"
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that I add stripes two different colors!  That way if one of the colors
matches the existing border color surrounding the image the other will
continue to work to protect those three edges. Also only one of the colors
will also be trimmed, leaving just one color stripe to be cleaned up. </P>

Here is the whole one side trim as a single command, but for trimming the
top edge (stripes are added to the bottom or 'South' edge).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert border.gif -gravity South \
          -background white -splice 0x1  -background black -splice 0x1 \
          -trim  +repage -chop 0x1   trim_north.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="trim_north.gif"
     ><IMG SRC="trim_north.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And here is a bottom edge only trim.  Of course the "<CODE><A
HREF="../option_link.cgi?gravity" >-gravity</A></CODE>" settings used in the
previous example is not needed and the setting defaults to a
'<CODE>North-West</CODE>' setting for images.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert border.gif \
          -background white -splice 0x1  -background black -splice 0x1 \
          -trim  +repage -chop 0x1   trim_south.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="trim_south.gif"
     ><IMG SRC="trim_south.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


Of course as before with border, splicing extra colors onto an image will
again change the virtual image canvas size and the layer images offset.  Again
this can be fixed using the same methods we showed in the previous section,
but it depends on which side you added the extra colors onto to preserve those
edges. </P>


<A NAME="trim_fuzz"></A>
<H3>Trimming with fuzzy color selection
<FONT SIZE=-1> -- Low Quality JPEG Images</FONT></H3>

Because JPEG is 'lossy' the colors in the image is generally not a single
color but slightly varying band of different colors. because of this "<CODE><A
HREF="../option_link.cgi?trim" >-trim</A></CODE>" will often fail for JPEG or
real world images. </P>

<I>FUTURE: Example of failure here</I></P>

As such you need to tell ImageMagick that colors that are not-exactly the
same, but are reasonally close should be treated as being the same.  Adding
a very small "<CODE><A HREF="../option_link.cgi?fuzz" >-fuzz</A></CODE>"
setting will do this.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert image.jpg  -fuzz 1% -trim +repage  image_fuzzy_trim.jpg
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

It is also a very good idea to specify the specific color you want that fuzz
to be relative to.  This can be added by specifically added a border of that
color using the "<CODE><A HREF="../option_link.cgi?border"
>-border</A></CODE>" operator.  The border will of course always match the
color to be trimmed, so will always be removed by "<CODE><A
HREF="../option_link.cgi?trim" >-trim</A></CODE>". </P>

<I>FUTURE: Example of fuzzy border trim here</I></P>


<A NAME="trim_noisy"></A>
<A NAME="trim_blur"></A>
<H3>Trimming 'Noisy' Images
<FONT SIZE=-1> -- Scanned Images</FONT></H3>

A similar problem is faced with scanned images, where scanners often produce
small single pixel errors, caused by dust, dirt, slight variations in the
scanner, or just electronic noise picked up by the reader.  The pixels errors
however this case is usually too big for a small <A
HREF="../color_basics/#fuzz" >fuzz factor</A> to overcome, so different
technique is needed to trim such images. </P>

The simplest solution, though often least practical is to take multiple scans
of the same image, or multiple frames in a still sequence of video), then
averaging the results to reduce the interference.  However this will not
remove dust specks on the scanner or help when only a single image or frame is
available, making this method impractical in most cases. </P>

A practical solution is a two step one.  With a copy of the image, process it
in some way to de-emphasize single pixel errors, or scanner dust, while
enhancing the effect of large blocks of highly contrasting colors. By then
using "<CODE><A HREF="../option_link.cgi?trim" >-trim</A></CODE>" on this
copy, and examining exactly what it did, you can then "<CODE><A
HREF="../option_link.cgi?crop" >-crop</A></CODE>" the original unmodified
image by the same amount. </P>

Their number of methods of de-emphasizing single pixel errors.  These include
"<CODE><A HREF="../option_link.cgi?blur" >-blur</A></CODE>", "<CODE><A
HREF="../option_link.cgi?median" >-median</A></CODE>", or even using <A
HREF="../#morphology/#basic" >Basic Morphology Operators</A> to remove
specific details, such a text and thin lines. </P>

This the 'blur' method gives two main controls:<DL><DD>
<LI>The "<CODE><A HREF="../option_link.cgi?blur" >-blur</A></CODE>" sigma
    radius, or the "<CODE><A HREF="../option_link.cgi?mediam"
    >-median</A></CODE>" convolution radius, which determines the size of dust
    specks you want to ignore. Note that both these values can be a floating
    point number so you have a fine control over the amount of the blur
    applied. </P>

    For more information on blurring see <A HREF="../blur/#blur"
    >Blurring Images</A>. </P>

<LI>The second control is the "<CODE><A HREF="../option_link.cgi?fuzz"
    >-fuzz</A></CODE>" color factor that controls the amount of color change
    matched by the "<CODE><A HREF="../option_link.cgi?trim" >-trim</A></CODE>"
    operator. That is how close to the desired image you want the trim to get.
    </P>
</DL>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example lets use a smaller "<CODE>logo:</CODE>" image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert logo:   -resize 30%   noisy.jpg
</CODE></PRE></TD></TR></TABLE>

In this small image we could regard the stars and title in the image as noise
which we want trim to ignore.  The stars in the above is about 5 pixels
across, so we want to use a value of about double that to get trim to
basically ignore them. </P>

</TD><TD>
  <A HREF="noisy.jpg"
     ><IMG SRC="noisy.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here is the result.  Note in this case we do not want an image,
just the canvas information from the image. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=blur_trim_info.txt>
  convert noisy.jpg  -virtual-pixel edge -blur 0x15 -fuzz 15% -trim  info:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="blur_trim_info.txt"
     ><IMG SRC="blur_trim_info.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  You may need to check the  <A HREF="../misc/#virtual" >Virtual Pixel</A>
  setting to enure that you get the right 'edge effects' with the blur. </P>

  Alternatively you can add a wide border of the same background color to
  image before blurring and adjusting the offset results appropriately.
  This may be better for more accurate results from both "<CODE><A
  HREF="../option_link.cgi?blur" >-blur</A></CODE>" and "<CODE><A
  HREF="../option_link.cgi?trim" >-trim</A></CODE>" operators.
</I></FONT></TD></TR></TABLE></P>

From the above result we can determine that "<CODE><A
HREF="../option_link.cgi?trim" >-trim</A></CODE>" had internally used
a "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" argument of
'<CODE>89x121+78+23</CODE>'.  This is the actual size of the trimmed image,
and its offset on the virtual canvas, and presumably the location of the major
(single) object we are looking for within the image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

This can then be used on the original image, which has not been blurred.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert noisy.jpg   -crop 89x121+78+23 +repage   noisy_trimmed.jpg
</CODE></PRE></TD></TR></TABLE></P>
And here we have trimmed our image to just the wizard!
</TD><TD>
  <A HREF="noisy_trimmed.jpg"
     ><IMG SRC="noisy_trimmed.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

This can be done in a single line, using a little bit of extra 'UNIX shell
scripting', and some formating of the results of that first command.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert noisy.jpg -crop \
    `convert noisy.jpg -virtual-pixel edge -blur 0x15 -fuzz 15% \
             -trim -format '%wx%h%O' info:`   +repage   noisy_trimmed_2.jpg
</CODE></PRE></TD></TR></TABLE></P>

See <A HREF="https://legacy.imagemagick.org/script/escape.php" >Image Property
Escapes</A> for more information on the "<CODE><A
HREF="../option_link.cgi?format" >-format</A></CODE>" setting used to control
the output of "<CODE><A HREF="../files/#info" >info:</A></CODE>". </P>

</TD><TD>
  <A HREF="noisy_trimmed_2.jpg"
     ><IMG SRC="noisy_trimmed_2.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<!--<CODE EXECUTE ASSERT>
  [ `identify -format '%wx%h' noisy_trimmed.jpg` != \
    `identify -format '%wx%h' noisy_trimmed_2.jpg` ] && echo >&2 \
  "ASSERTION FAILURE: Fuzzy trim sizes do not match\!"
</CODE>-->

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The above uses an UNIX command line shell feature for 'command-substitution'
  method using back-quotes '<CODE>`...`</CODE>'  to insert the generated
  "<CODE><A HREF="../option_link.cgi?crop" >-crop</A></CODE>" argument into
  the outer "<CODE>convert</CODE>" command.  </P>

  You can do this in a <A HREF="../api/#windows" >Windows Batch Script</A>,
  using a special <CODE>FOR..DO</CODE> construct. Follow the above link for
  details.

</I></FONT></TD></TR></TABLE></P>

Note that while the hand is of the wizard is fully visible, the point of the
hat isn't.  This is the drawback of this method, it will ignore sharp points
and fine details. But then that is what we were asking it to ignore in the
first place. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The method could be improved by expanding the area trimmed by a small amount
(10 pixels in 4 four directions), using some <A
HREF="../transform/#fx_escapes" >FX Escape</A> to do the mathematics...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert noisy.jpg -crop \
      `convert noisy.jpg -virtual-pixel edge -blur 0x15 -fuzz 15% -trim \
               -format '%[fx:w+20]x%[fx:h+20]+%[fx:page.x-10]+%[fx:page.y-10]' \
      info:` +repage   noisy_trimmed_3.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="noisy_trimmed_3.jpg"
     ><IMG SRC="noisy_trimmed_3.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If the calculated bounds expands beyond the original image, the <A
HREF="#crop" >crop operator</A> will automatically limit it to the image
bounds. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

In IMv7 (using the "<CODE>magick</CODE>" command) you can do it all in one
command, saving the calculated trim size in a setting for later use.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  magick noisy.jpg \
         \( +clone -virtual-pixel edge -blur 0x15 -fuzz 15% -trim \
            -set option:fuzzy_trim \
                     '%[fx:w+20]x%[fx:h+20]+%[fx:page.x-10]+%[fx:page.y-10]'\
            +delete \) \
         -crop %[fuzzy_trim] noisy_trimmed_4.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="noisy_trimmed_4.jpg"
     ><IMG SRC="noisy_trimmed_4.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
</I></FONT></TD></TR></TABLE></P>

Other methods of fuzzy trimming is using various <A
HREF="../morphology/#basic" >Morphological Methods</A> to remove the unwanted
parts of the image, before triming to find the bounds of the area wanted in
the original image. </P>

An user <A HREF="../forum_link.cgi?u=14154" >HugoRune</A> needed to trim an
image down to a highly different contrast regaion for scanning purposes.   See
<A HREF="../forum_link.cgi?t=14247" >Discussion on IM Forums</A>, for details.
</P>

<HR><!-- ------------------------------------------------------------------ -->
<ADDRESS>
Created: 15 March 2004 <BR>
Updated: 9 December 2016 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/crop/</CODE>
</ADDRESS></BODY></HTML>
